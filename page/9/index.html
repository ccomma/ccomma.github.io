<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta name="google-site-verification" content="5K7puGkNbKLWhZTmZZm6haOpSbJ-oOvUQFYJeMFBJSk">
  <meta name="baidu-site-verification" content="codeva-3O8Y6jTFCL">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ccomma.cn","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="下一个目标：改变世界！">
<meta property="og:type" content="website">
<meta property="og:title" content="CComma&#39;s Blog">
<meta property="og:url" content="https://ccomma.cn/page/9/">
<meta property="og:site_name" content="CComma&#39;s Blog">
<meta property="og:description" content="下一个目标：改变世界！">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="CComma">
<meta property="article:tag" content="编程技术、Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ccomma.cn/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CComma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GS592DM662"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GS592DM662","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?152282c2c823c1e5ab34c577ba338801"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="CComma's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/ccomma.png" alt="CComma's Blog">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CComma's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Connect the world</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">20</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">118</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CComma"
      src="/images/ccomma.png">
  <p class="site-author-name" itemprop="name">CComma</p>
  <div class="site-description" itemprop="description">下一个目标：改变世界！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ccomma" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ccomma" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ccomma_cat" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ccomma_cat" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/cd58652eb14b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/cd58652eb14b/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-12 22:59:00" itemprop="dateCreated datePublished" datetime="2022-05-12T22:59:00+08:00">2022-05-12</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/cd58652eb14b/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="cd58652eb14b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2022/pdf/12939765/1652407285001-fab2c18e-81c0-4748-bdca-10cf3e727610.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/pdf/12939765/1652407285001-fab2c18e-81c0-4748-bdca-10cf3e727610.pdf%22,%22name%22:%22%E5%88%AB%E4%B9%B1%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E4%BA%86%EF%BC%8C%E7%9C%8B%E4%B8%8B%E5%A4%A7%E5%8E%82%20Git%20%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%81.pdf%22,%22size%22:1610472,%22ext%22:%22pdf%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22type%22:%22application/pdf%22,%22taskId%22:%22u37544941-f41e-4c9f-972d-237495d4b11%22,%22taskType%22:%22upload%22,%22mode%22:%22title%22,%22id%22:%22u16e3b7e8%22,%22card%22:%22file%22%7D">别乱提交代码了，看下大厂 Git 提交规范是怎么做的！.pdf</a><br><a target="_blank" rel="noopener" href="http://iissnan.com/progit/">Pro Git 简体中文版 (iissnan.com)</a><br><a target="_blank" rel="noopener" href="https://github.com/zurawiki/gptcommit">gptcommit</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/920cb6e295db/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/920cb6e295db/" class="post-title-link" itemprop="url">Zookeeper 从入门到入土①：概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-23 19:29:17" itemprop="dateCreated datePublished" datetime="2022-04-23T19:29:17+08:00">2022-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/920cb6e295db/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="920cb6e295db/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>3 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ZooKeeper 是一个分布式协调中间件，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p><strong><em>特性：</em></strong></p>
<ul>
<li><em>顺序一致性：</em> 客户端的更新将按顺序执行。因其写操作完全由单一 Leader 节点来执行（事务 id）</li>
<li><em>原子性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 操作要么成功要么失败（事务）</li>
<li><em>单一视图：</em> &nbsp; &nbsp; 无论连接到哪个节点，客户端都能看到相同的视图。（恢复模式 + 广播模式）</li>
<li><em>及时性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 在特定时间范围内的数据是最新的。由最终一致性保证，同步需一定时间（数据同步）</li>
<li><em>可靠性：</em> <ul>
<li>数据不会丢失。zk 是将数据存储到内存中的，所以肯定会有持久化（日志 + 快照）</li>
<li>快速恢复 Leader。恢复模式（选主 + 数据同步）</li>
</ul>
</li>
</ul>
<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p><strong><em>conf/zoo.cfg：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算时间的基本单元 ms</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许从节点连接并同步到主节点的初始化连接时间，以 tickTime 为单位</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点与从节点请求和应答（心跳）的时间长度，以 tickTime 为单位</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快照及 Log 存储位置</span></span><br><span class="line">dataDir=/usr/local/zookeeper/dataDir</span><br><span class="line">dataLogDir=/usr/local/zookeeper/dataLogDir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端口</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host4，observer 角色</span></span><br><span class="line">server.4=49.56.165.144:2888:3888:observer</span><br></pre></td></tr></tbody></table></figure>

<p><strong>集群：</strong></p>
<ol>
<li>创建 dataDir/myid，内容为 1 代表 id 为 1。其他实例同上创建不同 id 的 myid 文件 </li>
<li>server. 服务器 id = 服务器 ip: 服务器之间的通信端口：服务器之间的投票选举端口 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1 当前机器的 host，用 0.0.0.0 表示</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h1><p>启动服务：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></tbody></table></figure>

<p>启动客户端：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh</span><br></pre></td></tr></tbody></table></figure>

<p>查看启动状态：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h1><ul>
<li>每当客户端连接到服务端会创建一个 SessionId。<strong>创建 / 删除 SessionId 也是事务操作，会有 zxid，会被同步到所有节点中</strong> </li>
<li> Session 过期，则根据该 Session 创建的临时节点 znode 都会被抛弃 </li>
<li>可设置超时时间。未超时的情况下，客户端 api 若保存了 SessionId，重连后 Session 不会消失（还是原来的 Session） </li>
<li>心跳机制</li>
</ul>
<h1 id="5-基本模型"><a href="#5-基本模型" class="headerlink" title="5. 基本模型"></a>5. 基本模型</h1><h2 id="5-1-Zookeeper-抽象模型"><a href="#5-1-Zookeeper-抽象模型" class="headerlink" title="5.1. Zookeeper 抽象模型"></a>5.1. Zookeeper 抽象模型</h2><p>Zookeeper 提供了一种树形结构级的命名空间<br>为了保证高吞吐和低延迟，Zookeeper 在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper <strong>不能用于存放大量的数据</strong>，每个节点的存放数据上限为 <strong>1M</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/71cee598f8577e486a102cf8e2e06ba4.png"></p>
<h2 id="5-2-节点类型"><a href="#5-2-节点类型" class="headerlink" title="5.2. 节点类型"></a>5.2. 节点类型</h2><ul>
<li><strong>永久无序节点：</strong> 不会因为会话结束或者超时而消失</li>
<li><strong>永久有序节点：</strong> 不会因为会话结束或者超时而消失，且有序</li>
<li><strong>临时无序节点：</strong> 如果会话结束或者超时就会消失</li>
<li><strong>临时有序节点：</strong> 如果会话结束或者超时就会消失，且有序<blockquote>
<p>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/957cfc92c9ca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/957cfc92c9ca/" class="post-title-link" itemprop="url">MyBatis 中使用枚举</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-05 19:49:27" itemprop="dateCreated datePublished" datetime="2021-12-05T19:49:27+08:00">2021-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/957cfc92c9ca/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="957cfc92c9ca/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在编码过程中，经常会遇到用某个数值来表示某种状态、类型或者阶段的情况，比如有这样一个枚举：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ComputerState</span> {</span><br><span class="line"></span><br><span class="line">    OPEN(<span class="number">10</span>),         <span class="comment">//开启</span></span><br><span class="line">    </span><br><span class="line">    CLOSE(<span class="number">11</span>),         <span class="comment">//关闭</span></span><br><span class="line">    </span><br><span class="line">    OFF_LINE(<span class="number">12</span>),     <span class="comment">//离线</span></span><br><span class="line">    </span><br><span class="line">    FAULT(<span class="number">200</span>),     <span class="comment">//故障</span></span><br><span class="line">    </span><br><span class="line">    UNKNOWN(<span class="number">255</span>);     <span class="comment">//未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    ComputerState(<span class="type">int</span> code) { <span class="built_in">this</span>.code = code; }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通常我们希望将表示状态的数值存入数据库，即 ComputerState.OPEN 存入数据库取值为 10。</p>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>首先，我们先看看 MyBatis 是否能够满足我们的需求。<br>MyBatis 内置了两个枚举转换器分别是：<code>org.apache.ibatis.type.EnumTypeHandler</code> 和 <code>org.apache.ibatis.type.EnumOrdinalTypeHandler</code>。</p>
<h2 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h2><p>这是默认的枚举转换器，该转换器将枚举实例转换为实例名称的字符串，即将 <code>ComputerState.OPEN</code> 转换 <code>OPEN</code>。</p>
<h2 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h2><p>顾名思义这个转换器将枚举实例的 ordinal 属性作为取值，即 <code>ComputerState.OPEN</code> 转换为 0，<code>ComputerState.CLOSE</code> 转换为 1。<br>使用它的方式是在 MyBatis 配置文件中定义：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com.example.entity.enums.ComputerState"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br>以上的两种转换器都不能满足我们的需求，所以看起来要自己编写一个转换器了。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>MyBatis 提供了 <code>org.apache.ibatis.type.BaseTypeHandler</code> 类用于我们自己扩展类型转换器，上面的 <code>EnumTypeHandler</code> 和 <code>EnumOrdinalTypeHandler</code> 也都实现了这个接口。</p>
<h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h2><p>我们需要一个接口来确定某部分枚举类的行为。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseCodeEnum</span> {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>该接口只有一个返回编码的方法，返回值将被存入数据库。</p>
<h2 id="2-改造枚举"><a href="#2-改造枚举" class="headerlink" title="2. 改造枚举"></a>2. 改造枚举</h2><p>就拿上面的 <code>ComputerState</code> 来实现 <code>BaseCodeEnum</code> 接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ComputerState</span> <span class="keyword">implements</span> <span class="title class_">BaseCodeEnum</span>{</span><br><span class="line"></span><br><span class="line">    OPEN(<span class="number">10</span>),         <span class="comment">//开启</span></span><br><span class="line">    </span><br><span class="line">    CLOSE(<span class="number">11</span>),         <span class="comment">//关闭</span></span><br><span class="line">    </span><br><span class="line">    OFF_LINE(<span class="number">12</span>),     <span class="comment">//离线</span></span><br><span class="line">    </span><br><span class="line">    FAULT(<span class="number">200</span>),     <span class="comment">//故障</span></span><br><span class="line">    </span><br><span class="line">    UNKNOWN(<span class="number">255</span>);     <span class="comment">//未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    ComputerState(<span class="type">int</span> code) { <span class="built_in">this</span>.code = code; }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> { <span class="keyword">return</span> <span class="built_in">this</span>.code; }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-编写一个转换工具类"><a href="#3-编写一个转换工具类" class="headerlink" title="3. 编写一个转换工具类"></a>3. 编写一个转换工具类</h2><p>现在我们能顺利的将枚举转换为某个数值了，还需要一个工具将数值转换为枚举实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeEnumUtil</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt; &amp; BaseCodeEnum&gt; E <span class="title function_">codeOf</span><span class="params">(Class&lt;E&gt; enumClass, <span class="type">int</span> code)</span> {</span><br><span class="line">        E[] enumConstants = enumClass.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (E e : enumConstants) {</span><br><span class="line">            <span class="keyword">if</span> (e.getCode() == code)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-自定义类型转换器"><a href="#4-自定义类型转换器" class="headerlink" title="4. 自定义类型转换器"></a>4. 自定义类型转换器</h2><p>准备工作做的差不多了，是时候开始编写转换器了。<br><code>BaseTypeHandler&lt;T&gt;</code> 一共需要实现 4 个方法：</p>
<ol>
<li><code>void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType)</code></li>
</ol>
<p>用于定义设置参数时，该如何把 Java 类型的参数转换为对应的数据库类型</p>
<ol start="2">
<li><code>T getNullableResult(ResultSet rs, String columnName)</code></li>
</ol>
<p>用于定义通过字段名称获取字段数据时，如何把数据库类型转换为对应的 Java 类型</p>
<ol start="3">
<li><code> T getNullableResult(ResultSt rs, int columnIndex)</code><br>用于定义通过字段索引获取字段数据时，如何把数据库类型转换为对应的 Java 类型</li>
<li><code>T getNullableResult(CallableStatement cs, int columnIndex)</code><br>用定义调用存储过程后，如何把数据库类型转换为对应的 Java 类型 </li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeEnumTypeHandler</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt; &amp; BaseCodeEnum&gt; <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;E&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeEnumTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Type argument cannot be null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, BaseCodeEnum parameter, JdbcType jdbcType)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException {</span><br><span class="line">        ps.setInt(i, parameter.getCode());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnName);</span><br><span class="line">        <span class="keyword">return</span> rs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> rs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> cs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> cs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">codeOf</span><span class="params">(<span class="type">int</span> code)</span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> CodeEnumUtil.codeOf(type, code);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Cannot convert "</span> + code + <span class="string">" to "</span> + type.getSimpleName() + <span class="string">" by code value."</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h2><p>接下来需要指定哪个类使用我们自己编写转换器进行转换，在 MyBatis 配置文件中配置如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.example.typeHandler.CodeEnumTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com.example.entity.enums.ComputerState"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br>搞定！ 经测试 <code>ComputerState.OPEN</code> 被转换为 10，<code>ComputerState.UNKNOWN</code> 被转换为 255，达到了预期的效果。</p>
<h2 id="6-优化"><a href="#6-优化" class="headerlink" title="6. 优化"></a>6. 优化</h2><p>在第 5 步时，我们在 MyBatis 中添加 typeHandler 用于指定哪些类使用我们自定义的转换器，一旦系统中的枚举类多了起来，MyBatis 的配置文件维护起来会变得非常麻烦，也容易出错。如何解决呢？<br>在 Spring 中我们可以使用 JavaConfig 方式来干预 SqlSessionFactory 的创建过程，来完成转换器的指定。</p>
<p><strong>思路</strong></p>
<ol>
<li>再写一个能自动匹配转换行为的转换器</li>
<li>通过 <code>sqlSessionFactory.getConfiguration().getTypeHandlerRegistry()</code> 取得类型转换器注册器</li>
<li>再使用 typeHandlerRegistry.setDefaultEnumTypeHandler (Class&lt;? extends TypeHandler&gt; typeHandler) 将第一步的转换器注册成为默认的</li>
</ol>
<p>首先，我们需要一个能确定转换行为的转换器：<br>AutoEnumTypeHandler.java</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoEnumTypeHandler</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">BaseTypeHandler</span> <span class="variable">typeHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutoEnumTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Type argument cannot be null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(BaseCodeEnum.class.isAssignableFrom(type)){</span><br><span class="line">            <span class="comment">// 如果实现了 BaseCodeEnum 则使用我们自定义的转换器</span></span><br><span class="line">            typeHandler = <span class="keyword">new</span> <span class="title class_">CodeEnumTypeHandler</span>(type);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 默认转换器 也可换成 EnumOrdinalTypeHandler</span></span><br><span class="line">            typeHandler = <span class="keyword">new</span> <span class="title class_">EnumTypeHandler</span>&lt;&gt;(type);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, E parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        typeHandler.setNonNullParameter(ps,i, parameter,jdbcType);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(rs,columnName);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(rs,columnIndex);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(cs,columnIndex);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们需要干预 <code>SqlSessionFactory</code> 的创建过程，将刚刚的转换器指定为默认的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix  = "mybatis")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">        DataSource dataSource,</span></span><br><span class="line"><span class="params">        JSONArrayHandler jsonArrayHandler,</span></span><br><span class="line"><span class="params">        JSONObjectHandler jsonObjectHandler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 设置配置文件及mapper文件地址</span></span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        factory.setConfigLocation(resolver.getResource(configLocation));</span><br><span class="line">        factory.setMapperLocations(resolver.getResources(mapperLocations));</span><br><span class="line">    </span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> factory.getObject();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取得类型转换注册器</span></span><br><span class="line">        <span class="type">TypeHandlerRegistry</span> <span class="variable">typeHandlerRegistry</span> <span class="operator">=</span> sqlSessionFactory.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">        <span class="comment">// 注册默认枚举转换器</span></span><br><span class="line">        typeHandlerRegistry.setDefaultEnumTypeHandler(AutoEnumTypeHandler.class);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... getter setter</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>搞定！ 这样一来，如果枚举实现了 <code>BaseCodeEnum</code> 接口就使用我们自定义的 <code>CodeEnumTypeHandler</code>，如果没有实现 <code>BaseCodeEnum</code> 接口就使用默认的。再也不用写 MyBatis 的配置文件了！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/fd6d81abe0b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/fd6d81abe0b0/" class="post-title-link" itemprop="url">操作系统从入门到入土⑤：输入 / 输出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-08 11:06:41" itemprop="dateCreated datePublished" datetime="2021-11-08T11:06:41+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/fd6d81abe0b0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="fd6d81abe0b0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>14 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-I-O-硬件原理"><a href="#1-I-O-硬件原理" class="headerlink" title="1. I/O 硬件原理"></a>1. I/O 硬件原理</h1><h2 id="1-1-I-O-设备"><a href="#1-1-I-O-设备" class="headerlink" title="1.1. I/O 设备"></a>1.1. I/O 设备</h2><p>I/O 设备大致可以分为 <strong>块设备（block device）</strong>和 <strong>字符设备（character device）</strong>。</p>
<p><strong>块设备：</strong><br>块设备把信息存储在固定大小的块中，大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的连续块为单位。<br>块设备的基本特征是每个块都能独立于其他块而读写。硬盘、蓝光光盘和 USB 是最常见的块设备。</p>
<p><strong>字符设备：</strong><br>字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。<br>字符设备是不可寻址的，也没有任何寻道操作。打印机、网络接口、鼠标 (用作指点设备)、以及大多数与磁盘不同的设备都可看作字符设备。</p>
<h2 id="1-2-设备控制器"><a href="#1-2-设备控制器" class="headerlink" title="1.2. 设备控制器"></a>1.2. 设备控制器</h2><p>I/O 设备一般由机械部件和电子部件两部分组成。机械部件则是设备本身；而电子部件又称作 ** 设备控制器（device controller）** 或 <strong>适配器（adapter）</strong>。通常是个人计算机主板上的芯片，或是（PCI）扩展槽中的印刷电路板。</p>
<p><strong>作用：</strong><br>控制一个或多个 I/O 设备，以实现 I/O 设备和计算机之间的数据交换。<br>控制器把串行的位流转换为字节块，并进行必要的错误校正工作。<br>字节块通常首先在控制器内部的一个缓冲区中按位进行组装，然后进行校验再将它复制到主存中。</p>
<blockquote>
<p>LCD 显示器的控制器也是一个位串行设备。它从内存中读入包含待显示字符的字节，产生信号以便使相应的像素改变背光的极化方式，从而将其写到屏幕上。</p>
</blockquote>
<h2 id="1-3-内存映射-I-O"><a href="#1-3-内存映射-I-O" class="headerlink" title="1.3. 内存映射 I/O"></a>1.3. 内存映射 I/O</h2><p><strong>寄存器：</strong><br>每个控制器有几个寄存器用来与 CPU 进行通信。</p>
<ul>
<li>通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。</li>
<li>通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</li>
</ul>
<p><strong>数据缓冲区：</strong><br>许多设备还有一个操作系统可以读写的数据缓冲区。</p>
<blockquote>
<p>例如，在屏幕上显示像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，可供程序或操作系统写入数据。</p>
</blockquote>
<p><strong>寻址控制器方案：</strong><br>CPU 如何与寄存器和数据缓冲区通信？</p>
<ol>
<li><strong>I/O 端口号（I/O port）：</strong></li>
</ol>
<p>每个控制寄存器被分配一个 I/O 端口号（8 位或 16 位整数），所有 I/O 端口形成 I/O 端口空间，只有操作系统可以访问。<br>在这一方案中，内存地址空间和 I/O 地址空间是不同的。可以使用一条特殊的 I/O 指令，例如 <code>IN REG, PORT</code>，CPU 可以读取控制寄存器 PORT 的内容并将结果存入到 CPU 寄存器 REG 中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb708a7c4a526a72448ac5116e88786f.png" alt="image.png"></p>
<ol start="2">
<li><strong>内存映射 I/O（memory-mapped I/O）：</strong></li>
</ol>
<p>将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，这样的系统称为内存映射 I/O。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1539db73122c168692b655dac119b9e2.png" alt="image.png"></p>
<p><strong>内存映射 I/O 优点：</strong></p>
<ol>
<li>I/O 指令读写设备控制寄存器，需要使用汇编代码，这增加了控制 I/O 的开销。而对于内存映射 I/O，I/O 设备驱动程序可以用 C 语言编写。</li>
<li>不需要特殊的保护机制来阻止用户进程执行 I/O 操作。</li>
<li>可以引用内存的每一条指令也可以引用控制寄存器。</li>
</ol>
<p>例如，如果存在一条指令 TEST 可以测试一个内存字是否为 0，那么它也可以用来测试一个控制寄存器是否为 0。<br>如果不是内存映射 I/O，必须首先将控制寄存器读入 CPU，然后再测试。</p>
<p><strong>实际工作原理：</strong><br>当 CPU 想要读入一个字的时候，将需要的地址放到总线的地址线上，然后在总线的一条控制线上置起一个 READ 信号。<br>还要用到第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。</p>
<h2 id="1-4-直接存储器存取"><a href="#1-4-直接存储器存取" class="headerlink" title="1.4. 直接存储器存取"></a>1.4. 直接存储器存取</h2><p><strong>非 DMA 数据交换过程：</strong><br>CPU 需要寻址设备控制器以便与它们交换数据，在没有使用 DMA 时磁盘读取数据效率不高，过程如下：</p>
<ol>
<li>首先控制器从磁盘驱动器串行地、一位一位地读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区中。</li>
<li>接着再计算校验和，以保证没有读错误发生。</li>
<li>然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息，并将其存人内存中。</li>
</ol>
<p><strong>DMA 数据交换过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/279ce57ad3eea8c671e2c9cffc98140e.png" alt="image.png"><br>DMA 控制器能独立于 CPU 访问系统总线，使用 DMA 时的过程：</p>
<ol>
<li>CPU 对 DMA 控制器进行编程，设置其的寄存器，以便让 DMA 控制器知道将什么数据传送到什么地方。</li>
</ol>
<p>DMA 控制器还要向磁盘控制器发送命令让它从磁盘读数据到其内部的缓冲区中，必要性：</p>
<ol>
<li>磁盘控制器可以在传送之前检验校验和。如果校验和是错误的，那么将发出一个表明错误的信号并且不会进行传送。</li>
<li>如果控制器要将数据直接写到内存，则它必须为要传送的每个字取得系统总线的控制权，会导致总线忙。</li>
</ol>
<p>如果块被放入内部缓冲区，则在 DMA 启动前不需要使用总线。</p>
<ol start="2">
<li>DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送。</li>
<li>磁盘控制器从内部缓冲区中读取字写到内存，这是另一个标准总线周期。</li>
<li>当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器。</li>
</ol>
<p>随后 DMA 控制器增加要使用的内存地址，并且减少字节计数。<br>如果字节计数仍然大于 0，则重复第 2 步到第 4 步，直到字节计数到达 0。<br>然后 DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。</p>
<p><strong>DMA 硬件集成方案：</strong><br>DMA 需要硬件的支持。DMA 控制器可以集成到磁盘控制器和其他控制器之中，这就要求每个设备有一个单独的 DMA 控制器。也可以将 DMA 控制器集成到主板上，由它调控到多个设备的数据传送。</p>
<p><strong>传输模式：</strong><br>许多总线能够以两种模式操作：每次一字模式和块模式。某些 DMA 控制器也能够以这两种模式操作。</p>
<ul>
<li><strong>周期窃取（eycle stealing）：</strong>每次一字模式下，DMA 控制器请求传送一个字并且得到这个字，传送多次。</li>
</ul>
<p>该模式下设备控制器会偶尔从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。这一机制称为周期窃取。</p>
<ul>
<li><strong>突发模式（burst mode）：</strong>在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这操作形式称为突发模式。</li>
</ul>
<p>它比周期窃取效率更高，因为获得总线占用了时间，并且以一次总线获得的代价能够传送多个字。<br>突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。</p>
<blockquote>
<p>联想：与 JVM 垃圾回收器串行收集与并行收集的区别类似。并行会暂停用户线程，专注于垃圾回收，吞吐量大，但也会加大用户响应时间，类似这里的突发模式。</p>
</blockquote>
<blockquote>
<p>某些 DMA 控制器是让设备控制器将字发送给 DMA 控制器，然后发起第 2 个总线请求将该字写到它应该去的任何地方。<br>采用这种方案，每传送一个字需要一个额外的总线周期，但是更加灵活，因为它可以执行设备到设备的复制甚至是内存到内存的复制（通过首先发起一个到内存的读，然后发起一个到不同内存地址的写）。</p>
</blockquote>
<h2 id="1-5-中断"><a href="#1-5-中断" class="headerlink" title="1.5. 中断"></a>1.5. 中断</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/848bd15e88456466d8d893cb2b556aa3.png" alt="image.png"><br><strong>产生中断信号：</strong><br>当一个 I/O 设备完成交给它的工作时，其通过在分配给它的一条总线信号线上置起信号从而产生中断。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。<br>为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。<br>如果有另一个中断正在处理中，该设备将继续在总线上置起中断信号，直到得到 CPU 的服务才被继续处理。</p>
<p>中断信号导致 CPU 停止当前正在做的工作去做其他的事情。<br>地址线上的数字是一个指向 ** 中断向量（interrupt vector）** 表格的索引，用于读取指向中断服务过程开始位置的程序计数器。</p>
<p><strong>服务开始前保存：</strong><br>在开始服务程序之前，硬件总是要保存一定的信息。必须保存程序计数器，这样被中断的进程才能够重新开<br>始。另一个极端是所有可见的寄存器和很多内部寄存器或许也要保存。</p>
<p>将这些信息保存到什么地方是一个问题：</p>
<ul>
<li>在内部寄存器中保存信息。在需要时操作系统可以读出这些内部寄存器。</li>
</ul>
<p>其缺点是，为避免第二个中断重写寄存器，以致在相关信息被读出前中断控制器无法得到应答。<br>这一策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据。</p>
<ul>
<li>在堆栈中保存信息。</li>
</ul>
<p>其带来的问题：</p>
<ul>
<li>如果使用当前堆栈，则它很可能是用户进程的堆栈，其堆栈指针甚至可能不是合法的，当硬件在其所指的地址写入时将导致致命错误。</li>
</ul>
<p>另外，若它指向一个页面的末端，那么在若干次内存写之后，页面边界可能被超出并且产生页面故障。这将会引起更大的问题：在何处保存状态以处理页面故障？</p>
<ul>
<li>如果使用内核堆栈，堆栈指针是合法的并且指向一个固定的页面。</li>
</ul>
<p>但是，切换到核心态可能要求改变 MMU 上下文，并且可能使高速缓存和 TLB 的大部分或全部失效。静态地或动态地重新装载所有这些东西将增加处理一个中断的时间，因而浪费 CPU 的时间。</p>
<p><strong>采用应答避免竞争：</strong><br>中断服务过程开始运行后，立刻通过将一个确定值写到中断控制器的某个 I/O 端口来对中断做出应答，来告诉中断控制器可以发出另一个中断。通过这种方式来避免多个同时发生的中断相互竞争。</p>
<h1 id="2-I-O-软件原理"><a href="#2-I-O-软件原理" class="headerlink" title="2. I/O 软件原理"></a>2. I/O 软件原理</h1><h2 id="2-1-I-O-软件的目标"><a href="#2-1-I-O-软件的目标" class="headerlink" title="2.1. I/O 软件的目标"></a>2.1. I/O 软件的目标</h2><p><strong>设备独立性（device independence）</strong>：设计的程序应该可以访问任意 I/O 设备。例如，读取一个文件作为输入的程序应该能够在硬盘、DVD 或者 USB 盘上读取文件，无需为每一种不同的设备修改程序。</p>
<p><strong>统一命名（uniform naming）</strong>：一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。用这种方法，所有文件和设备都采用相同的方式一路径名进行寻址。</p>
<blockquote>
<p>例如，一个 USB 盘可以安装到目录 /usr/ast/backup 下，这样复制一个文件到 /usr/ast/backup/monday 就是将文件复制到 USB 盘上。</p>
</blockquote>
<p><strong>错误处理（error handling）：</strong>一般来说，错误应该尽可能地在接近硬件的层面（低层）得到处理，只有低层软件处理不了才将错误上交高层处理。<br>当控制器发现了一个读错误时，如果它能够处理那么就应该自已设法纠正这一错误。如果控制器处理不了，则交给设备驱动程序处理，可能只需重读一次这块数据就正确了。</p>
<p><strong>同步传输（阻塞）和异步传输（中断驱动）：</strong></p>
<ul>
<li>异步：CPU 启动传输后便转去做其他工作，直到中断发生。</li>
<li>阻塞：在 read 系统调用之后，程序将自动被挂起，直到缓冲区中的数据准备好。</li>
</ul>
<p><strong>缓冲（buffering）：</strong><br>数据离开一个设备之后通常并不能直接存放到其最终的目的地。数据必须预先放置到输出缓冲区之中，从而消除缓冲区填满速率和缓冲区清空速率之间的相互影响，以避免缓冲区欠载。缓冲涉及大量的复制工作，并且经常对 I/O 性能有重大影响。</p>
<blockquote>
<p>例如，从网络上进来一个数据包时，直到将该数据包存放在某个地方并对其进行检查，操作系统才知道要将其置于何处。此外，某些设备具有严格的实时约束（如数字音频设备）。</p>
</blockquote>
<p><strong>共享设备和独占设备：</strong><br>有些 I/O 设备（磁盘）能够同时让多个用户使用。多个用户同时在同一磁盘上打开文件不会引起什么问题。<br>有些设备（磁带机）则必须由单个用户独占使用，直到该用户使用完，另一个用户才能拥有该磁带机。让多个用户随机将混杂的数据块写入同一磁带，这样是不能工作的。</p>
<h2 id="2-2-程序通知-I-O"><a href="#2-2-程序通知-I-O" class="headerlink" title="2.2. 程序通知 I/O"></a>2.2. 程序通知 I/O</h2><p>I/O 可以采用三种方式来实现。程序控制 I/O、中断驱动 I/O 和使用 DMA 的 I/O。</p>
<p><strong>程序控制 I/O（programmed I/O）：</strong>让 CPU 做全部工作。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6be16f108e5804a39fedcd6ff2634e2e.png" alt="image.png"><br>例如一个用户进程想通过串行接口在打印机上打印 8 个字符的字符串”ABCDEFGH“。</p>
<ol>
<li>软件首先要在用户空间的一个缓冲区中组装字符串，如 a) 所示。</li>
<li>然后，用户进程调用打开打印机之类的系统调用来获得打印机。</li>
</ol>
<p>如果打印机当前被另一个进程占用，该系统调用将失败并返回一个错误代码，或者将阻塞直到打印机可用。<br>成功获取打印机后，用户进程就发出一个系统调用打印字符串。</p>
<ol start="3">
<li>然后，操作系统将字符串缓冲区复制到内核空间中的一个数组中。</li>
<li>若打印机可用，操作系统就复制第一个字符到打印机的数据寄存器中，在这个例子中使用了内存映射 I/O。</li>
</ol>
<p>这一操作将激活打印机。字符也许还不会出现在打印机上，因为某些打印机在打印任何东西之前要先缓冲一行或一页。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/80c9e654e499/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/80c9e654e499/" class="post-title-link" itemprop="url">操作系统从入门到入土④：文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-29 17:26:09" itemprop="dateCreated datePublished" datetime="2021-10-29T17:26:09+08:00">2021-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/80c9e654e499/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="80c9e654e499/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>21 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文件是进程创建的信息逻辑单元，每个文件是独立于其他文件的，是对磁盘的建模，而非对 RAM 的建模。<br>如果能把每个文件看成一个地址空间，那么就能理解文件的本质了。</p>
<h1 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h1><p>文件是一种抽象机制，它提供了一种在磁盘上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘工作方式等有关细节。</p>
<h2 id="1-1-文件结构"><a href="#1-1-文件结构" class="headerlink" title="1.1. 文件结构"></a>1.1. 文件结构</h2><p>字节序列：<br>操作系统所见到的就是字节。把文件看成字节序列为操作系统提供了最大的灵活性。用户程序可以向文件中加入任何内容，并以任何方便的形式命名。</p>
<p>记录序列：<br>文件是具有固定长度记录的序列，每个记录都有其内部结构。<br>读操作返回一个记录，而写操作重写或追加一个记录。</p>
<p>树：<br>按 key 排序，可对特定 key 进行快速查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/65d091a49e4597962d304520c5c9d67d.png" alt="image.png"></p>
<h2 id="1-2-文件访问"><a href="#1-2-文件访问" class="headerlink" title="1.2. 文件访问"></a>1.2. 文件访问</h2><p><strong>顺序访问（sequential access）：</strong><br>进程在这些系统中可从头按顺序读取文件的全部字节或记录，但不能跳过某一些内容。<br>顺序访问文件是可以返回到起点的，需要时可多次读取该文件。在存储介质是磁带而不是磁盘时，顺序访问文件是很方便的。</p>
<p><strong>随机访问（random access file）：</strong><br>当用磁盘来存储文件时，可以不按顺序读取文件，或者也可以按照关键字来访问记录。这种能够以任何次序读取其中字节或记录的文件称作随机访问文件。 </p>
<p>如订票程序必须能直接访问该航班记录，而不必先读出其他航班的成千上万个记录。有两种方法可以指示从何处开始读取文件。</p>
<ul>
<li>一种是每次 read 操作都给出开始读文件的位置。</li>
<li>另种是用一个特殊的 seek 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。</li>
</ul>
<h1 id="2-文件系统的实现"><a href="#2-文件系统的实现" class="headerlink" title="2. 文件系统的实现"></a>2. 文件系统的实现</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/03309c8ff0e13ecd6dbca1884b53adb0.png" alt="image.png"><br><strong>主引导记录（Master Boot Record, MBR）：</strong><br>文件系统存放在磁盘上，划分为多个分区，每个分区中都有独立的文件系统。<br>磁盘的 0 号扇区称为主引导记录，用来引导计算机。</p>
<p><strong>分区表：</strong><br>在 MBR 的结尾是分区表。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。</p>
<p><strong>引导块（boot block）：</strong><br>在计算机被引导时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一个块，称为引导块，并执行之。引导块中的程序将装载该分区中的操作系统。<br>为统一起见， 每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统。不过，未来这个分区也许会有一个操作系统的。</p>
<p><strong>超级块（superblock）：</strong><br>超级块包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。<br>超级块中的信息包括：确定文件系统类型用的魔数、文件系统中块的数量等</p>
<h2 id="2-1-文件的实现"><a href="#2-1-文件的实现" class="headerlink" title="2.1. 文件的实现"></a>2.1. 文件的实现</h2><p>文件存储实现的关键问题是：如何记录文件用到哪些磁盘块。</p>
<h3 id="2-1-1-连续分配"><a href="#2-1-1-连续分配" class="headerlink" title="2.1.1. 连续分配"></a>2.1.1. 连续分配</h3><p>把每个文件作为一串连续数据块存储在磁盘上。<br>在块大小为 1KB 的磁盘上，50KB 的文件要分配 50 个连续的块。<br>在块大小为 2KB 的磁盘上，50KB 的文件要分配 25 个连续的块。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9d2d137aa665f2c49fb1186ed6343ae1.png" alt="image.png"><br>初始状态下，磁盘是空的。接着，从磁盘开始处（块 0）开始写入长度为 4 块的文件 A。紧接着，在文件 A 的结尾开始写入一个 3 块的文件 B。</p>
<p>每个文件都从一个新的块开始，这样如果文件 A 实际上只有 3.5 块，那么其最后一块的结尾会浪费一些空间。</p>
<p><strong>缺点：</strong><br>随着时间的推移，磁盘会变得零碎。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2fde8879d2d9fcab6b8095b4f21aedd5.png" alt="image.png"><br>假设删除 D 和 F，会在磁盘上留下一堆空闲块。磁盘不会填充空闲块，因为会涉及之后的所有文件。</p>
<p>磁盘被充满后，要么压缩磁盘，要么重新使用空洞所在的空闲空间。前者由于代价太高而不可行。后者需要维护一个空洞列表，但是在当创建一个新的文件时，就必须得知道该文件的最终大小，这是不可理喻的。</p>
<p>但这个办法在 CD-ROM 上是可行的并被广泛使用。在 CD-ROM 上所有文件的大小都是已知的，并在后续使用中它们的大小也不会改变。<br>所以如果文件的大小已知且不会改变，那么连续分配是一种好方法。</p>
<h3 id="2-1-2-链表分配"><a href="#2-1-2-链表分配" class="headerlink" title="2.1.2. 链表分配"></a>2.1.2. 链表分配</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/604bbbe0e74a4b222b595328b5c6f165.png" alt="image.png"><br>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。</p>
<p><strong>优点：</strong></p>
<ul>
<li>链表分配可以充分利用每个磁盘块。不会因为磁盘碎片而浪费存储空间。</li>
<li>在目录项中，只需要存放第一块的磁盘地址，文件的其他块就可以从这个首块地址查找到。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>随机访问相当缓慢。要获得块 n，操作系统每一次都必须从头开始，并且要先读前面的 n - 1 块。</li>
<li>由于指针占去了一些字节，每个磁盘块存储数据的字节数不再是 2 的整数次幂。怪异的大小降低了系统的运行效率，因为许多程序都是以长度为 2 的整数次幂来读写磁盘块的。</li>
</ul>
<p>由于每个块的前几个字节被指向下一个块的指针所占据，所以要读出完整的一个块大小的信息，就需要从两个磁盘块中获得和拼接。</p>
<h3 id="2-1-3-采用内存中的表进行链表分配"><a href="#2-1-3-采用内存中的表进行链表分配" class="headerlink" title="2.1.3. 采用内存中的表进行链表分配"></a>2.1.3. 采用内存中的表进行链表分配</h3><p>如果取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决使用链表的两个不足。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/260adba8d2976d1deaeeca52a9fd7c6c.png" alt="image.png"><br>内存中的这样一个表格称为 <strong>文件分配表（File Allocation Table, FAT）</strong>。</p>
<ul>
<li>文件 A 依次使用了磁盘块 4、7、2、10、12。</li>
<li>文件 B 依次使用了磁盘块 6、3、11、14。</li>
<li>这两个链都以一个不属于有效磁盘编号的特殊标记 -1 结束。</li>
</ul>
<p>因为整个链都存放在内存中，所以不需要任何磁盘引用，随机访问变得也容易了。</p>
<p><strong>缺点：</strong><br>必须把整个表都存放在内存中。<br>若磁盘大小为 1TB，块大小为 1KB，那么这张表需要有 10 亿项。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 内存。<br>上述方法并不实用，FAT 的管理方式不能较好地扩展并应用于大型磁盘中。</p>
<h3 id="2-1-4-i-节点"><a href="#2-1-4-i-节点" class="headerlink" title="2.1.4. i 节点"></a>2.1.4. i 节点</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a1f2c8b312ce3415c59614cb481c8990.png" alt="image.png"><br>给每个文件赋予一个称为 i 节点的数据结构。其中列出了文件属性和文件块的磁盘地址。所以只要有 i 节点，就能找到文件的所有块。</p>
<p>相比于 FAT，i 节点只在对应文件打开时才在内存中。而 FAT 需保留所有磁盘块的关系链表。</p>
<p>当一个文件所含的磁盘块的数目超出了 i 节点所能容纳的数目怎么办？<br>一个方案是最后一个地址指向另一个用于存储额外地址的块。</p>
<h2 id="2-2-文件属性的存储位置"><a href="#2-2-文件属性的存储位置" class="headerlink" title="2.2. 文件属性的存储位置"></a>2.2. 文件属性的存储位置</h2><p>每个文件系统维护文件的文件属性，它们必须存储在某个地方。</p>
<p><strong>存至目录项：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b92159db3de68498c88943e13be37fac.png" alt="image.png"><br>一种方法是把文件属性直接存放在目录项中。目录中有一个固定大小的目录项列<br>表，每个文件对应一项，其中包含一个文件名、一个文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p>
<p><strong>存至 i 节点：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c9f3295a4bd698e2628b6c48d3ba5cc8.png" alt="image.png"><br>对于采用 i 节点的系统，还存在另一种方法，即把文件属性存放在 i 节点中而不是目录项中。目录项会只有文件名和 i 节点号。</p>
<h2 id="2-3-目录的实现"><a href="#2-3-目录的实现" class="headerlink" title="2.3. 目录的实现"></a>2.3. 目录的实现</h2><p>打开文件时，操作系统利用路径名找到相应目录项。目录项中提供了查找文件磁盘块所需要的信息。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8afb0a7f4fea11bc8c7677a71eb7db20.png" alt="image.png"></p>
<h3 id="2-3-1-实现可变长度的长文件名"><a href="#2-3-1-实现可变长度的长文件名" class="headerlink" title="2.3.1. 实现可变长度的长文件名"></a>2.3.1. 实现可变长度的长文件名</h3><p><strong>简单固定长度：</strong><br>最简单的方法是给予文件名一个长度限制，典型值为 255 个字符，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间。</p>
<p><strong>文件名分散在各自文件中：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/32c033a3c3acfb80406195c6c3121f03.png" alt="image.png"><br>一种替代方案是每个目录项分为两部分。</p>
<ol>
<li>固定部分：以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息以及其他属性。</li>
<li>任意长度的实际文件名。</li>
</ol>
<p>如上图，有三个文件，project budget、personnel 和 foo，每个文件名以一个特殊字符（通常是 0）结束。</p>
<p>缺点：</p>
<ol>
<li>当移走文件后就引入了一个长度可变的空隙，下一个进来的文件不一定正好适合这个空隙。</li>
<li>一个目录项可能会分布在多个页面上，在读取文件名时可能发生缺页中断。</li>
</ol>
<p><strong>文件名集中在一起：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0fa715ceaed2fabec2fd258f402a9c35.png" alt="image.png"><br>另一种方法是，使目录项自身都有固定长度，而将文件名放置在目录后面的堆中。</p>
<p>优点：</p>
<ol>
<li>当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。当然，必须要对堆进行管理。而在处理文件名时缺页中断仍旧会发生。</li>
<li>文件名不再需要从字的边界开始，每个文件名后面就不需要用于凑整的填充字符了。</li>
</ol>
<h3 id="2-3-2-加快文件查找速度"><a href="#2-3-2-加快文件查找速度" class="headerlink" title="2.3.2. 加快文件查找速度"></a>2.3.2. 加快文件查找速度</h3><p><strong>散列表：</strong><br>对于非常长的目录，线性查找就太慢了。加快查找速度的一个方法是在每个目录中使用散列表。</p>
<p>添加一个文件时，对散列表中对应的表项进行检查。<br>如果该表项没有被使用，就将一个指向文件目录项的指针放入。<br>如果该表项被使用了，就构造一个链表，该链表的表头指针存放在该表项中，并链接所有具有相同散列值的文件目录项。</p>
<p>查找文件按照相同的过程进行。散列处理文件名，以便选择一个散列表项。<br>检查链表头在该位置上的链表的所有表项，查看要找的文件名是否存在。如果名字不在该链上，该文件就不在这个目录中。</p>
<p>使用散列表的优点是查找非常迅速。其缺点是需要复杂的管理。只有在预计系统中的目录经常会有成百上千个文件时，才把散列方案真正作为备用方案考虑。</p>
<p><strong>高速缓存：</strong><br>另一种加快大型目录查找速度的方法是，将查找结果存入高速缓存。<br>在开始查找之前，先查看文件名是否在高速缓存中。如果是，该文件可以立即定位。当然，只有在查询目标集中在相对小范围的文件集合的时候，高速缓存的方案才有效果。</p>
<h2 id="2-4-日志结构文件系统"><a href="#2-4-日志结构文件系统" class="headerlink" title="2.4. 日志结构文件系统"></a>2.4. 日志结构文件系统</h2><p><strong>技术背景：</strong><br>磁盘高速缓存迅速地增加，这使得来自文件系统高速缓存的大部分读请求不需要磁盘访问操作。<br>未来多数的磁盘访问是写操作，但是在一些文件系统中使用的提前读机制（需要读取数据之前预取磁盘块），并不能获得更好的性能。</p>
<p>在大多数文件系统中，写操作往往都是零碎的。<br>一个 50us 的磁盘写操作之前通常需要 10ms 的寻道时间和 4ms 的旋转延迟时间。</p>
<p>在 UNIX 文件系统上创建一个新文件。为了写这个文件，必须写该文件目录的节点、目录块、文件的 i 节点以及文件本身。<br>这些写操作有可能被延迟，如果在写操作完成之前发生死机，就可能在文件系统中造成不一致。所以 i 节点的写操作一般是立即完成的。</p>
<p><strong>原理：</strong><br>LFS 系统即使面对一个大部分由零碎的随机写操作组成的任务，同样能够充分利用磁盘的带宽。</p>
<p>所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘。段可能会包括 i 节点、目录块、数据块。</p>
<p>i 节点分散在整个日志中，而不是放在磁盘的某一个固定位置。维护一个由节点编号索引组成的节点图。<br>要打开一个文件，则首先需要从 i 节点图中找到文件的节点。一旦节点定位之后就可以找到相应的块的地址。所有的块都放在段中，在日志的某个位置上。</p>
<p><strong>清理线程：</strong><br>实际的硬盘空间是有限的，最终日志将会占用整个磁盘。LFS 有一个清理线程，会程周期地扫描日志进行磁盘压缩。</p>
<ul>
<li>首先读日志中的第一个段的摘要，检查有哪些 i 节点和文件。</li>
<li>然后查看当前节点图，判断该 i 节点是否有效以及文件块是否仍在使用中。<ul>
<li>如果没有使用，则该信息被丢弃。</li>
<li>如果仍然使用，那么 i 节点和块就进入内存等待写回到下一个段中。</li>
</ul>
</li>
</ul>
<p>当一个文件块被写回到一个新段的时候，该文件的 i 节点必须首先要定位、更新，然后放到内存中准备写回到下一个段中。i 节点图接着必须更新以指向新的位置。</p>
<ul>
<li>接着，原来的段被标记为空闲。整个磁盘成为一个大的环形的缓冲区，写线程将新的段写到前面，而清理线程则将旧的段从后面移走。</li>
</ul>
<p><strong>性能：</strong><br>LFS 在处理大量的零碎的写操作时性能上比 UNIX 好上一个数量级，在读和大块写操作的性能方面并不比 UNIX 文件系统差，甚至更好。</p>
<h2 id="2-5-日志文件系统"><a href="#2-5-日志文件系统" class="headerlink" title="2.5. 日志文件系统"></a>2.5. 日志文件系统</h2><p><strong>日志文件系统：</strong><br>保存一个用于记录系统下一步将要做什么的日志。这样当系统在任务中崩溃，重新启动后，可以查看日志获取崩溃前计划完成的任务。</p>
<p><strong>系统崩溃带来的问题：</strong><br>以移除文件操作举例，移除文件操作步骤如下：</p>
<ol>
<li>在目录中删除文件；</li>
<li>释放 i 节点到空闲节点池；</li>
<li>将所有磁盘块归还空闲磁盘块池。</li>
</ol>
<p>假如在第一步完成后系统崩溃。i 节点和文件块将不会被任何文件获得，也不会被再分配，它们只存在于废物池中的某个地方。<br>如果崩溃发生在第二步后，那么只有磁盘块会丢失。</p>
<p><strong>日志事务：</strong><br>日志文件系统先写一个日志项，列出三个将要完成的动作，然后日志项被写入磁盘。只有当日志项已经被写人，不同的操作才可以进行。当所有的操作成功完成后，擦除日志项。<br>如果系统这时崩溃，系统恢复后，文件系统可以通过检查日志来查看是不是有未完成的操作。如果有，可以重新运行所有未完成的操作，直到文件被正确地删除。<br>这要求被写入日志的操作必须是幂等的。</p>
<blockquote>
<p>保证中间件的可靠性也可以用这种方法</p>
</blockquote>
<p>为了增加可靠性，一个文件系统可以引入数据库中原子事务 (atomic transaction) 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。<br>这样，文件系统就会知道它或者必须完成所有被界定的操作，或者什么也不做。</p>
<h2 id="2-6-虚拟文件系统"><a href="#2-6-虚拟文件系统" class="headerlink" title="2.6. 虚拟文件系统"></a>2.6. 虚拟文件系统</h2><p>即使在同一个操作系统下，也会使用很多不同的文件系统。</p>
<h3 id="2-6-1-Windows-处理多文件系统"><a href="#2-6-1-Windows-处理多文件系统" class="headerlink" title="2.6.1. Windows 处理多文件系统"></a>2.6.1. Windows 处理多文件系统</h3><p>Windows 通过指定不同的盘符来处理这些不同的文件系统。当一个进程打开一个文件，盘符是显式或者隐式存在的。<br>所以 Windows 知道向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一的模式。</p>
<h3 id="2-6-2-Unix-处理多文件系统"><a href="#2-6-2-Unix-处理多文件系统" class="headerlink" title="2.6.2. Unix 处理多文件系统"></a>2.6.2. Unix 处理多文件系统</h3><p>相比之下，所有现代的 UNIX 系统做了一个很认真的尝试，即将多种文件系统整合到一个统一的结构中。<br>一个 Linux 系统可以用 ext2 作为根文件系统，ext3 分区装载在 /usr 下，另一块采用 ReiserFS 文件系统的硬盘装载在 /home 下，以及一个 ISO 9660 的 CD-ROM 临时装载在 /mnt 下。<br>从用户的观点来看，只有一个文件系统层级。它们事实上是多种文件系统，对于用户和进程是不可见的。</p>
<h3 id="2-6-3-虚拟文件系统（Virtual-File-System-VFS）"><a href="#2-6-3-虚拟文件系统（Virtual-File-System-VFS）" class="headerlink" title="2.6.3. 虚拟文件系统（Virtual File System, VFS）"></a>2.6.3. 虚拟文件系统（Virtual File System, VFS）</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0b47f051e1fb1983d4e108dd3f3b5ff0.png" alt="image.png"><br>虚拟文件系统尝试将多种文件系统统一成一个有序的结构。<br>其关键思想是抽象出所有文件系统共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。</p>
<p><strong>VFS 交互接口：</strong></p>
<ul>
<li>上层接口：被用户进程调用，是标准的 POSIX 系统调用，比如 open. read、 write 和 lseek 等。</li>
<li>下层接口：调用下层实际文件系统。VFS 接口包含许多功能调用。所以当创造一个新的文件系统和 VFS 一起工作时，设计者就必须确定它提供 VFS 所需要的功能调用。</li>
</ul>
<p><strong>用虚拟文件系统进行读操作过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a6babd0fa3d488ecd95bf7ca3c2815cf.png" alt="image.png"></p>
<ol>
<li>_装载文件系统：_文件系统在 VFS 中注册，提供一个包含 VFS 所需要的函数地址列表。VFS 知道如何执行实际文件系统提供的每一个功能。</li>
<li>_创建 v 节点：_如果一个文件系统装载在 /usr 并且一个进程调用 open (“/usr/lnclude/unistd.h”, O_RDONLY)</li>
</ol>
<p>VFS 会找到它所装载的文件的根目录，在那里查找路径 include/unistd.h，然后创建一个 v 节点并调用实际文件系统，从而返回文件 i 节点中的所有信息，并和其他信息一起复制到 v 节点中。</p>
<ol start="3">
<li>VFS 在文件描述符表中创建一个表项，并且将它指向新的 v 节点。</li>
<li>VFS 向调用者返回文件描述符，调用者可以用它去读、写或者关闭文件。</li>
<li>当进程用文件描述符进行一个读操作，VFS 通过进程表和文件描述符表确定 v 节点的位置，并跟随指针指向函数表，运行在实际文件系统中的代码。<blockquote>
<p>联想：VFS 类似一个面向用户的统一接口，具体实现由下层文件系统实现</p>
</blockquote>
</li>
</ol>
<h1 id="3-文件系统管理及优化"><a href="#3-文件系统管理及优化" class="headerlink" title="3. 文件系统管理及优化"></a>3. 文件系统管理及优化</h1><h2 id="3-1-磁盘空间管理"><a href="#3-1-磁盘空间管理" class="headerlink" title="3.1. 磁盘空间管理"></a>3.1. 磁盘空间管理</h2><p>按连续字节序列存储文件有一个明显问题，当文件扩大时，有可能需要在磁<br>盘上移动文件。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p>
<h3 id="3-1-1-块大小"><a href="#3-1-1-块大小" class="headerlink" title="3.1.1. 块大小"></a>3.1.1. 块大小</h3><p>块尺寸设的过大会导致很小的文件也会占用大量的磁盘空间。<br>块尺寸设的过小会导致大多数文件会跨越多个块，因此需要多次寻道与旋转延迟才能读出它们，从而降低了性能。</p>
<h3 id="3-1-2-记录空闲块"><a href="#3-1-2-记录空闲块" class="headerlink" title="3.1.2. 记录空闲块"></a>3.1.2. 记录空闲块</h3><p><strong>采用磁盘块链表：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b302e3be29c0fd7a4b63e189dcbfb173.png" alt="image.png"><br>链表的每个块中包含尽可能多的空闲磁盘块号。对于 1KB 大小的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲块的块号（需要有一个位置存放指向下一个块的指针）。</p>
<p><strong>采用位图：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/00a52c6a623e67ab4d59c781e5a5c9da.png" alt="image.png"><br>另一种空闲磁盘空间管理的方法是采用位图。<br>n 个块的磁盘需要 n 位位图。空闲块用 1 表示，已分配块用 0 表示（或者相反）。位图方法所需空间较少，因为每块只用一个二进制位标识，而在链表方法中，每一块要用到 32 位。</p>
<h2 id="3-2-文件系统性能"><a href="#3-2-文件系统性能" class="headerlink" title="3.2. 文件系统性能"></a>3.2. 文件系统性能</h2><p>访问磁盘比访问内存慢得多。读内存中一个 32 位字大概要 10ns。从硬盘上读的速度大约为 100MB/s，对每 32 位字来说，大约要慢 4 倍，还要加上 5~10ms 寻道时间，并等待所需的扇面抵达磁头下。</p>
<h3 id="3-2-1-磁盘高速缓存"><a href="#3-2-1-磁盘高速缓存" class="headerlink" title="3.2.1. 磁盘高速缓存"></a>3.2.1. 磁盘高速缓存</h3><p>高速缓存指的是一系列的块， 它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。<br>最常用的减少磁盘访问次数技术是 <strong>块高速缓存（block cache）</strong>或者 <strong>缓冲区高速缓存（buffer cache）</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/85532654edb9a0c1861fabf488dc2dda.png" alt="image.png"><br><strong>散列表：</strong>高速缓存使用散列表结构，方便快速查找所需要的块。</p>
<p><strong>LRU：</strong><br>使用双向链表把块以先后使用顺序链接起来。最近使用最少的块在链表的前端，最近使用最多的块在该链表的后端。</p>
<p>如果一个关键块（如 i 节点块）读进了高速缓存并做过修改，在写回磁盘前系统崩溃了，导致文件系统的不一致。如果把 i 节点块放在 LRU 链的尾部，在它到达链首并写回磁盘前，需要相当长的一段时间。</p>
<p><strong>置换策略：</strong><br>如果高速缓存已满，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入以后修改过，则要把它写回磁盘。<br>与分页相似，常用的页面置换算法适用于高速缓存。</p>
<p><strong>同步 / 异步写回：</strong><br>我们不希望数据块在告诉缓存放很久之后才写回磁盘，这样十分容易丢失数据。为此操作系统采取了策略。</p>
<ul>
<li>异步定时写回：UNIX 系统启动时会在后台运行 update 程序，每隔 30s 就执行 sync 调用。</li>
<li>同步写回： Windows 执行 FlushFileBuffers 系统调用。只要被写入高速缓存，就把每个被修改的块写回磁盘，但这样需要更多的磁盘 I/O。</li>
</ul>
<h3 id="3-2-2-块提前读"><a href="#3-2-2-块提前读" class="headerlink" title="3.2.2. 块提前读"></a>3.2.2. 块提前读</h3><p>在需要用到块之前，提前将其写入高速缓存，从而提高命中率。<br>许多文件都是顺序读的，如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作且在完成之后，会检查块 k+1 是否已经在高速缓存。如果还不在，文件系统会为块 k+1 安排一个预读。</p>
<p>块提前读策略只适用于实际顺序读取的文件。对随机访问文件，提前读丝毫不起作用。文件系统通过跟踪每一个打开文件的访问方式来确定时候是顺序访问。</p>
<p>在最初不能确定文件属于哪种存取方式时，先将该位设置成顺序访问方式，查找一完成就将该位清除。这样即便弄错了一次也只是浪费一小段磁盘的带宽而已。</p>
<h3 id="3-2-3-减少磁盘臂运动"><a href="#3-2-3-减少磁盘臂运动" class="headerlink" title="3.2.3. 减少磁盘臂运动"></a>3.2.3. 减少磁盘臂运动</h3><p>把有可能顺序访问的块放在一起，最好是在同一个柱面上，从而减少磁盘臂的移动次数。<br> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/e9eb9f4d0df9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e9eb9f4d0df9/" class="post-title-link" itemprop="url">操作系统从入门到入土③：内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-12 11:17:19" itemprop="dateCreated datePublished" datetime="2021-10-12T11:17:19+08:00">2021-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/e9eb9f4d0df9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="e9eb9f4d0df9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>30 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-无存储器抽象"><a href="#1-无存储器抽象" class="headerlink" title="1. 无存储器抽象"></a>1. 无存储器抽象</h1><p>早期大型计算机（20 世纪 60 年代之前）、小型计算机（20 世纪 70 年代之前）和个人计算机（20 世纪 80 年代之前）都没有存储器抽象。<strong>每一个程序都直接访问物理内存。</strong></p>
<blockquote>
<p>例如：<code>MOV REGISTER1, 1000</code>，计算机会将位置为 1000 的物理内存中的内容移到 REGISTER1 中。</p>
</blockquote>
<p><strong>问题 1：保护</strong></p>
<ol>
<li>如果用户程序可以寻址内存的每个字节，就可以很容易地破坏操作系统，从而使系统慢慢地停止运行。</li>
<li>想要同时运行多个程序是很困难的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容。</li>
</ol>
<p><strong>保护键：</strong></p>
<blockquote>
<p>对比：与锁的性质类似</p>
</blockquote>
<p>IBM 360 的早期模型是这样运行多个程序的</p>
<ul>
<li>每一个内存单元都会被分配一个 4 位的保护键，保护键存储在 CPU 的特殊寄存器中。</li>
<li>每一个进程有一个 PSW（Program Status Word，程序状态字），PSW 中保存一个 4 位的码。</li>
</ul>
<p>保护键作为进程和其相关内存的唯一标识。在访问内存的时候，首先查看进程的 PSW 码和这个内存块的保护键是否相同。如果相同就可以访问，如果不同，就禁止该进程访问。因为只有操作系统才能修改保护键，这样就避免了不同程序之间的相互访问。</p>
<p><strong>问题 2：重定位</strong><br>跳转指令跳转的地址是物理地址，多个程序运行时会出现问题。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fc710c94029dbb4af262853ac5447f69.png" alt="image.png"><br>a 和 b 为两个程序，依次装载到内存后如 c 所示，b 中的 JMP28 应该跳转至地址 16412，但实际却是跳转到了 28，原因就在于这两个程序中的地址都是绝对物理地址。</p>
<p><strong>静态重定位：</strong><br> IBM 360 对上述问题的补救方案是静态重定位。只要在装载程序的时候给每一个程序地址加上装载时的地址偏移量就可以了，例如 b 程序被装载到地址 16384，那么 JMP 28 加上偏移量 16384 就行了。<br>但是这个机制会减慢装载速度，而且装载器需要区分地址和常数，所以程序需要提供区分信息。</p>
<h1 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2. 地址空间"></a>2. 地址空间</h1><p>地址空间是进程可用于寻址内存的一套地址集合，其为程序创造了一种抽象的内存。每个进程都有唯一的专属地址空间，这就使得每个程序内代码中的地址也是唯一的（如上述 JMP 28  的物理地址也有别于别的程序的 28）。</p>
<h2 id="2-1-基址寄存器与界限寄存器"><a href="#2-1-基址寄存器与界限寄存器" class="headerlink" title="2.1. 基址寄存器与界限寄存器"></a>2.1. 基址寄存器与界限寄存器</h2><p>使用动态重定位，把每个进程的私有地址空间映射到物理内存的不同部分。<br>早期计算机（Intel 8088、CDC 6600 等）使用基址寄存器与界限寄存器实现：</p>
<ul>
<li>程序装载到内存中连续的空闲位置且无须重定位。</li>
<li>进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中，根据起始点和长度就能确定一段唯一的地址。</li>
</ul>
<p>每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。<br>同时，它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超过了界限，会产生错误并中止访问。</p>
<p><strong>缺点：</strong><br>每次访问内存都需要进行加法和比较运算，加法运算由于进位传递时间的问题会比较慢。</p>
<blockquote>
<p>对比：静态重定位</p>
</blockquote>
<h2 id="2-2-交换技术"><a href="#2-2-交换技术" class="headerlink" title="2.2. 交换技术"></a>2.2. 交换技术</h2><blockquote>
<p>针对内存超载的处理方法</p>
<ul>
<li>交换：把一个进程完整调入内存运行一段时间然后把它存回磁盘。</li>
<li>虚拟内存</li>
</ul>
</blockquote>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0fbe4c1e07dbdc1d9eb13dd9d4252b02.png" alt="image.png"><br>开始时内存中只有进程 A。之后创建进程 B 和 C 或者从磁盘将它们换入内存。之后 A 被交换到磁盘，然后 D 被调入，B 被调出，最后 A 再次被调入。<br>由于 A 的位置发生变化，所以在它换入的时候通过软件或者在程序运行期间通过硬件对其地址进行重定位。例如，基址寄存器和界限寄存器就适用于这种情况。</p>
<p><strong>数据增长：</strong><br>如果进程的数据段可增长（动态分配内存）<br>若其与一个空闲区相邻，可把该空闲区分配给该进程。<br>若其与另一个进程相邻，则要么把该进程移到一个空间足够大的地方，要么把其他进程交换出去以生成一个足够大的空闲区（交换区满了就只能挂起了）。</p>
<p>另一种方法是进程进入内存时分配一些额外的内存。</p>
<h2 id="2-3-空闲内存管理"><a href="#2-3-空闲内存管理" class="headerlink" title="2.3. 空闲内存管理"></a>2.3. 空闲内存管理</h2><p>在动态分配内存时，操作系统必须对其进行管理。<br>有两种方法跟踪内存使用情况：位图和空闲区链表。</p>
<h3 id="2-3-1-位图存储管理"><a href="#2-3-1-位图存储管理" class="headerlink" title="2.3.1. 位图存储管理"></a>2.3.1. 位图存储管理</h3><p>内存被划分成几个字到几千字节的分配单元，每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cb159ef29f82477ef771ee7bf69cfd53.png" alt="image.png"></p>
<blockquote>
<p>a) 内存：有 abcde 5 个进程和 3 个空闲区<br>b) 内存对应的位图<br>c) 空闲区链表形式</p>
</blockquote>
<p><strong>缺点：</strong><br>在决定把一个占 k 个分配单元的进程调入内存时，存储管理器必须搜索位图找出有 k 个连续 0 的串，这比较耗时，因为在位图中该串可能跨越字的边界。</p>
<h3 id="2-3-2-链表存储管理"><a href="#2-3-2-链表存储管理" class="headerlink" title="2.3.2. 链表存储管理"></a>2.3.2. 链表存储管理</h3><p>维护一个记录已分配内存段和空闲内存段的链表。<br>链表中的每一个结点都包含以下字段：空闲区或进程的指示标志、起始地<br>址、长度和指向下一结点的指针。</p>
<p><strong>分配内存算法：</strong></p>
<ol>
<li>首次适配：存储管理器搜索链表，找到足够大的空闲区，并将其分为两部分，一部分供进程使用，另一部分形成新的空闲区。</li>
<li>下次适配：和首次适配类似，每次找到合适的空闲区都记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索。</li>
<li>最佳适配：搜索整个链表，找到最小适配的空闲区。最佳适配算法会生成大量无用的小空闲区，比首次适配算法浪费更多的内存。</li>
<li>最差适配：与最佳相反，总是分配最大的空闲区，使新的空闲区比较大从而可以继续使用</li>
<li>快速适配：为常用大小的空闲区维护单独的链表。例如，一个链表第一个节点指向大小近似为 4KB 的空闲链表表头的指针，第二个指向 8KB 的，第三个指向 12KB 的……</li>
</ol>
<p>如果进程和空闲区维护各自的链表，那么算法速度能得到提高，但是链表维护成本也增加了。可以对空闲区列表排序提高最佳适配算法的检索速度</p>
<h1 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h1><blockquote>
<p>对比：<a href="#lJuAx">交换</a></p>
</blockquote>
<p>每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作<strong>页面（page）</strong>。 每一页有连续的地址范围。</p>
<ul>
<li>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。</li>
<li>当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</li>
</ul>
<h2 id="3-1-分页"><a href="#3-1-分页" class="headerlink" title="3.1. 分页"></a>3.1. 分页</h2><p>页面是由虚拟地址空间分割成的块，其在物理内存中对应的单元称为<strong>页框（page frame）</strong>，页面和页框大小通常是一样的。RAM 和磁盘之间的交换是以页面为单元进行的。</p>
<p><strong>虚拟地址：</strong><br>当程序执行指令 <code>MOV REG, 1000</code> 时，它把地址为 1000 的内存单元的内容复制到 REG 中。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>由程序产生的这些地址称为<strong>虚拟地址（virtual address）</strong>，它们构成了一个<strong>虚拟地址空间（virtual addressspace）</strong>。</p>
<ul>
<li>在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字。</li>
<li>在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到<strong>内存管理单元（Memory Management Unit, MMU）</strong>，MMU 把虚拟地址映射为物理内存地址。</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/092e1c73d5b99a606760bf2c77fc1a58.png" alt="image.png"></p>
<p><strong>MMU 映射机制：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79a2a7a5bc5e46d068d10f3f1e63116.png" alt="image.png"></p>
<ul>
<li>假如程序访问地址 0：<code>MOV REG, 0</code></li>
</ul>
<p>将虚拟地址 0 送到 MMU。MMU 发现虚拟地址在页面 0（0k<del>4k），其映射到页框 2（8k</del>12k），所以把地址变换为 8192 并把变换后的地址送到总线上。</p>
<ul>
<li>假如程序访问了一个未映射的页面：<code>MOV REG, 32780</code></li>
</ul>
<p>MMU 发现虚拟页面 8（32k-36k）没有被映射，于是使 CPU 陷入到操作系统，这个陷阱称为 ** 缺页中断 ** 或 ** 缺页错误（page fault） **。<br>随后操作系统找到一个不常使用的页框并把它的内容写入磁盘，然后把需要访问的页面读到该页框中，修改映射关系，再重新启动引起陷阱的指令。</p>
<p><strong>MMU 内部结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/00b9fa96cf01785079039c2a723adddf.png" alt="image.png"><br>这是 64kb 虚拟内存的 MMU 结构，第一列为页框号，第二列表示是否存在物理内存的映射关系。<br>输入的 16 位虚拟地址。前 4 位为页号，可以表示 16 个页面；后 12 位为偏移量。</p>
<ul>
<li>第二列为 0，则说明不存在物理内存的映射关系，这将引起一个陷阱。</li>
<li>第二列为 1，则将页表中查到的页框号复制到输出寄存器的高 3 位中，再加上虚拟地址的低 12 位，就构成了 15 位的物理地址，将其送到内存总线。</li>
</ul>
<p><strong>页表：</strong><br>页表的目的是把虚拟页面映射为页框。<br>页表每一项称为页表项<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/82a69ef8b9d229a38b91499e1c6de756.png" alt="image.png"></p>
<ul>
<li>页框号：通过映射要获得的值，与低位虚拟地址结合组成物理地址。</li>
<li>“在 / 不在” 位：判断是否有页框号，如果不存在则会引起一个缺页中断。</li>
<li>保护位：指出一个页允许什么类型的访问，读、写、执行等。</li>
<li>修改位：在写入一页时由硬件自定设置修改位。</li>
<li>访问位：页面被访问时设置访问位。不再被使用的页面会在缺页中断时被重新选择。</li>
<li>高速缓存禁止位：用于禁止高速缓存</li>
</ul>
<p><strong>缺页中断过程：</strong></p>
<ol>
<li><strong>陷入内核。</strong>硬件陷入内核，在堆栈中保存程序计数器。再启动一个汇编代码例程保存通用寄存器和其他易失的信息。</li>
<li><strong>得到虚拟页面。</strong>操作系统发现缺页中断，得到需要的虚拟页面，通常在硬件寄存器中。</li>
</ol>
<p>若没有，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。</p>
<ol start="3">
<li><strong>检查地址。</strong>检查这个虚拟地址是否有效，并检查存取与保护是否一致。</li>
</ol>
<p>如果存取与保护不一致，向进程发出一个信号或杀掉该进程。</p>
<ol start="4">
<li><strong>选择页框。</strong>如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。</li>
</ol>
<p>如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。</p>
<ol start="5">
<li><strong>写回脏页框。</strong>如果选择的页框被修改过（脏的），则将该页写回磁盘。</li>
</ol>
<p>并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。<br>该页框被标记为忙，以免因为其他原因而被其他进程占用。</p>
<ol start="6">
<li><p><strong>装入磁盘地址。</strong>一旦页框是干净的（本就是干净的或写回磁盘后变干净），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。</p>
<blockquote>
<p>该页面正在被装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</p>
</blockquote>
</li>
<li><p><strong>恢复状态。</strong>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。</p>
</li>
</ol>
<p>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。</p>
<ol start="8">
<li><strong>恢复进程。</strong>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。</li>
</ol>
<p>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。</p>
<p><strong>策略和机制分离：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/97adbcd53bb76f090983e69f0c6cea49.png" alt="image.png"><br>出现缺页中断：</p>
<ol>
<li>缺页中断处理程序找出需要哪个虚拟页面，并发送一条消息给外部页面调度程序告诉它发生了什么问题。</li>
<li>外部页面调度程序从磁盘中读入所需的页面，把它复制到自己的地址空间的某一位置。然后告诉缺页中断处理程序该页面的位置。</li>
<li>缺页中断处理程序从外部页面调度程序的地址空间中清除该页面的映射，然后请求 MMU 处理程序把它放到用户地址空间的正确位置，随后就可以重新启动用户进程了。</li>
</ol>
<h2 id="3-2-TLB"><a href="#3-2-TLB" class="headerlink" title="3.2. TLB"></a>3.2. TLB</h2><p>虚拟地址到物理地址的映射必须非常快。<br>分页机制使得程序需要访问页表，从而更加频繁的访问内存。<br>程序每条指令进行一两次或更多页表访问是必要的。如果执行一条指令需要 1ns，页表查询必须在 0.2 ns 之内完成。</p>
<p>由于大多数程序总是对少量的页面进行多次访问，所以可以为计算机设置一个缓存。</p>
<p><strong>概述：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/90113bce50b23988a7ac326a0509e061.png" alt="image.png"><br>此方案为计算机设置一个 <strong>转换检测缓冲区（Translation Lookaside Buffer，TLB，也称快表）</strong>，将虚拟地址直接映射到物理地址，而不必再访问页表。<br>它通常在 MMU 中，包含少量的表项（一般不超过 256 个），这些字段与页表中的一致，有效位表示该表项是否有效。</p>
<p>程序将虚拟地址放入 MMU 中进行转换时，硬件首先会通过虚拟页面号在 TLB 中寻找匹配：</p>
<ol>
<li>能找到且操作不违反保护位则直接返回，违反保护位则产生一个保护错误。</li>
<li>若找不到则会进行正常的页表查询，将查询得到的新项替代 TLB 中的一个淘汰项。新项的所有字段都被复制到 TLB，淘汰项的会将修改位复制会内存里对应的页表项中。</li>
</ol>
<p><strong>未命中情况：</strong></p>
<ul>
<li>访问非法地址：程序可能访问了一个非法地址，系统会产生段错误，不需要往 TLB 中添加映射。</li>
<li>软失效：TLB 失效但内存页表未失效，这时只需更新一下 TLB 就行，不需要产生磁盘 I/O。</li>
<li>硬失效：TLB 失效且内存页表失效，引发缺页中断。<ul>
<li>次要缺页错误：页面可能就在内存中，但未记录在该进程的页表里。</li>
</ul>
</li>
</ul>
<p>比如该页面可能已由其他进程从硬盘中调入内存，这时只需要把所需的页面正确映射到页表中就行。</p>
<ul>
<li>严重缺页错误：页面不在内存中，需要从硬盘中重新调入。</li>
</ul>
<p><strong>硬件采用简单的 TLB 管理方式，就能够获得较高的 TLB 命中率的原因：</strong><br>应用程序在运行过程中访问内存的模式具有时间局部性和空间局部性。</p>
<ul>
<li>时间局部性：被访问过一次的内存位置在未来通常会被多次访问。</li>
<li>空间局部性：如果一个内存位置被访问，那么其附近的内存位置通常在未来也会被访问。</li>
</ul>
<p><strong>软件 TLB 管理：</strong><br>TLB 表项被操作系统显式地装载。</p>
<ol>
<li>当 TLB 访问失效时，不再是由 MMU 到页表中查找并取出需要的页表项，而是生成一个 TLB 失效并将问题交给操作系统解决。</li>
<li>系统找到该页面，然后从 TLB 中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。当然，所有这一切都必须在有限的几条指令中完成，因为 TLB 失效比缺页中断发生得更加频繁。</li>
</ol>
<p>使用软件处理 TLB 失效时，需先在内存中找到页表，以定位到页表项。<br>但是页表也有自己的虚拟地址，就像查询其他虚拟地址一样，获取页表的物理地址时也会出现 TLB 失效。</p>
<h3 id="3-2-1-TLB-刷新"><a href="#3-2-1-TLB-刷新" class="headerlink" title="3.2.1. TLB 刷新"></a>3.2.1. TLB 刷新</h3><p>由于 TLB 是使用虚拟地址进行查询的，所以操作系统在进行页表切换（应用程序切换）的时候需要主动刷新 TLB。</p>
<p><strong>标签：</strong><br>若在切换应用程序的过程中刷新 TLB，当应用程序开始执行时会发生 TLB 未命中的情况。<br>一种为 TLB 缓存项打上 “标签” 的设计避免了这样的开销。AArch64 体系结构提供了 ASID（ Address Space IDentifier）功能，x86-64 上对应的功能称为（PCID, Process Context IDentifier）。</p>
<p>操作系统可以为不同的应用程序分配不同的 ASID 作为应用程序的身份标签，再将这个标签写入应用程序的页表基地址寄存器中的空闲位（如 TTBRO_ EL1 的高 16 位）。<br>同时，TLB 中的缓存项也会包含 ASID 这个标签，从而使得 TLB 中属于不同应用程序的缓存项可以被区分开。因此，在切换页表的过程中，操作系统不再需要清空 TLB 缓存项。</p>
<h2 id="3-3-针对大内存的页表"><a href="#3-3-针对大内存的页表" class="headerlink" title="3.3. 针对大内存的页表"></a>3.3. 针对大内存的页表</h2><p>如果虚拟地址空间很大，页表也会很大。<br>假设页面大小为 4kb，32 位的地址空间将有 100 万表项，每个进程都需要自己的页表。</p>
<h3 id="3-3-1-多级页表"><a href="#3-3-1-多级页表" class="headerlink" title="3.3.1. 多级页表"></a>3.3.1. 多级页表</h3><p>引入多级页表的原因是避免把全部页表一直保存再内存中。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ea5f80ecf748133e669860571ef9ae6c.png" alt="image.png"><br>如 a) 所示，32 位地址被划分为 10 位的 PT1 域、10 位的 PT2 域、12 位的 Offset 偏移量域。<br>因为偏移量是 12 位，所以页面大小是 212 = 4KB。10 位的 PT1 和 10 位的 PT2 一共 20 位，所以共有 220 个页面。</p>
<p>当一个虚拟地址被送到 MMU 时，首先提取 PT1 域将其作为顶级页表的索引。<br>因为整个 4GB（232 B = 4GB）虚拟地址空间已经按 4KB 大小分块，所以顶级页表中这 1024 个表项的每一个都表示 4M（PT2 的 10 位和偏移量的 12 位，222B = 4M）的块地址范围。</p>
<p>顶级页表的表项 0 指向程序正文的页表，表项 1 指向数据的页表，表项 1023 指向堆栈的页表。</p>
<h3 id="3-3-2-倒排页表"><a href="#3-3-2-倒排页表" class="headerlink" title="3.3.2. 倒排页表"></a>3.3.2. 倒排页表</h3><p>实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项。</p>
<p>虽然倒排页表节省了大量的空间，但从虚拟地址到物理地址的转换会变得很困难。<br>当进程 n 访问虛拟页面 p 时，硬件不能把 p 当作指向页表的一个索引来查找物理页框，必须搜索整个倒排页表来查找某一个表项（n，p），而且每一个内存访问操作都要执行一次。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/448fc4313215b1bea76c49137f20252c.png" alt="image.png"><br>解决办法是使用 TLB。如果 TLB 能够记录所有频繁使用的页面，地址转换就可能变<br>得像通常的页表一样快。<br>但是，当发生 TLB 失效时，需要用软件搜索整个倒排页表。可以建立一张散列表，用虚拟地址来散列，相同散列值的虚拟页面被链接在一起。 <br>如果散列表中的槽数与机器中物理页面数一样多，那么散列表的冲突链的平均长度将会是 1 个表项的长度，这将会大大提高映射速度。一旦页框号被找到，新的（虚拟页号，物理页框号）对就会被装载到 TLB 中。</p>
<h2 id="3-4-页面置换算法"><a href="#3-4-页面置换算法" class="headerlink" title="3.4. 页面置换算法"></a>3.4. 页面置换算法</h2><p>缺页中断时，操作系统必须在内存中选择一个页面将其换出内存。<br>如果换出的页面在内存驻留期间被修改过，就必须把它写回磁盘；否则直接淘汰就行了。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ab0c544f905e42850e96d56a9776fa23.png" alt="image.png"></p>
<h3 id="3-4-1-最优算法"><a href="#3-4-1-最优算法" class="headerlink" title="3.4.1. 最优算法"></a>3.4.1. 最优算法</h3><p>缺页中断发生时，下一条指令的那个页面将很快被访问，其他页面则可能要到 10、100 或 1000 条指令后才会被访问，所以每个页面都可以用其被访问前要执行的指令数作为标记。</p>
<p>最优页面置换算法规定应该置换标记最大（最晚执行）的页面。这样，下次调入这个页面发生的缺页中断就会被推迟。</p>
<p>但是当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。<br>当然，通过先在仿真程序上运行程序，跟踪所有页面的访问情况，然后在第二次运行时利用第一次收集的信息是可以实现最优页面置换算法的。</p>
<p>必须清楚以上方法只针对刚刚被测试过的程序和它的一个特定的输入。虽然这个方法对评价其他页面置换算法很有用，但它在实际系统中却不能使用。</p>
<h3 id="3-4-2-最少使用算法"><a href="#3-4-2-最少使用算法" class="headerlink" title="3.4.2. 最少使用算法"></a>3.4.2. 最少使用算法</h3><p>系统为每一个页面设置了 R/M 位。</p>
<ul>
<li>当页面被访问时设置 R 位。当启动一个进程时，将其所有的页面的这两个位都设为 0，R 位定期清 0（比如在时钟中断时）</li>
<li>当页面被写入时设置 M 位。</li>
</ul>
<p>当发生缺页中断时，操作系统检查所有的页面并根据它们当前的 R 位和 M 位，有以下几种情况：</p>
<ol>
<li>未被访问，未被修改。</li>
<li>未被访问，已被修改。（可能时钟中断导致 R 位清 0）</li>
<li>已被访问，未被修改。</li>
<li>已被访问，已被修改。</li>
</ol>
<p>NRU（Not Recently Used，最近未使用）算法优先淘汰未被访问的页面，若待选页面的访问位一致，则优先淘汰未被修改的页面。<br>其原理是在最近一个时钟滴答中淘汰一个没有被访向的已修改页面要比淘汰一个被频繁使用未修改页面好。</p>
<h3 id="3-4-3-先进先出算法"><a href="#3-4-3-先进先出算法" class="headerlink" title="3.4.3. 先进先出算法"></a>3.4.3. 先进先出算法</h3><p>由操作系统维护一个内存中的页面链表，最新进入的页面放在表尾，最早进入的页面放在表头。<br>当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。FIFO 可能会淘汰常用页面，由于这一原因，很少使用纯粹的 FIFO 算法。</p>
<h3 id="3-4-4-第二次机会算法"><a href="#3-4-4-第二次机会算法" class="headerlink" title="3.4.4. 第二次机会算法"></a>3.4.4. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去。所以我们可以给经常使用的页面一次 “机会”。<br>第二次机会（second chance）算法在 FIFO 的基础上，只淘汰未被访问的页面。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f711b7fff1c0ac76753a40479bdb8f2.png" alt="image.png"><br>对 FIFO 做修改，淘汰表头时先检查其 R 位。</p>
<ul>
<li>如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉</li>
<li>如果 R 位是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续搜索。</li>
</ul>
<h3 id="3-4-5-时钟算法"><a href="#3-4-5-时钟算法" class="headerlink" title="3.4.5. 时钟算法"></a>3.4.5. 时钟算法</h3><blockquote>
<p>对比 <a href="#cIq6z">第二次机会算法</a>、<a href="#ruPN1">先进先出算法</a></p>
</blockquote>
<p>第二次机会算法经常要在链表中移动页面，既降低了效率又不是很有必要。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/84944403fb0bf8c54ae1f7bd3197f319.png" alt="image.png"><br>时钟算法把所有的页面保存再一个环形链表中（顺时针），一个指针指向最先进入的页面，代表表头。</p>
<p>当发生缺页中断时，检查指针指向的页面的 R 位：</p>
<ul>
<li>若 R = 0：淘汰该页面，将新的页面替换该页面，指针向后移动一位</li>
<li>若 R = 1：将该页面的 R 位清 0，将指针指向下个节点，继续以上流程判断节点的 R 位。</li>
</ul>
<h3 id="3-4-6-最近最少使用算法"><a href="#3-4-6-最近最少使用算法" class="headerlink" title="3.4.6. 最近最少使用算法"></a>3.4.6. 最近最少使用算法</h3><blockquote>
<p>对比 <a href="#ejVd3">最少使用算法</a></p>
</blockquote>
<p>当缺页中断发生时，置换未使用时间最长的页面，这个策略被称为 LRU（Least Recently Used）。</p>
<p>需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问内存都必须要更新整个链表。</p>
<p><strong>NFU（Not Frequently Used，最不常用）算法：</strong><br>将每个页面与一个软件计数器关联，计数器的初值为 0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的 R 位加到它的计数器上。<br>这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。</p>
<p><strong>老化（aging）算法：</strong><br>修改 NFU 以模拟 LRU，在 R 位被加进之前先将计数器右移一位，然后将 R 位加到计数器最左端的位位，这样最近被访问的页面的计数器（例如 10000000）会比之前访问过的要大（例如 00000010）。发生缺页中断时置换计算器值最小的页面。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/411fc5d1851db93b0dec9282f198896d.png" alt="image.png"><br>图中页面内存的是计数器。<br>假设在第一个时钟后，页面 0 ~ 5 的 R 位值分别是 101011。即在时钟 0 到 1 期间，访问了页面 0、2、4、5，它们的 R 位设置为 1。对应的 6 个计数器在经过移位并把 R 位插入其左端后的值，如 a) 页面中的计数器所示。</p>
<h3 id="3-4-7-工作集算法"><a href="#3-4-7-工作集算法" class="headerlink" title="3.4.7. 工作集算法"></a>3.4.7. 工作集算法</h3><p>一个进程当前正在使用的页面的集合称为它的 <strong>工作集</strong>。</p>
<ul>
<li>如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断。</li>
<li>若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度也会变得很缓慢。</li>
</ul>
<p>设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了，该方法称为 ** 工作集模型 **</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/639ebbeb3e9c243d558065f686e1ff7e.png" alt="image.png"></p>
<h3 id="3-4-8-工作集时钟算法"><a href="#3-4-8-工作集时钟算法" class="headerlink" title="3.4.8. 工作集时钟算法"></a>3.4.8. 工作集时钟算法</h3><p>当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。</p>
<p><strong>WSClock</strong>（工作集时钟）算法基于时钟算法，并且使用了工作集信息，由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4d3a995bf746854cabf7612da8e96272.png" alt="image.png"><br>每次缺页中断时，首先检查指针指向的页面。</p>
<ul>
<li>如果 R 位为 1，那么该页面在当前时钟滴答中就被使用过，不适合被淘汰。把 R 位设为 0，然后指针指向下一个页面，并重复该算法。如 a) b)。</li>
<li>如果页面的生存时间大于 r 并且该页面未被修改，它就不在工作集中，并且在磁盘上有一个有效的副本。申请此页框，并把新页面放在其中。如 c) d)。</li>
<li>如果此页面被修改过，就不能立即申请页框，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。<blockquote>
<p>原则上，所有的页面都有可能因为磁盘 I/O 在某个时钟周期被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p>
</blockquote>
</li>
</ul>
<h1 id="4-分页系统中的设计问题"><a href="#4-分页系统中的设计问题" class="headerlink" title="4. 分页系统中的设计问题"></a>4. 分页系统中的设计问题</h1><h2 id="4-1-局部分配与全局分配"><a href="#4-1-局部分配与全局分配" class="headerlink" title="4.1. 局部分配与全局分配"></a>4.1. 局部分配与全局分配</h2><p>运行多个进程时发生缺页中断，该如何进行页面置换？</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b5a66a2a41a6a9c6c4869087deb8c3fa.png" alt="image.png"><br>A、B、C 是正在运行的进程，加入 A 发生了缺页中断，有两种方法</p>
<ol>
<li>局部页面置换：淘汰该进程生存时间最短的页面（A5）</li>
<li>全局页面置换：淘汰内存中生存时间最短的页面（B3）。通常情况下工作得比局部算法好</li>
</ol>
<h2 id="4-2-负载控制"><a href="#4-2-负载控制" class="headerlink" title="4.2. 负载控制"></a>4.2. 负载控制</h2><p>即使是使用最优页面置换算法并对进程采用理想的全局页框分配，系统也可能会发生页面频繁置换的情况。</p>
<p>一个方法是将一部分进程<a href="#lJuAx">交换</a>到磁盘，并释放他们所占有的所有页面。</p>
<h2 id="4-3-共享页面"><a href="#4-3-共享页面" class="headerlink" title="4.3. 共享页面"></a>4.3. 共享页面</h2><p>只读的页面（程序文本）可以共享，数据页面不能共享。</p>
<p>共享页面上存在一个问题，假设进程 A 和进程 B 同时运行一个编辑器并共享页面。如果调度程序决定从内存中移走 A，撤销其所有的页面并用一个其他程序来填充这些空的页框，则会引起 B 产生大量的缺页中断，才能把这些页面重新调入。</p>
<p><strong>写时拷贝：</strong><br>UNIX 中 fork 系统调用后，父进程和子进程要共享程序文本和数据。</p>
<ol>
<li>让这些进程分别拥有它们自己的页表，但都指向同一个页面集合。</li>
<li>一旦某个应用程序对该内存区域进行修改，就会触发缺页异常。这里的缺页异常是由于违反权限导致的，不同于之前所说的换页机制下的缺页异常是由于未映射导致的。</li>
<li>在触发了缺页异常后，CPU 同样会将控制流传递给操作系统预先设置的缺页异常处理函数。</li>
<li>在该函数中，操作系统会发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的。</li>
</ol>
<p>于是，操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。</p>
<p>若其中一个进程更新了数据，就会触发只读保护，并引发操作系统陷阱，生成一个该页的副本，这样每个进程都有自己的专用副本。<br>这种策略意味着那些从来不会执行写操作的页面是不需要复制的，只有实际修改的数据页面需要复制。</p>
<p><strong>内存去重：</strong><br>操作系统可以定期地扫描相同内容的物理页，找到其映射的虚拟页，然后只保留其中一个物理页。<br>并将具有相同内容的其他虚拟页都用写时拷贝的方式映射到这个物理页，然后释放其他的物理页以供将来使用。</p>
<p>内存去重功能会对应用程序访存时延造成影响。当应用程序写一个被去重的内存页时，既会触发缺页异常，又会导致内存拷贝，从而可能导致性能下降。</p>
<blockquote>
<p>时间换空间</p>
</blockquote>
<h2 id="4-4-共享库"><a href="#4-4-共享库" class="headerlink" title="4.4. 共享库"></a>4.4. 共享库</h2><p>现代操作系统中，有很多大型库被众多进程使用。一个更加通用的技术是使用 <strong>共享库</strong>（在 Windows 中称作 <strong>DLL</strong> 或 ** 动态链接库 **）。</p>
<p>当链接一个程序时，要在链接器的命令中指定一个或多个目标文件，可能还包括一些库文件。链接器会在库中寻找未定义外部函数，找到了则将它们加载到可执行二进制文件中。<br>静态链接上百个这些库的程序会浪费大量的磁盘空间，装载这些程序时也会浪费大量的内存空间。<br>当一个程序和共享库链接时，链接器没有加载被调用的函数，而是加载了一小段能够在运行时绑定被调用函数的存根例程（stub routine）。如果其他程序已经装载了某个共享库，就不用再次装载了。</p>
<h1 id="5-分段"><a href="#5-分段" class="headerlink" title="5. 分段"></a>5. 分段</h1><p>对许多问题来说，有多个独立的地址空间会好得多。<br>只使用一个虚拟空间时，我们需要管理表的扩张和收缩。<br>如果一个程序中变量的数量要远比其他部分的数量多时的情况。地址空间中分给符号表的块可能会被装满，但这时其他表中还有大量的空间。</p>
<p><strong>段：</strong><br>可以在及其上提供多个互相独立的逻辑段地址空间，每个段之间都是隔离的。<br>每个段由一个从 0 到最大的地址序列构成。段的长度可以是 0 到某个允许的最大值之间的任何一个值。不同段的长度通常情况下也都不相同，并在运行期间长度可变。</p>
<p>如果每个过程都位于一个独立的段中并且起始地址是 0，那么把单独编译好的过程链接起来的操作就可以得到很大的简化。</p>
<p>程序必须提供两部分地址，一个段号和 一个段内地址。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a73916e01c1798ff10b6cb9566e3b8e6.png" alt="image.png"></p>
<h1 id="6-内存分配"><a href="#6-内存分配" class="headerlink" title="6. 内存分配"></a>6. 内存分配</h1><h2 id="6-1-伙伴系统"><a href="#6-1-伙伴系统" class="headerlink" title="6.1. 伙伴系统"></a>6.1. 伙伴系统</h2><p>伙伴系统（buddy system）的基本思想是将物理内存划分成连续的块，以块作为基本单位进行分配。不同块的大小可以不同，但每个块都由一个或多个连续的物理页组成，物理页的数量必须是 2 的 n 次幂。</p>
<p><strong>分裂与合并：</strong><br>在处理分配请求的过程中，大的块可以分裂成两个小一号的块，这两个块互为伙件。分裂得到的块可以继续分裂，直到得到一个大小合适的块去服务相应的分配请求。<br>在一个块被释放后，分配器会找到其伙伴块，若伙伴块也处于空闲的状态，则将这两个伙伴块进行合并，形成一个大一号的空闲块，然后继续尝试向上合并。由于分裂操作和合并操作都是级联的，因此能够很好地缓解外部碎片的问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/b41ef6b33f18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b41ef6b33f18/" class="post-title-link" itemprop="url">操作系统从入门到入土②：进程与线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-13 10:23:33" itemprop="dateCreated datePublished" datetime="2021-09-13T10:23:33+08:00">2021-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/b41ef6b33f18/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="b41ef6b33f18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><p>进程本质上是正在执行的一个程序，它有程序、输入、输出以及状态。</p>
<p>单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>
<p>当一个进程有特定事件要求在指定的若干亳秒内发生，那么必须采取特殊措施以保证它们一定在这段时间中发生。然而，通常大多数进程并不受 CPU 多道程序设计或其他进程相对速度的影响。</p>
<p><strong>守护进程（daemon）：</strong>后台执行的进程</p>
<p><strong>地址空间（address space）：</strong><br>这是从某个最小值的存储位置（通常是 0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。</p>
<p><strong>子进程：</strong><br>若一个进程能够创建一个或多个进程（称为 <strong>子进程</strong>），而且这些进程又可以创建子进程，则形成得到进程树。合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信称为 <strong>进程间通信</strong></p>
<h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1. 创建"></a>1.1. 创建</h2><p><strong>4 种创建进程的主要事件：</strong></p>
<ul>
<li>系统初始化创建：启动系统时创建</li>
<li>运行的程序执行创建进程的系统调用：fork</li>
<li> 用户请求创建一个新进程：手动运行软件</li>
<li>一个批处理作业的初始化</li>
</ul>
<p><strong>fork：</strong></p>
<ol>
<li>在调用了 fork 后，这两个进程（父进程和子进程)）拥有相同的内存映像、同样的环境字符串和同样的打开文件。</li>
<li>子进程接着执行 execve 或一个类似的系统调用，以修改其内存映像并运行一个新的程序。</li>
<li>之所以要安排两步建立进程，是为了在 fork 之后 execve 之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</li>
</ol>
<p><strong>父进程与子进程的地址空间：</strong><br>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p>
<p>在 UNIX 中，不可写的内存区是共享的。或者，子进程通过 <strong>写时复制（copy-on-write）</strong>共享父进程的所有内存。若要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。</p>
<p>可写的内存是不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。</p>
<h2 id="1-2-终止"><a href="#1-2-终止" class="headerlink" title="1.2. 终止"></a>1.2. 终止</h2><p>通常由下列条件引起：</p>
<ol>
<li>正常退出（自愿的）</li>
<li>出错退出（自愿的）：通常是程序中的错误导致</li>
<li>严重错误（非自愿）：例如编译不存在的文件</li>
<li>被其他进程杀死（非自愿）：某个进程执行一个系统调（kill）用杀死另一个进程</li>
</ol>
<h2 id="1-3-层次结构"><a href="#1-3-层次结构" class="headerlink" title="1.3. 层次结构"></a>1.3. 层次结构</h2><p>在 UNIX 中，进程和它的所有子进程以及后裔共同组成一个进程组。<br>当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。<br>每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。</p>
<blockquote>
<p>UNIX 在启动时如何初始化自己。</p>
<ul>
<li>一个特殊进程 init 出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。</li>
<li>接着，为每个终端创建一个新进程，这些进程等待用户登录。</li>
<li>如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程。</li>
<li>这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</li>
</ul>
</blockquote>
<p>Windows 中没有进程层次的概念，所有的进程都是地位相同的。<br>但是在创建进程的时候，父进程会得到一个 ** 句柄 ** 来控制子进程。<br>父进程可以把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p>
<h2 id="1-4-状态"><a href="#1-4-状态" class="headerlink" title="1.4. 状态"></a>1.4. 状态</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/828b44f4de1b2b927606a14533ac78a5.png" alt="image.png"></p>
<ol>
<li>运行态：正在运行，占用 CPU</li>
<li> 就绪态：因其他进程在运行而暂时停止（未分配到 CPU 时间片）</li>
<li>阻塞态：进程阻塞至某一事件发生（如等待键盘输入、进程等待管道传输数据等）</li>
</ol>
<h2 id="1-5-实现"><a href="#1-5-实现" class="headerlink" title="1.5. 实现"></a>1.5. 实现</h2><p><strong>进程表：</strong><br>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即 <strong>进程表（process table）</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34de6f6d5359a8417458735c0caf39d6.png" alt="image.png"><br>每个进程占用一个进程表项，其包含了程序计数器、堆栈指针、内存分配状况、锁打开文件的状态、账号和调度信息。</p>
<p>进程由运行态装换到其他状态时必须保存的信息也会保存到进程表中，以保证该进程随后能再次启动。</p>
<p>单一进程的系统不需要进程表，因为单一进程从不挂起。</p>
<p><strong>中断切换程序：</strong><br>与每一 I/O 类关联的是一个叫 ** 中断向量（interrupt vector）** 的位置（靠近内存底部的固定区城）。它包含中断服务程序的入口地址。</p>
<p>当一个磁盘中断发生时，某一用户进程正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，随后跳转到中断向量所指示的地址。<br>这些是硬件完成的所有操作，然后中断服务例程就接管一切剩余的工作。</p>
<p><strong>中断发生后底层工作步骤：</strong></p>
<ol>
<li><p>硬件压入堆栈程序计数器等</p>
</li>
<li><p>硬件从中断向量装入新的程序计数器</p>
</li>
<li><p>汇编语言过程保存寄存器值，设置新的堆栈（无法用 C 实现）</p>
</li>
<li><p>C 中断服务例程运行（典型地读和缓冲输入）</p>
<blockquote>
<p>I/O 设备启动后，管理进程对其信号量执行 down 操作，使其阻塞<br>该步骤在设备的信号量上执行 up 操作，使相关进程设置为就绪状态</p>
</blockquote>
</li>
<li><p>调度程序决定下一个将运行的进程</p>
</li>
<li><p>C 过程返回至汇编代码</p>
</li>
<li><p>汇编语言过程开始运行新的当前进程</p>
</li>
</ol>
<h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><p><strong>必要性：</strong></p>
<ul>
<li>运行某些任务随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</li>
<li>线程比进程更轻量级，线程比进程能更快地被创建，也更容易撤销。在有大量线程需要动态和快速修改时，具有这一特性是很有用的。</li>
<li>性能方面，若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强。但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</li>
</ul>
<p><strong>共享资源：</strong><br>多线程概念要求并行实体要共享同一个地址空间和所有可用数据。<br>对于某些应用而言，这种能力是必需的。而这正是多进程模型（它们具有不同的地址空间）所无法具备的。</p>
<h2 id="2-1-构造-web-服务器的三种方法"><a href="#2-1-构造-web-服务器的三种方法" class="headerlink" title="2.1. 构造 web 服务器的三种方法"></a>2.1. 构造 web 服务器的三种方法</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6bbe3b9f1384ff80400a9cdd30eec6d1.png" alt="image.png"></p>
<h3 id="2-1-1-多线程实现"><a href="#2-1-1-多线程实现" class="headerlink" title="2.1.1. 多线程实现"></a>2.1.1. 多线程实现</h3><p>多线程异步</p>
<ul>
<li>分派线程（dispatcher）：接收请求，分派请求给一个被阻塞工作线程（work thread），通常是在线程某个专门字中写入一个消息指针，接着把它从阻塞状态转为就绪状态；</li>
<li>工作线程：被唤醒后检查是否在缓存中，命中则返回页面。未命中则阻塞调用 read 操作从磁盘获取，直到操作完成；</li>
<li>在此工作线程阻塞的同时，分派线程依然在工作（分派任务）。</li>
</ul>
<h3 id="2-1-2-单线程实现"><a href="#2-1-2-单线程实现" class="headerlink" title="2.1.2. 单线程实现"></a>2.1.2. 单线程实现</h3><ul>
<li>获取请求，查询缓存；</li>
<li>未命中则阻塞的查询磁盘；</li>
<li>此时服务器会空转，不能处理任何其他的请求。</li>
</ul>
<h3 id="2-1-3-有限状态机实现"><a href="#2-1-3-有限状态机实现" class="headerlink" title="2.1.3. 有限状态机实现"></a>2.1.3. 有限状态机实现</h3><p>使用 <strong>有限状态机（finite-state machine）</strong>保存状态，模拟线程及堆栈，并使用非阻塞 I/O。</p>
<ul>
<li>获取请求，查询缓存；</li>
<li>未命中则使用非阻塞的 read 系统调用查询磁盘，并在表格中记录当前请求的状态；</li>
<li>然后去处理下一个事件。<ul>
<li>可能是新的请求，则处理新请求；</li>
<li>可能是磁盘对先前操作的应答（信号或中断的形式），则从表格中取出对应的信息，并处理该应答。</li>
</ul>
</li>
</ul>
<h2 id="2-2-实现线程包环境"><a href="#2-2-实现线程包环境" class="headerlink" title="2.2. 实现线程包环境"></a>2.2. 实现线程包环境</h2><h3 id="2-2-1-在用户态实现"><a href="#2-2-1-在用户态实现" class="headerlink" title="2.2.1. 在用户态实现"></a>2.2.1. 在用户态实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e84dfc08363c2351445625f328384792.png" alt="image.png"><br><strong>结构：</strong><br>用户态模拟多线程，内核仍然是单线程。<br>运行时系统是一个管理线程过程的集合，线程在该系统的上层运行。<br>每个进程都偶有一个线程表，其和进程表类似。</p>
<p><strong>线程切换：</strong><br>调用一个运行时系统的过程进行线程切换，在线程表中保存该线程的寄存器，并把新线程的保存至重新装入及其的寄存器中。<br>只要堆栈指针和程序计数器被切换，新线程就能运行。<br>但始终只能运行该进程内的线程，直到 CPU 调度切换其他进程为止。</p>
<p><strong>优点：</strong></p>
<ul>
<li>在用户态进行线程切换至少比陷入内核要快一个数量级。</li>
<li>用户态线程允许每个进程有自己定制的调度算法。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>线程调度问题：</li>
</ul>
<p>如果一个线程开始运行，除非该线程自动放弃 CPU，否则该进程中的其他线程就不能运行。<br>在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度（轮流）的方式调度线程。除非某个线程能够按照自己的意志进入运行时系统，否则调度程序就没有任何机会。<br>一个可能的解决方案是让运行时系统请求每秒次的时钟信号（中断），但是这样对程序也是生硬和无序的。不可能总是高频率地发生周期性的时钟中断，即使可能，总的开销也是可观的。而且，线程可能也需要时钟中断，这就会扰乱运行时系统使用的时钟。</p>
<ul>
<li>阻塞系统调用问题：</li>
</ul>
<p>用户态线程不能进行阻塞系统调用（阻塞等待键盘输入等），因为会停止所有的线程。可以使用 select 系统调用（包装器）通知 read 是否会阻塞。</p>
<ul>
<li>不阻塞时才进行 read 调用</li>
<li>如果 read 调用会阻塞，就让出运行其他线程</li>
</ul>
<p>需要重写部分系统调用库，效率不高也不优雅。</p>
<ul>
<li>缺页中断问题：</li>
</ul>
<p>把计算机设置成并不是所有的程序都一次性放在内存中这样的一种工作方式。如果某个程序调用或者跳转到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令（和该指令的 “邻居们”），这就称为页面故障。在对所需的指令进行定位和读入时，相关的进程就被阻塞。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p>
<h3 id="2-2-2-在内核态实现"><a href="#2-2-2-在内核态实现" class="headerlink" title="2.2.2. 在内核态实现"></a>2.2.2. 在内核态实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34097c7499df1cc76fa684893527f7ee.png" alt="image.png"><br><strong>结构：</strong><br>在内核中存放线程表记录线程的寄存器、状态和其他信息。</p>
<p><strong>创建和销毁：</strong><br>线程的创建和销毁都得进行系统调用来完成，代价较大。<br>某些系统在回收线程时，只把它标记为不可运行。等到必须创建新线程时再重启这个线程，从而节省一些开销。</p>
<p><strong>线程切换：</strong><br>阻塞都在内核中发生（阻塞系统调用），代价较大。<br>当一个线程阻塞时，内核可以运行同一进程中的另一个线程或运行别的进程中的线程。</p>
<p><strong>问题：</strong></p>
<ul>
<li>进程创建新的进程，新进程的线程数与原进程相同还是只有一个。<ul>
<li>如果新建进程后就要调用 exec 启动一个新程序，最好只复制一个线程，避免不必要的开销。</li>
<li>如果新建进程后，该进程继续执行则最好复制所有的进程。</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-混合实现"><a href="#2-2-3-混合实现" class="headerlink" title="2.2.3. 混合实现"></a>2.2.3. 混合实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ac9744832c89093fd00d340a3dc048a5.png" alt="image.png"><br>一种方法是使用内核级线程，然后将用户级线程与其进行多路复用。<br>编程人员可以自定义哪些内核线程和哪些用户线程进行多路复用，灵活度较高。<br>每个内核级线程有一个可以轮流使用的用户级线程集合。</p>
<h2 id="2-3-调度程序激活机制"><a href="#2-3-调度程序激活机制" class="headerlink" title="2.3.调度程序激活机制"></a>2.3. 调度程序激活机制</h2><p>调度程序激活的目标是模拟内核线程的功能，并且为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。避免了在用户空间和内核空间之间的不必要转换。</p>
<ul>
<li>如果用户线程从事某种系统调用时是安全的，那就不应该进行专门的非阻塞调用或者进行提前检查。</li>
<li>如果线程阻塞在某个系统调用或页面故障上，只要在同一个进程中有任何就绪的线程，就应该有可能运行其他的线程。</li>
</ul>
<p><strong>虚拟处理器：</strong><br>当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让用户态中的运行时系统将线程分配到处理器上。</p>
<p><strong>分配与回收：</strong><br>被分配给一个进程的虚拟处理器的初始数量是一个，但是该进程可以申请更多的处理器并且在不用时退回。内核也可以取回已经分配出去的虚拟处理器，以便把它们分给需要更多处理器的进程。</p>
<p><strong>上行调用：</strong><br>当内核了解到一个线程被阻塞之后，内核通过在一个已知的起始地址启动该进程的运行时系统从而发出通知，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。<br>这是对 UNIX 中信号的一种粗略模拟。这个机制称为 ** 上行调用（upcall）**。</p>
<p><strong>线程调度：</strong><br>然后运行时系统就重新调度其线程。</p>
<ol>
<li>把当前线程标记为阻塞并从就绪表中取出另一个线程，设置其寄存器，然后启动它。</li>
<li>当内核知道原来的线程又可运行时，内核会再次上行调用运行时系统，通知它这一事件。</li>
<li>此时该运行时系统按照自己的判断，可能立即重启动被阻塞的线程，也可能把它放入就绪表中稍后运行。</li>
</ol>
<p><strong>中断处理：</strong><br>在某个用户线程运行的同时发生一个硬件中断时，被中断的 CPU 切换进内核态。</p>
<ul>
<li>如果被中断的进程对引起该中断的事件不感兴趣。比如，是另一个进程的 I/O 完成了。</li>
</ul>
<p>那么在中断处理程序结束之后，就把被中断的线程恢复到中断之前的状态。</p>
<ul>
<li>不过，如果该进程对中断感兴趣。比如，是该进程中的某个线程所需要的页面到达了。<ol>
<li>被中断的线程就不再启动，并且被挂起。</li>
<li>运行时系统则启动对应的虚拟 CPU，此时被中断线程的状态保存在堆栈中。</li>
<li>随后，运行时系统决定在该 CPU 上调度哪个线程：被中断的线程、新就绪的线程还是某个第三种选择。</li>
</ol>
</li>
</ul>
<p>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。通常，n 层提供 n + 1 层可调用的特定服务，但是 n 层不能调用 n + 1 层中的过程。上行调用并不遵守这个基本原理。</p>
<h2 id="2-4-弹出式线程"><a href="#2-4-弹出式线程" class="headerlink" title="2.4. 弹出式线程"></a>2.4. 弹出式线程</h2><p>线程如何处理到来的消息？<br>传统的方法是将进程或线程阻塞在一个 receive 系统调用上，等待消息到来。<br>当消息到达时，该系统调用接收消息，并打开消息检查其内容，然后进行处理。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8db0ef2450f716996389814f9e4d7665.png" alt="image.png"><br>另一种方法为 <strong>弹出式线程</strong>，一个消息的到达导致系统创建一个处理该消息的线程。</p>
<p><strong>优势：</strong><br>弹出式线程没有必须存储的寄存器、堆栈等。所以能快速创建这类线程，消息到达与处理开始之间的时间非常短。</p>
<p><strong>内核中运行：</strong></p>
<ul>
<li>在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和 I/O 设备，这些也许在中断处理时有用。</li>
<li>但是，出错的内核线程会比出错的用户线程造成更大的损害。例如，如果某个线程运行时间太长，又没有办法抢占它，就可能造成进来的信息丢失。</li>
</ul>
<h1 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h1><p><strong>问题：</strong><br>线程也存在以下问题</p>
<ul>
<li>信息传递问题：一个进程如何把信息传递给另一个进程</li>
<li>资源竞争问题：如何确保多个进程在关键活动中不会出现交叉</li>
<li>执行顺序问题：比如，进程 A 产生数据而进程 B 打印数据，那么 B 在打印之前必须等待，直到 A 已经产生一些数据。</li>
</ul>
<h2 id="3-1-互斥"><a href="#3-1-互斥" class="headerlink" title="3.1. 互斥"></a>3.1. 互斥</h2><p>我们把对共享内存进行访问的程序片段称作 <strong>临界区域（critical region）</strong>或 <strong>临界区 ( critical section）</strong>。如果能使两个进程不能同时处于临界区中，就能避免竞争。</p>
<p>几种互斥方案用于避免多个进程运行在临界区中。</p>
<h3 id="3-1-1-屏蔽中断"><a href="#3-1-1-屏蔽中断" class="headerlink" title="3.1.1. 屏蔽中断"></a>3.1.1. 屏蔽中断</h3><p>屏蔽中断后，时钟中断也被屏蔽。所以 CPU 将不会切换到其他进程。</p>
<p>但是把屏蔽中断的权利交给用户进程是不合理的。<br>而且在多处理器系统中，其他的 CPU 仍然在运行，并可以访问共享内存。</p>
<h3 id="3-1-2-锁变量"><a href="#3-1-2-锁变量" class="headerlink" title="3.1.2. 锁变量"></a>3.1.2. 锁变量</h3><p>共享的互斥变量作为锁，1 代表占有，0 代表未被占有。只有值为 0 时进程才能进入临界区，并将锁改为 1。</p>
<p>但是读锁和改锁这是两个操作，不是原子操作。依然会有竞争问题</p>
<h3 id="3-1-3-严格轮换法"><a href="#3-1-3-严格轮换法" class="headerlink" title="3.1.3. 严格轮换法"></a>3.1.3. 严格轮换法</h3><p>以下进程 0 和进程 1 使用自旋锁轮换执行</p>
<p>进程 0 执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>);  <span class="comment">/* 不等于 0 就一直循环 */</span></span><br><span class="line">    critical_region();</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>进程 1 执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>);  <span class="comment">/* 等于 1 就一直循环 */</span></span><br><span class="line">    critical_region();</span><br><span class="line">    turn <span class="number">0</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>连续测试一个变量直到某个值出现为止，称为 <strong>忙等待（busy waiting）</strong><br>用于忙等待的锁，称为 <strong>自旋锁（spin lock）</strong><br>由于这种方式浪费 CPU 时间，只有在等待时间非常短的情况下，才能使用此方法。</p>
<h3 id="3-1-4-Peterson-解法"><a href="#3-1-4-Peterson-解法" class="headerlink" title="3.1.4. Peterson 解法"></a>3.1.4. Peterson 解法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N     2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="comment">/* 所有值初始化为 0（FALSE） */</span></span><br><span class="line"><span class="type">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">    <span class="comment">/* 另一个进程 */</span></span><br><span class="line">    other = <span class="number">1</span> - process;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 表示进入临界区 */</span></span><br><span class="line">    interested[process] = TRUE;</span><br><span class="line">    <span class="comment">/* 设置标志 */</span></span><br><span class="line">    turn = process;</span><br><span class="line">    <span class="comment">/* 空语句 */</span></span><br><span class="line">    <span class="keyword">while</span> (interested[other] == TRUE &amp;&amp; turn == process);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程：谁离开 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">    interested[process] = FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>enter_ region：代表进入临界区<br>leave_region：代表离开临界区</p>
<p><code>interested[process] == TRUE</code> 表明 process 进程想进入临界区</p>
<ul>
<li>若当前进程想进入临界区（即 <code>interested[process] == TRUE</code>）而另一个进程不想（即 <code>interested[other] == FALSE</code>）时，while 肯定为 false，当前进程直接进入临界区。</li>
<li>当两个进程都想进入临界区（即 interested [0] 和 interested [1] 都为 TRUE）时，此时取决于 turn，turn 会指向后进入的进程。所以先进入的进程能进入临界区。</li>
</ul>
<h3 id="3-1-5-TSL-指令"><a href="#3-1-5-TSL-指令" class="headerlink" title="3.1.5. TSL 指令"></a>3.1.5. TSL 指令</h3><p><strong>测试并加锁（test and set lock）：</strong>硬件支持的一种方案，特别是多处理器的计算机都有这条指令：TSL RX, LOCK。</p>
<p><strong>原理：</strong><br>它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值，这两个操作保证是不可分割的。执行 TSL 指令的 CPU 将 <strong>锁住内存总线</strong>，以禁止其他 CPU 在本指令结束之前访问内存。</p>
<ul>
<li>锁住存储总线不同于屏蔽中断。中断只对当前处理器有影响，对别的处理器没影响，所以屏蔽中断不能阻止其他处理器对内存的访问。</li>
<li>让处理器 2 远离内存直到处理器 1 完成的唯一方法就是锁住总线，这需要硬件层面的支持（一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能用）</li>
</ul>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。<br>当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为 0。</p>
<p><strong>代码：</strong></p>
<ol>
<li><code>TSL REGISTER,LOCK</code>：将 lock 原来的值复制到寄存器中并将 lock 设为 1</li>
<li><code>CMP REGISTER,#0</code>：将寄存器中的值与 0 比较</li>
<li><code>JNE enter_region</code>：如果不是 0，说明以前已被加锁，则循环重新测试</li>
<li>若其他进程离开临界区（lock 变为 0），则可加锁。</li>
<li>释放锁只需把 lock 设为 0 即可。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    TSL REGISTER,LOCK    | 复制锁到寄存器并将锁设为 1</span><br><span class="line">    CMP REGISTER,#0      | 判断锁是否为 0</span><br><span class="line">    JNE enter_region     | 若不是 0，说明锁已被设置，所以循环</span><br><span class="line">    RET                  | 返回调用者，进入临界区</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">    MOVE LOCK,#0         | 在锁中存入 0</span><br><span class="line">    RET                  | 返回调用者</span><br></pre></td></tr></tbody></table></figure>
XCHG 指令可以代替 TSL，它原子性地交换了两个位置的内容，达到一样的效果。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVE REGISTER,#1         | 在寄存器中存一个 1</span><br><span class="line">XCHG REGISTER,LOCK       | 交换寄存器与锁变量的内容</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>优先级反转问题：</strong><br>Peterson 解法和 TSL/XCHG 本质上都有忙等待的缺点<br>考虑一台计算机有两个进程，H 优先级较高，L 优先级较低。调度规则规定，只要 H 处于就绪态它就可以运行。<br>在某一时刻，L 处于临界区中，此时 H 变到就绪态，准备运行。现在 H 开始忙等待，但由于当 H 就绪时 L 不会被调度，也就无法离开临界区，所以 H 将永远忙等待下去。这种情况有时被称作 ** 优先级反转问题（priority inversion problem）**。</p>
<p><strong>多个进程如何共享内存变量？</strong></p>
<ol>
<li>信号量等某些共享数据结构可以存放在内核中，并且只能通过系统调用来访问。</li>
<li>让进程共享部分地址空间。缓冲区和其他数据结构可以共享。如果没有可共享的途径，则可以使用共享文件。</li>
</ol>
<h2 id="3-2-生产者-消费者问题"><a href="#3-2-生产者-消费者问题" class="headerlink" title="3.2. 生产者-消费者问题"></a>3.2. 生产者 - 消费者问题</h2><p>也称作 <strong>有界缓冲区（bounded-buffer）</strong>问题。<br>两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。</p>
<ul>
<li>当缓冲区已满时，生产者就睡眠以避免继续生产数据项，待消费者从缓冲区中取出一个或多个数据项时再唤醒它。</li>
<li>当缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                                  <span class="comment">/* 缓冲区槽数据 */</span></span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;                                 <span class="comment">/* 缓冲区数据项数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();                 <span class="comment">/* 产生下一个新数据项 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == N) sleep();               <span class="comment">/* 如果缓冲区满了，就进入休眠 */</span></span><br><span class="line">        insert_item(item);                     <span class="comment">/* 将新数据项放入缓冲区 */</span></span><br><span class="line">        count = count + <span class="number">1</span>;                     <span class="comment">/* 将缓冲区的数据项计数器+1 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) wakeup(consumer);      <span class="comment">/* 判断缓冲区是否为空 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) sleep();               <span class="comment">/* 如果缓冲区为空，则进入休眠 */</span></span><br><span class="line">        item = remove_item();                  <span class="comment">/* 从缓冲区中取出一个数据项 */</span></span><br><span class="line">        count = count - <span class="number">1</span>;                     <span class="comment">/* 将缓冲区的数据项计数器-1 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>) wakeup(producer);  <span class="comment">/* 判断缓冲区是否已满 */</span></span><br><span class="line">        consume_item(item);                    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会出现竞争条件：</p>
<ol>
<li>缓冲区（队列）为空时，消费者读取 count 的值为 0。</li>
<li>若此时消费者暂停，生产者运行，并向缓冲区中加入一个数据项，这时调用 wakeup 来唤醒消费者。但是，消费者并未睡眠，所以 wakeup 信号丢失。</li>
<li>消费者再次运行时，用之前读取的 count 判断，于是进入睡眠。</li>
</ol>
<h2 id="3-3-信号量与互斥量"><a href="#3-3-信号量与互斥量" class="headerlink" title="3.3. 信号量与互斥量"></a>3.3. 信号量与互斥量</h2><h3 id="3-3-1-信号量"><a href="#3-3-1-信号量" class="headerlink" title="3.3.1. 信号量"></a>3.3.1. 信号量</h3><p><strong>信号量（semaphore）</strong>，由 Dijkstra 在 1965 年提出的一种方法。本质上是一个计数器，用来记录对某个资源的数量（资源池）。</p>
<p>Dijkstra 建议设立两种操作：down 和 up。可以把信号量看成是一个有若干信号的池子。</p>
<ul>
<li><strong>down（P，Proberen 尝试）：</strong>调用 down，进程尝试去拿到一个信号（即尝试使信号量减 1：取出值，判断是否 &gt; 0，再操作）。<ul>
<li>拿到后才能进入临界区；</li>
<li>拿不到（去拿时信号量已为 0）则进入睡眠（阻塞），等待有信号被释放时再进行 down 操作；</li>
</ul>
</li>
<li><strong>up（V，Verhogen 增加）：</strong>进程离开临界区时，调用 up，进程将释放信号（信号量加 1）。<ul>
<li>如果有其他进程因拿不到信号而正在睡眠（即之前 down 的时候发现信号量为 0），则由系统唤醒其中一个正在睡眠的进程，继续进行 down 操作尝试去拿信号。所以最后表现是信号量还是 0，但有一个正在睡眠的进程被唤醒，拿到了当前进程的信号。</li>
<li>当然，如果没有其他进程因拿不到信号而进入睡眠，那么当前进程释放信号会直接使信号量加 1。</li>
</ul>
</li>
</ul>
<p><strong>保证检查数值、修改变量值和睡眠操作都是原子操作。</strong></p>
<ul>
<li>单核 CPU 操作系统在执行以上操作时暂时屏蔽中断</li>
<li>由于中断只对当前处理器有影响，对别的处理器没影响，屏蔽中断不能阻止其他处理器对内存的访问。所以多 CPU 系统中使用 TSX 或 XCHG 指令来区人保同一时刻只有一个 CPU 对信号量进行操作</li>
</ul>
<p><strong>使用信号量解决生产者 - 消费者问题：</strong><br>信号量的作用：</p>
<ul>
<li>互斥：由 mutex 实现互斥，保证同一时刻只有一个进程访问内存变量</li>
<li>同步：full 和 empty 保证某件事件的顺序发生或不发生。如下保证当缓冲区满时生产者暂停；当缓冲区空时消费者暂停。<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                     <span class="comment">/* 缓冲区中的槽数目 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;            <span class="comment">/* 信号量是一种特殊的整型数据 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;              <span class="comment">/* 控制对临界区的访问 */</span></span><br><span class="line">semaphore empty = N;              <span class="comment">/* 计数缓冲区的空槽数目 */</span></span><br><span class="line">semaphore full = <span class="number">0</span>;               <span class="comment">/* 计数缓冲区的满槽数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();    <span class="comment">/* 产生放在缓冲区中的一些数据 */</span></span><br><span class="line">        down(&amp;empty);             <span class="comment">/* 将空槽数目减 1 */</span></span><br><span class="line">        down(&amp;mutex);             <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        insert_item(item);        <span class="comment">/* 将新数据项放到缓冲区中 */</span></span><br><span class="line">        up(&amp;mutex);               <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        up(&amp;full);                <span class="comment">/* 将满槽的数目加 1 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        down(&amp;full);              <span class="comment">/* 将满槽数目减 1 */</span></span><br><span class="line">        down(&amp;mutex);             <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        item = remove_item();     <span class="comment">/* 从缓冲区中取出数据项 */</span></span><br><span class="line">        up(&amp;mutex);               <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        up(&amp;empty);               <span class="comment">/* 将空槽数目减 1 */</span></span><br><span class="line">        comsume_item(item);       <span class="comment">/* 处理数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-3-2-互斥量"><a href="#3-3-2-互斥量" class="headerlink" title="3.3.2. 互斥量"></a>3.3.2. 互斥量</h3><p>信号量的简化版本，用一个整形量表示：0 表示解锁；其他值表示加锁。<br>互斥量仅仅适用于管理共享资源或一小段代码，因此很适用于处理线程。</p>
<p>以下是线程互斥：使用 thread_yield 避免忙等待</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">    TSL REGISTER,MUTEX     | 将互斥信号量复制到寄存器，并且将互斥信号量置为 1</span><br><span class="line">    CMP REGISTER,#0        | 判断互斥信号量是否为 0</span><br><span class="line">    JZE ok                 | 如果互斥信号量为 0，表示未加锁，返回</span><br><span class="line">    CALL thread_yield      | 已加锁，让出线程</span><br><span class="line">    JMP mutex_lock         | 稍后再试</span><br><span class="line">ok: RET                    |返回调用者；进入临界区</span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">    MOVE MUTEX,#0          | 将 mutex 置为 0，即释放锁</span><br><span class="line">    RET                    | 返回调用者</span><br></pre></td></tr></tbody></table></figure>

<p><strong>1. 快速用户区互斥量 futex</strong><br>自旋锁适用于等待时间短的情况，如果等待时间长，会浪费 CPU 周期。<br>互斥锁适用于竞争量大的情况，它会阻塞进程，直到锁被释放才会让内核接触阻塞。如果一开始只有很小的竞争，那么不停地切换内核会有很大的花销，而且预测竞争锁的数量并不容易。</p>
<p>futex 结合了自旋锁及互斥锁的优点。futex 是 Linux 的一个特性，它实现了基本的锁（很像互斥锁），且尽量避免陷入内核从而可观地改善了性能。<br>一个 futex 包含两个部分：一个内核服务和一个用户库。</p>
<ul>
<li>内核服务提供一个等待队列，允许多个进程在一个锁上等待。除非内核对它们解除阻塞否则这些进程将不会运行。将一个进程放到等待队列需要系统调用（开销大），应尽量避免出现这种情况。</li>
<li>在没有竞争时，futex 完全在用户空间工作。这些进程共享通用的锁变量 —— 一个对齐的 32 位整数锁。</li>
</ul>
<p>假设锁初始值为 1（释放状态）。线程通过执行原子操作 “减少并检验” 来夺取锁。这个线程检查结果，看锁是否被释放。</p>
<ul>
<li>如果未处于加锁状态，该线程成功夺取锁。</li>
<li>如果锁被另一个线程持有，futex 库不会自旋，而是使用一个系统调用把这个线程放在内核的等待队列上。因为已经该线程被阻塞了，所以无所谓开销。</li>
<li>当一个线程使用完锁，会通过原子操作 “增加并检验” 来释放锁，并检查是否仍有进程阻塞在内核等待队列上。如果有，它会通知内核可以对等待队列里的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与其中。</li>
</ul>
<p><strong>2. pthread 中的互斥量</strong></p>
<table>
<thead>
<tr>
<th><strong>线程调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> pthread_mutex_init</td>
<td> 创建一个互斥量</td>
</tr>
<tr>
<td> pthread_mutex_destory</td>
<td> 销毁一个互斥量</td>
</tr>
<tr>
<td> pthread_mutex_lock</td>
<td> 获取一个锁，否则阻塞</td>
</tr>
<tr>
<td> pthread_mutex_trylock</td>
<td> 获取一个锁，否则失败</td>
</tr>
<tr>
<td> pthread_mutex_unlock</td>
<td> 释放一个锁</td>
</tr>
</tbody></table>
<p>Pthread 提供许多可以用来同步线程的函数。其基本机制是使用一个可以被加锁和解锁的互斥量来保护每个临界区。<br>一个线程如果想要进入临界区，它首先尝试锁住相关的互斥量。</p>
<ul>
<li>如果互斥量没有加锁，那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他线程进入。</li>
<li>如果互斥量已经被加锁，则调用线程被阻塞，直到该互斥量被解锁。</li>
<li>如果多个线程在等待同一个互斥量，当锁释放时，这些等待的线程中只有一个被允许运行并将互斥量重新锁定。这些互斥锁不是强制性的，而是由程序员来保证线程正确地使用它们。</li>
</ul>
<p><strong>3. pthread 中的条件变量</strong><br>pthread 提供了另一种同步机制：<strong>条件变量</strong>。</p>
<table>
<thead>
<tr>
<th><strong>线程调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> pthread_cond_init</td>
<td> 创建一个条件变量</td>
</tr>
<tr>
<td> pthread_cond_destory</td>
<td> 销毁一个条件变量</td>
</tr>
<tr>
<td> pthread_cond_wait</td>
<td> 阻塞以等待一个信号</td>
</tr>
<tr>
<td> pthread_cond_signal</td>
<td> 向另一个线程发信号来唤醒它</td>
</tr>
<tr>
<td> pthread_cond_broadcast</td>
<td> 向多个线程发信号来让它们全部唤醒</td>
</tr>
</tbody></table>
<p>互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。<br>例如生产者 - 消费者问题中生产者使用互斥量保证操作的原子性，不被其他线程干扰。但是如果在缓冲区满了这样的条件下想要将生产者阻塞就得需要条件变量了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000000000                                 <span class="comment">/* 需要生产的数量 */</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> condc, condp;</span><br><span class="line"><span class="type">int</span> buffer = <span class="number">0</span>;                                        <span class="comment">/* 生产者消费者使用的缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;the_mutex);                <span class="comment">/* 互斥使用缓冲区 */</span></span><br><span class="line">        <span class="keyword">while</span> (buffer != <span class="number">0</span>) {</span><br><span class="line">            pthread_cond_wait(&amp;condp, &amp;the_mutex);</span><br><span class="line">        }</span><br><span class="line">        buffer = i;                                    <span class="comment">/* 将数据放入缓冲区 */</span></span><br><span class="line">        pthread_cond_signal(&amp;condc);                   <span class="comment">/* 唤醒消费者 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;the_mutex);              <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;the_mutex);                 <span class="comment">/* 互斥使用缓冲区 */</span></span><br><span class="line">        <span class="keyword">while</span> (buffer == <span class="number">0</span>) {</span><br><span class="line">            pthread_cond_wait(&amp;condc, &amp;the_mutex);</span><br><span class="line">        }</span><br><span class="line">        buffer = <span class="number">0</span>;                                     <span class="comment">/* 从缓冲区中取出数据 */</span></span><br><span class="line">        pthread_cond_signal(&amp;condp);                    <span class="comment">/* 唤醒生产者 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;the_mutex);               <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">pthread_t</span> pro,con;</span><br><span class="line">    pthread_mutex_init(&amp;the_mutex, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_init(condc, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_init(condp, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;con, <span class="number">0</span>, consumer, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;pro, <span class="number">0</span>, producer, <span class="number">0</span>);</span><br><span class="line">    pthread_join(pro, <span class="number">0</span>);</span><br><span class="line">    pthread_join(con, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_destory(&amp;condc);</span><br><span class="line">    pthread_cond_destory(&amp;condp);</span><br><span class="line">    pthread_mutex_destory(&amp;the_mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-4-管程"><a href="#3-4-管程" class="headerlink" title="3.4. 管程"></a>3.4. 管程</h2><p>一个管程（monitor）是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。<br>进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。<br>管程是一个编程语言的概念，由编程语言提供支持。例如 java 的 synchronized。</p>
<p><strong>特性：</strong><br>任一时刻管程中只能有一个活跃进程，这使得管程能有效地完成互斥。<br>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。</p>
<ul>
<li>如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。</li>
<li>如果没有活跃进程在使用管程，则该调用进程可以进入。</li>
</ul>
<p><strong>条件变量：</strong></p>
<ul>
<li>wait：当前进程在某个条件变量上调用 wait 使自身阻塞，并将另一个等待在管程外的进程调入管程</li>
<li> signal：当前进程在某个条件变量上调用 signal 唤醒在其上等待的进程。</li>
</ul>
<p>这时管程中会有两个进程：当前进程和被唤醒的进程，所以在 signal 之后得做处理使得管程只运行一个进程（多种方案）。</p>
<ul>
<li>可以挂起当前进程，直接运行唤醒的进程（Hoare 建议）。</li>
<li>可以使当前进程立即退出管程，从而运行唤醒的进程（Brinch Hansen 建议）。</li>
<li>可以继续运行当前线程，直到退出管程后再裕兴唤醒的进程。</li>
</ul>
<p><strong>与信号量实现的区别：</strong><br>用信号量也能实现相同的效果，对 <code>value=0</code> 的信号量进行 P 操作（相当于 wait）使得调用进程阻塞，对其进行 V 操作（相当于 signal）使其唤醒。但与信号量不同的是条件变量不能累加：</p>
<ul>
<li>对一个没有进程在其阻塞的信号量使用 V 操作会使信号量加 1，这样如果有进程下次调用 P 操作将不会阻塞。</li>
<li>但对没有进行过 wait 操作的条件变量使用 signal 操作不会有任何作用。signal 必须在 wait 之后才会起作用。</li>
</ul>
<h2 id="3-5-消息传递"><a href="#3-5-消息传递" class="headerlink" title="3.5. 消息传递"></a>3.5. 消息传递</h2><p>管程与信号量可以解决单个计算机内的竞争问题，但在一个分布式系统里这些原语都会失效。<br><strong>消息传递（message passing）</strong>可以解决这个问题。提供两个系统调用过程：</p>
<ul>
<li>send (destination, &amp;message)：向一个给定的目标发送</li>
<li> receive (source, &amp;message)：从一个给定的源或任意源接收一条消息</li>
</ul>
<h3 id="3-5-1-消息传递系统的设计要点"><a href="#3-5-1-消息传递系统的设计要点" class="headerlink" title="3.5.1. 消息传递系统的设计要点"></a>3.5.1. 消息传递系统的设计要点</h3><p><strong>消息丢失问题：</strong><br>为了防止消息丢失，接收方一旦接收到信息，马上回送一条特殊的 <strong>确认（acknowledgement）</strong>消息。如果发送方在一段时间间隔内未收到确认，则重发消息。<br>确认消息也有可能会丢失，这时发送者将重发消息，所以接收者如何保证消息幂等性很重要，可通过版本号解决。</p>
<p><strong>进程命名问题：</strong><br>在 send 和 receive 调用中所制定的进程必须是没有二义性的。</p>
<p><strong>身份认证（authentication）问题：</strong>客户端怎么判断与之通信的是不是一个冒充者？</p>
<p>……</p>
<h3 id="3-5-2-用消息传递解决生产者-消费者问题"><a href="#3-5-2-用消息传递解决生产者-消费者问题" class="headerlink" title="3.5.2. 用消息传递解决生产者-消费者问题"></a>3.5.2. 用消息传递解决生产者 - 消费者问题</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                         <span class="comment">/* 缓冲区中的槽数目 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    message m;                        <span class="comment">/* 消息缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();        <span class="comment">/* 产生放入缓冲区的一些数据 */</span></span><br><span class="line">        receive(consumer, &amp;m);        <span class="comment">/* 等待消费者发送空缓冲区 */</span></span><br><span class="line">        build_message(&amp;m, item);      <span class="comment">/* 建立一个待发送的消息 */</span></span><br><span class="line">        send(consumer, &amp;m);           <span class="comment">/* 发送数据项给消费者 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item, i;</span><br><span class="line">    message m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        send(producer, &amp;m);            <span class="comment">/* 发送 N 个空缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        receive(producer, &amp;m);         <span class="comment">/* 接收包含数据项的消息 */</span></span><br><span class="line">        item = extract_item(&amp;m);       <span class="comment">/* 将数据项从消息中提取出来 */</span></span><br><span class="line">        send(producer, &amp;m);            <span class="comment">/* 将空缓冲区发送回生产者 */</span></span><br><span class="line">        consume_item(item);            <span class="comment">/* 处理数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>信箱：</strong><br>如何对消息进行编址？可以为每个进程分配一个唯一的地址，让消息按进程的地址编址。<br>也可以引入一种新的数据结构，称作 ** 信箱（mailbox）**：一个用来对一定数量的消息进行缓冲的地方。使用信箱时，在 send 和 receive 调用中的地址参数就是信箱的地址，而不是进程的地址。当一个进程试图向一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走，从而为新消息腾出空间。</p>
<p>信箱起到缓冲机制的作用，能够容纳那些已被发送但尚未被目标进程接收的消息。</p>
<p><strong>会合：</strong><br>使用信箱的另一种极端方法是彻底取消缓冲。采用这种方法时，send 和 receive 会进行一对一传输。</p>
<ul>
<li>如果下线执行 send ，那么它直到 receive 接收到消息之前都会被阻塞。</li>
<li>同理，先执行 receive，在 send 发送消息前接收者会被阻塞。</li>
</ul>
<p>这种方案常被称为 ** 会合（rendezvous）**。与带有缓冲的消息方案相比，该方案实现起来更容易，但却降低了灵活性。</p>
<h2 id="3-6-屏障"><a href="#3-6-屏障" class="headerlink" title="3.6. 屏障"></a>3.6. 屏障</h2><p>在有些应用中划分了若干阶段，只有所有的进程都就绪才能进入下一个阶段。<br><strong>屏障（barrier）</strong>可用于一组进程同步，可在每个阶段的结尾安置屏障来实现。<br>当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p>
<p>例：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/86dd057f2abb5745be8515ff5045dab3.png" alt="image.png"><br> A、B、D 进程完成计算，执行 barrier 原语被挂起进入屏障，只有当 C 进程（最后一个进程）到达屏障屏障时所有的进程才一起被释放。</p>
<h2 id="3-7-读-复制-更新（Read-Copy-Update）"><a href="#3-7-读-复制-更新（Read-Copy-Update）" class="headerlink" title="3.7. 读-复制-更新（Read-Copy-Update）"></a>3.7. 读 - 复制 - 更新（Read-Copy-Update）</h2><p>RCU 可以看做读写锁的高性能版本。</p>
<ul>
<li>读操作不需要获得任何锁就可以访问，不使用原子操作。</li>
<li>写操作在访问前需要先复制一份副本，然后对副本进行修改，最后使用一个回调机制，在适当的时机把指向原来数据的指针重新指向新的被修改的数据。</li>
</ul>
<h1 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h1><p>调度程序需考虑 CPU 的利用率，因为进程切换的代价是比较高的。</p>
<ol>
<li>首先用户态必须切换到内核态；</li>
<li>然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新装载。内存映像（例如，页表内的内存访问位）也必须保存；</li>
<li>接着，通过运行调度算法选定一个新进程；</li>
<li>之后，应该将新进程的内存映像重新装入 MMU；</li>
<li>最后新进程开始运行。</li>
</ol>
<p>进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。所以如果每秒钟切换进程的次数太多，会耗费大量 CPU 时间。</p>
<h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h2><p><strong>调度时机：</strong></p>
<ol>
<li>在创建一个新进程之后，可以任意决定先运行父进程还是先运行子进程。</li>
<li>在一个进程退出时必须做出调度决策。必须从就绪进程集中选择另外某个进程，如果没有就绪的进程，通常会运行一个系统提供的空闲进程。</li>
<li>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</li>
<li>在一个 I/O 中断发生时，必须做出调度决策。调度程序决定是否让新就绪的进程运行，还是让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</li>
</ol>
<p><strong>调度算法分类：</strong><br>如果硬件时钟提供 50Hz、60Hz 或其他频率的周期性中断，可以在每个时钟中断或者在每 k 个时钟中断时做出调度决策。根据如何处理时钟中断，可以把调度算法分为两类。</p>
<ul>
<li><strong>非抢占式：</strong>调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在 I/O 上或等待另一个进程），或者直到该进程自动释放 CPU。即使该进程运行了若千个小时，它也不会被强迫挂起。</li>
</ul>
<p>这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。</p>
<ul>
<li><strong>抢占式：</strong>调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时仍在运行，它就被挂起，然后调度程序挑选另一个进程运行。</li>
</ul>
<p>进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是唯一的选择了。</p>
<h2 id="4-2-批处理系统中的调度"><a href="#4-2-批处理系统中的调度" class="headerlink" title="4.2. 批处理系统中的调度"></a>4.2. 批处理系统中的调度</h2><h3 id="4-2-1-先来先服务"><a href="#4-2-1-先来先服务" class="headerlink" title="4.2.1. 先来先服务"></a>4.2.1. 先来先服务</h3><p>非抢占式。进程按照它们请求 CPU 的顺序使用 CPU。类似队列的先进先出。缺点是大任务容易阻塞。</p>
<h3 id="4-2-2-最短作业优先"><a href="#4-2-2-最短作业优先" class="headerlink" title="4.2.2. 最短作业优先"></a>4.2.2. 最短作业优先</h3><p>非抢占式。按照运行时间从小到大处理。只有在所有的作业都可同时运行的情况下才是最优化的。如果有运行时间较短的任务还未到达而只能运行其他较大的任务，这种情况下平均时间会较大。</p>
<h3 id="4-2-3-最短剩余时间优先"><a href="#4-2-3-最短剩余时间优先" class="headerlink" title="4.2.3. 最短剩余时间优先"></a>4.2.3. 最短剩余时间优先</h3><p>最短作业优先的抢占式版本。调度程序总是选择剩余运行时间最短的那个进程运行。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。</p>
<h2 id="4-3-交互式系统中的调度"><a href="#4-3-交互式系统中的调度" class="headerlink" title="4.3. 交互式系统中的调度"></a>4.3. 交互式系统中的调度</h2><h3 id="4-3-1-轮转调度"><a href="#4-3-1-轮转调度" class="headerlink" title="4.3.1. 轮转调度"></a>4.3.1. 轮转调度</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3fccdb0a67e6fab47c8c5fca1add5d01.png" alt="image.png"><br>每个进程被分配一个时间片，允许该进程在该时间段中运行。如果在时间片结束或是该进程阻塞 / 结束，则将 CPU 并分配给另一个进程。当一个进程用完它的时间片后，就被移到队列的末尾。</p>
<p>从一个进程切换到另一个进程是需要一定时间进行管理事务处理的，如保存和装入寄存器值及内存映像、更新各种表格和列表、清除和重新调入内存高速缓存等。<br>所以如果时间片的时间与进程切换的时间比值过小，会造成进程频繁切换；如果比值过大，则后面的进程可能无法在短时间内使用 CPU。时间片设为 20~50ms 通常是一个比较合理的折中。</p>
<h3 id="4-3-2-优先级调度"><a href="#4-3-2-优先级调度" class="headerlink" title="4.3.2. 优先级调度"></a>4.3.2. 优先级调度</h3><p>为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前<br>进程的优先级。这之后如果该进程的优先级低于次高优先级的进程，则进行进程切换。<br>另一种方法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。</p>
<p>为达到某种目的，优先级也可以由系统动态确定。例如，有些进程为 I/O 密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配给它 CPU，以便启动下一个 I/O 请求，这样就可以在另一个进程计算的通知执行 I/O 操作。</p>
<p>可以将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。</p>
<h3 id="4-3-3-多级队列"><a href="#4-3-3-多级队列" class="headerlink" title="4.3.3. 多级队列"></a>4.3.3. 多级队列</h3><p>属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行 2 个时间片，再次一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后被移到下一类。</p>
<p>考虑有一个进程需要连续计算 100 个时间片。它最初被分配 1 个时间片，然后被换出。下次它将获得 2 个时间片，接下来分别是 4、8、16、32  和 64。当然最后一次它只使用 64 个时间片中的 37 个便可以结束工作。</p>
<p>该进程需要 7 次交换（包括最初的装入），而如果采用纯粹的轮转算法则需要 100 次交换。而且，随着进程优先级的不断降低，它的运行频度逐渐放慢，从而为短的交互进程让出 CPU。</p>
<h3 id="4-3-4-最短进程优先"><a href="#4-3-4-最短进程优先" class="headerlink" title="4.3.4. 最短进程优先"></a>4.3.4. 最短进程优先</h3><p>与批处理系统中的最短作业优先相同。可以根据进程过去的行为估计运行时间的长短，<br>对于最新一次的运行时间 T 和上一次预估运行时间 P，可以对他们进行加权来得到最新的预估时间。如 aT+(1-a) P，当 a=1/2 时，当前预估时间为 T/2+P/2。</p>
<h3 id="4-3-5-保证调度"><a href="#4-3-5-保证调度" class="headerlink" title="4.3.5. 保证调度"></a>4.3.5. 保证调度</h3><p>向用户做出明确的性能保证并去实现它。例如 n 个用户，每个用户获得 1/n 的 CPU 时间。<br>系统必须跟踪各个进程自创建以来已使用了多少 CPU 时间，然后计算它们应获得的 CPU 时间。</p>
<h3 id="4-3-6-彩票调度"><a href="#4-3-6-彩票调度" class="headerlink" title="4.3.6. 彩票调度"></a>4.3.6. 彩票调度</h3><p>为进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就<br>随机抽出一张彩票，拥有该彩票的进程获得该资源。</p>
<p>可以给更重要的进程额外的彩票，以便增加它们获胜的机会。如果总共有 100 张彩票，而有一个进程持有其中的 20 张，那么在每一次抽奖中该进程就有 20% 的取胜机会。<br>短期时间内会有不公平的问题，但从长期来看，该进程会得到 20% 的 CPU。</p>
<p><strong>优点：</strong><br>彩票调度实现简单而且可以迅速调整。加入一个新进程出现并得到一些彩票，那么在下一次的抽奖中，该进程会有同它持有的彩票数量成比例的机会拿到奖励。</p>
<p><strong>缺点：</strong><br>彩票调度并没有在 CPU 调度程序里广泛使用。一个原因是不能很好的适合 I/O；另一个原因是票数分配问题没有确定的解决方式，比如你新打开了一个浏览器进程，那该给他分配多少票？票数少了，响应跟不上，票数多了，又会浪费 CPU 时间。</p>
<h3 id="4-3-7-公平分享调度"><a href="#4-3-7-公平分享调度" class="headerlink" title="4.3.7. 公平分享调度"></a>4.3.7. 公平分享调度</h3><p>以上算法关注的是进程本身而不是所有者，假设用户 1 启动 9 个进程而用户 2 启动 1 个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90% 的 CPU 时间，而用户 2 只得到 10% 的 CPU 时间。</p>
<p>公平愤怒向调度使每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。两个用户都得到获得 50% CPU 时间的保证。</p>
<h2 id="4-4-实时系统中的调度"><a href="#4-4-实时系统中的调度" class="headerlink" title="4.4. 实时系统中的调度"></a>4.4. 实时系统中的调度</h2><p>实时系统通常可以分为 ** 硬实时（hard real time）<strong>和</strong> 软实时（soft real time）**，硬实时是必须满足绝对的截止时间，软实时是虽然不希望偶尔错失截止时间，但是可以容忍。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为 <strong>周期性（以规则的时间间隔发生）</strong>事件或 ** 非周期性（发生时间不可预知）** 事件。一个系统可能要响应多个周期性事件流。根据每个事件需要处理时间的长短，系统甚至有可能无法处理完所有的事件。</p>
<p>实时系统的调度算法可以是静态或动态的。前者在系统开始运行之前作出调度决策，后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等全部信息时，静态调度才能工作，而动态调度算法不需要这些限制。</p>
<h1 id="5-IPC-问题"><a href="#5-IPC-问题" class="headerlink" title="5. IPC 问题"></a>5. IPC 问题</h1><p>IPC（Inter-Process Communication）问题：进程间通信问题</p>
<h2 id="5-1-哲学家就餐问题"><a href="#5-1-哲学家就餐问题" class="headerlink" title="5.1. 哲学家就餐问题"></a>5.1. 哲学家就餐问题</h2><p>互斥访问竞争模型。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f39086303733b0ad3d17fb855e17217a.png" alt="image.png"><br>五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉。由于通心粉很滑，所以需要两把叉子才能夹住，相邻两个盘子之间放有一把叉子。</p>
<p>他们的生活方式是交替地进行思考和进餐，当一个哲学家觉得饿了时，他就试图分两次去取其左边和右边的叉子，每次拿一把，但不分次序。</p>
<p>如果成功地得到了两把叉子，就开始吃饭，吃完后放下叉子继续思考。如何实现程序且决不会出现死锁？</p>
<p><strong>先拿左叉再尝试拿右叉：</strong><br>如果先拿左叉，再去查看右叉是否可用，这样会出现饥饿。比如当所有人同时拿起左叉，他们都会发现右叉不能用，于是都放下左叉，过了一会儿又同时拿起左叉，一直循环下去。主要原因是拿不到叉子不意味着叉子正被人用于吃饭。</p>
<p>可以在拿不到右叉时随机等待一段时间，而不是等待相同的时间，但是有随机性，可靠性并不是百分百。</p>
<p><strong>哲学家状态控制：</strong></p>
<ol>
<li>更改状态：A 想吃饭，更改状态为饥饿。</li>
<li>条件阻塞：A 发现旁边有人正在吃饭则 A 进入阻塞，否则直接就餐。</li>
<li>条件唤醒：被阻塞的 A 旁边有人吃完时，A 就观察左右两边是不是都没人在吃饭，是的话可以唤醒就餐。</li>
</ol>
<p>该算法加入状态，不会出现死锁，因为一个哲学家只有在两个邻座都不在进餐时，才允许转换到进餐状态。<br>但是会出现某个哲学家处于饥饿状态，当左右两边的哲学家交替吃饭，则当前的哲学家始终吃不上饭。<br>该算法能够实现对于任意多位哲学家的情况都能获得最大的并行度，因此也具有重要的意义。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N        5            <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT     (i+N-1)%N    <span class="comment">/* i 的左邻居编号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT    (i+1)%N      <span class="comment">/* i 的右邻居编号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0            <span class="comment">/* 哲学家在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1            <span class="comment">/* 哲学家试图拿起叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2            <span class="comment">/* 哲学家进餐 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;        <span class="comment">/* 信号量是一种特殊的整型数据 */</span></span><br><span class="line"><span class="type">int</span> state[N];                 <span class="comment">/* 数组用来跟踪记录每位哲学家的状态 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;          <span class="comment">/* 临界区的互斥 */</span></span><br><span class="line">semaphore s[N];               <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);              <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state[i] = HUNGRY;         <span class="comment">/* 记录哲学家 i 处于饥饿的状态 */</span></span><br><span class="line">    test(i);                   <span class="comment">/* 尝试获取 2 把叉子 */</span></span><br><span class="line">    up(&amp;mutex);                <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    down(&amp;s[i]);               <span class="comment">/* 如果得不到需要的叉子则阻塞 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);               <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state[i] = THINKING;        <span class="comment">/* 哲学家已经就餐完毕 */</span></span><br><span class="line">    test(LEFT);                 <span class="comment">/* 检查左边的邻居现在可以吃吗 */</span></span><br><span class="line">    test(RIGHT);                <span class="comment">/* 检查右边的邻居现在可以吃吗 */</span></span><br><span class="line">    up(&amp;mutex);                 <span class="comment">/* 离开临界区 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY </span><br><span class="line">        &amp;&amp; state[LEFT] != EATING </span><br><span class="line">        &amp;&amp; state[RIGHT] != EATING) {</span><br><span class="line">        </span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>只允许 4 人同时就餐：</strong><br>至多只允许四个哲学家同时进餐，因为少了一个人，所以即使这 4 人同时拿叉子也会保证至少有一个哲学家能够进餐。就解决了同时拿叉互等的问题。<br>以下将 count 作为信号量，只允许 4 个哲学家同时进入餐厅就餐。申请进入餐厅的哲学家进入等待队列，根据 FIFO 的原则，总会进入到餐厅就餐，因此不会出现饿死和死锁的现象。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">chopstick</span>[5]=</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 每个叉子都是信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">count</span>=</span><span class="number">4</span>;                       <span class="comment">// 4 个位置，信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        think();                                <span class="comment">// 思考</span></span><br><span class="line">        P(count);                               <span class="comment">// 人数控制</span></span><br><span class="line">        P(chopstick[i]);                        <span class="comment">// 拿起左叉</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);                  <span class="comment">// 拿起右叉</span></span><br><span class="line">        eat();                                  <span class="comment">// 吃饭</span></span><br><span class="line">        V(chopstick[i]);                        <span class="comment">// 放下左叉</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);                  <span class="comment">// 放下右叉</span></span><br><span class="line">        V(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>左右叉子绑定：</strong><br>仅当哲学家的左右两只叉子都可用时，才允许他拿起叉子进餐。</p>
<ol>
<li>利用 AND 型信号量机制实现</li>
</ol>
<p>由于等待队列的存在，使得对资源的请求满足 FIFO 的要求，因此不会出现饥饿的情形。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        Swait(chopstick[(i + <span class="number">1</span>)] % <span class="number">5</span>, chopstick[i]);</span><br><span class="line">        eat();</span><br><span class="line">        Ssignal(chopstick[(i + <span class="number">1</span>)] % <span class="number">5</span>, chopstick[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>利用信号量的保护机制实现</li>
</ol>
<p>通过信号量 mutex 对 eat () 之前的取左侧和右侧叉子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        signal(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>奇偶顺序拿叉：</strong><br>规定奇数号的哲学家先拿起他左边的叉子，然后再去拿他右边的叉子；偶数号的哲学家则相反。<br>1、2 号哲学家竞争 1 号叉子，3、4 号哲学家竞争 3 号叉子。即五个哲学家都竞争奇数号叉子，获得后，再去竞争偶数号叉子，最后总会有一个哲学家能获得两只叉子而进餐。<br>申请不到的哲学家进入阻塞等待队列，根 FIFO 原则，则先申请的哲学家会较先可以吃饭，因此不会出现饿死的哲学家。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            wait(chopstick[i]) ;</span><br><span class="line">            eat();</span><br><span class="line">            signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            signal(chopstick[i]) ;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 奇数哲学家，先左后右。</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            wait(chopstick[i]) ;</span><br><span class="line">            wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            eat();</span><br><span class="line">            signal(chopstick[i]) ;</span><br><span class="line">            signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-2-读者-写者问题"><a href="#5-2-读者-写者问题" class="headerlink" title="5.2. 读者-写者问题"></a>5.2. 读者 - 写者问题</h2><p>数据库访问模型。<br>读写互斥。多个进程可以同时读库；但如果一个进程正在写库，那么其他所有进程都不能访问数据库。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;       <span class="comment">/* 控制对 rc 的访问 */</span></span><br><span class="line">semaphore db = <span class="number">1</span>;          <span class="comment">/* 控制对 db 的访问 */</span></span><br><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;                <span class="comment">/* 正在读或者即将读的进程数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        down(&amp;mutex);      <span class="comment">/* 获得对 rc 的互斥访问 rc */</span></span><br><span class="line">        rc = rc + <span class="number">1</span>;       <span class="comment">/* 多了一个读者 */</span></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">1</span>) {     <span class="comment">/* 如果是第一个读者 */</span></span><br><span class="line">            down(&amp;db);</span><br><span class="line">        }</span><br><span class="line">        up(&amp;mutex);        <span class="comment">/* 释放对 rc 的互斥访问 */</span></span><br><span class="line">        </span><br><span class="line">        read_data_base();  <span class="comment">/* 访问数据 */</span></span><br><span class="line">        </span><br><span class="line">        down(&amp;mutex);      <span class="comment">/* 获得对 rc 的互斥访问权 */</span></span><br><span class="line">        rc = rc - <span class="number">1</span>;       <span class="comment">/* 少了一个读者 */</span></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) {     <span class="comment">/* 如果是最后一个读者 */</span></span><br><span class="line">            up(&amp;db);</span><br><span class="line">        }</span><br><span class="line">        up(&amp;mutex);        <span class="comment">/* 释放对 rc 的访问 */</span></span><br><span class="line">        </span><br><span class="line">        use_data_read();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        think_up_data();</span><br><span class="line">        </span><br><span class="line">        down(&amp;db);         <span class="comment">/* 互斥访问数据库 */</span></span><br><span class="line">        write_data_base();</span><br><span class="line">        up(&amp;db);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只要有一个稳定的读者流存在，写者将永远没有机会访问数据库。为避免这种情形，可以采用写者优先的方式：读者访问时若发现写者正在等待则在写者之后挂起（排队），缺点是并发度和效率较低。</p>
<h2 id="5-3-睡眠的理发师"><a href="#5-3-睡眠的理发师" class="headerlink" title="5.3. 睡眠的理发师"></a>5.3. 睡眠的理发师</h2><ol>
<li>5 把供顾客等候的椅子</li>
<li>一个理发师同时只能给一个顾客理发</li>
<li>没有顾客，理发师进入睡眠状态。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHAIRS 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore customers=<span class="number">0</span>;</span><br><span class="line">semaphore barbers=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;  <span class="comment">//protect 'waiting'</span></span><br><span class="line"><span class="type">int</span> waiting=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">barber</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        down(&amp;customers);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        waiting=waiting<span class="number">-1</span>;</span><br><span class="line">        up(&amp;barbers);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        cut_hair();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting&lt;CHAIRS)</span><br><span class="line">    {</span><br><span class="line">        waiting=waiting+<span class="number">1</span>;</span><br><span class="line">        up(&amp;customers);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        down(&amp;barbers);</span><br><span class="line">        get_haircut();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>另一版：</strong><br>一个理发店有一个入口和一个出口。理发店内有一个可站 5 位顾客的站席区、4 个单人沙发、3 个理发师及其专用理发工具、一个收银台。新来的顾客坐在沙发上等待；没有空沙发时，可在站席区等待；站席区满时，只能在入口外等待。理发师可从事理发、收银和休息三种活动。理发店的活动满足下列条件：<br>1）休息的理发师是坐地自己专用的理发椅上，不会占用顾客的沙发；<br>2）处理休息状态的理发师可为在沙发上等待时间最长的顾客理发；<br>3）理发时间长短由理发师决定；<br>4）在站席区等待时间最长的顾客可坐到空闲的理发上；<br>5）任何时刻最多只能有一个理发师在收银。<br>试用信号量机制或管程机制实现理发师进程和顾客进程。</p>
<p>原理：<br>(1) customer 进程：<br>首先检查站席区是否已满（stand_capacity）, 若满选择离开，否则进入站席区，即进入理发店。在站席区等待沙发的空位（信号量 sofa），如果沙发已满，则进入阻塞等待队列，直到出现空位，在站席区中等待时间最长的顾客离开站席区（stand_capacity）。坐到沙发上，等待理发椅 (barber_chair)，如果理发椅已满，则进入阻塞等待队列，直到出现空位，在沙发上等待时间最长的顾客离开沙发（释放信号量 sofa）。坐到理发椅上，释放准备好的信号（customer_ready），获得该理发师的编号（0~1 的数字）。等待理发师理发结束（finished [barber_number]）。在离开理发椅之前付款（payment），等待收据 (receipt)，离开理发椅（leave_barberchair）。最后离开理发店。<br>这里需要注意几点：<br>a) 首先是几个需要进行互斥处理的地方，主要包括：进入站席区、进入沙发、进入理发椅和付款几个地方。<br>b) 通过 barber_chair 保证一个理发椅上最多只有一名顾客。但这也不够，因为单凭 baber_chair 无法保证一名顾客离开理发椅之前，另一位顾客不会坐到该理发椅上，因此增加信号量 leave_barberchair，让顾客离开理发椅后，释放该信号，而理发师接收到该信号后才释放 barber_chair 等待下一位顾客。<br>c) 在理发的过程中，需要保证是自己理发完毕，才能够进行下面的付款、离开理发椅的活动。这个机制是通过 customer 进程获得给他理发的理发师编号来实现的，这样，当该编号的理发师释放对应的 finished [i] 信号的时候，该顾客才理发完毕。<br>d) 理发师是通过 mutex 信号量保证他们每个人同时只进行一项操作（理发或者收款）。<br>e) 为了保证该顾客理发完毕后马上可以付款离开，就应该保证给该顾客理发的理发师在理发完毕后马上到收银台进入收款操作而不是给下一位顾客服务。在伪码中由以下机制实现：即顾客在释放离开理发椅的信号前，发出付款的信号。这样该理发师得不到顾客的离开理发椅的信号，不能进入下一个循环为下一名顾客服务，而只能进入收款台的收款操作。直到顾客接到收据后，才释放离开理发椅的信号，离开理发椅，让理发师释放该理发椅的信号，让下一位等待的顾客坐到理发椅上。<br>(2) barber 进程<br>首先将该理发师的编号压入队列，供顾客提取。等待顾客坐到理发椅坐好 (信号量 customer_ready)，开始理发，理发结束后释放结束信号（finished [i]）。等待顾客离开理发椅（leave_barberchair）（期间去收银台进行收款活动），释放理发椅空闲信号 (barber_chair)，等待下一位顾客坐上来。<br>(3) cash（收银台）进程<br>等待顾客付款 (payment), 执行收款操作，收款操作结束，给付收据（receipt）。</p>
<p>信号量总表：<br>stand_capacity 顾客等待进入理发店 顾客离开站席区<br>sofa 顾客等待坐到沙发 顾客离开沙发<br>barber_chair 顾客等待空理发椅，理发师释放空理发椅<br>customer_ready 理发师等待，直到一个顾客坐到理发椅；顾客坐到理发椅上，给理发师发出信号<br>mutex 等待理发师空闲，执行理发或收款操作；理发师执行理发或收款结束，进入空闲状态<br>mutex1 执行入队或出队等待入队或出队结束，释放信号<br>finished [i] 顾客等待对应编号理发师理发结束；理发师理发结束，释放信号<br>leave_barberchair 理发师等待顾客离开理发椅；顾客付款完毕得到收据，离开理发椅释放信号<br>payment 收银员等待顾客付款顾客付款，发出信号<br>receipt 顾客等待收银员收、开具收据；收银员收款结束、开具收据，释放信号</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">semaphore stand_capacity=<span class="number">5</span>;</span><br><span class="line">semaphore sofa=<span class="number">4</span>;</span><br><span class="line">semaphore barber_chair=<span class="number">3</span>;</span><br><span class="line">semaphore customer_ready=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">3</span>;</span><br><span class="line">semaphore mutex1=<span class="number">1</span>;</span><br><span class="line">semaphore finished[<span class="number">3</span>]= {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">semaphore leave_barberchair=<span class="number">0</span>;</span><br><span class="line">semaphore payment=<span class="number">0</span>;</span><br><span class="line">semaphore receipt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> barber_number;</span><br><span class="line">    wait(stand_capacity); <span class="comment">//等待进入理发店</span></span><br><span class="line">    enter_room(); <span class="comment">//进入理发店</span></span><br><span class="line">    wait(sofa); <span class="comment">//等待沙发</span></span><br><span class="line">    leave_stand_section(); <span class="comment">//离开站席区</span></span><br><span class="line">    signal(stand_capacity);</span><br><span class="line">    sit_on_sofa(); <span class="comment">//坐在沙发上</span></span><br><span class="line">    wait(barber_chair); <span class="comment">//等待理发椅</span></span><br><span class="line">    get_up_sofa(); <span class="comment">//离开沙发</span></span><br><span class="line">    signal(sofa);</span><br><span class="line">    wait(mutex1);</span><br><span class="line">    sit_on_barberchair(); <span class="comment">//坐到理发椅上</span></span><br><span class="line">    signal(customer_ready);</span><br><span class="line">    barber_number=dequeue(); <span class="comment">//得到理发师编号</span></span><br><span class="line">    signal(mutex1);</span><br><span class="line">    wait(finished[barber_number]); <span class="comment">//等待理发结束</span></span><br><span class="line">    pay(); <span class="comment">//付款</span></span><br><span class="line">    signal(payment); <span class="comment">//付款</span></span><br><span class="line">    wait(receipt); <span class="comment">//等待收据</span></span><br><span class="line">    get_up_barberchair(); <span class="comment">//离开理发椅</span></span><br><span class="line">    signal(leave_barberchair); <span class="comment">//发出离开理发椅信号</span></span><br><span class="line">    exit_shop(); <span class="comment">//了离开理发店</span></span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">barber</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        wait(mutex1);</span><br><span class="line">        enqueue(i); <span class="comment">//将该理发师的编号加入队列</span></span><br><span class="line">        signal(mutex1);</span><br><span class="line">        wait(customer_ready); <span class="comment">//等待顾客准备好</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        cut_hair(); <span class="comment">//理发</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(finished[i]); <span class="comment">//理发结束</span></span><br><span class="line">        wait(leave_barberchair); <span class="comment">//等待顾客离开理发椅信号</span></span><br><span class="line">        signal(barber_chair); <span class="comment">//释放barber_chair 信号</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">cash</span><span class="params">()</span> <span class="comment">//收银</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        wait(payment); <span class="comment">//等待顾客付款</span></span><br><span class="line">        wait(mutex); <span class="comment">//原子操作</span></span><br><span class="line">        get_pay(); <span class="comment">//接受付款</span></span><br><span class="line">        give_receipt(); <span class="comment">//给顾客收据</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(receipt); <span class="comment">//收银完毕，释放信号</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：<br>在分析该问题过程中，出现若干问题，是参阅相关资料后才认识到这些问题的隐蔽性和严重性的，主要包括：<br>（1）在顾客进程，如果是在释放 leave_barberchair 信号之后进行付款动作的话，很容易造成没有收银员为其收款的情形， 原因是： 为该顾客理发的理发师收到 leave_barberchair 信号后，释放 barber_chair 信号，另外一名顾客坐到理发椅上，该理发师有可能为这另外一名顾客理发，而没有为刚理完发的顾客收款。为解决这个问题，就是采取在释放 leave_barberchair 信号之前，完成付款操作。这样该理发师无法进入下一轮循环为另外顾客服务，只能到收银台收款。<br>（2）本算法是通过给理发师编号的方式，当顾客坐到某理发椅上也同时获得理发师的编号，如此，当该理发师理发结束，释放信号，顾客只有接收到为其理发的理发师的理发结束信号才会进行付款等操作。这样实现，是为避免这样的错误，即：如果仅用一个 finished 信号量的话，很容易出现别的理发师理发完毕释放了 finished 信号，把正在理发的这位顾客赶去付款，而已经理完发的顾客却被阻塞在理发椅上的情形。当然也可以为顾客进行编号，让理发师获取他理发的顾客的编号，但这样就会限制顾客的数量，因为 finished [] 数组不能是无限的。而为理发师编号，则只需要三个元素即可。</p>
<h2 id="5-4-练习题"><a href="#5-4-练习题" class="headerlink" title="5.4. 练习题"></a>5.4. 练习题</h2><p>1、某小型超级市场，可容纳 50 人同时购物。入口处有篮子，每个购物者可拿一只篮子入内购物。出口处结帐，并归还篮子（出、入口禁止多人同时通过）。试用信号量和 P、 V 操作写出购物者的同步算法。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex1=<span class="number">1</span>,mutex2=<span class="number">1</span>,empty=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex1);</span><br><span class="line">    take a basket;</span><br><span class="line">    V(mutex1);</span><br><span class="line">    shopping;</span><br><span class="line">    P(mutex2);</span><br><span class="line">    put back a basket;</span><br><span class="line">    V(mutex2);</span><br><span class="line">    leaving;</span><br><span class="line">    V(empty);</span><br><span class="line">}</span><br><span class="line">conend;</span><br></pre></td></tr></tbody></table></figure>

<p>2、桌上有个只能盛得下一个水果的空盘子。爸爸可向盘中放苹果或桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定：当盘子空时，一次只能放入一个水果供吃者取用。试用信号量和 P、 V 操作实现爸爸、儿子和女儿这三个循环进程之间的同步。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore empty=<span class="number">1</span>,orange=<span class="number">0</span>,apple=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> fruit;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">father</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(empty);</span><br><span class="line">        fruit=put_fruit();</span><br><span class="line">        <span class="keyword">if</span>(fruit==ORE) V(orange);</span><br><span class="line">        <span class="keyword">else</span> V(apple);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">son</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(orange);</span><br><span class="line">        eat orange;</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">daughter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(apple);</span><br><span class="line">        eat apple;</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>3、设 A、 B 两点之间是一段东西向的单行车道，现在要设计一个 AB 路段自动管理系统，管理规则如下：当 AB 间有车辆在行驶时同方向的车可以同时驶入 AB 段，但另一方向的车必须在 AB 段外等待；当 AB 段之间无车辆行驶时，到达 AB 段的任一方向的车都可进入 AB 段，但不能从两个方向同时驶入，即只能有一个方向的车驶入；当某方向在 AB 段行驶的车辆驶出了 AB 段且暂无车辆进入 AB 段时，应让另一方向等待的车辆进入 AB 段行驶。试用信号量和 P、V 操作管理 AB 路段车辆的行驶。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>,mAtoB=<span class="number">1</span>,mBtoA=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> car_numAtoB=<span class="number">0</span>,car_numBtoA=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">carFromAtoB</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(mAtoB);</span><br><span class="line">    <span class="keyword">if</span>(car_numAtoB==<span class="number">0</span>)</span><br><span class="line">        P(mutex);</span><br><span class="line">    ++car_numAtoB;</span><br><span class="line">    V(mAtoB);</span><br><span class="line">    Car runs from A to B;</span><br><span class="line">    P(mAtoB);</span><br><span class="line">    --car_numAtoB;</span><br><span class="line">    <span class="keyword">if</span>(car_numAtoB==<span class="number">0</span>)</span><br><span class="line">        V(mutex);</span><br><span class="line">    V(mAtoB);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">carFromBtoA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(mBtoA);</span><br><span class="line">    <span class="keyword">if</span>(car_numBtoA==<span class="number">0</span>)</span><br><span class="line">        P(mutex);</span><br><span class="line">    ++car_numBtoA;</span><br><span class="line">    V(mBtoA);</span><br><span class="line">    Car runs from B to A;</span><br><span class="line">    P(mBtoA);</span><br><span class="line">    --car_numBtoA;</span><br><span class="line">    <span class="keyword">if</span>(car_numBtoA==<span class="number">0</span>)</span><br><span class="line">        V(mutex);    </span><br><span class="line">    V(mBtoA);</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>4、有两个用户进程 A 和 B，在运行过程中都要使用系统中的一台打印机输出计算结果。为保证这两个进程能正确地打印出各自的结果，请用信号量和 P、 V 操作写出各自的有关申请、使用打印机的代码。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);</span><br><span class="line">        print();</span><br><span class="line">        V(mutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>5、有一个阅览室，共有 100 个座位，读者进入时必须先在一张登记表上登记，该表为每一座位列一表目，包括座号和读者姓名等，读者离开时要消掉登记的信息，试用 PV 操作描述读者进程之间的同步关系。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>,seats=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_in</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(seats);</span><br><span class="line">    P(mutex);</span><br><span class="line">    登记;</span><br><span class="line">    V(mutex);</span><br><span class="line">    read();</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_out</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    V(seats);</span><br><span class="line">    P(mutex);</span><br><span class="line">    消去登记;</span><br><span class="line">    V(mutex);</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>6、设有一台计算机，有两条 I/O 通道，分别挂一台输入机和一台打印机。若要把输入机上的数据逐一地输入到缓冲区 B1 中，然后处理，并把结果搬到缓冲区 B2 中，最后在打印机上输出。用 P-V 操作写出这些进程的同步算法。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/545cb74e88b486b863fb5b54e3cf3334.png" alt="20160406120541066.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">empty1</span>, <span class="title">full1</span>, <span class="title">empty2</span>, <span class="title">full2</span>=</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line">data B1, B2;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">IP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        Get a new  data from input unit into x;</span><br><span class="line">        P(empty1);</span><br><span class="line">        B1=x;</span><br><span class="line">        V(full1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">PP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(full2);</span><br><span class="line">        x=B2;</span><br><span class="line">        V(empty2);</span><br><span class="line">        print x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">CP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x,y;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(full1);</span><br><span class="line">        x=B1;</span><br><span class="line">        V(empty1);</span><br><span class="line">        Compute on x and put the result into y;</span><br><span class="line">        P(empty2);</span><br><span class="line">        B2=y;</span><br><span class="line">        V(full2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>7、假定有三个进程 R、W1、W2 共享一个缓冲区 B，B 中每次只能存放一个整数。进程 R 每次启动输入设备读一个整数且把它存放在缓冲区 B 中，若存放到缓冲区 B 中的是奇数，则由进程 W1 将其取出打印，否则由进程 W2 将其取出打印。要求用 PV 操作管理这 3 个并发进程，使它们能够正确同步工作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">empty</span>, <span class="title">fullo</span>, <span class="title">fulle</span>=</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> B;</span><br><span class="line"><span class="type">void</span> process <span class="title function_">R</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        input data into x;</span><br><span class="line">        P(empty);</span><br><span class="line">        B=x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)  V(fullo);</span><br><span class="line">        <span class="keyword">else</span>  V(fulle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> process <span class="title function_">W1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(fullo);</span><br><span class="line">        y=B;</span><br><span class="line">        V(empty);</span><br><span class="line">        print y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> process <span class="title function_">W2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(fulle);</span><br><span class="line">        z=B;</span><br><span class="line">        V(empty);</span><br><span class="line">        print z;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/da53cb8a00c9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/da53cb8a00c9/" class="post-title-link" itemprop="url">操作系统从入门到入土①：概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-23 21:28:05" itemprop="dateCreated datePublished" datetime="2021-08-23T21:28:05+08:00">2021-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/da53cb8a00c9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="da53cb8a00c9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>28 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>深入理解计算机系统使用指南：<a target="_blank" rel="noopener" href="https://book.douban.com/review/5627139/">https://book.douban.com/review/5627139/</a></p>
<h1 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1. 什么是操作系统"></a>1. 什么是操作系统</h1><p>操作系统所处的位置<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/590b181ef083493161a55fbaf2fdc3c3.png" alt="image.png"><br>硬件包括芯片、电路板、磁盘、键盘、显示器以及类似的设备。</p>
<p><strong>用户态和内核态</strong><br>多数计算机有两种运行模式：内核态和用户态。</p>
<ul>
<li>内核态：操作系统运行在内核态，具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态的程序由硬件保护，防止用户试图对其进行修改。</li>
<li>用户态：软件的其余部分运行在用户态，只使用了机器指令中的一个子集。</li>
</ul>
<h2 id="1-1-操作系统分类"><a href="#1-1-操作系统分类" class="headerlink" title="1.1. 操作系统分类"></a>1.1. 操作系统分类</h2><ul>
<li><strong>单用户操作系统：</strong>单用户操作系统一次只能支持一个用户程序的运行。单用户操作系统向用户提供联机交互式的工作环境，比如 MS-DOS 就是一个经典的单用户操作系统。</li>
<li><strong>批处理操作系统：</strong>早期的一种大型机用操作系统。可对用户作业成批处理，期间无需用户干预，分为单道批处理系统和多道批处理系统。</li>
<li><strong>分时操作系统：</strong>利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</li>
<li><strong>实时操作系统：</strong>一个能够在指定或者确定的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统，实时意思就是对响应时间有严格要求，要以足够快的速度进行处理。分为硬实时和软实时两种。</li>
<li><strong>通用操作系统：</strong>同时兼有多道批处理、分时、实时处理的功能，或者其中两种以上功能的操作系统。</li>
<li><strong>网络操作系统：</strong>一种在通常操作系统功能的基础上提供网络通信和网络服务功能的操作系统。</li>
<li><strong>分布式操作系统：</strong>一种以计算机网络为基础的，将物理上分布的具有自治功能的数据处理系统或计算机系统互联起来的操作系统。分布式系统中各台计算机无主次之分，系统中若干台计算机可以并行运行同一个程序，分布式操作系统用于管理分布式系统资源。</li>
<li><strong>嵌入式操作系统：</strong>一种运行在嵌入式智能芯片环境中，对整个智能芯片以及它所操作、控制的各种部件装置等资源进行统一协调、处理、指挥和控制的系统软件。</li>
</ul>
<h2 id="1-2-操作系统接口"><a href="#1-2-操作系统接口" class="headerlink" title="1.2. 操作系统接口"></a>1.2. 操作系统接口</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/902ce2a4b8fbf79f5a078c45d91c759a.png" alt="image.png"><br>分为系统调用接口、POSIX 接口和领域应用接口</p>
<h3 id="1-2-1-系统调用接口"><a href="#1-2-1-系统调用接口" class="headerlink" title="1.2.1. 系统调用接口"></a>1.2.1. 系统调用接口</h3><p>应用程序通过操作系统内核提供的接口（例如系统调用）向内核申请服务。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f4de6dbc1320586c69e548b30db936f0.png" alt="image.png"><br>printf -&gt; lib 中的 write -&gt; svc 下陷到内核 -&gt; 下陷处理函数 sys_syscall 找到内核对应中对应的函数 -&gt; sys_write</p>
<h3 id="1-2-2-POSIX-接口"><a href="#1-2-2-POSIX-接口" class="headerlink" title="1.2.2. POSIX 接口"></a>1.2.2. POSIX 接口</h3><p>为了同一个应用程序在不同操作系统上的可移植性，逐渐形成了一些可移植操作系统接口标准。<br>POSIX（Portable Operating System Interface for uniX，可移植操作系统接口）。POSIX 标准通常通过 C library（libc）来实现，常见的 libc 包括 glibc、musl、eglibc。 Android 也实现了一个名为 bionic 的 libc。<br>应用程序只需要调用 libc 提供的接口就可以实现对操作系统功能的调用。</p>
<h3 id="1-2-3-领域应用接口"><a href="#1-2-3-领域应用接口" class="headerlink" title="1.2.3. 领域应用接口"></a>1.2.3. 领域应用接口</h3><p>在 POSIX 或操作系统调用的基础上还可以封装面向不同领域的领域应用接口。</p>
<h1 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2. 硬件"></a>2. 硬件</h1><h2 id="2-1-CPU"><a href="#2-1-CPU" class="headerlink" title="2.1. CPU"></a>2.1. CPU</h2><p>指令集架构（Instruction Set Architecture, ISA）是 CPU 和软件之间的桥梁。ISA 包含指令集、特权级、寄存器、执行模式、安全扩展、性能加速扩展等诸多方面。</p>
<h3 id="2-1-1-指令集"><a href="#2-1-1-指令集" class="headerlink" title="2.1.1. 指令集"></a>2.1.1. 指令集</h3><p>每个 CPU 都有一套可执行的专门 ** 指令集 **。所以，x86 处理器不能执行 ARM 程序，而 ARM 处理器也不能执行 x86 程序。</p>
<h3 id="2-1-2-特权级"><a href="#2-1-2-特权级" class="headerlink" title="2.1.2. 特权级"></a>2.1.2. 特权级</h3><p>AArch64（首款 64 位架构的 ARM 处理器）中的特权级被称为异常级别（Exception Level，EL）<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ed211bcc7bcc01fc8becc25b4b24223b.png" alt="image.png"></p>
<ul>
<li>EL0：最低的特权级，应用程序通常运行在该特权级，也称为 <strong>用户态</strong>。</li>
<li>EL1：操作系统通常运行在该特权级，也称为 ** 内核态 **。</li>
<li>EL2：在虚拟化场景下需要，虚拟机监控器（Virtual Machine Monitor，VMM）通常运行在该特权级。</li>
<li>EL3：TrustZone 是从 ARMv6 体系结构开始引入的安全特性，其从逻辑上将整个系统分为安全世界（能访问所有资源）和普通世界（不能访问安全世界的资源）。</li>
</ul>
<p>EL3 和安全特性 TrustZone 相关，负责普通世界和安全世界之间的切换。</p>
<p><strong>用户态切换至内核态的场景：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5daa365ab39433c1f7f95ea9d561b540.png" alt="image.png"></p>
<ol>
<li>应用程序执行 svc（特权调用，supervisor call）指令切换。</li>
<li>指令触发异常切换，如缺页异常。</li>
<li>CPU 收到来自外设的中断。</li>
</ol>
<p><strong>用户态切换至内核态过程：</strong><br>操作系统可以在异常向量表中为不同的异常类型配置相应的异常处理函数。</p>
<ol>
<li>发生特权级切换时，CPU 会读取 VBAR_EL1（向量基地址寄存器，Vector Base Address Register）来获得 <strong>异常向量表（exception vector table）</strong>的基地址。</li>
<li>然后根据异常原因（ESR_EL1 中保存的内容）调用操作系统设置的相应异常处理函数。</li>
<li>该函数通常会先保存应用程序的上下文（如通用寄存器），然后会根据异常原因进行相应的处理。</li>
</ol>
<p>例如，若特权级切换是应用程序执行 svc 指令导致的，则执行相应的系统调用；<br>若特权级切换是访存过程中缺页异常导致的，则执行相应的缺页异常处理函数。</p>
<ol start="4">
<li>异常处理完成之后，操作系统会恢复应用程序的上下文，然后执行 eret（异常返回，Exception Return）指令恢复 CPU 自动保存的 EL0 状态，并切回到 EL0，使应用程序从被中断处继续执行。</li>
</ol>
<p><strong>pipeline</strong><br>为了改善性能，CPU 设计师早就放弃了同时读取、解码和执行一条指令的简单模型。许多现代 CPU 具有同时 ** 取出多条指令 ** 的机制。这样的机制称为 <strong>流水线（pipeline）</strong>。<br>例如，一个 CPU 可以有单独的取指单元、解码单元和执行单元，于是当它执行指令 n 时，还可以对指令 n ＋1 解码，并且读取指令 n +2。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0cab757be7497b7484eb81ea077f99a6.png" alt="image.png"></p>
<p><strong>超标量 CPU</strong><br>超标量 CPU，有多个执行单元。两个或更多的指令被同时取出、解码并装入暂存缓冲区中，直至它们执行完毕。只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之。<br>有指令不按顺序执行的隐患。</p>
<blockquote>
<p>例如，一个 CPU 用于整数算术运算，一个 CPU 用于浮点算术运算，一个 CPU 用于布尔运算。</p>
</blockquote>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5e547a976ceee90d436a019295be0c8f.png" alt="image.png"></p>
<h3 id="2-1-3-寄存器"><a href="#2-1-3-寄存器" class="headerlink" title="2.1.3. 寄存器"></a>2.1.3. 寄存器</h3><p>用与 CPU 相同的材料制成，所以和 CPU 一样快。</p>
<h2 id="2-2-存储器"><a href="#2-2-存储器" class="headerlink" title="2.2. 存储器"></a>2.2. 存储器</h2><p>存储器分层结构<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/869cb1408042650ad093b5f8b9e5ea52.png" alt="image.png"></p>
<h3 id="2-2-2-高速缓存"><a href="#2-2-2-高速缓存" class="headerlink" title="2.2.2. 高速缓存"></a>2.2.2. 高速缓存</h3><p><strong>L1 缓存：</strong>总是在 CPU 中，用来将已解码的指令调入 CPU 的执行引擎，不存在任何延时。</p>
<p><strong>L2 缓存：</strong>用来存放近来使用过的若干兆字节的内存字，延时 1 或 2 个时钟周期。</p>
<ul>
<li>带有共享 L2 缓存的 4 核芯片（Intel）：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fdaffb91f95605d5f515bf1c43744278.png" alt="image.png"></p>
<ul>
<li>带有分离 L2 缓存的 4 核芯片（AMD）：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a96f844f844d6460c884f87fdb5fa325.png" alt="image.png"></p>
<p><strong>缓存行：</strong><br>CPU 缓存是由若干个缓存行（cache line）组成的。物理内存与 CPU 缓存之间的数据传输以缓存行为单位，一般为 64 字节。这比单个字节读取要快得多。<br>每个缓存行有一个用于表示其是否有效的有效位（valid bit）和一个用于标识其对应的物理地址的标记地址（tag address）。</p>
<p><strong>缓存命中：</strong><br>当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。</p>
<ul>
<li>命中，就不需要访问主存，命中通常需要两个时钟周期。</li>
<li>未命中就必须访问内存，这将花费大量时间。<blockquote>
<p>存储器读取某一个位置，接下来访问这个位置的概率非常高，尤其是紧随其后的内存位置。</p>
</blockquote>
</li>
</ul>
<p><strong>缓存结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f5410bebb3a5c861935545799d24673a.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4819fdb071292e7a1b549a75762fa5b3.png" alt="image.png"><br>物理地址在逻辑上分为 Tag、Set（也称为 Index）以及 Offset 三段。</p>
<blockquote>
<p>类似三维坐标中的 xyz 坐标</p>
</blockquote>
<p>组（Set）与路（Way）是 CPU 缓存的经典概念。</p>
<ul>
<li>物理地址中的 Set 段能表示的最大数目称为组。</li>
<li>同一组（即 Set 段相等）下，支持的最大 Tag 数则称为路，即同一组下的缓存行数目，该 CPU 缓存被称为 4 路组相联（4-Way Set Associative）。</li>
</ul>
<h3 id="2-2-3-主存"><a href="#2-2-3-主存" class="headerlink" title="2.2.3. 主存"></a>2.2.3. 主存</h3><ul>
<li>随机访问存储器（RAM）</li>
<li>只读存储器（ROM）：用于启动计算机的引导加载模块</li>
<li>电可擦除可编程 ROM（EEPROM） 和闪存：与 ROM 相比可以擦除和重写</li>
</ul>
<h3 id="2-2-4-磁盘"><a href="#2-2-4-磁盘" class="headerlink" title="2.2.4. 磁盘"></a>2.2.4. 磁盘</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2dd668189cb0c4710403d1fe3578022.png" alt="image.png"><br><strong>概念：</strong></p>
<ul>
<li>在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为 <strong>磁道</strong>（track）。</li>
<li>把一个给定臂的位置上的所有磁道合并起来，组成了一个 <strong>柱面</strong>（cylinder）。外部的柱面比内部的柱面有更多的扇区。</li>
</ul>
<p><strong>过程：</strong></p>
<ol>
<li>机械臂从一个柱面移到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，其具体时间取决于驱动器。</li>
<li>一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，这就增加了 5ms 至 10ms 的时延，其具体延时取决于驱动器的转速。</li>
<li>一旦所需要的扇区移到磁头之下，就开始读写，低端硬盘的速率是 50MB/s，而高速磁盘的速率是 160 MB/s。</li>
</ol>
<h3 id="2-2-5-I-O-设备"><a href="#2-2-5-I-O-设备" class="headerlink" title="2.2.5. I/O 设备"></a>2.2.5. I/O 设备</h3><ul>
<li><strong>实际设备：</strong>如 SATA（串行高级技术附件），标准化后任何一个 SATA 磁盘控制器就可以适配任一种 SATA 磁盘。</li>
<li><strong>设备控制器：</strong></li>
</ul>
<p>设备控制器是插在电路板上的一块芯片或一组芯片。它从操作系统接收命令，物理地控制设备。</p>
<blockquote>
<p>例如，从设备读数据，并且完成数据的处理。</p>
</blockquote>
<p>控制器的任务是为操作系统提供一个简单的接口（不过还是很复杂）。</p>
<blockquote>
<p>例如，磁盘控制器可以接受一个命令从磁盘 2 读出 11206 号扇区，然后，控制器把这个线性扇区号转化为柱面、扇区和磁头。</p>
</blockquote>
<ul>
<li><strong>设备驱动程序：</strong>与设备控制器交互的软件。每个控制器厂家必须为所支持的操作系统提供相应的设备驱动程序。<blockquote>
<p>例如，一台扫描仪会配有用于 OS X、Windows 7、Windows 8 以及 Linux 的设备驱动程序。</p>
</blockquote>
</li>
</ul>
<p>设备驱动器装入操作系统的三个途径：</p>
<ol>
<li>将内核与设备驱动程序重新链接，然后重启动系统。许多 UNIX 系统以这种方式工作。</li>
<li>在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启动系统。在系统启动时，操作系统去找寻所需的设备驱动程序并装载之。Windows 就是以这种方式工作。</li>
<li>操作系统能够在运行时接受新的设备驱动程序并且立即将其安装好，无须重启动系统。热插拔设备，像 USB 之类需要动态可装载设备驱动程序。</li>
</ol>
<ul>
<li><strong>I/O 端口空间：</strong></li>
</ul>
<p>每个设备控制器都有少量用于通信的寄存器。<br>要激活控制器，设备驱动程序从操作系统获得一条命令，然后翻译成对应的值，并写进设备寄存器中。所有设备寄存器的集合构成了 I/O 端口空间。</p>
<blockquote>
<p>例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数和方向（读或写）的寄存器。</p>
</blockquote>
<p><strong>内存映射 I/O（Memory-Mapped I/O MMIO）</strong><br>把输人输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。<br>CPU 可以使用和访问物理内存一样的指令去读写这些属于设备的地址。</p>
<p><strong>实现输入输出的三种方式：</strong></p>
<ul>
<li>忙等待（轮询）：</li>
</ul>
<p>用户程序发出一个系统调用，内核对设备驱动程序进行过程调用，然后设备驱动程序启动 I/O 并循环检查该设备是否完成了工作。<br>当 I/O 结束后，设备驱动程序把数据送到指定的地方并返回，然后操作系统将控制返回给调用者。<br>其缺点是要占据 CPU，CPU 一直轮询设备直到对应的 I/O 操作完成。</p>
<ul>
<li>中断：</li>
</ul>
<p>设备驱动程序启动设备，让该设备在操作完成时发出一个中断，设备驱动程序在这个时刻返回。<br>当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成，操作系统接着在需要时阻塞调用者并安排其他工作进行。</p>
<ul>
<li>直接存储器访问（DMA）芯片：</li>
</ul>
<p>可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。CPU 对 DMA 芯片进行设置，说明需要传送的字节数、有关的设备和内存地址以及操作方向，接着启动 DMA。当 DMA 芯片完成时，它引发一个中断。</p>
<p>MMIO 使得 CPU 可以主动地访问设备，中断使得设备能够主动地通知 CPU，这两种机制是 CPU 与设备之间交互的重要方式。</p>
<h3 id="2-2-6-总线"><a href="#2-2-6-总线" class="headerlink" title="2.2.6. 总线"></a>2.2.6. 总线</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/751efc320e7e6078af3fddf32b2bd3e3.png" alt="image.png"><br><strong>概述：</strong><br>系统有很多总线（例如高速缓存、内存、PCle、PCI、USB、SATA 和 DMI)，每条总线的传输速度和功能都不同。操作系统必须了解所有总线的配置和管理。其中主要的总线是 PCIe 总线。</p>
<p><strong>USB（Universal Serial Bus）：</strong><br>将所有慢速 I/O 设备（如键盘和鼠标）与计算机连接。USB 是一种集中式总线，其根设备每 1ms 轮询一次 IO 设备，看是否有信息收发。USB 1.0 可以处理总计 12Mb/s 的负载，USB 2.0 总线提速到 480 Mb/s，而 USB 3.0 能达到不小于 5Gb/s 的速率。</p>
<p><strong>SCSI（Small Computer System Interface）：</strong><br>是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上。主要用在服务器和工作站中，速度可以达到 640MB/s。</p>
<h3 id="2-2-7-启动计算机"><a href="#2-2-7-启动计算机" class="headerlink" title="2.2.7. 启动计算机"></a>2.2.7. 启动计算机</h3><p><strong>BIOS：</strong><br>基本输入输出系统（Basic Input Output System，BIOS）。<br>在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 IO 以及其他过程。<br>现在这个程序存放在一块闪速 RAM 中，它是非易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p>
<p><strong>BIOS 的运行过程：</strong><br>在计算机启动时，BIOS 开始运行。</p>
<ol>
<li>首先检查所安装的 RAM 数量，键盘和其他基本设备是否已安装并正常响应。</li>
<li>接着，开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。</li>
</ol>
<p>也会记录即插即用设备。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。</p>
<ol start="3">
<li>根据存储在 CMOS 存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个 BIOS 配置程序，对设备清单进行修改。</li>
</ol>
<p>如果存在 CD-ROM（有时是 USB），则系统试图从中启动，如果失败，系统将从硬盘启动。</p>
<ol start="5">
<li>启动设备上的第一个扇区，被读入内存并执行。这个扇区中包含一个检查分区表的程序，以确定哪个分区是活动的。</li>
<li>然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动。</li>
<li>然后，操作系统询问 BIOS，以获得配置信息。系统检查每个设备对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的 CD-ROM。</li>
<li>一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或 GUI。</li>
</ol>
<p><strong>即插即用（plug and play）：</strong><br>每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。</p>
<blockquote>
<p>例如，键盘的中断级别是 1，并使用 0x60 至 0x64 的 I/O 地址，<br>软盘控制器是中断 6 级并使用 Ox3F0 至 0x3F7 的 I/O 地址，<br>而打印机是中断 7 级并使用 0x378 至 0x37A 的 I/O 地址等。</p>
</blockquote>
<p>如果有一块声卡和调制解调卡，都是使用中断 4，它们就会冲突。必须得在每块 I/O 卡上提供 DIP 开关或跳接器，并指导用户对其进行设置去选择中断级别和 I/O 地址才能解决冲突。</p>
<p>即插即用让系统能自动地收集有关 I/O 设备的信息，集中赋予中断级别和 I/O 地址，然后通知每块卡所使用的数值。计算机启动时 BIOS 会记录所有的设备，如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。</p>
<h1 id="3-系统相关"><a href="#3-系统相关" class="headerlink" title="3. 系统相关"></a>3. 系统相关</h1><h2 id="3-1-文件系统"><a href="#3-1-文件系统" class="headerlink" title="3.1. 文件系统"></a>3.1. 文件系统</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7be685d0842f095478c4a8ec5d133368.png" alt="image.png"><br><strong>进程树和文件树的区别：</strong></p>
<ul>
<li>一般进程的树状结构层次不深（很少超过三层），而文件树状结构的层次常常多达四层、五层或更多层。</li>
<li>进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在数年之久。</li>
<li>所有权及保护：只有父进程能控制和访问子进程，而在文件和目录能使其他用户也可以访问。</li>
</ul>
<p><strong>文件描述符：</strong><br>在读写文件之前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作 <strong>文件描述符（file descriptor）</strong>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p>
<p><strong>安装文件系统：</strong><br>UNIX 允许把光盘上的文件系统接到主文件树上。mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3bd18a1e7aeb83e60b48cac26d32224.png" alt="image.png"></p>
<p>装配文件系统将使得装配目录中已有的任何文件都不可访问，因此装配点通常都是空的。<br>但是，系统管理人员可能需要将某些位于被装配目录中的非常重要的文件复制到装配点，使得他们在进行设备检查或修理时，可以在紧急事件中的普通路径上找到这些文件。</p>
<p><strong>特殊文件：</strong><br>提供特殊文件是为了使 I/O 设备看起来像文件一般。I/O 设备也可通过同样的系统调用进行读写。<br>按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如， <code>/dev/lp</code> 是打印机。</p>
<ul>
<li><strong>块特殊文件：</strong>指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第 4 块，程序可以直接访问设备的第 4 块而不必考虑存放该文件的文件系统结构。</li>
<li><strong>字符特殊文件：</strong>用于打印机、调制解调器和其他接收或输出字符流的设备。</li>
</ul>
<p><strong>管道：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4db296dab3b41db38c8ce5363f902b6b.png" alt="image.png"><br>管道（pipe）是一种虚文件，它可连接两个进程。如果进程 A 和 B 希望通过管道对话，它们必须提前设置该管道。</p>
<p>当进程 A 想对进程 B 发送数据时，它把数据写到管道上，进程 B 可以通过读该管道而得到数据。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p>
<p>若进程想发现它所写入的输出文件不是真正的文件而是管道，则需要使用特殊的系统调用。</p>
<h1 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h1><p><strong>read 系统调用：</strong><br>它的调用由 C 程序完成，方法是调用一个与该系统调用名称相同的库过程 read。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = read(fd, buffer,nbytes);</span><br></pre></td></tr></tbody></table></figure>
<p>调用过程如下<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b9c383ffb4292b3281fd9169719d85d.png" alt="image.png"></p>
<h2 id="4-1-进程管理"><a href="#4-1-进程管理" class="headerlink" title="4.1. 进程管理"></a>4.1. 进程管理</h2><table>
<thead>
<tr>
<th><strong>进程管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> pid = fork()</td>
<td> 创建与父进程相同的子进程</td>
</tr>
<tr>
<td> pid = waitpid(pid, &amp;statloc, options)</td>
<td> 等待一个子进程终止</td>
</tr>
<tr>
<td> s = execve(name, argv, environp)</td>
<td>execve () 系统调用的作用是运行另外一个指定的程序。它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。<br><br>execve () 系统调用通常与 fork () 系统调用配合使用。从一个进程中启动另一个程序时，通常是先 fork () 一个子进程，然后在子进程中使用 execve () 变身为运行指定程序的进程。</td>
</tr>
<tr>
<td>exit(status)</td>
<td> 终止进程执行并返回状态</td>
</tr>
</tbody></table>
<p>pid：进程的 id</p>
<p><strong>fork：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define TRUE 1</span></span><br><span class="line"></span><br><span class="line">/*一直循环下去*/</span><br><span class="line">while (TRUE) {</span><br><span class="line">    /*在屏幕上显示提示符*/</span><br><span class="line">    type_prompt();</span><br><span class="line">    /*从终端读取输入*/</span><br><span class="line">    read_command(command, parameters);</span><br><span class="line">    </span><br><span class="line">    /* 派生子进程 */</span><br><span class="line">    if(fork() != 0) {</span><br><span class="line">        /* 父代码 */</span><br><span class="line">        /*等待子进程退出*/</span><br><span class="line">        waitpid(-1, &amp;status, 0);</span><br><span class="line">    } else {</span><br><span class="line">        /* 子代码 */</span><br><span class="line">        /* 执行其他命令 */</span><br><span class="line">        execve(command, parameters, 0)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>父进程从终端读取命令，创建一个子进程，等待该子进程执行命令。</p>
<ol>
<li>父进程执行 waitpid 系统调用来等待子进程结束，直至子进程终止。</li>
</ol>
<p>waitpid 参数：</p>
<ul>
<li>waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个老的子进程。</li>
<li>在 waitpid 完成之后，将把第二个参数 statloc 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。</li>
<li>有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立即返回。</li>
</ul>
<ol start="2">
<li>子进程通过使用 execve 系统调用执行用户的命令。这个系统调用会引起其整个核心映像被一个文件所替代，该文件由第一个参数给定。</li>
</ol>
<p>execve 参数：</p>
<ul>
<li>name：要执行的文件名称。如 <code>cp</code></li>
<li>argv：指向变量数组的指针。传入命令的参数</li>
<li> environp：指向环境数组的指针</li>
</ul>
<p><strong>进程存储空间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c4e8e2382c2444687c3d06817d09d4e6.png" alt="image.png"><br>在 UNIX 中的进程将其存储空间划分为三段：<strong>正文段</strong>（如程序代码）、<strong>数据段</strong>（如变量）以及 <strong>堆栈段</strong>。数据向上增长而堆栈向下增长。</p>
<h2 id="4-2-文件管理"><a href="#4-2-文件管理" class="headerlink" title="4.2. 文件管理"></a>4.2. 文件管理</h2><table>
<thead>
<tr>
<th><strong>文件管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> fd = open(file, how, …)</td>
<td> 打开一个文件供读、写或两者</td>
</tr>
<tr>
<td> s = close(fd)</td>
<td> 关闭一个打开的文件</td>
</tr>
<tr>
<td> n = read(fd, buffer, bnytes)</td>
<td> 把数据从一个文件读到缓冲区中</td>
</tr>
<tr>
<td> n= write(fd, buffer, nbytes)</td>
<td> 把数据从缓冲区写到一个文件中</td>
</tr>
<tr>
<td> position = lseek(fd, offset, whence)</td>
<td> 移动文件指针</td>
</tr>
<tr>
<td> s = stat(name, &amp;buf)</td>
<td> 取得文件的状态信息</td>
</tr>
</tbody></table>
<p>fd：文件描述符<br>n：字节数<br>position：在文件中的偏移量</p>
<p><strong>open：</strong><br>使用 open 打开文件返回文件描述符，然后可使用返回的文件描述符进行读写操作。接着可以用 close 关闭文件。</p>
<p><strong>lseek：</strong><br>每个文件有一个指向文件当前位置的指针。在顺序读（写）时，该指针通常指向要读出（写入）的下一个字节。<br>lseek 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p>
<h2 id="4-3-目录管理"><a href="#4-3-目录管理" class="headerlink" title="4.3. 目录管理"></a>4.3. 目录管理</h2><table>
<thead>
<tr>
<th><strong>目录和文件系统管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> s = mkdir(name, mode)</td>
<td> 创建一个新目录</td>
</tr>
<tr>
<td> s = rmdir(name)</td>
<td> 删去一个空目录</td>
</tr>
<tr>
<td> s = link(name1, name2)</td>
<td> 创建 — 个新目录项 name2，并指向 name1</td>
</tr>
<tr>
<td>s = unlink(name)</td>
<td> 删去一个目录项</td>
</tr>
<tr>
<td> s = mount(special, name, flag)</td>
<td> 安装一个文件系统</td>
</tr>
<tr>
<td> s = umount(special)</td>
<td> 卸载一个文件系统</td>
</tr>
</tbody></table>
<p><strong>link：</strong><br>允许同一个文件以两个或多个名称出现</p>
<p>在 UNIX 中，每个文件都有唯一的编号，即 <strong>i - 编号</strong>，用以标识文件。该 i - 编号是对 i - 节点表格的一个引用，它们一一对应，说明该文件的拥有者、磁盘块的位置等。</p>
<p>目录就是一个包含了（i - 编号，ASCII 名称）集合的文件。link 所做的只是利用某个已有文件的 i - 编号，创建一个新目录项（也许用一个新名称）。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/13120eed179bb298fadd9b6213436b73.png" alt="image.png"><br>上图两个目录项有相同的 i - 编号（70)，从而指向同一个文件。如果使用 unlink 系统调用将其中一个文件移走了，可以保留另一个。</p>
<p>如果两个都被移走了，UNIX 00 看到尚且存在的文件没有目录项，就会把该文件从磁盘中移去。</p>
<h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4. 其他"></a>4.4. 其他</h2><table>
<thead>
<tr>
<th><strong>杂项</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> s = chdir(dirname)</td>
<td> 改变工作目录</td>
</tr>
<tr>
<td> s = chmod(name, mode)</td>
<td> 修改一个文件的保护位</td>
</tr>
<tr>
<td> s = kill(pid, signal)</td>
<td> 发送信号给一个进程</td>
</tr>
<tr>
<td> seconds =time(&amp;seconds)</td>
<td> 自 1970 年 1 月 1 日起的流逝时间</td>
</tr>
</tbody></table>
<p>seconds：流逝时间</p>
<h1 id="5-操作系统结构"><a href="#5-操作系统结构" class="headerlink" title="5. 操作系统结构"></a>5. 操作系统结构</h1><h2 id="5-1-策略和机制"><a href="#5-1-策略和机制" class="headerlink" title="5.1. 策略和机制"></a>5.1. 策略和机制</h2><p>策略表示要做什么，机制表示该怎么做。<br>有时会出现一个进程有多个子进程，每个子进程可能实现不同的功能（计算分析，访问磁盘等），并具有不同的优先级。这就要求调度程序需要从用户进程中获取调度决策信息。</p>
<p>将调度算法以某种形式参数化，而参数可以由用户进程填写。这样便使得策略和机制分离，算法由底层实现，而用户进程可以设置参数来对其进行调整。<br>假设内核使用优先级调度算法，并提供一条可供进程设置优先级的系统调用，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。</p>
<h2 id="5-2-内核结构"><a href="#5-2-内核结构" class="headerlink" title="5.2. 内核结构"></a>5.2. 内核结构</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/312f99ce48aa5ad6ba301199402cc63f.png" alt="image.png"></p>
<h3 id="5-2-1-简要结构（单体）"><a href="#5-2-1-简要结构（单体）" class="headerlink" title="5.2.1. 简要结构（单体）"></a>5.2.1. 简要结构（单体）</h3><p>整个操作系统在内核态以单一程序的方式运行。整个操作系统以过程集合的方式编写，链接成一个大型可执行二进制程序。</p>
<p>使用这种技术，系统中每个过程可以自由调用其他过程，只要后者提供了前者所需要的一些有用的计算工作。调用任何一个你所需要的过程或许会非常高效。</p>
<p>但上千个可以不受限制地彼此调用的过程常常导致系统笨拙且难于理解。并且，任何一个过程的崩溃都会连累整个系统。</p>
<p><strong>结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cd380e424a2d459ac19ceab59d67fa32.png" alt="image.png"><br>对于这类操作系统的基本结构，需要如下结构：</p>
<ol>
<li>需要一个主程序，用来处理服务过程请求。</li>
<li>需要一套服务过程，用来执行系统调用。</li>
<li>需要一套实用过程，用来辅助服务过程。</li>
</ol>
<p>每一个系统调用都通过一个服务过程为其工作并运行之。要有一组实用程序来完成一些服务过程所需要用到的功能，如从用户程序取数据等。</p>
<h3 id="5-2-2-宏内核"><a href="#5-2-2-宏内核" class="headerlink" title="5.2.2. 宏内核"></a>5.2.2. 宏内核</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/491287cf15c1f944680853bd043f4d52.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/84bad2763dcb858b305543c2b2542986.png" alt="image.png"><br>THE 操作系统结构，底层保证基础功能，上层依赖底层</p>
<blockquote>
<p>注：让我想起了七层网络模型</p>
</blockquote>
<h3 id="5-2-3-微内核"><a href="#5-2-3-微内核" class="headerlink" title="5.2.3. 微内核"></a>5.2.3. 微内核</h3><p>在宏内核架构下，所有内核模块均运行在特权空间，一个单点的错误就可能会导致整个系统崩溃或者被攻破。<br>为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有微内核运行在内核态，其余的模块由于功能相对弱些，则作为普通用户进程运行。</p>
<p><strong>优点：</strong><br>由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。所以，音频驱动中的错误会使声音断续或停止，但是不会使整个计算机垮掉。</p>
<p><strong>使用场景：</strong><br>通常桌面操作系统并不使用微内核。微内核在实时、工业、航空以及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。</p>
<h3 id="5-2-4-客户端-服务器模式"><a href="#5-2-4-客户端-服务器模式" class="headerlink" title="5.2.4. 客户端-服务器模式"></a>5.2.4. 客户端 - 服务器模式</h3><p>客户端 - 服务器模式将进程划分为两类</p>
<ul>
<li><strong>服务器：</strong>每个服务器提供某种服务</li>
<li><strong>客户端：</strong>使用这些服务。</li>
</ul>
<p>通常，在系统最底层是微内核，但并不是必须这样。客户端 - 服务器模式的本质是存在客户端进程和服务器进程。</p>
<p><strong>消息通信：</strong><br>客户端和服务器之间的通信是消息传递。为了获得一个服务，客户端进程构造段消息，并将其发给合适的服务器。该服务器完成工作，发送回应。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f2d774d2e4a167de32b95d9501fb6175.png" alt="image.png"><br>一个普遍方式是运行在不同计算机上的客户端和服务器，通过局域网或广域网连接。<br>其内部细节对客户端来说是屏蔽的。所以，客户端 - 服务器模式是一种可以应用在单机或者网络机器上的抽象。</p>
<h3 id="5-2-5-虚拟机"><a href="#5-2-5-虚拟机" class="headerlink" title="5.2.5. 虚拟机"></a>5.2.5. 虚拟机</h3><p><strong>虚拟机监控程序：</strong><br>VM/370 系统<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b48fee8fcee4ccbc80d43fc246d00625.png" alt="image.png"><br>这个系统的核心被称为 <strong>虚拟机监控程序（virtual machine monitor）</strong>，它在裸机上运行并且具备了多道程序功能<br>该系统向上层提供了若干台虚拟机。每台虚拟机都与裸机相同，所以不同的虛拟机可以运行不同的操作系统。</p>
<p><em>CMS：</em><br>在早期的 VM/370 系统上，有一些系统运行 OS/360 或者其他大型批处理或事务处理操作系统，而另一些虚拟机运行单用户、交互式系统供分时用户使用，这个系统称为 <strong>会话监控系统（Conversational Monitor System,CMS）</strong>。</p>
<p><em>系统调用：</em><br>当一个 CMS 程序执行系统调用时，该调用被陷入到其虚拟机的操作系统上。<br>CMS 然后发出硬件 I/O 指令读出虛拟磁盘或其他需要执行的调用。这些 I/O 指令由 VM/370 陷入并完成指令。通过对多道程序功能和提供扩展机器二者的完全分离，每个部分都变得非常简单、非常灵活且容易维护。</p>
<p><strong>第一类与第二类虚拟机管理程序：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a5e7937f43820fcebaf697e622ad0f7d.png" alt="image.png"><br><em>区别：</em><br>第二类虚拟机管理程序利用 <strong>宿主操作系统（host operatingsystem）</strong>并通过其文件系统创建进程、存储文件等。它从 CD-ROM 安装盘中读入供选择的 <strong>客户操作系统（guestoperating system）</strong>，并安装在一个虚拟盘上，该盘实际上只是宿主操作系统的文件系统中的一个大文件。</p>
<p>第一类虚拟机管理程序没有底层（宿主操作系统）支持，所以必须在原始的硬盘分区上自行管理储存。</p>
<h3 id="5-2-6-外壳"><a href="#5-2-6-外壳" class="headerlink" title="5.2.6. 外壳"></a>5.2.6. 外壳</h3><p>与虚拟机克隆真实机器不同，另一种策略是对机器进行分区，即给每个用户整个资源的一个子集。</p>
<p>外核的任务是为虚拟机分配资源，确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/a39820b4ce4b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/a39820b4ce4b/" class="post-title-link" itemprop="url">ThreadLocal 详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-13 22:03:28" itemprop="dateCreated datePublished" datetime="2021-03-13T22:03:28+08:00">2021-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/a39820b4ce4b/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="a39820b4ce4b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/a39820b4ce4b/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/26d195955dea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/26d195955dea/" class="post-title-link" itemprop="url">Java 并发详解 ⑦：AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-05 18:48:44" itemprop="dateCreated datePublished" datetime="2021-03-05T18:48:44+08:00">2021-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/26d195955dea/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="26d195955dea/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>6 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p><strong>概述：</strong> 用来控制一个线程等待多个线程</p>
<p><strong>原理：</strong><br>维护了一个计数器 cnt，每次调用 countDown () 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await () 方法而在等待的线程就会被唤醒</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/859b76a0bc977dc9c5274854fdf6fbaa.png"></p>
<p><strong>API：</strong></p>
<ul>
<li><strong>await()：</strong> 调用 await () 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行</li>
<li><strong> await(long timeout, TimeUnit unit)：</strong> 和 await () 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行</li>
<li><strong> countDown()：</strong> 将 count 值减 1</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountdownLatchExample</span> {</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// run..run..run..run..run..run..run..run..run..run..end</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>场景：</strong></p>
<ol>
<li>启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行 </li>
<li>实现多个线程开始执行任务的最大并行性<br>CountDownLatch (1)，多个线程挂起，当主线程调用 countDown () 时，多个线程同时被唤醒</li>
</ol>
<p><strong>不足：</strong><br>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>
<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p><strong>概述：</strong> 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行</p>
<p><strong>原理：</strong><br>线程执行 await () 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await () 方法而在等待的线程才能继续执行</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34d25411ae97dcbd9bf972dc9b81c829.png"></p>
<p><strong>方法：</strong></p>
<ul>
<li><strong>await()</strong></li>
<li><strong>await(long timeout, TimeUnit unit)：</strong> 设置超时时间，超过该时间仍然还有线程还没到达屏障则忽略这些线程，将等待的线程全部释放</li>
</ul>
<p><strong>区别：</strong> CyclicBarrier 和 CountdownLatch 的区别是，CyclicBarrier 的计数器通过调用 reset () 方法可以 <strong>循环使用</strong>，所以它才叫做循环屏障</p>
<p><strong>构造器：</strong> CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会选择一个线程执行一次</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> {</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> {</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>重用：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(N);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Writer</span>(barrier).start();</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Writer</span>(barrier).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line"> </span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span>(BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Phaser"><a href="#3-Phaser" class="headerlink" title="3. Phaser"></a>3. Phaser</h2><p>main：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"p"</span> + i)).start();</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"新郎"</span>)).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"新娘"</span>)).start();</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Phaser：指定什么阶段做什么事</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ass MarriagePhaser <span class="keyword">extends</span> <span class="title class_">Phaser</span> {</span><br><span class="line">    <span class="comment">// phase: 阶段编号： registeredParties: 此阶段注册人数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAdvance</span><span class="params">(<span class="type">int</span> phase, <span class="type">int</span> registeredParties)</span> {</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (phase) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>run：如何到达阶段逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// doing something</span></span><br><span class="line">        <span class="comment">// 等待所有注册的线程全部到达后执行</span></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"新郎"</span>) || name.equals(<span class="string">"新娘"</span>)) {</span><br><span class="line">            System.out.printf(<span class="string">"%s 洞房！\n"</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 指定注销</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            phaser.arriveAndDeregister();</span><br><span class="line">            <span class="comment">//phaser.register()</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-ReadWriteLock"><a href="#4-ReadWriteLock" class="headerlink" title="4. ReadWriteLock"></a>4. ReadWriteLock</h2><p>StampedLock</p>
<ul>
<li>共享锁</li>
<li>排它锁 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5. Semaphore"></a>5. Semaphore</h2><p><strong>概述：</strong> Semaphore 类似于操作系统中的信号量，可以 <strong>控制对互斥资源的访问线程数</strong></p>
<p><strong>原理：</strong><br>acquire () 获取一个许可，如果没有就等待<br>release () 释放一个许可<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fcd57279bb6fbe23660b6fb53d4c0848.png"></p>
<p><strong>构造器：</strong></p>
<ul>
<li><strong>Semaphore(int permits)：</strong> 参数 permits 表示许可数目，即同时可以允许多少线程进行访问</li>
<li><strong> Semaphore(int permits, boolean fair)：</strong> 这个多了一个参数 fair 表示是否是公平的，即等待时间越久的越先获取许可</li>
</ul>
<p><strong>API：</strong></p>
<ul>
<li><strong>acquire()：</strong> 获取一个许可</li>
<li><strong> acquire(int permits)：</strong> 获取 permits 个许可</li>
<li><strong> release()：</strong> 释放一个许可</li>
<li><strong> release(int permits)：</strong> 释放 permits 个许可</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalRequestCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(clientCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalRequestCount; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-Exchanger"><a href="#6-Exchanger" class="headerlink" title="6. Exchanger"></a>6. Exchanger</h2><p>线程交换</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"T1"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 阻塞等待交换，交换后才能继续执行</span></span><br><span class="line">        s1 = exchanger.exchange(s1);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + s1);</span><br><span class="line">}, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"T2"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        s2 = exchanger.exchange(s2);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + s2);</span><br><span class="line">}, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// t1:T2</span></span><br><span class="line"><span class="comment">// t2:T1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-LockSupport"><a href="#7-LockSupport" class="headerlink" title="7. LockSupport"></a>7. LockSupport</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">            <span class="comment">// 停止当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">t.start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 继续执行</span></span><br><span class="line">LockSupport.unpark(t);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-CompletableFuture"><a href="#8-CompletableFuture" class="headerlink" title="8. CompletableFuture"></a>8. CompletableFuture</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sermonlizhi/article/details/123356877">CompletableFuture 使用详解</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c9dc192fa63">CompletableFuture 避坑 1—— 需要自定义线程池</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/339203275">使用 CompletableFuture 时，那些令人头疼的问题</a><br>管理多个线程运行后返回的结果</p>
<ul>
<li>allOf ()：所有任务全部完成才结束</li>
<li> anyOf ()：任意一个任务完成才结束 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; futureTM = CompletableFuture.supplyAsync(() -&gt; priceOfTM())</span><br><span class="line">    <span class="comment">// 对结果进行处理</span></span><br><span class="line">    .thenApply(String::valueOf)</span><br><span class="line">    .thenApply(str -&gt; <span class="string">"price "</span> + str)</span><br><span class="line">    .thenAccept(System.out::println);</span><br><span class="line">CompletableFuture&lt;Double&gt; futureTB = CompletableFuture.supplyAsync(() -&gt; priceOfTB());</span><br><span class="line">CompletableFuture&lt;Double&gt; futureJD = CompletableFuture.supplyAsync(() -&gt; priceOfJD());</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(futureTM, futureTB, futureJD).join();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环线程获取订单数</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">7</span>;</span><br><span class="line">List&lt;ReserveOrderCountVO&gt; resultList = Lists.newArrayListWithExpectedSize(totalCount);</span><br><span class="line">CompletableFuture[] completableFutures = Stream.iterate(<span class="number">0</span>, n -&gt; ++n).limit(totalCount)</span><br><span class="line">    .map(num -&gt; CompletableFuture.supplyAsync(() -&gt; <span class="built_in">this</span>.getReserveCountByDate(reserveCountQuery, now.plusDays(num)), COUNT_EXECUTOR)</span><br><span class="line">         .whenComplete((result, e) -&gt; resultList.add(result)))</span><br><span class="line">    .toArray(CompletableFuture[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞直到所有任务运行结束</span></span><br><span class="line">CompletableFuture.allOf(completableFutures).join();</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-AQS-源码"><a href="#9-AQS-源码" class="headerlink" title="9. AQS 源码"></a>9. AQS 源码</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/da9d051dcc3d">Java 技术之 AQS 详解</a></p>
<p>内部维护一个 state 和一个双向线程链表</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/37dad34951493ee77b1058a67e6356b0.png"></p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/82c79dff8f34a6e45717d561477e01ac.png"></p>
<ol>
<li>ReentrantLock#lock <ol>
<li><p>AbstractQueuedSynchronizer#compareAndSetState：CAS 把 state 从 0 变为 1，若成功则代表拿到锁 </p>
</li>
<li><p>AbstractOwnableSynchronizer#setExclusiveOwnerThread：若抢到锁，则设置当前线程为独占线程 </p>
</li>
<li><p>AbstractQueuedSynchronizer#acquire </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>ReentrantLock.NonfairSync#tryAcquire<br>  1. ReentrantLock.Sync#nonfairTryAcquire： </p>
<ul>
<li>state 为 0，则继续调用 compareAndSetState 抢锁（尝试把 state 变为 1，成功则接着调用 setExclusiveOwnerThread）</li>
<li>state 为 &gt; 0，且当前线程是独占访问的那个线程（说明锁重入），则 state++（此时 state 代表重入线程数）</li>
<li>否则 TryAcquire 失败</li>
</ul>
</li>
<li><p> TryAcquire 失败则调用 AbstractQueuedSynchronizer#addWaiter：使用 CAS 加入链表队列</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// jdk 9 使用 VarHandler.set(this, pred)。</span></span><br><span class="line">        <span class="comment">// VarHandler 内部有 CAS 的方法</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) {</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>jdk 9 使用 <code>VarHandler.set(this, pred)</code> 代替 <code>node.prev = pred;</code>，其调用 native 实现（相当于直接操纵二进制码），效率比反射高<br>VarHandler 指向一个变量  </p>
<pre><code>     1. AbstractQueuedSynchronizer#acquireQueued：加入队列后不断监听前一个节点，若前节点为头结点（已拿到锁），则试图去抢锁，成功则返回 false（不中断）
</code></pre>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CComma</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ccomma" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://ccomma.cn/page/9/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ccomma","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
