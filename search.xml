<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git flow</title>
    <url>/321db62aa323/</url>
    <content><![CDATA[<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f388a58466a12a9126440b2257c9781a.png"></p>
<h2 id="1-Master"><a href="#1-Master" class="headerlink" title="1. Master"></a>1. Master</h2><p>线上</p>
<h2 id="2-Develop"><a href="#2-Develop" class="headerlink" title="2. Develop"></a>2. Develop</h2><p>开发</p>
<h2 id="3-Feature"><a href="#3-Feature" class="headerlink" title="3. Feature"></a>3. Feature</h2><p>Feature 分支做完后，必须合并回 Develop 分支<br>合并完分支后一般会删点这个 Feature 分支，但是也可以保留</p>
<h2 id="4-Release"><a href="#4-Release" class="headerlink" title="4. Release"></a>4. Release</h2><p><em><strong>概述：</strong></em> 基于 Develop 分支创建，用于测试，修改 Bug<br><em><strong>创建：</strong></em> 一旦创建了 Release 分支之后，不要再从 Develop 分支上合并新的改动到 Release 分支<br><em><strong>发布：</strong></em> 发布 Release 分支时，合并 Release 到 Master 和 Develop， 同时在 Master 分支上打个 Tag 记住 Release 版本号，然后删除 Release 分支</p>
<h2 id="5-Hotfix"><a href="#5-Hotfix" class="headerlink" title="5. Hotfix"></a>5. Hotfix</h2><p>基于 Master 分支创建，开发完后需要合并回 Master 和 Develop 分支，同时在 Master 上打一个 tag</p>
<p>若有收获，就点个赞吧</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git 常用命令</title>
    <url>/b5a35826dc8c/</url>
    <content><![CDATA[<h2 id="1-提交和拉取"><a href="#1-提交和拉取" class="headerlink" title="1. 提交和拉取"></a>1. 提交和拉取</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂存所有文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂存并提交</span></span><br><span class="line">git commit -am</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">push 到远程 git</span></span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程 git 下拉到本地 git</span></span><br><span class="line">git pull</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h2 id="2-查看"><a href="#2-查看" class="headerlink" title="2. 查看"></a>2. 查看</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看不同</span></span><br><span class="line">git diff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看你的每一次命令</span></span><br><span class="line">git reflog</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-回退"><a href="#3-回退" class="headerlink" title="3. 回退"></a>3. 回退</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退上一次提交，保留暂存区</span></span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到指定版本</span></span><br><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-检出"><a href="#4-检出" class="headerlink" title="4. 检出"></a>4. 检出</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取暂存区文件到工作区</span></span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout branchName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建并检出分支</span></span><br><span class="line">git checkout -b dev  =&gt;  git branch dev   &amp;   git checkout dev</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-远程"><a href="#5-远程" class="headerlink" title="5. 远程"></a>5. 远程</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程库的信息</span></span><br><span class="line">git remote</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示了可以抓取和推送的 origin 的地址</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程地址</span></span><br><span class="line">git remote add origin git@github.com:xxxxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程 git 上 <span class="built_in">clone</span> 项目</span></span><br><span class="line">git clone git@github.com:xxxxx</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-分支"><a href="#6-分支" class="headerlink" title="6. 分支"></a>6. 分支</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 dev 分支</span></span><br><span class="line">git branch dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 dev 分支</span></span><br><span class="line">git branch -d dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强行删除 dev 分支</span></span><br><span class="line">git branch -D dev</span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-合并"><a href="#7-合并" class="headerlink" title="7. 合并"></a>7. 合并</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并 dev 分支到当前分支</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制禁用 Fast forward</span></span><br><span class="line">git merge --no-ff -m "merge branch 'dev' into master" dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变基</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较 git merge 合并整合得到的结果没有任何区别，但是通过 git rebase 衍合能产生一个更为整洁的提交历史。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把解决分支补丁同最新主干代码之间的冲突的责任，划转给由提交补丁的人来解决</span></span><br><span class="line">git rebase</span><br></pre></td></tr></tbody></table></figure>
<h2 id="8-暂存"><a href="#8-暂存" class="headerlink" title="8. 暂存"></a>8. 暂存</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加注释</span></span><br><span class="line">git stash save "message"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储列表</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用某个存储，不删除</span></span><br><span class="line">git stash apply</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个存储</span></span><br><span class="line">git stash drop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用并删除某个存储</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-标签"><a href="#9-标签" class="headerlink" title="9. 标签"></a>9. 标签</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建一个新的标签</span></span><br><span class="line">git tag v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对 <span class="built_in">id</span> 为 f52c633 的 commit 打标签</span></span><br><span class="line">git tag v0.9 f52c633</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除标签</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送标签</span></span><br><span class="line">git push origin v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送全部标签</span></span><br><span class="line">git push origin --tags</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程标签</span></span><br><span class="line">git push origin :refs/tags/v0.9</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有标签</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带有说明的标签</span></span><br><span class="line">git tag -a v0.1 -m "version 0.1 released" 1094adb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看标签信息</span></span><br><span class="line">git show v0.9</span><br></pre></td></tr></tbody></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000002783245">Git push 与 pull 的默认行为</a></li>
<li><a href="https://www.jianshu.com/p/4a8f4af4e803">rebase 用法小结</a></li>
<li><a href="https://blog.csdn.net/wh_19910525/article/details/7554489">merge&nbsp;和&nbsp;rebase&nbsp;间的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git 常用配置记录</title>
    <url>/2cf460af3028/</url>
    <content><![CDATA[<h2 id="1-配置用户名"><a href="#1-配置用户名" class="headerlink" title="1. 配置用户名"></a>1. 配置用户名</h2><p><code>git config --global user.name "username"</code></p>
<h2 id="2-配置邮箱"><a href="#2-配置邮箱" class="headerlink" title="2. 配置邮箱"></a>2. 配置邮箱</h2><p><code>git config --global user.email "xxxx@xxxx.xx"</code></p>
<span id="more"></span>
<h2 id="3-其他配置"><a href="#3-其他配置" class="headerlink" title="3. 其他配置"></a>3. 其他配置</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让 Git 不要管 Windows/Unix 换行符转换的事</span></span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-编码配置"><a href="#4-编码配置" class="headerlink" title="4. 编码配置"></a>4. 编码配置</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">避免 git gui 中的中文乱码</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">避免 git status 显示的中文文件名乱码</span></span><br><span class="line">git config --global core.quotepath off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让 git 对大小写敏感</span></span><br><span class="line">git config --global core.ignorecase false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置别名</span></span><br><span class="line">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>5. ssh key pair 配置</strong><br>SSH 是建立在应用层和传输层基础上的安全协议，其目的是专为远程登录会话和其他网络服务提供安全性的保障<br>SSH 密钥对可以让我们方便的登录到 SSH 服务器，而无需输入密码</p>
<ol>
<li>Windows 上 Git Bash 命令行窗口中输入：ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com">xxx@xxx.com</a>“</li>
<li>接着一直回车生成 ssh key pair</li>
<li><code>ssh-add ~/.ssh/id_rsa</code>    #把专用密钥添加到 ssh-agent 的高速缓存中，ssh-agent 能避免这种反复输入私钥的烦恼</li>
<li><code>cat ~/.ssh/id_rsa.pub</code></li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e1edcae107e0bcbb1f409d558e1434a1.png" alt="image.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/upshi/article/details/78327125">(10 条消息) Git 多 SSH 账号管理_一黑到底 - CSDN 博客_git 多 ssh</a></li>
<li><a href="https://www.cnblogs.com/popfisher/p/5731232.html">Windows 下 Git 多账号配置，同一电脑多个 ssh-key 的管理 - popfisher - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>ES 写入原理及调优</title>
    <url>/4216ce6ea7d2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？</p>
<p><strong>1. 解决写入问题</strong><br>心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。</p>
<p><strong>2. 学习架构设计思想</strong><br>这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。</p>
<p><strong>3. 应对面试</strong><br>虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题</p>
<p>常见的面试问题：</p>
<ul>
<li>你了解 ES 的写入原理吗</li>
<li>你了解文档的写入 / 删除过程吗</li>
<li>如何保证 ES 数据写入一致性</li>
<li>文档写入超时原因</li>
<li> ES 写入实时性如何去保证</li>
<li>数据量大时如何保证数据写入性能</li>
<li>如何提高数据检索能力</li>
</ul>
<span id="more"></span>
<h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h2><p>ES 中的数据写入均发生在主分片上。由于 ES 是分布式系统，实际接收到写入请求的节点可能是任意一台节点，这就需要将请求通过 routing 路由到具体主分片所在的节点，将数据写入该节点的主分片中，然后主分片再同步数据到其他节点的副分片中。<br>路由公式：<code>shard_num = hash(_routing) % num_primary_shards</code><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b20c17eb26dfc1a90e9433ae005a39e.jpeg"><br>具体流程：</p>
<ol>
<li>客户端发起写入请求至 node 4</li>
<li>node 4 通过文档 id 在路由表中的映射信息确定当前数据的位置为分片 0，分片 0 的主分片位于 node 5，并将数据转发至 node 5。</li>
<li>数据在 node 5 写入，写入成功之后将数据的同步请求转发至其副本所在的 node 4 和 node 6 上面，等待所有副本数据写入成功之后 node 5 将结果报告 node 4，并由 node 4 将结果返回给客户端，报告数据写入成功。</li>
</ol>
<h2 id="写一致性策略"><a href="#写一致性策略" class="headerlink" title="写一致性策略"></a>写一致性策略</h2><p>ES 5.x 之后，一致性策略由 <code>wait_for_active_shards</code> 参数控制：状态为 active 的主副分片数量达到设定阈值时才视为写入成功，才会返回数据给客户端。默认为 1，即只需要主分片写入成功，可设置为 <code>all</code> 或任何正整数，最大值为索引中的分片总数 (&nbsp;<code>number_of_replicas + 1</code> )。</p>
<p>如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间 30 秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。</p>
<p>执行索引操作时，分配给执行索引操作的主分片可能不可用。造成这种情况的原因可能是主分片当前正在从网关恢复或正在进行重定位。默认情况下，索引操作将在主分片上等待最多 1 分钟，然后才会失败并返回错误。</p>
<h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p>我们已经知道了宏观上的写入流程：先找到主节点，写入主节点后再同步到副节点。<br><strong>那 ES 是怎么把数据写入主节点和副节点中的呢？</strong></p>
<p>大家可能会有疑问，难道不是直接写入到磁盘吗？<strong>我们可以思考下，每次请求都直接写入到磁盘这种方式在高并发的场景下会消耗大量的 IO 资源，每次都要寻址然后写入磁盘。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba7282dc7f49c616767143d774646a3b.jpeg" alt="未命名文件.jpg"></p>
<p>对此我们可以用缓存来解决，即把数据写入系统缓存后，定期批量写入磁盘，同时缓存也提供检索服务。<br>而 Lucene 中索引是细分为多个 segment 的，segment 是索引中存储索引数据的内部存储元素，并且是不可变的。较小的 segment 会定期合并到较大的 segment 中，以控制索引大小。问题又来了：<strong>如果每次请求都创建一个新的 segment，那么会导致频繁的合并操作（merge）。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ec5aedd4c9bc6e805872b3f5944957a8.jpeg" alt="未命名文件.jpg"></p>
<p>所以 ES 在请求进入缓存之前先让请求进缓冲区（memory buffer），每秒或每 100 个缓存才会执行刷新操作（Refresh）把缓冲区中的数据创建 segment 写入系统缓存中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/10b375c43ff4ab15fe0c8ed7fa469f8e.jpeg" alt="未命名文件 (1).jpg"></p>
<p>至此这套批量持久化结构已经比较完善，但还有一个问题：<strong>缓存虽然提高了性能，但毕竟未持久化到磁盘，一旦系统出现故障数据就会丢失。</strong>ES 采用事务日志（translog）的方式解决此问题，当请求进来时会同时写入缓冲区和事务日志中，当服务重启后就会从事务日志中恢复数据到缓存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dcb5acedec3e2a0f97e678cd403a0eea.jpeg" alt="未命名文件 (1).jpg"></p>
<p>整体结构：</p>
<ul>
<li>Memory Buffer（缓冲区）：数据批量操作，高性能写入</li>
<li> Translog（事务日志）：保证数据写入安全性，防止丢失</li>
<li> OS Cache（内存）：保证数据高性能检索</li>
<li> OS Disk（磁盘）：保证数据持久化</li>
</ul>
<p>具体流程：</p>
<ol>
<li>客户端写入 Memory Buffer 缓冲区，并追加写入 Translog 事务日志（删除、写入…）以保证数据安全性。</li>
<li>Memory Buffer 达到阈值（100 条 / 1s）后执行 Refresh 操作生成 Segment 索引文件到系统缓存中。<ol>
<li>然后系统缓存会把该 Segment 标记为可被检索，因此数据有 1s 不可读的延迟。</li>
<li>Refresh 操作不能过于频繁，因此针对实时性不高的数据，可以配置 refresh 的间隔时间为 30s 一次。</li>
</ol>
</li>
<li>每个 Segment 都会消耗文件句柄、内存、CPU 运行周期，所以每隔一段时间会执行 Merge 操作，合并 Segment。<ol>
<li>Merge 操作发生在 JVM 中，频率过高会占用堆内存空间，所以 Refresh 的频率不能太高，否则会使 Merge 频率增高。</li>
<li>不合并 Segment 的影响：<ol>
<li>每个 Segment 占据的内存不会随着 GC 释放的。导致系统内存不足，进一步导致超时问题。</li>
<li>查询时会遍历每个 Segment，过多的 Segment 会导致查询速度下降。</li>
</ol>
</li>
</ol>
</li>
<li>执行 Flush 操作缓存写入 OS Disk（磁盘）并提交一次，并清空 Translog。<ol>
<li>系统缓存每隔 30 分钟、Translog 每隔 5 秒刷一次到磁盘中，所以默认情况下，可能会有 5s 数据丢失。</li>
<li>系统缓存和 Translog 写满时也会刷磁盘。</li>
</ol>
</li>
<li>断电等异常操作导致数据丢失时，服务重启后会读取 Translog 中的数据到缓存中，以完成回滚操作。</li>
</ol>
<p>相关参数：</p>
<ul>
<li>index.translog.durability：同步还是异步<ul>
<li> request：（默认）主副分片在每个请求后执行 fsync 和 commit，才会向客户端报告索引、删除、更新或批量请求的成功。如果发生崩溃，那么所有只要是已经确认的写操作都已经被提交到磁盘。</li>
<li>async：在后台每 index.translog.sync_interval 时间进行一次 fsync 和 commit。意味着如果发生崩溃，那么所有在上一次自动提交以后的已确认的写操作将会丢失。</li>
</ul>
</li>
<li>index.translog.sync_interval：translog 多久被同步到磁盘并提交一次。默认 5 秒。这个值不能小于 100ms。</li>
<li>index.translog.flush_threshold_size：translog 执行 flush 操作的空间最大阈值，默认 512 MB。</li>
</ul>
<h2 id="写入性能调优"><a href="#写入性能调优" class="headerlink" title="写入性能调优"></a>写入性能调优</h2><p>生产经常面临的写入可以分为两种情况：</p>
<ul>
<li>高并发：高频的创建 / 更新索引文档，一般发生在 C 端场景下</li>
<li>高吞吐：定期重建索引或批量更新文档数据，一般为 B 端场景</li>
</ul>
<p><strong>1. 提升写入吞吐量和并发</strong><br>ES 数据写入具有一定的延时性，这是为了减少频繁的索引文件产生。默认情况下 ES 每秒生成一个 segment 文件，当达到一定阈值的时候会执行 merge，merge 过程发生在 JVM 中，频繁的生成 segmen 文件可能会导致频繁的触发 FGC，导致 OOM。<br>为了避免避免这种情况，通常采取的手段是降低 segment 文件的生成频率，手段有两个，一个是增加时间阈值，另一个是增大 buffer 的空间阈值。</p>
<ol>
<li>增加 flush 时间间隔。Flush 是 IO 操作，很消耗性能，不能太频繁</li>
<li>增加 refresh_interval 的参数值<ol>
<li>目的是减少 segment 文件的创建，减少 segment 的 merge 次数。</li>
<li>merge 是发生在 JVM 中的，有可能导致 full GC，增加 refresh 会降低搜索的实时性。</li>
</ol>
</li>
<li>增加 buffer 大小<ol>
<li>减小 refresh 的时间间隔，因为导致 segment 文件创建的原因不仅有时间阈值，还有 buffer 空间大小，写满了也会创建。</li>
<li>默认最小值 48MB &lt; 默认值 JVM 空间的 10% &lt; 默认最大无限制</li>
</ol>
</li>
<li>关闭副本（提高单次吞吐）<ol>
<li>需要单次写入大量数据的时候，可以关闭副本（减少数据同步），暂停搜索服务，或选择在检索请求量谷值区间时间段来完成。因为副本的存在会导致主从之间频繁的进行数据同步，大大增加服务器的资源占用。</li>
<li>可通过则设置 index.number_of_replicas 为 0 以加快索引速度。没有副本意味着丢失单个节点可能会导致数据丢失，因此数据保存在其他地方很重要，以便在出现问题时可以重试初始加载。初始加载完成后，可以设置 index.number_of_replicas 改回其原始值。</li>
</ol>
</li>
<li>max_result_window 参数</li>
</ol>
<p>分页返回的最大数值，默认值为 10000。通过设定一个合理的阈值，避免初学者分页查询时由于单页数据过大而导致 OOM。</p>
<p><strong>2. 提高写入实时性（不推荐）</strong><br>在搜索引擎的业务场景下，用户一般并不需要那么高的写入实时性。有时这个延时的过程需要处理很多事情，比如信息需要后台审核。<br>可以提高 Memory Buffer 的 refresh 操作频率，但是过高的 refresh 会导致频繁 merge segment，会消耗更多堆内存、CPU 的资源。</p>
<h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><p>1. 避免单次召回大量数据<br>搜索引擎最擅长的事情是从海量数据中查询少量相关文档，而非单次检索大量文档。非常不建议动辄查询上万数据。如果有这样的需求，建议使用滚动查询。<br> <br>2. 避免单个文档过大<br>硬性限制：<br>鉴于默认 http.max_content_length 设置为 100MB，Elasticsearch 将拒绝索引任何大于该值的文档。可以增加该特定设置，但 Lucene 仍然有大约 2GB 的限制。<br> <br>大型文档对网络、内存使用和磁盘造成了更大的压力，即使对于不请求的搜索请求也是如此。<br> <br>3. 使用 filter 代替 query<br>query 是要对查询的每个结果计算相关性得分的，而 filter 不会。另外 filter 有相应的缓存机制，可以提高查询效率。<br> <br>4. 避免深度分页<br> <br>5. 使用 Keyword 类型<br>并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为查询优化数字字段，例如 integeror long。如果不需要范围查找，对于 term 查询而言，keyword 比 integer 性能更好。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index-modules-translog.html">Translog | Elasticsearch Guide [7.17] | Elastic</a></li>
<li><a href="https://blog.csdn.net/a645293829/article/details/132223065">【HBZ 分享】ES 索引分片的写入原理 及 流程</a></li>
</ul>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂 Mybatis</title>
    <url>/42e07de1eb46/</url>
    <content><![CDATA[<h1 id="一、配置-MyBatis（XML-形式）"><a href="#一、配置-MyBatis（XML-形式）" class="headerlink" title="一、配置 MyBatis（XML 形式）"></a>一、配置 MyBatis（XML 形式）</h1><p>src/main/resources/mybatis-config.xml：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载外部的properties文件，使用 ${jdbc.driver} 等形式注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给单独的实体起别名--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;typeAlias type="com.lagou.pojo.User" alias="user"&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--批量起别名：该包下所有的类的本身的类名：别名还不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"tk.mybatis.simple.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"UNPOOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="username" value="root"/&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;property name="password" value=""/&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;package name="tk.mybatis.simple.mapper"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"tk/mybatis/simple/mapper/CountryMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>


<span id="more"></span>
<h1 id="二、具体语句"><a href="#二、具体语句" class="headerlink" title="二、具体语句"></a>二、具体语句</h1><h2 id="1-Insert"><a href="#1-Insert" class="headerlink" title="1. Insert"></a>1. Insert</h2><p>insert 返回主键</p>
<h3 id="1-1-只适用于支持主键自增的数据库"><a href="#1-1-只适用于支持主键自增的数据库" class="headerlink" title="1.1. 只适用于支持主键自增的数据库"></a>1.1. 只适用于支持主键自增的数据库</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert2"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into sys_user(</span><br><span class="line">        user_name, user_password)</span><br><span class="line">    values(</span><br><span class="line">        #{userName}, #{userPassword})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2-使用-selectKey-返回主键的值"><a href="#1-2-使用-selectKey-返回主键的值" class="headerlink" title="1.2. 使用 selectKey 返回主键的值"></a>1.2. 使用 selectKey 返回主键的值</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert2"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into sys_user(</span><br><span class="line">        user_name, user_password)</span><br><span class="line">    values(</span><br><span class="line">        #{userName}, #{userPassword})</span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>Oracle：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> <span class="attr">result</span>=<span class="string">"long"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">    SELECT SEQ_ID.nextval from dual</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"tk.mybatis.simple.model.SysUser"</span>&gt;</span></span><br><span class="line">    select id,</span><br><span class="line">        user_name userName,</span><br><span class="line">        user_password userPassword</span><br><span class="line">    from sys_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用 resultType 需要设置别名来实现自动映射</p>
<h1 id="三、注解方式"><a href="#三、注解方式" class="headerlink" title="三、注解方式"></a>三、注解方式</h1><h2 id="1-Select-注解"><a href="#1-Select-注解" class="headerlink" title="1. @Select  注解"></a>1. @Select  注解</h2><h3 id="1-1-通过别名自动映射"><a href="#1-1-通过别名自动映射" class="headerlink" title="1.1. 通过别名自动映射"></a>1.1. 通过别名自动映射</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Select({"select id, role_name roleName ",</span></span><br><span class="line"><span class="meta">         "from sys_role ",</span></span><br><span class="line"><span class="meta">         "where id = #{id}"})</span></span><br><span class="line">SysRole <span class="title function_">selectById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select({"select id, role_name roleName </span></span><br><span class="line"><span class="meta">          from sys_role </span></span><br><span class="line"><span class="meta">          where id = #{id}"})</span></span><br><span class="line">SysRole <span class="title function_">selectById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2-使用-resultMap-方式"><a href="#1-2-使用-resultMap-方式" class="headerlink" title="1.2. 使用 resultMap 方式"></a>1.2. 使用 resultMap 方式</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 id，实现共用</span></span><br><span class="line"><span class="meta">@Results(id = "roleResultMap", value = {</span></span><br><span class="line"><span class="meta">    @Result(property = "id", column = "id", id = true),</span></span><br><span class="line"><span class="meta">    @Result(property = "roleName", column = "role_name")</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Results({</span></span><br><span class="line"><span class="meta">    @Result(property = "id", column = "id", id = true),</span></span><br><span class="line"><span class="meta">    @Result(property = "roleName", column = "role_name")</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="meta">@Select("select id, role_name from sys_role where id = #{id}")</span></span><br><span class="line">SysRole <span class="title function_">selectById2</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResultMap("roleResultMap")</span></span><br><span class="line"><span class="meta">@Select("select * from sys_role")</span></span><br><span class="line">List&lt;SysRole&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-insert-注解"><a href="#2-insert-注解" class="headerlink" title="2. @insert  注解"></a>2. <a href="/insert">@insert </a> 注解</h2><h3 id="2-1-返回自增主键"><a href="#2-1-返回自增主键" class="headerlink" title="2.1. 返回自增主键"></a>2.1. 返回自增主键</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Insert({"insert into sys_role(role_name)",</span></span><br><span class="line"><span class="meta">         "values(#{roleName})"})</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = "id")</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert2</span><span class="params">(SysRole sysRole)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-返回非自增主键"><a href="#2-2-返回非自增主键" class="headerlink" title="2.2. 返回非自增主键"></a>2.2. 返回非自增主键</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Insert({"insert into sys_role(role_name)",</span></span><br><span class="line"><span class="meta">         "values(#{roleName})"})</span></span><br><span class="line"><span class="meta">@SelectKey(statement = "SELECT LAST_INSERT_ID()",</span></span><br><span class="line"><span class="meta">           keyProperty = "id",</span></span><br><span class="line"><span class="meta">           resultType = Long.class,</span></span><br><span class="line"><span class="meta">           before = false)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert3</span><span class="params">(SysRole sysRole)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Provider-注解"><a href="#3-Provider-注解" class="headerlink" title="3. Provider 注解"></a>3. Provider 注解</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = PrivilegeProvider.class, metod = "selectById")</span></span><br><span class="line">SysPrivilege <span class="title function_">selectById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><em>PrivilegeProvider：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivilegeProvider</span> {</span><br><span class="line">    <span class="comment">// 直接返回字符串 sql 也行</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">selectById</span><span class="params">(<span class="keyword">final</span> Long id)</span> {</span><br><span class="line">        result <span class="keyword">new</span> <span class="title class_">SQL</span>() {</span><br><span class="line">            {</span><br><span class="line">                SELECT(<span class="string">"id, privilege_name, privilege_url"</span>);</span><br><span class="line">                FROM(<span class="string">"sys_privilege"</span>);</span><br><span class="line">                WHERE(<span class="string">"id = #{id}"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="四、动态SQL"><a href="#四、动态SQL" class="headerlink" title="四、动态SQL"></a>四、动态 SQL</h1><h2 id="1-if-用法"><a href="#1-if-用法" class="headerlink" title="1. if 用法"></a>1. if 用法</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">    and user_name like concat('%', #{userName}, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-choose-用法"><a href="#2-choose-用法" class="headerlink" title="2. choose 用法"></a>2. choose 用法</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwhise</span>&gt;</span><span class="tag">&lt;/<span class="name">otherwhise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-where-set-trim-用法"><a href="#3-where-set-trim-用法" class="headerlink" title="3. where set trim 用法"></a>3. where set trim 用法</h2><h3 id="3-1-where-用法"><a href="#3-1-where-用法" class="headerlink" title="3.1. where 用法"></a>3.1. where 用法</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">        and user_name like concat('%', #{userName}, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-set-用法"><a href="#3-2-set-用法" class="headerlink" title="3.2. set 用法"></a>3.2. set 用法</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByIdSelective"</span>&gt;</span></span><br><span class="line">    update sys_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">            user_name = #{userName},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userPassword != null and userPassword != ''"</span>&gt;</span></span><br><span class="line">            user_password = #{userPassword},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-trim-用法"><a href="#3-3-trim-用法" class="headerlink" title="3.3. trim 用法"></a>3.3. trim 用法</h3><p>where 标签对应 trim 的实现：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>set 标签对应的 trim 实现：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>prefix： 给内容增加 prefix 指定的前缀</li>
<li> prefixOverrides： 把内容中匹配的前缀字符串去掉</li>
<li> suffix： 给内容增加 suffix 指定的后缀</li>
<li> suffixOverrides： 把内容中匹配的后缀字符串去掉</li>
</ul>
<h2 id="4-foreach-用法"><a href="#4-foreach-用法" class="headerlink" title="4. foreach 用法"></a>4. foreach 用法</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"i"</span>&gt;</span></span><br><span class="line">    #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-bind-用法"><a href="#5-bind-用法" class="headerlink" title="5. bind 用法"></a>5. bind 用法</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null and userName != ''"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"userNameLike"</span> <span class="attr">value</span>=<span class="string">"'%' + userName + '%'"</span>/&gt;</span></span><br><span class="line">    and user_name like #{userNameLike}</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="五、高级结果映射"><a href="#五、高级结果映射" class="headerlink" title="五、高级结果映射"></a>五、高级结果映射</h1><h2 id="1-一对一映射"><a href="#1-一对一映射" class="headerlink" title="1. 一对一映射"></a>1. 一对一映射</h2><h3 id="1-1-使用自动映射"><a href="#1-1-使用自动映射" class="headerlink" title="1.1. 使用自动映射"></a>1.1. 使用自动映射</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserAndRoleById"</span> <span class="attr">resultType</span>=<span class="string">"tk.mybatis.simple.model.SysUser"</span>&gt;</span></span><br><span class="line">    select u.id, u.user_name as userName, u.user_password as userPassword, </span><br><span class="line">           r.id as "role.id", r.role_name as "role.roleName"</span><br><span class="line">    from sys_user u</span><br><span class="line">    inner join sys_user_role ur on u.id = ur.user_id</span><br><span class="line">    inner join sys_role r on ur.role_id = r.id</span><br><span class="line">    where u.id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2-使用-resultMap-配置一对一映射"><a href="#1-2-使用-resultMap-配置一对一映射" class="headerlink" title="1.2. 使用 resultMap 配置一对一映射"></a>1.2. 使用 resultMap 配置一对一映射</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userRoleMap"</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.simple.model.SysUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userPassword"</span> <span class="attr">column</span>=<span class="string">"user_password"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"role.id"</span> <span class="attr">column</span>=<span class="string">"role_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"role.roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-使用-resultMap-的-association-标签配置一对一映射"><a href="#1-3-使用-resultMap-的-association-标签配置一对一映射" class="headerlink" title="1.3. 使用 resultMap 的 association 标签配置一对一映射"></a>1.3. 使用 resultMap 的 association 标签配置一对一映射</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userRoleMap"</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.simple.model.SysUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"role"</span> <span class="attr">columnPrefix</span>=<span class="string">"role_"</span> <span class="attr">javaType</span>=<span class="string">"tk.mybatis.simple.model.SysRole"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-一对多映射"><a href="#2-一对多映射" class="headerlink" title="2. 一对多映射"></a>2. 一对多映射</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userRoleListMap"</span> <span class="attr">extends</span>=<span class="string">"userMap"</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.simple.model.SysUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userPassword"</span> <span class="attr">column</span>=<span class="string">"user_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"roleList"</span> <span class="attr">columnPrefix</span>=<span class="string">"role_"</span> <span class="attr">javaType</span>=<span class="string">"tk.mybatis.simple.model.SysRole"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-返回-Map"><a href="#3-返回-Map" class="headerlink" title="3.返回 Map"></a>3. 返回 Map</h2><h3 id="3-1-map-的-value-为-java-类"><a href="#3-1-map-的-value-为-java-类" class="headerlink" title="3.1. map 的 value 为 java 类"></a>3.1. map 的 value 为 java 类</h3><p>mapper.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@MapKey("id")</span></span><br><span class="line">Map&lt;Long, UserInfo&gt; <span class="title function_">getUserInfoMap</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>mapper.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserResultMap"</span> <span class="attr">type</span>=<span class="string">"com.xixicat.domain.UserInfo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserInfoMap"</span> <span class="attr">resultMap</span>=<span class="string">"UserResultMap"</span>&gt;</span></span><br><span class="line">   select id,username,sex from user_info</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-map-的-value-为-map"><a href="#3-2-map-的-value-为-map" class="headerlink" title="3.2. map 的 value 为 map"></a>3.2. map 的 value 为 map</h3><p>mapper.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@MapKey("id")</span></span><br><span class="line">Map&lt;Long, Map&lt;String,Object&gt;&gt; <span class="title function_">getUserValueMap</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>mapper.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserValueMap"</span> <span class="attr">resultType</span>=<span class="string">"map"</span> &gt;</span></span><br><span class="line">        select id,username,sex from user_info</span><br><span class="line">        from user_info</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-返回-List"><a href="#3-3-返回-List" class="headerlink" title="3.3. 返回 List<Map<key, value>>"></a>3.3. 返回 List&lt;Map&lt;key, value&gt;&gt;</h3><p>mapper.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">countInquireForMobile</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>mapper.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"countInquireForMobile"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select o.status as `status`, count(mc.id) as `count`</span><br><span class="line">    from mall_contract mc</span><br><span class="line">    join mall_order o on o.contract_no = mc.contract_no</span><br><span class="line">    where o.archive = false and o.flag = 0</span><br><span class="line">    and o.status in ('SUBMITTED', 'PAID', 'SHIPPED', 'SUCCESS') and o.refund_status = 'CREATE'</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"params.opUserType == 'BUYER'"</span>&gt;</span></span><br><span class="line">        and o.buyer_id = #{params.operatorId,typeHandler=idHandler}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"params.opUserType == 'SELLER'"</span>&gt;</span></span><br><span class="line">        and o.seller_id = #{params.operatorId,typeHandler=idHandler}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    group by o.status</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-鉴别器映射"><a href="#4-鉴别器映射" class="headerlink" title="4. 鉴别器映射"></a>4. 鉴别器映射</h2><p>类似于 switch</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"rolePrivilegeListMapChoose"</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.simple.model.SysRole"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">"enabled"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultMap</span>=<span class="string">"rolePrivilegeListMapSelect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-枚举处理器"><a href="#5-枚举处理器" class="headerlink" title="5. 枚举处理器"></a>5. 枚举处理器</h2><p>在 mybatis-config.xml 中添加配置：使用枚举的索引进行处理</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">"tk.mybatis.simple.type.Enabled"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">handler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-自定义处理器"><a href="#6-自定义处理器" class="headerlink" title="6. 自定义处理器"></a>6. 自定义处理器</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnabledTypeHandler</span> <span class="keyword">implements</span> <span class="title class_">TypeHanlder</span>&lt;Enabled&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Enabled&gt; enabledMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Enabled&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnabledTypeHandler</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (Enabled enabled : Enabled.values()) {</span><br><span class="line">            enabledMap.put(enabled.getValue(), enabled);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, </span></span><br><span class="line"><span class="params">        Enabled parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line"></span><br><span class="line">        ps.setInt(i, parameter.getValue());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enabled <span class="title function_">getResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> rs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> enabledMap.get(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enabled <span class="title function_">getResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> cs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> enabledMap.get(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 mybatis-config.xml 中配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">"tk.mybatis.simple.type.Enabled"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">handler</span>=<span class="string">"tk.mybatis.simple.type.EnabledTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="六、缓存"><a href="#六、缓存" class="headerlink" title="六、缓存"></a>六、缓存</h1><h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存"></a>1. 一级缓存</h2><p><strong><em>范围：</em></strong> SqlSession</p>
<p><strong><em>概述：</em></strong><br>MyBatis 的一级缓存存在于 SqlSession 的生命周期中，默认开启<br>在同一个 SqlSession 中查询时，MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个 Map 对象中</p>
<p><strong><em>清空缓存：</em></strong> 更新或删除操作会清空缓存，或使用 SqlSession#clearCache () 方法进行手动刷新</p>
<p><strong><em>flushCache=”true”：</em></strong> 查询数据前清空当前的一级缓存</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">flushCache</span>=<span class="string">"true"</span> <span class="attr">resultMap</span>=<span class="string">"userMap"</span>&gt;</span></span><br><span class="line">    select * from sys_user where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h2><p><strong><em>范围：</em></strong> Mapper(namespace)</p>
<p><strong><em>概述：</em></strong><br>默认不开启<br>会重新创建一个对象进行 copy<br>无法实现分布式缓存</p>
<h3 id="2-1-在-mapper-xml-中配置"><a href="#2-1-在-mapper-xml-中配置" class="headerlink" title="2.1. 在 mapper.xml 中配置"></a>2.1. 在 mapper.xml 中配置</h3><p>二级缓存全局开关： 不必配置，默认已为 true<br>mybatis-config.xml：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>开启二级缓存：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"tk.mybatis.simple.mapper.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认的二级缓存会有如下效果</p>
<ul>
<li>所有的 select 语句将会被缓存</li>
<li>所有的 insert、update、delete 语句将会刷新缓存</li>
<li>缓存会使用 LRU 算法来回收</li>
<li>根据时间表（刷新间隔），缓存不会以任何时间顺序刷新</li>
<li>缓存会存储集合或对象 1024 个引用</li>
<li>缓存会被视为 可读可写 的，所以返回的对象不是共享的，可以安全的修改</li>
</ul>
<p>cache 可配置的属性：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">size</span>=<span class="string">"512"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>eviction：收回策略</li>
<li> LRU（最近最少使用）：移除最长时间不被使用的对象，默认</li>
<li> FIFO（先进先出）：按对象进入缓存的顺序来移除它们</li>
<li> SOFT（软引用）：移除基于垃圾回收器状态和弱引用规则的对象</li>
<li> WEAK（弱引用）：更积极地移除基于垃圾收集器状态和弱引用规则的对象</li>
<li> flushInterval：刷新间隔。毫秒，默认不设置（没有刷新间隔，缓存仅在调用 sql 时刷新）。</li>
<li>size：引用数目。默认 1024</li>
<li>readOnly：只读。只读的缓存会给所有调用者返回缓存对象的相同实例，不能修改。默认 false</li>
</ul>
<h3 id="2-2-在-Mapper-接口中配置二级缓存"><a href="#2-2-在-Mapper-接口中配置二级缓存" class="headerlink" title="2.2. 在 Mapper 接口中配置二级缓存"></a>2.2. 在 Mapper 接口中配置二级缓存</h3><p><strong><em>当只使用注解方式配置二级缓存时：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleMapper</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><em>配置属性：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(</span></span><br><span class="line"><span class="meta">    eviction = FifoCache.class,</span></span><br><span class="line"><span class="meta">    flushInterval = 60000,</span></span><br><span class="line"><span class="meta">    size = 512,</span></span><br><span class="line"><span class="meta">    readWrite = true</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong><em>当同时使用注解方式和 &nbsp;XML 映射文件时：</em></strong> 使用参照缓存<br>这样就会使用命名空间为 tk.mybatis.simple.mapperRoleMapper 的缓存配置，即 RoleMapper.xml 中配置的缓存</p>
<p>引用 Mapp 接口中配置的二级缓存</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"tk.mybatis.simple.mapper.RoleMapper"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-使用二级缓存"><a href="#2-3-使用二级缓存" class="headerlink" title="2.3. 使用二级缓存"></a>2.3. 使用二级缓存</h3><p>使用可读写缓存，通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个 <strong>新的实例</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">sqlSession = getSqlSession();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 获取 RoleMapper 接口</span></span><br><span class="line">    <span class="type">RoleMapper</span> <span class="variable">roleMapper</span> <span class="operator">=</span> sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">    <span class="comment">// 调用 selectById 方法，查询 id = 1 的用户</span></span><br><span class="line">    <span class="type">SysRole</span> <span class="variable">role2</span> <span class="operator">=</span> roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 第二个 session 获取的用户名是 New Nam</span></span><br><span class="line">    Assert.assertEquals(<span class="string">"New Name"</span>, role2.getRoleName());</span><br><span class="line">    <span class="comment">// 这里的 role2 和前一个 session 查询的结果是两个不同的实例</span></span><br><span class="line">    Assert.assertNotEquals(role1, role2);</span><br><span class="line">    <span class="comment">// 获取 role3</span></span><br><span class="line">    <span class="type">SysRole</span> <span class="variable">role3</span> <span class="operator">=</span> roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 这里的 role2 和 role3 是两个不同的实例</span></span><br><span class="line">    Assert.assertNotEquals(role2, role3);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="comment">// 关闭 sqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4-二级缓存适用场景"><a href="#2-4-二级缓存适用场景" class="headerlink" title="2.4. 二级缓存适用场景"></a>2.4. 二级缓存适用场景</h3><ul>
<li>以查询为主的应用中，只有尽可能少的 curd</li>
<li> 绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据</li>
<li>分布式场景不能使用，需要借助第三方缓存中间件</li>
</ul>
<h3 id="2-5-使用-redis-实现二级缓存"><a href="#2-5-使用-redis-实现二级缓存" class="headerlink" title="2.5. 使用 redis 实现二级缓存"></a>2.5. 使用 redis 实现二级缓存</h3><ol>
<li><p>加入依赖 </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>使用缓存 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(implementation = RedisCache.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserMapper</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="七、插件"><a href="#七、插件" class="headerlink" title="七、插件"></a>七、插件</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>对 mybatis 的扩展，其原理是拦截器，在四大组件（<code>Executor</code>、<code>StatementHandler</code>、<code>ParamterHandler</code>、<code>ResultSetHandler</code>）使用时拦截处理</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3bcdaa2f4207b968a1d3ad28bf5504a.png" alt="image.png"></p>
<p><strong><em>允许拦截的方法：</em></strong></p>
<ul>
<li>Executor（执行器）：update、query、commit、rollback</li>
<li>StatementHandler（SQL 语句构建器）：prepare、parameterize、batch、update、query</li>
<li>ParameterHandler（参数处理器）：getParameterObject、setParameters</li>
<li>ResultSetHandler（结果集处理器）：handleResultSets、handleOutputParameters</li>
</ul>
<p><strong><em>原理：</em></strong><br>在四大组件对象创建时遍历所有的拦截器，每个拦截器都使用 interceptor.plugin (target) 方法对目标类进行增强</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ParameterHandler <span class="title function_">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object object, BoundSql sql, InterceptorChain interceptorChain)</span> {</span><br><span class="line">    <span class="type">ParameterHandler</span> <span class="variable">parameterHandler</span> <span class="operator">=</span> mappedStatement.getLang().createParameterHandler(mappedStatement,object,sql); </span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler); </span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> { </span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) { </span><br><span class="line">        target = interceptor.plugin(target);</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-自定义插件"><a href="#2-自定义插件" class="headerlink" title="2. 自定义插件"></a>2. 自定义插件</h2><ol>
<li><p>实现 Interceptor 并添加注解</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts({</span></span><br><span class="line"><span class="meta">    @Signature(</span></span><br><span class="line"><span class="meta">        // 指定组件</span></span><br><span class="line"><span class="meta">        type = Executor.class,</span></span><br><span class="line"><span class="meta">        // 指定方法</span></span><br><span class="line"><span class="meta">        method = "query",</span></span><br><span class="line"><span class="meta">        // 指定参数确定方法</span></span><br><span class="line"><span class="meta">        args = {MapperStatement.class, Object.class, RowBounds.class, ResultHandler.class}</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> {</span><br><span class="line">    <span class="comment">// 每次操作都会进入该方法</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        System.out.println(<span class="string">"对方法进行了增强...."</span>); </span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把这个拦截器生成一个代理放到拦截器链中</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> { </span><br><span class="line">        System.out.println(<span class="string">"将要包装的目标对象"</span> + target);</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件初始化时调用一次，获取配置的属性，如下：&lt;name, Bob&gt;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> { </span><br><span class="line">        System.out.println(<span class="string">"初始化参数"</span> + properties);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>配置到配置文件中</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.xxx.plugin.ExamplePlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Bob"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ②：内存加载过程</title>
    <url>/17b2c6107a38/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/be76fa729422f94da885b3affcb0e043.png"></h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2193f9400d40e164fc7a3c65bbf78a18.png"></p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>内存数据放入高速缓存中时是以缓存行的形式放入的，多数情况把内存中连续的 64 字节的数据作为一个缓存行加入高速缓存，不会只单独放入几个字节的数据</p>
<p><strong>伪共享问题：</strong> 位于同一缓存行的两个不同数据，被两个不同 CPU 锁定，产生互相影响的伪共享问题</p>
<p>缓存行对齐</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheLinePadding</span> {</span><br><span class="line">    <span class="comment">// 加上 padding，使 arr[0] 和 arr[1] 在两个不同的缓存行中</span></span><br><span class="line">    <span class="comment">// 使运行速度提升</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start) / <span class="number">100_0000</span> + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>缓存锁：</strong> MESI<br><a href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU 缓存一致性协议</a></p>
<p><strong>总线锁：</strong> 有些无法被缓存的数据或者跨越多个缓存行的数据还是得使用总线锁</p>
<span id="more"></span>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><blockquote>
<p>验证 <strong>JVM/jmm/Disorder.java</strong><br><a href="https://www.cnblogs.com/liushaodong/p/4777308.html">现代 cpu 的合并写技术对程序的影响</a></p>
</blockquote>
<p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，慢 100 倍），去同时执行另一条指令，前提是两条指令没有依赖关系</p>
<ul>
<li>读指令的同时可以执行不影响的其他指令 </li>
<li>写指令的同时可以进行合并写<br>WCBuffers（Write Combining Buffers），只能存放 4 字节的数据。用于写指令合并缓存。 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WriteCombining</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITEMS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayA = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayB = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayC = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayD = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayE = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayF = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseOne</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseTwo</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>如何保证不重排：</strong></p>
<ul>
<li>CPU 内存屏障（硬件方面实现）：Inter X86 <ul>
<li>sfence：在 sfence 指令前的写操作必须在 sfence 指令后的写操作前完成</li>
<li> lfence：在 lfence 指令前的读操作必须在 lfence 指令后的读操作前完成</li>
<li> mfence：在 mfence 指令前的写操作必须在 mfence 指令后的读操作前完成</li>
</ul>
</li>
<li> CPU lock 原子汇编指令（硬件方面实现）：Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个 CPU </li>
<li>JVM 规范（JSR 133）：依赖于硬件实现 <ul>
<li><p>LoadLoad 屏障：<br>保证读操作 Load1 先于读操作 Load2 执行 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>StoreStore 屏障：<br>保证写操作 Store1 先于写操作 Store2 执行</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>LoadStore 屏障：<br>保证读操作 Load1 先于写操作 Store2 执行 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>StoreLoad 屏障：<br>保证写操作 Store1 先于读操作 Load2 执行 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="volatile-实现细节"><a href="#volatile-实现细节" class="headerlink" title="volatile 实现细节"></a>volatile 实现细节</h2><ol>
<li><p>字节码层面：<code>ACC_VOLATILE</code> 编码 </p>
</li>
<li><p>JVM 层面： </p>
</li>
<li><p>写操作</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">StoreStore 屏障</span><br><span class="line">volatile 写操作</span><br><span class="line">StoreLoad 屏障</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>读操作 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">LoadLoad 屏障</span><br><span class="line">volatile 读操作</span><br><span class="line">LoadStore 屏障</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>OS 和硬件层面：<br><a href="https://blog.csdn.net/qq_26222859/article/details/52235930">volatile 与 lock 前缀指令</a></p>
</li>
</ol>
<h2 id="synchronized-实现细节"><a href="#synchronized-实现细节" class="headerlink" title="synchronized 实现细节"></a>synchronized 实现细节</h2><ol>
<li><p>字节码层面<br>ACC_SYNCHRONIZED </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">; 加锁</span><br><span class="line">monitorenter</span><br><span class="line">...</span><br><span class="line">; 释放锁</span><br><span class="line">monitorexit</span><br><span class="line">...</span><br><span class="line">; 异常后释放锁</span><br><span class="line">monitorexit</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>JVM 层面<br>C C++ 调用了操作系统提供的同步机制 </p>
</li>
<li><p>OS 和硬件层面<br>X86 : lock cmpxchg / xxx<br><a href="https://blog.csdn.net/21aspnet/article/details/88571740">Java 使用字节码和汇编语言同步分析 volatile，synchronized 的底层实现</a></p>
</li>
</ol>
<h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9955c75af53f7c91f9e8c5281104a60a.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ①：类加载过程</title>
    <url>/a5a1f97e57aa/</url>
    <content><![CDATA[<h1 id="Java-从编码到执行"><a href="#Java-从编码到执行" class="headerlink" title="Java 从编码到执行"></a>Java 从编码到执行</h1><ul>
<li>-Xmixed：混合模式<ul>
<li>使用解释器 + 热点代码编译</li>
<li>起始阶段采用解释执行</li>
<li>热点代码检测<ul>
<li>多次被调用的方法（使用 <em>方法计数器</em> 检测方法执行频率）</li>
<li>多次被调用的循环（使用 <em>循环计数器</em> 检测循环执行频率）</li>
<li>进行编译</li>
</ul>
</li>
</ul>
</li>
<li> -Xint：解释模式，启动快，执行慢</li>
<li> -Xcomp：编译模式，启动慢，执行快</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2156c7988772301af2598f85978aa973.png"></p>
<span id="more"></span>
<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p>Class 文件实际上是二进制字节流，JVM 定义了一系列规范，用把 Class 文件 “翻译” 成 Class 类</p>
<blockquote>
<p>逻辑上划分的数据类型：u1（1 字节）、u2（2 字节）、u4（4 字节）、u8（8 字节）和 _info（表类型）<br>_info 的来源是 hotspot 源码中的写法</p>
</blockquote>
<h2 id="1-查看-16-进制字节码"><a href="#1-查看-16-进制字节码" class="headerlink" title="1. 查看 16 进制字节码"></a>1. 查看 16 进制字节码</h2><p>.java 文件使用 javac 命令进行编译后得到 .class 文件<br>可以使用 BinEd（IDEA 插件）查看 .class 文件的 16 进制字节码</p>
<p><strong>ByteCode 类：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCode</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对应 .class 文件的编码：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/600850a2b74ea516c0548bee82ae4c57.png"></p>
<h2 id="2-Class-文件构成"><a href="#2-Class-文件构成" class="headerlink" title="2. Class 文件构成"></a>2. Class 文件构成</h2><p>使用 JClassLib（IDEA 插件）查看 ByteCode<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5e68f176c036bb3d9a344731d4918cf3.png"></p>
<p><strong>classfile 构成：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9c7016ea0849b42824754e2c05d703be.png" alt="image.png"></p>
<p>对应关系<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bac8a4b6e7bb96e91703b27431068d94.png"></p>
<p>常量：</p>
<ul>
<li>常量池 #1 号标记： <ul>
<li>标记位 07（1 字节），表明了常量类型</li>
<li>索引 00 0e（2 字节），代表指向常量池 #14 号标记</li>
</ul>
</li>
</ul>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类是在 <strong>运行期间第一次使用</strong> 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d695b8e008fc69af9f5abbbd1bdb687f.png"></p>
<p>loadClass () 中实现了双亲委派机制，委托给父加载器去执行，父加载器没找到则会调用自己的 findClass () 去找</p>
<ul>
<li>自定义类加载器：重写 findClass () </li>
<li>打破双亲委派机制：重写 loadClass ()</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ③：对象布局</title>
    <url>/bb934922f9ae/</url>
    <content><![CDATA[<p>关于对象面试题：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/76e9ee5cde5f219f62feda2b7c010e0c.png"></p>
<span id="more"></span>
<h2 id="对象大小（64位机）"><a href="#对象大小（64位机）" class="headerlink" title="对象大小（64位机）"></a>对象大小（64 位机）</h2><h3 id="观察虚拟机配置"><a href="#观察虚拟机配置" class="headerlink" title="观察虚拟机配置"></a>观察虚拟机配置</h3><p>java -XX:+PrintCommandLineFlags -version<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ce5fe8a059aadf88a5d2c234b794c466.png"></p>
<h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><ol>
<li>对象头：markword &nbsp;8 字节</li>
<li> ClassPointer 指针：-XX:+UseCompressedClassPointers 压缩打开为 4 字节，不开启为 8 字节</li>
<li>实例数据 <ol>
<li>引用类型：-XX:+UseCompressedOops 为 4 字节 不开启为 8 字节<br>Oops Ordinary Object Pointers</li>
</ol>
</li>
<li>Padding 对齐，8 的倍数</li>
</ol>
<h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><ol>
<li>对象头：markword 8 字节</li>
<li> ClassPointer 指针同上</li>
<li>数组长度：4 字节</li>
<li>数组数据</li>
<li>对齐 8 的倍数</li>
</ol>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.jvm.agent.ObjectSizeAgent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -XX:+UseCompressedClassPointers：类型指针压缩</span></span><br><span class="line"><span class="comment">// -XX:+UseCompressedOops：对象引用指针压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T03_SizeOfAnObject</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">Object</span>())); <span class="comment">// 16=8+4+4(补齐)</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">int</span>[] {})); <span class="comment">// 16=8+4+4</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">P</span>()));      <span class="comment">// 32</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P</span> {</span><br><span class="line">        				<span class="comment">//8 _markword</span></span><br><span class="line">        				<span class="comment">//4 _class pointer -XX:+UseCompressedClassPointers</span></span><br><span class="line">        <span class="type">int</span> id;         <span class="comment">//4</span></span><br><span class="line">        String name;    <span class="comment">//4 _oops pointer -XX:+UseCompressedOops</span></span><br><span class="line">        <span class="type">int</span> age;        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> b1;        <span class="comment">//1</span></span><br><span class="line">        <span class="type">byte</span> b2;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        Object o;       <span class="comment">//4</span></span><br><span class="line">        <span class="type">byte</span> b3;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1f48821968af3f61ba2549ad0f182ab2.png"></p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5867b24cf62e22bcb9419dd6188048a3.png"></p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/308846f67dd99e4a10150ab5100777a1.png"></p>
<h2 id="IdentityHashCode"><a href="#IdentityHashCode" class="headerlink" title="IdentityHashCode"></a>IdentityHashCode</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/48af01c10aa17ee76bb5d6d57bfb5ef6.png"></p>
<p><a href="https://cloud.tencent.com/developer/article/1480590">死磕 Synchronized 底层实现，面试你还怕什么？</a><br><a href="https://cloud.tencent.com/developer/article/1484167">面试题深入解析：Synchronized 底层实现</a><br><a href="https://cloud.tencent.com/developer/article/1485795">死磕 Synchronized 底层实现 – 重量级锁</a><br><a href="https://cloud.tencent.com/developer/article/1482500">一文让你读懂 Synchronized 底层实现，秒杀面试官</a></p>
<h2 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h2><p><a href="https://blog.csdn.net/clover_lily/article/details/80095580">访问对象两种方式 – 句柄和直接指针</a></p>
<ol>
<li>句柄池</li>
<li>直接指针</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ⑤：垃圾回收 GC</title>
    <url>/703024019fe3/</url>
    <content><![CDATA[<p><a href="https://my.oschina.net/wenbo123/blog/1822414">深入学习 JVM-JVM 安全点和安全区域</a><br>垃圾收集主要是针对 <strong>堆</strong> 和 <strong>方法区</strong> 进行<br>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收</p>
<blockquote>
<p>简历：熟悉 GC 常用算法，熟悉常见垃圾回收器，具有实际 JVM 调优实战经验</p>
</blockquote>
<span id="more"></span>
<h2 id="1-定位垃圾"><a href="#1-定位垃圾" class="headerlink" title="1. 定位垃圾"></a>1. 定位垃圾</h2><h3 id="引用计数算法（ReferenceCount）"><a href="#引用计数算法（ReferenceCount）" class="headerlink" title="引用计数算法（ReferenceCount）"></a>引用计数算法（ReferenceCount）</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p><strong>缺点：</strong> 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。<br>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可达性分析算法（RootSearching）"><a href="#可达性分析算法（RootSearching）" class="headerlink" title="可达性分析算法（RootSearching）"></a>可达性分析算法（RootSearching）</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/08d4fb7079a7b5bf5d49229fa194f19a.png"></p>
<p><strong>GC Roots 一般包含以下内容：</strong></p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h2 id="2-常见的垃圾回收算法"><a href="#2-常见的垃圾回收算法" class="headerlink" title="2. 常见的垃圾回收算法"></a>2. 常见的垃圾回收算法</h2><h3 id="2-1-标记清除（mark-sweep）："><a href="#2-1-标记清除（mark-sweep）：" class="headerlink" title="2.1. 标记清除（mark sweep）："></a>2.1. 标记清除（mark sweep）：</h3><p>将存活的对象进行标记，然后清理掉未被标记的对象<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c095fbf1f48f934ef8424d74398aab4.png"></p>
<p><strong>扫描两次：</strong></p>
<ol>
<li>一次扫描先标记存活对象</li>
<li>再一次扫描清除未被标记对象</li>
</ol>
<p><strong>缺点：</strong> 扫描两次，位置不连续，产生碎片<br>存活对象比较多的情况下效率较高</p>
<h3 id="2-2-拷贝算法（copying）"><a href="#2-2-拷贝算法（copying）" class="headerlink" title="2.2. 拷贝算法（copying）"></a>2.2. 拷贝算法（copying）</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a89f8c7f688fa4599fa66e948ed90104.png"></p>
<p>缺点：需移动对象，浪费空间<br>优点：扫描一次，没有碎片<br>适用于存活对象比较少的情况</p>
<h3 id="2-3-标记压缩（mark-compact）"><a href="#2-3-标记压缩（mark-compact）" class="headerlink" title="2.3. 标记压缩（mark compact）"></a>2.3. 标记压缩（mark compact）</h3><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fc77038fc65575fc5cf760615ebd1b06.png"></p>
<p>缺点：扫描两次，需移动对象，效率低下<br>优点：没有碎片，方便对象分配，不会产生内存减半</p>
<h3 id="2-4-分代收集"><a href="#2-4-分代收集" class="headerlink" title="2.4. 分代收集"></a>2.4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p>
<ul>
<li><strong>新生代使用：</strong> 复制算法</li>
<li><strong>老年代使用：</strong> <em>标记 - 清除</em> 或者 <em>标记 - 整理</em> 算法</li>
</ul>
<blockquote>
<p>除 Epsilon ZGC Shenandoah 之外的 GC 都是使用逻辑分代模型<br>G1 是逻辑分代，物理不分代<br>除此之外的不仅逻辑分代，而且物理分代</p>
</blockquote>
<h2 id="3-常见的垃圾回收器"><a href="#3-常见的垃圾回收器" class="headerlink" title="3. 常见的垃圾回收器"></a>3. 常见的垃圾回收器</h2><p><strong>Card Table</strong><br>由于做 YGC 时，需要扫描整个 OLD 区，效率非常低，所以 JVM 设计了 CardTable， 如果一个 OLD 区 CardTable 中有对象指向 Y 区，就将它设为 Dirty，下次扫描时，只需要扫描 Dirty Card<br>在结构上，Card Table 用 BitMap 来实现</p>
<p><strong>垃圾回收器：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/74a7af57d6561629a8c202ad2ea7052a.png"></p>
<p>连线表示垃圾收集器可以配合使用</p>
<p><strong>垃圾收集器跟内存大小的关系：</strong></p>
<ol>
<li>Serial 几十兆</li>
<li> PS 上百兆 - 几个 G</li>
<li>CMS - 20G</li>
<li>G1 - 上百 G</li>
<li>ZGC - 4T - 16T（JDK13）</li>
</ol>
<p><strong>STW：</strong> stop the world。指 GC 中让用户线程全部暂停而产生的停顿。任何一个垃圾回收器都有 STW，减少 STW 能提升用户响应时间，但也会减少吞吐量。</p>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3039c3437ef855d43e0b0d97f9cc5906.png"><br>用于收集年轻代垃圾的收集器，只会使用 <strong>一个 GC 线程</strong> 进行垃圾收集工作。</p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ed4141deb669e0bb7e36cb996893124b.png"></p>
<p>用于收集年轻代垃圾的收集器，使用多个 GC 线程收集垃圾</p>
<p>关注吞吐量，目标是 <strong>达到一个可控制的吞吐量</strong>，它被称为 “吞吐量优先” 收集器</p>
<ul>
<li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务</li>
<li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</li>
</ul>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>用于收集年轻代垃圾的收集器。新版本的 Parallel Scavenge，与其相比做了增强以便能与 CMS 配合使用</p>
<p><a href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p>
<ul>
<li>ParNew 响应时间优先（配合 CMS）</li>
<li>Parallel Scavenge 吞吐量优先</li>
</ul>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>用于收集老年代垃圾的收集器。Serial 收集器的老年代版本。</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用（效率低下）</li>
</ul>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>用于收集老年代垃圾的收集器。Parallel Scavenge 收集器的老年代版本。</p>
<h3 id="ConcurrentMarkSweep"><a href="#ConcurrentMarkSweep" class="headerlink" title="ConcurrentMarkSweep"></a>ConcurrentMarkSweep</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0056bba0a475211847be07f38ad4aa89.png"></p>
<p>用于收集老年代垃圾的收集器。垃圾回收和应用程序同时运行，降低 STW 的时间。</p>
<p><strong>流程：</strong><br>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p>
<ol>
<li><strong>初始标记：</strong> 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</li>
<li><strong>并发标记：</strong> 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿</li>
<li><strong>重新标记：</strong> 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li>
<li><strong>并发清除：</strong> 不需要停顿</li>
</ol>
<p><strong>CMS 的问题：</strong><br>CMS 问题比较多，所以现在没有一个版本默认是 CMS，只能手工指定<br>CMS 既然是 MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS 的老年代分配对象分配不下的时候，使用 SerialOld 进行老年代回收</p>
<ul>
<li><em>吞吐量低：</em> 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高 </li>
<li><em>无法处理浮动垃圾：</em> </li>
<li><ul>
<li><em>浮动垃圾：</em> 指并发清除阶段由于用户线程继续运行而产生的垃圾。这部分垃圾只能到下一次 GC 时才能进行回收 </li>
<li><em>需预留内存：</em> 由于浮动垃圾的存在，因此需要预留出一部分内存。这意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收 </li>
<li><em>Concurrent Mode Failure：</em> 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS </li>
<li>解决方案：<br>降低触发 CMS 的阈值<br>–XX:CMSInitiatingOccupancyFraction 92%：内存打到 92% 时才会触发 CMS。可以降低这个值，让 CMS 保持老年代足够的空间</li>
</ul>
</li>
<li><em>空间碎片：</em> 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为 0 指的是经过多少次 FGC 才进行压缩</li>
</ul>
<p>算法：三色标记 + Incremental Update</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>特点：</strong></p>
<ul>
<li>并发收集</li>
<li>压缩空间，不会延长 GC 的暂停时间</li>
<li>更容易预测 GC 的暂停时间</li>
<li>适用不需要实现很高吞吐量的场景</li>
<li>每个内存区域不是固定的，可能这次存放新生代下次就存放老年代了</li>
<li>新老年代比例： 5%-60%。不用手工指定，G1 以此作为预测停顿时间的基准</li>
</ul>
<p>Edne、Survivor、Old、Humongous（超过单个 Region 的 50%）<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/01c373df0cb413e396b0d02b559fd50d.png"></p>
<p><strong>CSet（Collection Set）：</strong></p>
<ul>
<li>一组可被回收的分区的集合 </li>
<li>在 CSet 中存活的数据会在 GC 过程中被移动到另一个可用分区 </li>
<li>CSet 中的分区可以来自 Eden 空间、Survivor 空间或老年代 </li>
<li>CSet 占用不到整个堆空间的 1% 大小</li>
</ul>
<p><strong>RSet（Remembered Set）：</strong></p>
<ul>
<li>是一块存放在 Region 内部的 Map，记录了其他 Region 中的对象到本 Region 的引用</li>
<li>使垃圾回收器不用去扫描整个堆来获取引用了当前分区的对象，只需要扫描 RSet 即可</li>
</ul>
<p><strong>当对象无法分配时也会产生 FullGC，如何解决：</strong></p>
<ul>
<li>扩内存 </li>
<li>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大） </li>
<li>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是 45%） <blockquote>
<p>MixedGC：类似 CMS<br>XX:InitiatingHeapOccupacyPercent</p>
<ul>
<li>默认值 45%</li>
<li> 当分配堆空间超过这个值，启动 MixedGC</li>
</ul>
</blockquote>
</li>
</ul>
<p>算法：三色标记 + SATB<br><strong>三色标记：</strong></p>
<ul>
<li>黑色：自身和成员变量均已标记完成</li>
<li>灰色：自身被标记，成员变量未被标记</li>
<li>白色：未被标记的对象</li>
</ul>
<p><strong>漏标：</strong><br>当一个黑色的对象引用了一个白色对象，且这个白色对象只被这个黑色对象引用时会漏标<br>该白色对象已无法被遍历到了</p>
<p><strong>解决漏标的方案：</strong></p>
<ul>
<li>Incremental update：关注引用的增加。黑色的对象引用白色对象时把黑色对象重新标记为灰色，下次重新扫描属性，CMS 使用</li>
<li> SATB（snapshot at the beginning）：关注引用的删除。当引用消失时把这个引用推到 GC 的堆栈，保证引用的对象还能被 GC 扫描到。</li>
</ul>
<p>G1 使用 SATB，Incremental update 把黑色对象变为灰色对象后，后续还得对其成员变量进行扫描，效率不高。<br>SATB 配合 RSet 判断记录的白色对象是否为漏标对象<br><a href="https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html">垃圾优先型垃圾回收器调优</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>ZGC (1ms) PK C++<br>算法：ColoredPointers + LoadBarrier </li>
<li>Shenandoah<br>算法：ColoredPointers + WriteBarrier </li>
<li>Epsilon</li>
</ol>
<h2 id="4-常见垃圾回收器组合"><a href="#4-常见垃圾回收器组合" class="headerlink" title="4. 常见垃圾回收器组合"></a>4. 常见垃圾回收器组合</h2><ul>
<li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old：小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器 </p>
</li>
<li><p>-XX:+UseParNewGC = ParNew + SerialOld：这个组合已经很少用（在某些版本中已经废弃） </p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future">Why Remove support for ParNew+SerialOld and	DefNew+CMS in the future？</a></p>
</blockquote>
</li>
<li><p>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old </p>
</li>
<li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8 默认) 【PS + SerialOld】 </p>
</li>
<li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old </p>
</li>
<li><p>-XX:+UseG1GC = G1</p>
</li>
</ul>
<p>Linux 中没找到默认 GC 的查看方法，而 windows 中会打印 UseParallelGC</p>
<ul>
<li>java +XX:+PrintCommandLineFlags -version</li>
<li> 通过 GC 的日志来分辨</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ④：JVM 结构</title>
    <url>/291701d89b2f/</url>
    <content><![CDATA[<h1 id="JVM-组成"><a href="#JVM-组成" class="headerlink" title="JVM 组成"></a>JVM 组成</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7262d675db05948b1465f1a2a9357640.png"></p>
<p><strong>JVM 的结构基本上由 4 部分组成：</strong></p>
<ul>
<li>_类加载器：_在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</li>
<li>_运行时数据区：_将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块</li>
<li><strong>执行引擎：</strong>执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</li>
<li><strong> 本地方法调用：</strong>调用 C 或 C++ 实现的本地方法的代码返回结果</li>
</ul>
<span id="more"></span>
<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6c3857d9b048e4cc8a8885bdb6a24cb5.png"></p>
<h2 id="PC-程序计数器"><a href="#PC-程序计数器" class="headerlink" title="PC 程序计数器"></a>PC 程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）<br>用于存放指令位置<br>虚拟机的运行，类似于这样的循环：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (not end) {</span><br><span class="line"></span><br><span class="line">	取 PC 中的位置，找到对应位置的指令；</span><br><span class="line"></span><br><span class="line">	执行该指令；</span><br><span class="line"></span><br><span class="line">	PC ++;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><a href="https://blog.csdn.net/jt781861965/article/details/114957201?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">变量定义在 for 循环外面还是里面</a></li>
</ul>
<p>Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息<br>从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p>
<p><strong>栈结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6edee50da5b933a07357b09c750bb056.png"></p>
<p>Frame：每个方法对应一个栈帧</p>
<ol>
<li>Local Variable Table </li>
<li>Operand Stack<br>对于 long 的处理（store and load），多数虚拟机的实现都是原子的<br>jls 17.7，没必要加 volatile </li>
<li>Dynamic Linking<br><a href="https://blog.csdn.net/qq_41813060/article/details/88379473">java Dynamic Linking</a><br>jvms 2.6.3 </li>
<li>return address<br>a () -&gt; b ()，方法 a 调用了方法 b，b 方法的返回值放在什么地方</li>
</ol>
<p>例：<code>i = i++;</code> 的栈实现</p>
<p><strong>常用字节码指令：</strong><br>store、load、pop、mul、sub<br>invoke：</p>
<ol>
<li>InvokeStatic：调用静态方法</li>
<li> InvokeVirtual：普通方法，自带多态</li>
<li> InvokeInterface：调用接口的方法</li>
<li> InovkeSpecial：<br>可以直接定位，不需要多态的方法<br>private 方法 ， 构造方法</li>
<li> InvokeDynamic：<br>lambda 表达式或者反射或者其他动态语言 scala kotlin，或者 CGLib ASM，动态产生的 class，会用到的指令</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>所有对象都在这里分配内存</strong>，是垃圾收集的主要区域<br>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常</p>
<p>堆是所有 <strong>线程共享</strong> 的<br>默认新生代：老年代 = 1 : 2</p>
<h3 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h3><p>分为 伊甸园（Edne）和两个 幸存区（Survival），默认比例为 Eden：from：to = 8：1：1，保证了内存的利用率达到 90%</p>
<p><strong>Eden：</strong></p>
<ul>
<li><strong>线程共享：</strong> 由于堆是所有线程共享的，因此在堆上分配内存 <strong>需要加锁</strong> </li>
<li><strong> TLAB：</strong> 为提升效率，每个新建的线程在 Eden 上分配了一块独立的空间由该线程独享，这块空间称为 <strong>TLAB</strong>（Thread Local Allocation Buffer） </li>
<li>在 TLAB 上分配内存 <strong>不需要加锁</strong>，因此 JVM 在给线程中的对象分配内存时会尽量在 TLAB 上分配 <ul>
<li>如果对象过大或 TLAB 用完，则仍然在堆上进行分配。如果 Eden 区内存也用完了，则会进行一次 Minor GC（young GC）</li>
</ul>
</li>
</ul>
<p><strong>Survival（from &amp; to）：</strong><br><a href="https://www.jianshu.com/p/989d3b06a49d">jvm 误区 – 动态对象年龄判定</a></p>
<ul>
<li>在发生 Minor GC 时，Eden 区和 Survival from 区会把一些仍然存活的对象复制进 Survival to 区，并清除内存 <ul>
<li>将此时在 Survivor to 区存活下来的对象的年龄设置为 1，以后这些对象每在 Survivor 区熬过一次 GC，它们的年龄就加 1，当对象年龄达到某个年龄（默认值为 15）时，就会把它们移到老年代中<br><strong>调整年龄：</strong> -XX:MaxTenuringThreshold<br><strong>默认年龄：</strong> <ul>
<li>·Parallel Scavenge 15</li>
<li>CMS 6</li>
<li>G1 15</li>
</ul>
</li>
<li>s1 -&gt; s2 超过 50%：把年龄最大的放入老年代</li>
</ul>
</li>
<li>在发生一次 Minor GC 后，from 区就会和 to 区互换</li>
</ul>
<p><strong>分配担保：</strong><br><a href="https://cloud.tencent.com/developer/article/1082730">JVM 内存分配担保机制</a><br>如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p>
<h3 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><p>年老代里存放的都是存活时间较久的，大小较大的对象。<br><strong>Full GC：</strong> 当年老代容量满的时候，会触发一次 Major GC（Full GC），回收年老代和年轻代中不再被使用的对象资源</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p><strong>垃圾回收：</strong> 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p><strong>永久代（PermSpace）：</strong><br>JDK &lt; 1.8<br>方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是 Hotspot 虚拟机对其的一种实现。</p>
<p>永久代的大小受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变</p>
<ul>
<li>字符串常量位于 PermSpace</li>
<li>FGC 不会清理</li>
<li>大小启动的时候指定，不能变</li>
</ul>
<p><strong>元空间（MetaSpace）：</strong><br>JDK &gt;= 1.8</p>
<ul>
<li>移除永久代，并把方法区移至元空间（位于本地内存中，而不是虚拟机内存中）</li>
<li>字符串常量存放到堆内存中</li>
<li>会触发 FGC 清理</li>
<li>元空间大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol>
<li><strong>栈上分配：</strong> 无需手动调整<ul>
<li>线程私有小对象</li>
<li>无逃逸</li>
<li>支持标量替换</li>
</ul>
</li>
<li><strong>线程本地分配 TLAB（Thread Local Allocation Buffer）：</strong> 无需手动调整</li>
</ol>
<ul>
<li>占用 Eden，默认 1%</li>
<li> 多线程的时候不用竞争 Eden 就可以申请空间，提高效率</li>
<li>小对象</li>
</ul>
<ol start="3">
<li><strong>大对象直接进入老年代：</strong></li>
</ol>
<ul>
<li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</li>
<li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</li>
<li> XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制</li>
</ul>
<ol start="4">
<li><strong>对象优先在 Eden 分配：</strong> 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC </li>
<li><strong>长期存活的对象进入老年代：</strong> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中 </li>
<li><strong>空间分配担保：</strong></li>
</ol>
<ul>
<li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的 </li>
<li>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败 <ul>
<li>如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li>
<li>如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</li>
</ul>
</li>
</ul>
<h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><ul>
<li><strong>调用 System.gc ()：</strong> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存 </li>
<li><strong>老年代空间不足：</strong> <ul>
<li>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</li>
<li>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li>
</ul>
</li>
<li><strong>空间分配担保失败：</strong> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC </li>
<li><strong>JDK 1.7 及以前的永久代空间不足：</strong> <ul>
<li>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</li>
<li>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</li>
</ul>
</li>
<li><strong>Concurrent Mode Failure：</strong> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 从入门到入土 ⑥：GC 调优</title>
    <url>/52c1fa2be06e/</url>
    <content><![CDATA[<h1 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h1><h2 id="PS-GC-日志详解"><a href="#PS-GC-日志详解" class="headerlink" title="PS GC 日志详解"></a>PS GC 日志详解</h2><p>PS 日志格式：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cea63f941b61313d69888b79ac15efb4.png"></p>
<p>heap dump 部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)</span><br><span class="line">                            后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2cbf3593b5f78f7b83cf8e027ad91748.png"></p>
<span id="more"></span>
<h2 id="CMS-日志分析"><a href="#CMS-日志分析" class="headerlink" title="CMS 日志分析"></a>CMS 日志分析</h2><p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
<p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</p>
<blockquote>
<p>ParNew：年轻代收集器<br>6144-&gt;640：收集前后的对比<br>（6144）：整个年轻代容量<br>6585 -&gt; 2770：整个堆的情况<br>（19840）：整个堆大小</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: 8511K(13696K)] 9866K(19840K), <span class="number">0.0040321</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line">	<span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.018</span>/<span class="number">0.018</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">	<span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: <span class="number">1597</span> K (<span class="number">6144</span> K)][Rescan (parallel) , <span class="number">0.0008396</span> secs][weak refs processing, <span class="number">0.0000138</span> secs][<span class="keyword">class</span> <span class="title class_">unloading</span>, <span class="number">0.0005404</span> secs][scrub symbol table, <span class="number">0.0006169</span> secs][scrub string table, <span class="number">0.0004903</span> secs][<span class="number">1</span> CMS-remark: 8511K(13696K)] 10108K(19840K), <span class="number">0.0039567</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line">	<span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line">	<span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line">	<span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line">	<span class="comment">//scrub symbol(string) table: </span></span><br><span class="line">		<span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line">		<span class="comment">//internalized string respectively</span></span><br><span class="line">	<span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line">	<span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.005</span>/<span class="number">0.005</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">	<span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">	<span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="G1-日志详解"><a href="#G1-日志详解" class="headerlink" title="G1 日志详解"></a>G1 日志详解</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[GC <span class="title function_">pause</span> <span class="params">(G1 Evacuation Pause)</span> (young) (initial-mark), <span class="number">0.0015790</span> secs]</span><br><span class="line"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span><br><span class="line"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span><br><span class="line">   [Parallel Time: <span class="number">1.5</span> ms, GC Workers: <span class="number">1</span>] <span class="comment">//一个GC线程</span></span><br><span class="line">      [GC Worker <span class="title function_">Start</span> <span class="params">(ms)</span>:  <span class="number">92635.7</span>]</span><br><span class="line">      [Ext Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">1.1</span>]</span><br><span class="line">      [Update <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">         [Processed Buffers:  <span class="number">1</span>]</span><br><span class="line">      [Scan <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Code Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="title function_">Copy</span> <span class="params">(ms)</span>:  <span class="number">0.1</span>]</span><br><span class="line">      [Termination (ms):  <span class="number">0.0</span>]</span><br><span class="line">         [Termination Attempts:  <span class="number">1</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Other</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Total</span> <span class="params">(ms)</span>:  <span class="number">1.2</span>]</span><br><span class="line">      [GC Worker <span class="title function_">End</span> <span class="params">(ms)</span>:  <span class="number">92636.9</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.0</span> ms]</span><br><span class="line">   [Other: <span class="number">0.1</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Proc: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [Free CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)]</span><br><span class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法 evacuation，进行 FGC</span></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18M(20M), <span class="number">0.0719656</span> secs]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)], [Metaspace: <span class="number">38</span></span><br><span class="line">76K-&gt;3876K(1056768K)] [Times: user=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="GC-调优"><a href="#GC-调优" class="headerlink" title="GC 调优"></a>GC 调优</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol>
<li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li>
<li>响应时间：STW 越短，响应时间越好</li>
</ol>
<p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p>
<p>问题：<br>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p>
<p>响应时间：网站 GUI API （1.8 G1）</p>
<p><strong>什么是调优？</strong></p>
<ol>
<li>根据需求进行 JVM 规划和预调优</li>
<li>优化运行 JVM 运行环境（慢，卡顿）</li>
<li>解决 JVM 运行过程中出现的各种问题（OOM）</li>
</ol>
<h2 id="调优规划"><a href="#调优规划" class="headerlink" title="调优规划"></a>调优规划</h2><ul>
<li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓 </p>
</li>
<li><p>监控（压力测试，能看到结果） </p>
</li>
<li><p>步骤： </p>
<ol>
<li>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） <ol>
<li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li>
<li>吞吐量 = 用户时间 /(用户时间 + GC 时间) [PS]</li>
</ol>
</li>
<li> 选择回收器组合</li>
<li>计算内存需求（经验值 1.5G 16G）</li>
<li>选定 CPU（越高越好）</li>
<li>设定年代大小、升级年龄</li>
<li>设定日志参数 <ol>
<li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li>
<li> 或者每天产生一个日志文件</li>
</ol>
</li>
<li>观察日志情况</li>
</ol>
</li>
<li><p>案例 1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？ </p>
<blockquote>
<p>这个问题比较业余，因为很多不同的服务器配置都能支撑（1.5G 16G）<br>1 小时 360000 集中时间段， 100 个订单 / 秒，（找一小时内的高峰期，1000 订单 / 秒）<br>经验值，<br>非要计算：一个订单产生需要多少内存？512K * 1000 500M 内存<br>专业一点儿问法：要求响应时间 100ms<br>压测！</p>
</blockquote>
</li>
<li><p>案例 2：12306 遭遇春节大规模抢票应该如何支撑？ </p>
<blockquote>
<p>12306 应该是中国并发量最大的秒杀网站：<br>号称并发量 100W 最高<br> CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发（10K 问题） 100 台机器<br>普通电商订单 -&gt; 下单 -&gt; 订单系统（IO）减库存 -&gt; 等待用户付款<br>12306 的一种可能的模型： 下单 -&gt; 减库存 和 订单 (redis kafka) 同时异步进行 -&gt; 等付款<br>减库存最后还会把压力压到一台服务器<br>可以做分布式本地库存 + 单独服务器做库存均衡<br>大流量的处理方法：分而治之</p>
</blockquote>
</li>
<li><p>怎么得到一个事务会消耗多少内存？ </p>
<blockquote>
<ol>
<li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到 </li>
<li>用压测来确定</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h2><ol>
<li>有一个 50 万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G<br>的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为 64 位，16G<br>的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了 <ol>
<li>为什么原网站慢？<br>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间变慢</li>
<li>为什么会更卡顿？<br>内存越大，FGC 时间越长</li>
<li>解决方案：PS -&gt; PN + CMS 或者 G1</li>
</ol>
</li>
<li> 系统 CPU 经常 100%，如何调优？(面试高频)<br>CPU 100% 那么一定有线程在占用系统资源， <ol>
<li>找出哪个进程 cpu 高（top）</li>
<li>该进程中的哪个线程 cpu 高（top -Hp）</li>
<li>导出该线程的堆栈（jstack）</li>
<li>查找哪个方法（栈帧）消耗时间（jstack）</li>
<li>工作线程占比高 | 垃圾回收线程占比高</li>
</ol>
</li>
<li>系统内存飙高，如何查找问题？（面试高频） <ol>
<li>导出堆内存（jmap）</li>
<li>分析（jhat jvisualvm mat jprofiler … ）</li>
</ol>
</li>
<li>如何监控 JVM <ol>
<li>jstat jvisualvm jprofiler arthas top…</li>
</ol>
</li>
</ol>
<h2 id="解决-JVM-运行中的问题"><a href="#解决-JVM-运行中的问题" class="headerlink" title="解决 JVM 运行中的问题"></a>解决 JVM 运行中的问题</h2><h3 id="一个案例理解常用工具"><a href="#一个案例理解常用工具" class="headerlink" title="一个案例理解常用工具"></a>一个案例理解常用工具</h3><ol>
<li><p>测试代码： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T15_FullGC_Problem01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CardInfo</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"张三"</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">50</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;){</span><br><span class="line">            modelFit();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modelFit</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">        taskList.forEach(info -&gt; {</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            executor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">                <span class="comment">//do sth with info</span></span><br><span class="line">                info.m();</span><br><span class="line"></span><br><span class="line">            }, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title function_">getAllCardInfo</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="type">CardInfo</span> <span class="variable">ci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardInfo</span>();</span><br><span class="line">            taskList.add(ci);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01 </p>
</li>
<li><p>运维团队首先受到报警信息（CPU Memory） </p>
</li>
<li><p>top 命令观察到问题：内存不断增长 CPU 占用率居高不下 </p>
</li>
<li><p>top -Hp 观察进程中的线程，哪个线程 CPU 和内存占比高 </p>
</li>
<li><p>jps 定位具体 java 进程<br>jstack 定位线程状况，重点关注：WAITING BLOCKED<br>eg.<br>waiting on &lt;0x0000000088ca3310&gt; （a java.lang.Object）<br>假如有一个进程中 100 个线程，很多线程都在 waiting on <xx> ，一定要找到是哪个线程持有这把锁<br>怎么找？搜索 jstack dump 的信息，找<xx> ，看哪个线程持有这把锁 RUNNABLE </xx></xx></p>
</li>
<li><p>线程的名称（尤其是线程池）都要写有意义的名称 </p>
</li>
<li><p>jinfo pid </p>
</li>
<li><p>jstat -gc 动态观察 gc 情况 / 阅读 GC 日志发现频繁 GC /arthas 观察 /jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个 500 个毫秒打印 GC 的情况<br>如果面试官问你是怎么定位 OOM 问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmdline arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察） </p>
</li>
<li><p>jmap - histo 4655 | head -20，查找有多少对象产生 </p>
</li>
<li><p>jmap -dump:format=b,file=xxx pid ：<br>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<br>1：设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件<br>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响<br>3：在线定位（一般小点儿公司用不到） </p>
</li>
<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01 </p>
</li>
<li><p>使用 MAT /jhat/jvisualvm 进行 dump 文件分析<br><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html">java 命令 –jhat 命令使用</a><br>jhat -J-mx512M xxx.dump<br><a href="http://192.168.17.11:7000/">http://192.168.17.11:7000</a><br>拉到最后：找到对应链接<br>可以使用 OQL 查找特定问题对象 </p>
</li>
<li><p>找到代码的问题</p>
</li>
</ol>
<h3 id="jconsole-远程连接"><a href="#jconsole-远程连接" class="headerlink" title="jconsole 远程连接"></a>jconsole 远程连接</h3><ol>
<li><p>程序启动加入参数： </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果遭遇 Local host name unknown：XXX 的错误，修改 /etc/hosts 文件，把 XXX 加入进去 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.17</span><span class="number">.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>关闭 linux 防火墙（实战中应该打开对应端口） </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>windows 上打开 jconsole 远程连接 192.168.17.11:11111</p>
</li>
</ol>
<h3 id="jvisualvm-远程连接"><a href="#jvisualvm-远程连接" class="headerlink" title="jvisualvm 远程连接"></a>jvisualvm 远程连接</h3><p>简单做法：<a href="https://www.cnblogs.com/liugh/p/7620336.html">使用 jvisualvm 的 jstatd 方式远程监控 Java 程序</a></p>
<h3 id="jprofiler（收费）"><a href="#jprofiler（收费）" class="headerlink" title="jprofiler（收费）"></a>jprofiler（收费）</h3><h3 id="arthas-在线排查工具"><a href="#arthas-在线排查工具" class="headerlink" title="arthas 在线排查工具"></a>arthas 在线排查工具</h3><ul>
<li>为什么需要在线排查？<br>在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的 threaddump 或者 heapdump 不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li>
<li>jvm 观察 jvm 信息</li>
<li> thread &nbsp;定位线程问题</li>
<li> dashboard 观察系统情况</li>
<li> heapdump + jhat 分析</li>
<li> jad 反编译<br>动态代理生成类的问题定位<br>第三方的类（观察代码）<br>版本问题（确定自己最新提交的版本是不是被使用）</li>
<li>redefine 热替换<br>目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性<br>m() -&gt; mm()</li>
<li>sc &nbsp;- search class</li>
<li>watch &nbsp;- watch method</li>
<li> 没有包含的功能：jmap</li>
</ul>
<h3 id="产生原因案例"><a href="#产生原因案例" class="headerlink" title="产生原因案例"></a>产生原因案例</h3><p>OOM 产生的原因多种多样，有些程序未必产生 OOM，不断 FGC（CPU 飙高，但内存回收特别少）（上面案例）</p>
<ol>
<li><p>硬件升级系统反而卡顿的问题（见上） </p>
</li>
<li><p>线程池不当运用产生 OOM 问题（见上）<br>不断的往 List 里加对象（实在太 LOW） </p>
</li>
<li><p>jira 问题<br>实际生产参数案例： </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-Xms9216m -Xmx9216m </span><br><span class="line">-XX:-OmitStackTraceInFastThrow </span><br><span class="line">-Xloggc:/opt/xxx/logs/xxx-gc-%t.log </span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br><span class="line">-XX:GCLogFileSize=20M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCCause -classpath /opt/xxx/bin/...jar</span><br></pre></td></tr></tbody></table></figure>
<p><br>实际系统不断重启<br>解决问题 加内存 + 更换垃圾回收器 G1<br>真正问题在哪儿？不知道 </p>
</li>
<li><p>tomcat http-header-size 过大问题（Hector） </p>
</li>
<li><p>lambda 表达式导致方法区溢出问题（MethodArea / Perm Metaspace）<br>LambdaGC.java &nbsp; &nbsp; -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails <span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">"C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar"</span> com.mashibing.jvm.gc.LambdaGC</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 11341K-&gt;1880K(38400K)] 11341K-&gt;1888K(125952K), <span class="number">0.0022190</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 1880K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;1777K(35328K)] 1888K-&gt;1777K(73728K), [Metaspace: 8164K-&gt;8164K(1056768K)], <span class="number">0.0100681</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(38400K)] 1777K-&gt;1777K(73728K), <span class="number">0.0005698</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Last ditch collection)</span> [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 1777K-&gt;1629K(67584K)] 1777K-&gt;1629K(105984K), [Metaspace: 8164K-&gt;8156K(1056768K)], <span class="number">0.0124299</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:<span class="number">388</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:<span class="number">411</span>)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">	at sun.misc.Unsafe.defineClass(Native Method)</span><br><span class="line">	at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:<span class="number">63</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">399</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">394</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:<span class="number">393</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:<span class="number">112</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:<span class="number">398</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:<span class="number">360</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:<span class="number">1574</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.access$<span class="number">1500</span>(ObjectStreamClass.java:<span class="number">79</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">519</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:<span class="number">391</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1134</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:<span class="number">727</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:<span class="number">719</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:<span class="number">690</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:<span class="number">439</span>)</span><br><span class="line">	at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:<span class="number">550</span>)</span><br><span class="line">	at sun.management.Agent.startLocalManagementAgent(Agent.java:<span class="number">137</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>直接内存溢出问题（少见）<br>《深入理解 Java 虚拟机》P59，使用 Unsafe 分配直接内存，或者使用 NIO 的问题 </p>
</li>
<li><p>栈溢出问题<br>-Xss 设定太小 </p>
</li>
<li><p>比较一下这两段程序的异同，分析哪一个是更优的写法： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) {</span><br><span class="line">    o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重写 finalize 引发频繁 GC<br>小米云，HBase 同步系统，系统通过 nginx 访问超时报警，最后排查，C++ 程序员重写 finalize 引发频繁 GC 问题<br>为什么 C++ 程序员会重写 finalize？（new delete）<br>finalize 耗时比较长（200ms） </p>
</li>
<li><p>如果有一个系统，内存一直消耗不超过 10%，但是观察 GC 日志，发现 FGC 总是频繁产生，会是什么引起的？<br>System.gc () (这个比较 Low) </p>
</li>
<li><p>Distuptor 有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出 (来自 死物风情) </p>
</li>
<li><p>用 jvm 都会溢出，mycat 用崩过，1.6.5 某个临时版本解析 sql 子查询算法有问题，9 个 exists 的联合 sql 就导致生成几百万的对象（来自 死物风情） </p>
</li>
<li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池，<br>解决方案：减少堆空间（太 TM low 了），预留更多内存产生 native thread<br>JVM 内存占物理内存比例 50% - 80%</p>
</li>
</ol>
<h1 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JVM 的命令行参数参考</a><br>HotSpot 参数分类</p>
<ul>
<li>标准： - 开头，所有的 HotSpot 都支持 </li>
<li>非标准：-X 开头，特定版本 HotSpot 支持特定命令 </li>
<li>不稳定：-XX 开头，下个版本可能取消</li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li>
<li> -XX:+UseTLAB<br>使用 TLAB，默认打开</li>
<li> -XX:+PrintTLAB<br>打印 TLAB 的使用情况</li>
<li> -XX:TLABSize<br>设置 TLAB 大小</li>
<li> -XX:+DisableExplictGC<br>System.gc () 不管用 ，FGC</li>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintHeapAtGC</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-XX:+PrintGCCauses</li>
<li>-XX:+PrintGCApplicationConcurrentTime（低）<br>打印应用程序时间</li>
<li> -XX:+PrintGCApplicationStoppedTime （低）<br>打印暂停时长</li>
<li> -XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li>
<li> -verbose:class<br>类加载详细过程</li>
<li> -XX:+PrintVMOptions</li>
<li>-XX:+PrintFlagsFinal</li>
<li>-XX:+PrintFlagsInitial：查看所有 JVM 参数启动的初始值</li>
<li> -XX:+PrintCommandLineFlags：默认的参数</li>
<li> -Xloggc:opt/log/gc.log</li>
<li>-XX:MaxTenuringThreshold<br>升代年龄，最大值 15</li>
<li> 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数 -XX:CompileThreshold 逃逸分析 标量替换 …<br>这些不建议设置</li>
</ul>
<h2 id="Parallel-常用参数"><a href="#Parallel-常用参数" class="headerlink" title="Parallel 常用参数"></a>Parallel 常用参数</h2><ul>
<li>-XX:SurvivorRatio</li>
<li>-XX:PreTenureSizeThreshold<br>大对象到底多大</li>
<li> -XX:MaxTenuringThreshold</li>
<li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于 CMS，一般设为和 CPU 核数相同</li>
<li> -XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li>
</ul>
<h2 id="CMS-常用参数"><a href="#CMS-常用参数" class="headerlink" title="CMS 常用参数"></a>CMS 常用参数</h2><ul>
<li>-XX:+UseConcMarkSweepGC</li>
<li>-XX:ParallelCMSThreads<br>CMS 线程数量</li>
<li> -XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始 CMS 收集，默认是 68%（近似值），如果频繁发生 SerialOld 卡顿，应该调小，（频繁 CMS 回收）</li>
<li>-XX:+UseCMSCompactAtFullCollection<br>在 FGC 时进行压缩</li>
<li> -XX:CMSFullGCsBeforeCompaction<br>多少次 FGC 之后进行压缩</li>
<li> -XX:+CMSClassUnloadingEnabled</li>
<li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行 Perm 回收</li>
<li> GCTimeRatio<br>设置 GC 时间占用程序运行时间的百分比</li>
<li> -XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代</li>
</ul>
<h2 id="G1-常用参数"><a href="#G1-常用参数" class="headerlink" title="G1 常用参数"></a>G1 常用参数</h2><ul>
<li>-XX:+UseG1GC</li>
<li>-XX:MaxGCPauseMillis<br>建议值，G1 会尝试调整 Young 区的块数来达到这个值</li>
<li> -XX:GCPauseIntervalMillis<br>？GC 的间隔时间</li>
<li> -XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着 size 增加，垃圾的存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长<br>ZGC 做了改进（动态区块大小）</li>
<li>G1NewSizePercent<br>新生代最小比例，默认为 5%</li>
<li>G1MaxNewSizePercent<br>新生代最大比例，默认为 60%</li>
<li>GCTimeRatio<br>GC 时间建议比例，G1 会根据这个值调整堆空间</li>
<li> ConcGCThreads<br>线程数量</li>
<li> InitiatingHeapOccupancyPercent<br>启动 G1 的堆空间占用比例</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blogs.oracle.com/jonthecollector/our-collectors">Our Collectors</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">Java Platform, Standard Edition Tools Reference</a></li>
<li><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp">Java HotSpot VM Options</a></li>
<li>JVM 调优参考文档： <a href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li>
<li><a href="https://www.cnblogs.com/nxlhero/p/11660854.html">利用 JVM 在线调试工具排查线上问题</a></li>
<li><a href="https://www.jianshu.com/p/507f7e0cc3a3">Arthas 使用</a>：arthas 常用命令</li>
<li> Arthas 手册： <ol>
<li>启动 arthas java -jar arthas-boot.jar</li>
<li> 绑定 java 进程</li>
<li> dashboard 命令观察系统整体情况</li>
<li> help 查看帮助</li>
<li> help xx 查看具体命令帮助</li>
</ol>
</li>
<li> jmap 命令参考： <a href="https://www.jianshu.com/p/507f7e0cc3a3">https://www.jianshu.com/p/507f7e0cc3a3</a> <ol>
<li>jmap -heap pid</li>
<li>jmap -histo pid</li>
<li>jmap -clstats pid</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 常用指令</title>
    <url>/e27ad8b5a7cb/</url>
    <content><![CDATA[<h1 id="栈设置"><a href="#栈设置" class="headerlink" title="栈设置"></a>栈设置</h1><ul>
<li>-Xss: 栈大小</li>
</ul>
<h1 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h1><ul>
<li>-Xms: 初始堆大小</li>
<li> -Xmx: 最大堆大小</li>
<li> -Xmn: 新生代大小</li>
<li> -XX:NewSize=n: 设置年轻代大小</li>
<li> -XX:NewRatio=n: 设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</li>
<li>-XX:SurvivorRatio=n: 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。<ul>
<li>如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5</li>
</ul>
</li>
<li>-XX:PretenureSizeThreshold: 大于此值的对象直接在老年代分配</li>
<li> -XX:MaxTenuringThreshold: 定义年龄的阈值。在 Eden 中的对象经过 Minor GC 依然存活，将移动到 Survivor 中，年龄增加 1 岁，超过该年龄阈值将进入老年代</li>
</ul>
<span id="more"></span>
<h1 id="永久代设置"><a href="#永久代设置" class="headerlink" title="永久代设置"></a>永久代设置</h1><ul>
<li>-XX:PermSize: 初始化永久代大小</li>
<li> -XX:MaxPermSize=n: 永久代最大容量</li>
</ul>
<p><strong>元空间：</strong></p>
<ul>
<li><strong>-XX:MetaspaceSize ：</strong> 分配给类元数据空间的初始大小。<ul>
<li>MetaspaceSize 的值设置的过大会延长垃圾回收时间。</li>
<li>垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
</ul>
</li>
<li><strong>-XX:MaxMetaspaceSize ：</strong>分配给类元数据空间的最大值<ul>
<li>超过此值就会触发 Full GC 。此值默认没有限制，但应取决于系统内存的大小，JVM 会动态地改变此值。</li>
</ul>
</li>
</ul>
<h1 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h1><ul>
<li>-XX:+UseSerialGC: 设置串行收集器</li>
<li> -XX:+UseParallelGC: 设置并行收集器</li>
<li> -XX:+UseParalledlOldGC: 设置并行年老代收集器</li>
<li> -XX:+UseConcMarkSweepGC: 设置并发收集器</li>
<li> -XX:ParallelCMSThreads: 并发标记扫描垃圾回收器 = 为使用的线程数量</li>
<li> -XX:+UseG1GC: G1 垃圾回收器</li>
</ul>
<p><strong>并行收集器配置：</strong></p>
<ul>
<li>-XX:ParallelGCThreads=n: 设置并行收集器收集时使用的 CPU 数和并行收集线程数。默认开启的线程数量与 CPU 数量相同</li>
<li> -XX:MaxGCPauseMillis=n: 设置并行收集最大暂停时间</li>
<li> -XX:GCTimeRatio=n: 设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)-XX:+CMSIncrementalMode: 设置为增量模式。适用于单 CPU 情况。</li>
<li>-XX:ParallelGCThreads=n: 设置并发收集器年轻代收集方式为并行收集时，使用的 CPU 数。并行收集线程数。</li>
</ul>
<h1 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h1><ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>对象引用类型</title>
    <url>/0f07a3efe588/</url>
    <content><![CDATA[<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。<br><strong>作用：</strong> 缓存</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>// ===== 软引用测试（-Xms:20M -Xmx20M） =====</p>
<p>SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024<em>1024</em>10]);<br>System.out.println(m.get());</p>
<p>// 再分配一个数组，heap 将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉<br>byte[] b = new byte[1024<em>1024</em>15];<br>System.out.println(m.get()); // null</p>
</blockquote>
<span id="more"></span>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p><strong>作用：</strong> 一般用在容器里。强引用和弱引用同时指向某个对象，当强引用不再指向该对象时，该对象就该被回收</p>
<p>例：ThreadLocal 对象 new 后有强引用，而当前线程中的 ThreadLocalMap 对象的键也有 ThreadLocal 对象的弱引用，所以当 ThreadLocal 对象失去强引用时 ThreadLocalMap 中对应的键也会变为 null，防止了内存泄露。虽然 ThreadLocalMap 的键为 null 了，但是其 value 值还存在所以依然会有内存泄露，所以需要执行 ThreadLocal#remove 方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>WeakReference<m> m = new WeakReference&lt;&gt;(new M());</m></p>
<p>System.out.println(m.get());<br>System.gc();<br>System.out.println(m.get()); // null</p>
<p>ThreadLocal<m> tl = new ThreadLocal&lt;&gt;();<br>tl.set(new M());<br>tl.remove();</m></p>
</blockquote>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p>
<p><em>作用：</em></p>
<ul>
<li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 </li>
<li>管理堆外内存（通常给编写 JVM 的人使用）：DirectByteBuffer 对象指向堆外内存。当 DirectByteBuffer 被回收时，可以通过队列检测到，然后清理堆外内存 </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 关联了对象和队列</span></span><br><span class="line"><span class="comment">// 当对象被回收引用会放入队列中</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line"><span class="comment">// 不能通过 get() 拿到里面的值</span></span><br><span class="line">pf.get();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对象被回收后，通过 poll() 方法可以拿出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; poll = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (poll != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"--- 虚引用对象被jvm回收了 ---- "</span> + poll);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>性能调优监控工具</title>
    <url>/abfd88afec7e/</url>
    <content><![CDATA[<h1 id="1-jps（Java-Virtual-Machine-Process-Status-Tool）"><a href="#1-jps（Java-Virtual-Machine-Process-Status-Tool）" class="headerlink" title="1. jps（Java Virtual Machine Process Status Tool）"></a><strong>1. jps（Java Virtual Machine Process Status Tool）</strong></h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3725340a4dc81fe9baf2250d63d3487b.png" alt="image.png"><br><strong><em>作用：</em></strong> 用来输出 JVM 中运行的进程状态信息<br><strong><em>指令：</em></strong> jps [options] [hostid]</p>
<ul>
<li>-q 不输出类名、Jar 名和传入 main 方法的参数</li>
<li> -m 输出传入 main 方法的参数</li>
<li> -l 输出 main 类或 Jar 的全限名</li>
<li> -v 输出传入 JVM 的参数</li>
</ul>
<span id="more"></span>
<h1 id="2-jstack"><a href="#2-jstack" class="headerlink" title="2. jstack"></a>2. jstack</h1><p><strong><em>作用：</em></strong> 用来查看某个 Java 进程内的线程堆栈信息<br>指令：<br>jstack [option] pid<br>jstack [option] executable core<br>jstack [option] [server-id@]remote-hostname-or-ip</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>类加载机制详解</title>
    <url>/279728ca8833/</url>
    <content><![CDATA[<p>类是在 ** 运行期间第一次使用 ** 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存</p>
<h1 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1. 类的生命周期"></a>1. 类的生命周期</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7d761e858b6b41b873e936793f188da9.png" alt="image.png"><br>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<span id="more"></span>
<h1 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h1><p>包含了加载、验证、准备、解析和初始化这 5 个阶段</p>
<h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1. 加载"></a>2.1. 加载</h2><p>加载过程完成以下三件事：</p>
<ol>
<li><strong>获取二进制字节流：</strong> 通过一个类的全限定名来获取定义此类的 <strong>二进制字节流</strong><ol>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流</li>
<li>从网络中获取，最典型的应用是 Applet</li>
</ol>
</li>
<li><strong> 存储结构转化：</strong> 将这个字节流所代表的 ** 静态存储结构 ** 转化为方法区的 <strong>运行时存储结构</strong></li>
<li><strong>生成 Class 对象：</strong> 在内存中生成一个代表这个类的 <strong>Class 对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2. 验证"></a>2.2. 验证</h2><p><strong><em>概述：</em></strong> 确保 Class 文件的字节流中包含的信息 <strong>符合当前虚拟机的要求（如 cafe babe）</strong>，并且不会危害虚拟机自身的安全</p>
<h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3. 准备"></a>2.3. 准备</h2><p><strong><em>概述：</em></strong> 准备阶段为 ** 静态变量 ** 分配内存并 <strong>设置初始值</strong>，使用的是 ** 方法区 ** 的内存</p>
<ul>
<li><p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中</p>
</li>
<li><p>初始值一般为 0 值，例如下面的静态变量 value 被初始化为 0 而不是 123</p>
<blockquote>
<p> public static int value = 123; </p>
</blockquote>
</li>
<li><p>如果静态变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0</p>
<blockquote>
<p> public static final int value = 123;</p>
</blockquote>
</li>
</ul>
<h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4. 解析"></a>2.4. 解析</h2><p><strong><em>概述：</em></strong><br>将常量池的符号引用替换为 <strong>直接引用 <strong>的过程<br>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定<br></strong><em>符号引用：</em></strong> 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中<br><strong><em>直接引用：</em></strong> 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在</p>
<h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5. 初始化"></a>2.5. 初始化</h2><p><strong><em>概述：</em></strong><br>初始化阶段即虚拟机执行 <strong>类构造器</strong> () 方法的过程<br>初始化阶段才真正开始执行类中定义的 Java 程序代码<br><strong><em>特点：</em></strong></p>
<ul>
<li><p><strong>静态初始化：</strong> 编译器自动收集类中所有 静态变量的赋值动作和静态语句块中的语句，由 class 类构造器对 ** 静态变量 <strong>、</strong>静态代码块 ** 进行 ** 初始化 **。编译器收集的顺序由语句在源文件中出现的顺序决定。</p>
<ul>
<li>如果一个类中不包含静态语句块，也没有对静态变量有赋值操作，编译器可以不为该类生成 () 方法。</li>
<li>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        	i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        	System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">	    }</span><br><span class="line">	    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>先父后子：</strong> 与类的构造函数（或者说实例构造器 ()）不同，() 不需要显式的调用父类的构造器。<strong>虚拟机会自动保证在子类的 () 方法运行之前</strong>，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。这也意味着父类中定义的 <strong>静态语句块的执行要优先于子类</strong></p>
</li>
<li><p><strong>接口：</strong> 执行接口的 () 方法不需要先执行父接口的 () 方法。<strong>只有当父接口中定义的变量使用时</strong>，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法</p>
</li>
<li><p><strong>加锁等待：</strong> 如果多个线程同时初始化一个类，只会有 ** 一个线程执行 ** 这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</p>
</li>
</ul>
<h1 id="3-类初始化时机"><a href="#3-类初始化时机" class="headerlink" title="3. 类初始化时机"></a>3. 类初始化时机</h1><h2 id="3-1-主动引用"><a href="#3-1-主动引用" class="headerlink" title="3.1. 主动引用"></a>3.1. 主动引用</h2><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>当虚拟机启动时，用户需要指定一个要执行的 <strong>入口类</strong>（包含 main () 方法的那个类），虚拟机会先初始化这个主类</li>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>以及调用一个类的静态方法的时候</li>
</ul>
</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要 ** 先触发其父类 ** 的初始化</li>
<li>使用 java.lang.reflect 包的方法对类进行 ** 反射调用 ** 的时候，如果类没有进行初始化，则需要先触发其初始化</li>
<li>当使用 JDK 1.7 的 ** 动态语言 ** 支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ul>
<h2 id="3-2-被动引用"><a href="#3-2-被动引用" class="headerlink" title="3.2. 被动引用"></a>3.2. 被动引用</h2><p>以上 5 种场景中的行为称为对一个类进行主动引用<br>除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li><p>通过子类 <strong>引用父类的静态字段</strong>，不会导致子类初始化</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// value 字段在 SuperClass 中定义</span></span><br><span class="line">System.out.println(SubClass.value);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过 <strong>数组定义来引用类</strong>，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>** 常量 ** 在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="4-类与类加载器"><a href="#4-类与类加载器" class="headerlink" title="4. 类与类加载器"></a>4. 类与类加载器</h1><p>两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间<br>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</p>
<h2 id="4-1-类加载器分类"><a href="#4-1-类加载器分类" class="headerlink" title="4.1. 类加载器分类"></a>4.1. 类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>** 启动类加载器（Bootstrap ClassLoader）： ** 这个类加载器用 C++ 实现，是虚拟机自身的一部分</li>
<li><strong>所有其他类的加载器：</strong> 这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）：</strong><ul>
<li>此类加载器负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中</li>
<li>启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）：</strong><ul>
<li>这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器</li>
</ul>
</li>
<li><strong>应用程序类加载器（Application ClassLoader）：</strong><ul>
<li>这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader () 方法的返回值，因此一般称为系统类加载器</li>
<li>它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
</li>
</ul>
<h2 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2. 双亲委派模型"></a>4.2. 双亲委派模型</h2><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器<br>下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）<br>该模型要求除了顶层的启动类加载器外，其余的类加载器都应 <strong>有自己的父类加载器 <strong>。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/de5f150dd562209218479d94c4105e4e.png" alt="image.png"><br></strong><em>工作过程：</em></strong> 一个类加载器首先将类加载请求传送到父类加载器，<strong>只有当父类加载器无法完成类加载请求时才尝试加载</strong><br>** <em>优点：</em>** 使得 Java 类随着它的类加载器一起具有一种带有 <strong>优先级的层次关系</strong>，从而使得基础类得到 <strong>统一</strong></p>
<ul>
<li><strong>共享功能：</strong> 可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</li>
<li><strong>隔离功能：</strong> 主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException 。</li>
</ul>
<p><strong><em>例：</em></strong> java.lang.Object 存放在 rt.jar（使用启动类加载器）中，如果编写另外一个 java.lang.Object 的类（应用程序类加载器）并放到 ClassPath 中。<br>由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。<br><strong><em>实现：</em></strong><br>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：<br>先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-3-自定义类加载器实现"><a href="#4-3-自定义类加载器实现" class="headerlink" title="4.3. 自定义类加载器实现"></a>4.3. 自定义类加载器实现</h2><p>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。<br>它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass () 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass () 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass () 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> {</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>new 关键字创建对象的过程：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0f0b824d58ce871b1e380098f87dadb4.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 知识点梳理</title>
    <url>/ef9c4250508f/</url>
    <content><![CDATA[<h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="1-B-Tree-原理"><a href="#1-B-Tree-原理" class="headerlink" title="1. B+ Tree 原理"></a>1. B+ Tree 原理</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1. 数据结构"></a>1.1. 数据结构</h3><p><strong><em>B Tree：</em></strong> B Tree 指的是 Balance Tree，也就是 <strong>平衡树</strong>。平衡树是一颗查找树，并且 <strong>所有叶子节点位于同一层</strong><br><strong><em>B+ Tree：</em></strong> B+ Tree 是基于 B Tree 和叶子节点 <strong>顺序访问指针 <strong>进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br></strong><em>非递减：</em></strong> 在 B+ Tree 中，一个节点中的 key 从左到右 <strong>非递减排列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2d1103b4d71fad09128907f8eca6190.png" alt="image.png"></p>
<span id="more"></span>
<h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2. 操作"></a>1.2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data<br>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性</p>
<h3 id="1-3-与红黑树的比较"><a href="#1-3-与红黑树的比较" class="headerlink" title="1.3. 与红黑树的比较"></a>1.3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<ol>
<li>更少的查找次数<ol>
<li>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O (h)=O (logdN)，其中 d 为每个节点的出度。</li>
<li>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</li>
</ol>
</li>
<li>利用磁盘预读特性<ol>
<li>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</li>
<li>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li>
</ol>
</li>
</ol>
<h2 id="2-MySQL-索引"><a href="#2-MySQL-索引" class="headerlink" title="2. MySQL 索引"></a>2. MySQL 索引</h2><h3 id="2-1-B-Tree-索引"><a href="#2-1-B-Tree-索引" class="headerlink" title="2.1. B+ Tree 索引"></a>2.1. B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型<br><strong><em>速度快：</em></strong> 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多<br><strong><em>排序、分组：</em></strong> 除了用于查找，还可以用于排序和分组<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引<br><strong><em>主索引（聚簇索引）：</em></strong><br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/30543773300e9ea98415981a1d06e6cf.png" alt="image.png"><br><strong><em>辅助索引（非聚簇索引）：</em></strong><br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/314a86a9ddf86481c7ccb3a16791ef29.png" alt="image.png"></p>
<h3 id="2-2-哈希索引"><a href="#2-2-哈希索引" class="headerlink" title="2.2. 哈希索引"></a>2.2. 哈希索引</h3><p>哈希索引能以 O (1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组</li>
<li>只支持精确查找，无法用于部分查找和范围查找</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3. 全文索引"></a>2.3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="2-4-空间数据索引"><a href="#2-4-空间数据索引" class="headerlink" title="2.4. 空间数据索引"></a>2.4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1. 独立的列"></a>3.1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> sakila.actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2. 多列索引"></a>3.2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好<br>例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id </span><br><span class="line"><span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3-索引列的顺序"><a href="#3-3-索引列的顺序" class="headerlink" title="3.3. 索引列的顺序"></a>3.3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。<br><strong><em>索引的选择性：</em></strong> 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。<br>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 </p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line"></span><br><span class="line">   staff_id_selectivity: <span class="number">0.0001</span></span><br><span class="line">customer_id_selectivity: <span class="number">0.0373</span></span><br><span class="line">               <span class="built_in">COUNT</span>(<span class="operator">*</span>): <span class="number">16049</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-4-前缀索引"><a href="#3-4-前缀索引" class="headerlink" title="3.4. 前缀索引"></a>3.4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>对于前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5. 覆盖索引"></a>3.5. 覆盖索引</h3><p>索引包含 <strong>所有需要查询的字段的值</strong>。<br><strong><em>优点：</em></strong></p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="4-索引的优点"><a href="#4-索引的优点" class="headerlink" title="4. 索引的优点"></a>4. 索引的优点</h2><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<h2 id="5-索引的使用条件"><a href="#5-索引的使用条件" class="headerlink" title="5. 索引的使用条件"></a>5. 索引的使用条件</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="1-使用-Explain-进行分析"><a href="#1-使用-Explain-进行分析" class="headerlink" title="1. 使用 Explain 进行分析"></a>1. 使用 Explain 进行分析</h2><p>Explain 用来 <strong>分析 SELECT 查询语句</strong>，开发人员可以通过分析 Explain 结果来优化查询语句<br><strong><em>重要字段：</em></strong></p>
<ul>
<li><strong>select_type：</strong> 查询类型，有简单查询、联合查询、子查询等</li>
<li><strong> key：</strong> 使用的索引</li>
<li><strong> rows：</strong> 扫描的行数</li>
</ul>
<h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><h3 id="2-1-减少请求的数据量"><a href="#2-1-减少请求的数据量" class="headerlink" title="2.1. 减少请求的数据量"></a>2.1. 减少请求的数据量</h3><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="2-2-减少服务器端扫描的行数"><a href="#2-2-减少服务器端扫描的行数" class="headerlink" title="2.2. 减少服务器端扫描的行数"></a>2.2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id="3-重构查询方式"><a href="#3-重构查询方式" class="headerlink" title="3. 重构查询方式"></a>3. 重构查询方式</h2><h3 id="3-1-切分大查询"><a href="#3-1-切分大查询" class="headerlink" title="3.1. 切分大查询"></a>3.1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do {</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")</span><br><span class="line">} while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-分解大连接查询"><a href="#3-2-分解大连接查询" class="headerlink" title="3.2. 分解大连接查询"></a>3.2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联<br><strong><em>好处：</em></strong></p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN () 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><p><strong><em>概述：</em></strong> MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br><strong><em>隔离级别：</em></strong><br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<br>在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻读。<br><strong><em>索引：</em></strong> 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。<br><strong><em>内部优化：</em></strong> 包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。<br><strong><em>热备份：</em></strong> 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h2><p><strong><em>概述：</em></strong> 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br><strong><em>特性：</em></strong> 提供了压缩表、空间数据索引等。<br><strong><em>事务：</em></strong> 不支持事务。<br><strong><em>读写锁：</em></strong> 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。<br><strong><em>索引：</em></strong> 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ul>
<li><strong>事务：</strong> InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li>
<li><strong>并发：</strong> MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li>
<li><strong>外键：</strong> InnoDB 支持外键</li>
<li><strong>备份：</strong> InnoDB 支持在线热备份</li>
<li><strong>崩溃恢复：</strong> MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li>
<li><strong>其它特性：</strong> MyISAM 支持压缩表和空间数据索引</li>
</ul>
<h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT (11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL (18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。<br>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h2 id="4-时间和日期"><a href="#4-时间和日期" class="headerlink" title="4. 时间和日期"></a>4. 时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3 id="4-1-DATETIME"><a href="#4-1-DATETIME" class="headerlink" title="4.1. DATETIME"></a>4.1. DATETIME</h3><p><strong><em>概述：</em></strong> 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。<br><strong><em>时区：</em></strong> 与时区无关。<br>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如 “2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3 id="4-2-TIMESTAMP"><a href="#4-2-TIMESTAMP" class="headerlink" title="4.2. TIMESTAMP"></a>4.2. TIMESTAMP</h3><p><strong><em>概述：</em></strong> 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。<br><strong><em>时区：</em></strong> 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。<br>MySQL 提供了 FROM_UNIXTIME () 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP () 函数把日期转换为 UNIX 时间戳。<br><strong><em>优点：</em></strong> 比 DATETIME 空间效率更高。</p>
<h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><h2 id="1-水平切分"><a href="#1-水平切分" class="headerlink" title="1. 水平切分"></a>1. 水平切分</h2><p><strong><em>概述：</em></strong> 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。<br>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c737fd088f55ee87e034c39ac838861.png" alt="image.png"></p>
<h2 id="2-垂直切分"><a href="#2-垂直切分" class="headerlink" title="2. 垂直切分"></a>2. 垂直切分</h2><p><strong><em>概述：</em></strong> 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。<br>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9cb0ca9f7892a9d4fca291f0674da13c.png" alt="image.png"></p>
<h2 id="3-Sharding-策略"><a href="#3-Sharding-策略" class="headerlink" title="3. Sharding 策略"></a>3. Sharding 策略</h2><p><strong><em>策略：</em></strong></p>
<ul>
<li><strong>哈希取模：</strong> hash(key) % N</li>
<li><strong> 范围：</strong> 可以是 ID 范围也可以是时间范围</li>
<li><strong>映射表：</strong> 使用单独的一个数据库来存储映射关系</li>
</ul>
<p><strong><em>问题：</em></strong></p>
<ol>
<li><strong>事务问题：</strong> 使用分布式事务来解决，比如 XA 接口。</li>
<li><strong>连接：</strong> 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li>
<li><strong>ID 唯一性：</strong><ol>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ol>
</li>
</ol>
<h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><p>主要涉及三个线程： binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程：</strong> 负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程：</strong> 负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li>
<li><strong>SQL 线程：</strong> 负责读取重放日志并重放其中的 SQL 语句。</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5ebee84b776054508db67f7a9ca22bc1.png" alt="image.png"></p>
<h2 id="2-读写分离"><a href="#2-读写分离" class="headerlink" title="2. 读写分离"></a>2. 读写分离</h2><p><strong>概述：</strong> 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br><strong>优点：</strong></p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ul>
<p><strong>实现：</strong> 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a18825649461134799421b2a56728e4d.png" alt="image.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/myseries/p/10728533.html">MySQL 中的几种日志了解</a></li>
<li><a href="https://blog.csdn.net/bluishglc/column/info/sharding">数据库分库分表 (sharding)</a></li>
<li><a href="https://www.cnblogs.com/idoljames/p/11694039.html">Mysql 主从复制原理及同步延迟问题</a></li>
<li><a href="https://blog.51cto.com/6300167/2344750">mysql 主从复制延迟问题</a></li>
<li><a href="https://www.jianshu.com/p/37f54c32c93c">mysql 读写分离和解决主从同步延时问题</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis 中使用枚举</title>
    <url>/957cfc92c9ca/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在编码过程中，经常会遇到用某个数值来表示某种状态、类型或者阶段的情况，比如有这样一个枚举：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ComputerState</span> {</span><br><span class="line"></span><br><span class="line">    OPEN(<span class="number">10</span>),         <span class="comment">//开启</span></span><br><span class="line">    </span><br><span class="line">    CLOSE(<span class="number">11</span>),         <span class="comment">//关闭</span></span><br><span class="line">    </span><br><span class="line">    OFF_LINE(<span class="number">12</span>),     <span class="comment">//离线</span></span><br><span class="line">    </span><br><span class="line">    FAULT(<span class="number">200</span>),     <span class="comment">//故障</span></span><br><span class="line">    </span><br><span class="line">    UNKNOWN(<span class="number">255</span>);     <span class="comment">//未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    ComputerState(<span class="type">int</span> code) { <span class="built_in">this</span>.code = code; }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通常我们希望将表示状态的数值存入数据库，即 ComputerState.OPEN 存入数据库取值为 10。</p>
<span id="more"></span>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>首先，我们先看看 MyBatis 是否能够满足我们的需求。<br>MyBatis 内置了两个枚举转换器分别是：<code>org.apache.ibatis.type.EnumTypeHandler</code> 和 <code>org.apache.ibatis.type.EnumOrdinalTypeHandler</code>。</p>
<h2 id="EnumTypeHandler"><a href="#EnumTypeHandler" class="headerlink" title="EnumTypeHandler"></a>EnumTypeHandler</h2><p>这是默认的枚举转换器，该转换器将枚举实例转换为实例名称的字符串，即将 <code>ComputerState.OPEN</code> 转换 <code>OPEN</code>。</p>
<h2 id="EnumOrdinalTypeHandler"><a href="#EnumOrdinalTypeHandler" class="headerlink" title="EnumOrdinalTypeHandler"></a>EnumOrdinalTypeHandler</h2><p>顾名思义这个转换器将枚举实例的 ordinal 属性作为取值，即 <code>ComputerState.OPEN</code> 转换为 0，<code>ComputerState.CLOSE</code> 转换为 1。<br>使用它的方式是在 MyBatis 配置文件中定义：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com.example.entity.enums.ComputerState"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br>以上的两种转换器都不能满足我们的需求，所以看起来要自己编写一个转换器了。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>MyBatis 提供了 <code>org.apache.ibatis.type.BaseTypeHandler</code> 类用于我们自己扩展类型转换器，上面的 <code>EnumTypeHandler</code> 和 <code>EnumOrdinalTypeHandler</code> 也都实现了这个接口。</p>
<h2 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h2><p>我们需要一个接口来确定某部分枚举类的行为。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseCodeEnum</span> {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>该接口只有一个返回编码的方法，返回值将被存入数据库。</p>
<h2 id="2-改造枚举"><a href="#2-改造枚举" class="headerlink" title="2. 改造枚举"></a>2. 改造枚举</h2><p>就拿上面的 <code>ComputerState</code> 来实现 <code>BaseCodeEnum</code> 接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ComputerState</span> <span class="keyword">implements</span> <span class="title class_">BaseCodeEnum</span>{</span><br><span class="line"></span><br><span class="line">    OPEN(<span class="number">10</span>),         <span class="comment">//开启</span></span><br><span class="line">    </span><br><span class="line">    CLOSE(<span class="number">11</span>),         <span class="comment">//关闭</span></span><br><span class="line">    </span><br><span class="line">    OFF_LINE(<span class="number">12</span>),     <span class="comment">//离线</span></span><br><span class="line">    </span><br><span class="line">    FAULT(<span class="number">200</span>),     <span class="comment">//故障</span></span><br><span class="line">    </span><br><span class="line">    UNKNOWN(<span class="number">255</span>);     <span class="comment">//未知</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    ComputerState(<span class="type">int</span> code) { <span class="built_in">this</span>.code = code; }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> { <span class="keyword">return</span> <span class="built_in">this</span>.code; }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-编写一个转换工具类"><a href="#3-编写一个转换工具类" class="headerlink" title="3. 编写一个转换工具类"></a>3. 编写一个转换工具类</h2><p>现在我们能顺利的将枚举转换为某个数值了，还需要一个工具将数值转换为枚举实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeEnumUtil</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt; &amp; BaseCodeEnum&gt; E <span class="title function_">codeOf</span><span class="params">(Class&lt;E&gt; enumClass, <span class="type">int</span> code)</span> {</span><br><span class="line">        E[] enumConstants = enumClass.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (E e : enumConstants) {</span><br><span class="line">            <span class="keyword">if</span> (e.getCode() == code)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-自定义类型转换器"><a href="#4-自定义类型转换器" class="headerlink" title="4. 自定义类型转换器"></a>4. 自定义类型转换器</h2><p>准备工作做的差不多了，是时候开始编写转换器了。<br><code>BaseTypeHandler&lt;T&gt;</code> 一共需要实现 4 个方法：</p>
<ol>
<li><code>void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType)</code></li>
</ol>
<p>用于定义设置参数时，该如何把 Java 类型的参数转换为对应的数据库类型</p>
<ol start="2">
<li><code>T getNullableResult(ResultSet rs, String columnName)</code></li>
</ol>
<p>用于定义通过字段名称获取字段数据时，如何把数据库类型转换为对应的 Java 类型</p>
<ol start="3">
<li><code> T getNullableResult(ResultSt rs, int columnIndex)</code><br>用于定义通过字段索引获取字段数据时，如何把数据库类型转换为对应的 Java 类型</li>
<li><code>T getNullableResult(CallableStatement cs, int columnIndex)</code><br>用定义调用存储过程后，如何把数据库类型转换为对应的 Java 类型 </li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeEnumTypeHandler</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt; &amp; BaseCodeEnum&gt; <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;E&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeEnumTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Type argument cannot be null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, BaseCodeEnum parameter, JdbcType jdbcType)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException {</span><br><span class="line">        ps.setInt(i, parameter.getCode());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnName);</span><br><span class="line">        <span class="keyword">return</span> rs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> rs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> cs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> cs.wasNull() ? <span class="literal">null</span> : codeOf(code);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">codeOf</span><span class="params">(<span class="type">int</span> code)</span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> CodeEnumUtil.codeOf(type, code);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Cannot convert "</span> + code + <span class="string">" to "</span> + type.getSimpleName() + <span class="string">" by code value."</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h2><p>接下来需要指定哪个类使用我们自己编写转换器进行转换，在 MyBatis 配置文件中配置如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span> <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.example.typeHandler.CodeEnumTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com.example.entity.enums.ComputerState"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p> &nbsp;<br>搞定！ 经测试 <code>ComputerState.OPEN</code> 被转换为 10，<code>ComputerState.UNKNOWN</code> 被转换为 255，达到了预期的效果。</p>
<h2 id="6-优化"><a href="#6-优化" class="headerlink" title="6. 优化"></a>6. 优化</h2><p>在第 5 步时，我们在 MyBatis 中添加 typeHandler 用于指定哪些类使用我们自定义的转换器，一旦系统中的枚举类多了起来，MyBatis 的配置文件维护起来会变得非常麻烦，也容易出错。如何解决呢？<br>在 Spring 中我们可以使用 JavaConfig 方式来干预 SqlSessionFactory 的创建过程，来完成转换器的指定。</p>
<p><strong>思路</strong></p>
<ol>
<li>再写一个能自动匹配转换行为的转换器</li>
<li>通过 <code>sqlSessionFactory.getConfiguration().getTypeHandlerRegistry()</code> 取得类型转换器注册器</li>
<li>再使用 typeHandlerRegistry.setDefaultEnumTypeHandler (Class&lt;? extends TypeHandler&gt; typeHandler) 将第一步的转换器注册成为默认的</li>
</ol>
<p>首先，我们需要一个能确定转换行为的转换器：<br>AutoEnumTypeHandler.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoEnumTypeHandler</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">BaseTypeHandler</span> <span class="variable">typeHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutoEnumTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span> {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Type argument cannot be null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(BaseCodeEnum.class.isAssignableFrom(type)){</span><br><span class="line">            <span class="comment">// 如果实现了 BaseCodeEnum 则使用我们自定义的转换器</span></span><br><span class="line">            typeHandler = <span class="keyword">new</span> <span class="title class_">CodeEnumTypeHandler</span>(type);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 默认转换器 也可换成 EnumOrdinalTypeHandler</span></span><br><span class="line">            typeHandler = <span class="keyword">new</span> <span class="title class_">EnumTypeHandler</span>&lt;&gt;(type);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, E parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        typeHandler.setNonNullParameter(ps,i, parameter,jdbcType);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(rs,columnName);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(rs,columnIndex);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> (E) typeHandler.getNullableResult(cs,columnIndex);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们需要干预 <code>SqlSessionFactory</code> 的创建过程，将刚刚的转换器指定为默认的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix  = "mybatis")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">        DataSource dataSource,</span></span><br><span class="line"><span class="params">        JSONArrayHandler jsonArrayHandler,</span></span><br><span class="line"><span class="params">        JSONObjectHandler jsonObjectHandler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 设置配置文件及mapper文件地址</span></span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        factory.setConfigLocation(resolver.getResource(configLocation));</span><br><span class="line">        factory.setMapperLocations(resolver.getResources(mapperLocations));</span><br><span class="line">    </span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> factory.getObject();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取得类型转换注册器</span></span><br><span class="line">        <span class="type">TypeHandlerRegistry</span> <span class="variable">typeHandlerRegistry</span> <span class="operator">=</span> sqlSessionFactory.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">        <span class="comment">// 注册默认枚举转换器</span></span><br><span class="line">        typeHandlerRegistry.setDefaultEnumTypeHandler(AutoEnumTypeHandler.class);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... getter setter</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>搞定！ 这样一来，如果枚举实现了 <code>BaseCodeEnum</code> 接口就使用我们自定义的 <code>CodeEnumTypeHandler</code>，如果没有实现 <code>BaseCodeEnum</code> 接口就使用默认的。再也不用写 MyBatis 的配置文件了！</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统原理</title>
    <url>/abede0468156/</url>
    <content><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/14ce66fea5c132fb2889b56af226f5c9.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="2-ACID"><a href="#2-ACID" class="headerlink" title="2. ACID"></a>2. ACID</h2><h3 id="2-1-原子性（Atomicity）"><a href="#2-1-原子性（Atomicity）" class="headerlink" title="2.1. 原子性（Atomicity）"></a>2.1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p>
<h3 id="2-2-一致性（Consistency）"><a href="#2-2-一致性（Consistency）" class="headerlink" title="2.2. 一致性（Consistency）"></a>2.2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</p>
<h3 id="2-3-隔离性（Isolation）"><a href="#2-3-隔离性（Isolation）" class="headerlink" title="2.3. 隔离性（Isolation）"></a>2.3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的</p>
<h3 id="2-4-持久性（Durability）"><a href="#2-4-持久性（Durability）" class="headerlink" title="2.4. 持久性（Durability）"></a>2.4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失<br>使用重做日志来保证持久性<br><strong><em>理解：</em></strong> 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/340df236be6073235c93ec32f85bccb2.png" alt="image.png"></p>
<h2 id="3-AUTOCOMMIT"><a href="#3-AUTOCOMMIT" class="headerlink" title="3. AUTOCOMMIT"></a>3. AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。<br>如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p><strong><em>概述：</em></strong> 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题<br>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p>
<h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1. 丢失修改"></a>1. 丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5699ecb598913f47c5e996bd30467a1b.png" alt="image.png"></p>
<h2 id="2-读脏数据"><a href="#2-读脏数据" class="headerlink" title="2. 读脏数据"></a>2. 读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1e7a318bb33ae42872be8b6f981afe99.png" alt="image.png"></p>
<h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/600643f3fa1c4175a70b2e7e419dd444.png" alt="image.png"></p>
<h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4. 幻读"></a>4. 幻读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cc2dd0b4a10f306d6eb1d39200abc61c.png" alt="image.png"></p>
<h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="1-封锁粒度"><a href="#1-封锁粒度" class="headerlink" title="1. 封锁粒度"></a>1. 封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁<br>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="2-封锁类型"><a href="#2-封锁类型" class="headerlink" title="2. 封锁类型"></a>2. 封锁类型</h2><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1. 读写锁"></a>2.1. 读写锁</h3><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/26454bd0fd3a5fe1a6f848d7237335fc.png" alt="image.png"></p>
<h3 id="2-2-意向锁"><a href="#2-2-意向锁" class="headerlink" title="2.2. 意向锁"></a>2.2. 意向锁</h3><p><strong><em>概念：</em></strong> 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁。它们表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。<br><strong><em>现象：</em></strong> 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br><strong>规定：</strong></p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li>
</ul>
<p><strong><em>原理：</em></strong> 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。<br>各种锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3eed892c3a7ec589352d30f9b14fa561.png" alt="image.png"></p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁</li>
<li> S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁</li>
</ul>
<h2 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3. 封锁协议"></a>3. 封锁协议</h2><h3 id="3-1-三级封锁协议"><a href="#3-1-三级封锁协议" class="headerlink" title="3.1. 三级封锁协议"></a>3.1. 三级封锁协议</h3><p><strong><em>一级封锁协议：</em></strong><br>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁<br>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f31b55014ddb0a0a435cf553af74da2b.png" alt="image.png"><br><strong><em>二级封锁协议：</em></strong><br>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。<br>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c88864935fbcdf40bda35f48ca62f25e.png" alt="image.png"><br><strong><em>三级封锁协议：</em></strong><br>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。<br>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b258ef58d2448d4e983995c3adb129c.png" alt="image.png"></p>
<h3 id="3-2-两段锁协议"><a href="#3-2-两段锁协议" class="headerlink" title="3.2. 两段锁协议"></a>3.2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。<br>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。<br>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<blockquote>
<p>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)</p>
</blockquote>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<blockquote>
<p>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)</p>
</blockquote>
<h2 id="4-MySQL-隐式与显示锁定"><a href="#4-MySQL-隐式与显示锁定" class="headerlink" title="4. MySQL 隐式与显示锁定"></a>4. MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><p><a href="https://www.cnblogs.com/shoshana-kong/p/10516404.html">Mysql 默认的事务隔离级别为什么是可重复读</a><br><strong>1. 未提交读（READ UNCOMMITTED）</strong><br>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<p><strong>2. 提交读（READ COMMITTED）</strong><br>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<p><strong>3. 可重复读（REPEATABLE READ）</strong><br>保证在同一个事务中多次读取同样数据的结果是一样的。<br>对 update 语句进行行加锁</p>
<p><strong>4. 可串行化（SERIALIZABLE）</strong><br>强制事务串行执行。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/92baf28f1dd4b475882244d42de388b5.png" alt="image.png"></p>
<h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p><a href="https://www.jianshu.com/p/db334404d909">浅析 Mysql 的隔离级别及 MVCC</a><br>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="1-版本号"><a href="#1-版本号" class="headerlink" title="1. 版本号"></a>1. 版本号</h2><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<h2 id="2-隐藏的列"><a href="#2-隐藏的列" class="headerlink" title="2. 隐藏的列"></a>2. 隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了</li>
</ul>
<h2 id="3-Undo-日志"><a href="#3-Undo-日志" class="headerlink" title="3. Undo 日志"></a>3. Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6d8b260999c124ace1b2e329bc62ec5d.png" alt="image.png"></p>
<h2 id="4-实现过程"><a href="#4-实现过程" class="headerlink" title="4. 实现过程"></a>4. 实现过程</h2><p>以下实现过程针对可重复读隔离级别。<br>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<h3 id="4-1-SELECT"><a href="#4-1-SELECT" class="headerlink" title="4.1. SELECT"></a>4.1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。<br>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h3 id="4-2-INSERT"><a href="#4-2-INSERT" class="headerlink" title="4.2. INSERT"></a>4.2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h3 id="4-3-DELETE"><a href="#4-3-DELETE" class="headerlink" title="4.3. DELETE"></a>4.3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h3 id="4-4-UPDATE"><a href="#4-4-UPDATE" class="headerlink" title="4.4. UPDATE"></a>4.4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h2 id="5-快照读与当前读"><a href="#5-快照读与当前读" class="headerlink" title="5. 快照读与当前读"></a>5. 快照读与当前读</h2><h3 id="5-1-快照读"><a href="#5-1-快照读" class="headerlink" title="5.1. 快照读"></a>5.1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-2-当前读"><a href="#5-2-当前读" class="headerlink" title="5.2. 当前读"></a>5.2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。<br>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p><strong><em>记录索引：</em></strong> 锁定一个记录上的索引，而不是记录本身。<br>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p><strong><em>记录索引间隙：</em></strong> 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-Next-Key-Locks"><a href="#3-Next-Key-Locks" class="headerlink" title="3. Next-Key Locks"></a>3. Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, positive infinity)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h2><p>属性不可分。</p>
<h2 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h2><p>每个非主属性完全函数依赖于键码。<br>可以通过分解来满足。</p>
<h2 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h2><p>非主属性不传递函数依赖于键码。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 安装</title>
    <url>/64823704abb1/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1.安装依赖环境"></a>1. 安装依赖环境</h2><ol>
<li>安装 gcc：<code>yum install gcc-c++</code></li>
<li>安装 PCRE 库，用于解析正则表达式：<code>yum install -y pcre pcre-devel</code></li>
<li>zlib 压缩：<code>yum install -y zlib zlib-devel</code></li>
<li>SSL 安全加密套接字协议层，用于 HTTP 安全传输：<code>yum insta;; -y openssl openssl-devel</code></li>
</ol>
<span id="more"></span>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2. 安装</h2><ol>
<li><p>解压得到源码：<code>tar -zxvf nginx-1.17.8.tar.gz</code></p>
</li>
<li><p><code>mkdir /var/temp/nginx -p</code></p>
</li>
<li><p><code>cd nginx-1.17.8 </code></p>
</li>
<li><p>创建 makefile 文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定安装目录</span></span></span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># pid</span></span></span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 锁定安装文件，防止被恶意篡改或误操作</span></span></span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 错误日志</span></span></span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># http 日志</span></span></span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启用 gzip 模块，在线实时压缩输出数据流</span></span></span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设定客户端请求的临时目录</span></span></span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设定 http 代理临时目录</span></span></span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设定 fastcgi 临时目录</span></span></span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设定 uwsg 临时目录</span></span></span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设定 scgi 临时目录</span></span></span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>make 编译：<code>make</code></p>
</li>
<li><p>安装：<code>make install</code>，完毕之后在 /usr/local/ 下会产⽣⼀个 nginx ⽬录</p>
</li>
</ol>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd nginx/sbin </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动</span></span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 停止</span></span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重新加载</span></span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果在云服务器安装，需要开启默认的 nginx 端口 80</li>
<li> 如果在虚拟机安装，需要关闭防火墙</li>
<li>本地 win 或 mac 需要关闭防火墙</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 常用函数</title>
    <url>/ae293ca3b3d3/</url>
    <content><![CDATA[<h2 id="concat-str1-str2-…"><a href="#concat-str1-str2-…" class="headerlink" title="concat(str1, str2,…)"></a>concat(str1, str2,…)</h2><h2 id="date-sub-curdate-interval-7-day"><a href="#date-sub-curdate-interval-7-day" class="headerlink" title="date_sub(curdate(), interval 7 day)"></a>date_sub(curdate(), interval 7 day)</h2><span id="more"></span>
<h2 id="substring-str-start-len"><a href="#substring-str-start-len" class="headerlink" title="substring(str, start, len)"></a>substring(str, start, len)</h2><h3 id="3-1-从字符串的第-4-个字符位置开始取，直到结束"><a href="#3-1-从字符串的第-4-个字符位置开始取，直到结束" class="headerlink" title="3.1. 从字符串的第 4 个字符位置开始取，直到结束"></a>3.1. 从字符串的第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f989799d1594d6c6347f726aa6db249.png" alt="image.png"></p>
<h3 id="3-2-从字符串的倒数第-4-个字符位置开始取，直到结束"><a href="#3-2-从字符串的倒数第-4-个字符位置开始取，直到结束" class="headerlink" title="3.2 从字符串的倒数第 4 个字符位置开始取，直到结束"></a>3.2 从字符串的倒数第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0636d54c94efe5f728e072b11e5d04dc.png" alt="image.png"></p>
<h3 id="3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符"><a href="#3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符"></a>3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4aca25208e5313e87f299a38e4d2c0c4.png" alt="image.png"></p>
<h3 id="3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符"><a href="#3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符"></a>3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b3176ddb272f1050b3f9616ff715d5d.png" alt="image.png"></p>
<h2 id="substring-index-str-‘-’-2"><a href="#substring-index-str-‘-’-2" class="headerlink" title="substring_index(str, ‘>’, 2)"></a>substring_index(str, ‘&gt;’, 2)</h2><h3 id="4-1-截取第二个-‘-’-之前的所有字符"><a href="#4-1-截取第二个-‘-’-之前的所有字符" class="headerlink" title="4.1. 截取第二个 ‘.’ 之前的所有字符"></a>4.1. 截取第二个 ‘.’ 之前的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a2f362bf0cf1858e59d7096f97caf712.png" alt="image.png"></p>
<h3 id="4-2-截取倒数第二个-‘-’-之后的所有字符"><a href="#4-2-截取倒数第二个-‘-’-之后的所有字符" class="headerlink" title="4.2. 截取倒数第二个 ‘.’ 之后的所有字符"></a>4.2. 截取倒数第二个 ‘.’ 之后的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7bd62c1fcce43cc5037a59c28a74533f.png" alt="image.png"></p>
<h2 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP_CONCAT"></a>GROUP_CONCAT</h2><p>测试数据表<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f5cec81e840d7468bdc4c338f528d9c8.png" alt="image.png"><br> <br>以 product_id; 分组，把 name 字段的值打印在一行，逗号分隔 (默认) <br> SELECT id,GROUP_CONCAT(name) FROM test_brand GROUP BY product_id;<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3b8b8c51da8a0c3eb4b4fe0e2a61c970.png" alt="image.png"></p>
<ul>
<li>group_concat () 有长度限制 1024， 需要修改配置 group_concat_max_len，如果超过大小会被截断</li>
<li>排序 GROUP_CONCAT (name ORDER BY id DESC) </li>
<li>当你用 group_concat 的时候请注意，连接起来的字段如果是 int 型，一定要转换成 char 再拼起来，否则在你执行后 (ExecuteScalar 或者其它任何执行 SQL 返回结果的方法) 返回的将不是一个逗号隔开的串，而是 byte []</li>
</ul>
<h2 id="COUNT-等聚合函数"><a href="#COUNT-等聚合函数" class="headerlink" title="COUNT 等聚合函数"></a>COUNT 等聚合函数</h2><p>count 不会统计 null：</p>
<ul>
<li>count(t.aae140 = ‘390’ or null)</li>
<li>count(case when region_stat.city_num &gt; 0 and prov_stat.city_num &gt; city_stat.city_num then 1 end)</li>
</ul>
<h2 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">UNIX_TIMESTAMP(NOW(3)) * 1000</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>一文搞懂 Nginx</title>
    <url>/d8b663bf1a04/</url>
    <content><![CDATA[<ul>
<li>Tengine 下载和文档：<a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a></li>
<li>Nginx 官网和文档：<a href="http://nginx.org/">http://nginx.org</a></li>
<li> 特点：CPU 和内存占用少，并发能力强，支持 50000 个并发连接数</li>
</ul>
<p><strong>nginx 相对于 apache 的优点：</strong></p>
<ul>
<li>轻量级，同样起 web 服务，比 apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，而 apache 则是阻塞型的，在高并发下 nginx 能保持低资源低消耗高性能</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ul>
<p><strong>apache 相对于 nginx 的优点：</strong></p>
<ul>
<li>rewrite ，比 nginx 的 rewrite 强大</li>
<li>模块超多，基本想到的都可以找到</li>
<li>少 bug ，nginx 的 bug 相对较多</li>
</ul>
<p>Nginx 配置简洁，Apache 复杂<br>最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程；nginx 是异步的，多个连接（万级别）可以对应一个进程</p>
<span id="more"></span>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>conf/nginx.conf</p>
<h3 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h3><p>全局配置（events 块之前都是全局块），比如 worker 进 程的数量、错误⽇志的位置</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行用户</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user nobody;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">worker 进程数量，通常设置为和 cpu 数量相等</span></span><br><span class="line">worker_processes 1;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局错误日志</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error_log  logs/error.log  info;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pid 文件位置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid        logs/nginx.pid;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个 nginx 进程打开的最多文件描述符数目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">worker_rlimit_nofile 65535;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-events"><a href="#2-events" class="headerlink" title="2. events"></a>2. events</h3><p>主要影响 nginx 服务器与⽤户的网络连接</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">events {</span><br><span class="line">    # 参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span><br><span class="line">    # epoll 模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    use epoll;</span><br><span class="line">    # 每个 workder 进程最⼤连接数为 1024</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>单个进程最大连接数：</strong></p>
<ul>
<li>并发总数：worker_processes * worker_connections</li>
<li> 在设置了反向代理的情况下，并发总数 = worker_processes * worker_connections / 4。为什么上面反向代理要除以 4，应该说是一个经验值。</li>
<li>因为并发受 IO 约束，max_clients 的值须小于系统可以打开的最大文件数</li>
</ul>
<p><strong>可以打开的文件句柄数是多少</strong></p>
<ul>
<li>系统总限制： <code>/proc/sys/fs/file-max</code></li>
<li>当前使用句柄数：<code>/proc/sys/fs/file-nr</code></li>
<li>修改句柄数：<code>ulimit -SHn 65535</code></li>
</ul>
<p><code>–$ cat /proc/sys/fs/file-max</code>，输出：<code>97320</code><br>并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内<br>所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置，使得并发总数小于操作系统可以打开的最大文件数目</p>
<h3 id="3-http"><a href="#3-http" class="headerlink" title="3. http"></a>3. http</h3><p>配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡等<br>每个 server 可以独立对外提供服务，这样就可以实现一台主机对外提供多个 web 服务，支持三种类型的虚拟主机配置：</p>
<ul>
<li>基于 ip 的虚拟主机， （一块主机绑定多个 ip 地址）</li>
<li>基于域名的虚拟主机（servername）</li>
<li>基于端口的虚拟主机（listen 如果不写 ip 端口模式）<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http 全局配置</span></span><br><span class="line">http {</span><br><span class="line">    # 引入mime类型定义文件</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 设定日志格式</span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    # 开启高效文件传输模式</span><br><span class="line">    # 是否调用 sendfile 函数来输出文件，对于普通应用设为 on，</span><br><span class="line">    # 如果用来进行下载等应用磁盘 I/O 重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class="line">    sendfile      on;</span><br><span class="line">    # 在 linux/Unix 系统中优化 tcp 数据传输，仅在 sendfile 开启时有效</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    # 长连接超时时间，秒</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line">    # 反向代理</span><br><span class="line">    upstream myServer {</span><br><span class="line">        # weight：默认为1。weight越大，负载的权重就越大。</span><br><span class="line">        server 127.0.0.1:8080    weight=5  max_conns=800;</span><br><span class="line">        server 127.0.0.1:8081;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    # 开启 gzip 压缩</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    # 设置允许压缩的页面最小字节数，默认值是0，不管页面多大都压缩</span><br><span class="line">    # 页面字节数从 header 头的 content-length 中进行获取。</span><br><span class="line">    # 建议设置成大于2k的字节数，小于2k可能会越压越大。</span><br><span class="line">    #gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">    # 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。</span><br><span class="line">    # 例如 4 4k 代表以 4k 为单位，按照原始数据大小以 4k 为单位的 4 倍申请内存。 </span><br><span class="line">    #     4 8k 代表以 8k 为单位，按照原始数据大小以 8k 为单位的 4 倍申请内存。</span><br><span class="line">    # 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储 gzip 压缩结果。</span><br><span class="line">    #gzip_buffers 4 16k;</span><br><span class="line"></span><br><span class="line">    # 压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    #gzip_http_version 1.0;</span><br><span class="line"></span><br><span class="line">    # 压缩级别，1-10，数字越大压缩的越好，也越占用 CPU 时间</span><br><span class="line">    #gzip_comp_level 2;</span><br><span class="line"></span><br><span class="line">    # 压缩类型，默认就已经包含text/html</span><br><span class="line">    #gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line"></span><br><span class="line">    # E6及以下禁止压缩</span><br><span class="line">    #gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    # 给 CDN 和代理服务器使用</span><br><span class="line">    # 针对相同url，可以根据头信息返回压缩和非压缩副本</span><br><span class="line">    #gzip_vary on;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server 块，虚拟主机</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每个 server 可以独立对外提供服务，这样就可以实现一台主机对外提供多个web服务</span></span><br><span class="line">    server {</span><br><span class="line">        # 监听的端口</span><br><span class="line">        listen       80;</span><br><span class="line">        # 定义使用 localhost 访问。域名可以有多个，用空格隔开</span><br><span class="line">        server_name  localhost xxx.com;</span><br><span class="line"></span><br><span class="line">        # 编码集</span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        # 默认请求</span><br><span class="line">        # location URI {}    对当前路径及子路径下的所有对象都生效；</span><br><span class="line">        # location = URI {}  精确匹配指定的路径，不包括子路径；</span><br><span class="line">        # location ~ URI {} location ~* URI {}  </span><br><span class="line">        #     模式匹配URI，可使用正则表达式，区分字符大小写，*不区分字符大小写；</span><br><span class="line">        # location ^~ URI {} 禁用正则表达式</span><br><span class="line">        # 优先级：= &gt; ^~ &gt; |* &gt;  /|/dir/</span><br><span class="line">        location / {</span><br><span class="line">            proxy_pass http://myServer/;</span><br><span class="line">            # 默认的网站根目录位置</span><br><span class="line">            # root   html;</span><br><span class="line">            # 默认页</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        # ip 控制</span><br><span class="line">        location  {</span><br><span class="line">      	   deny  IP /IP段</span><br><span class="line">      	   deny  192.168.1.109;</span><br><span class="line">      	   allow 192.168.1.0/24;192.168.0.0/16;192.0.0.0/8</span><br><span class="line">      	}</span><br><span class="line"></span><br><span class="line">        # 用户认证访问</span><br><span class="line">        location ~ (.*)\.avi$ {</span><br><span class="line">                 auth_basic  "closed site";</span><br><span class="line">                 auth_basic_user_file conf/users;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        # 错误提示页面</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache's document root</span><br><span class="line">        # concurs with nginx's one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht {</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-反向代理服务器"><a href="#1-反向代理服务器" class="headerlink" title="1. 反向代理服务器"></a>1. 反向代理服务器</h3><p>浏览器设置代理服务器为正向代理。Nginx 作为反向代理服务器接收并转发请求 </p>
<ol>
<li>部署 tomcat，保持默认监听 8080 端⼝ </li>
<li>修改配置<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8987a1ed1c748ec90345cada5aa50600.png"><br>多 location 的使⽤（优先级从高到低排序）：<br>  - 精确匹配：location = /lagou {…}<br>  - 匹配路径的前缀：location ^~ /lagou {…}<br>  - 不区分⼤⼩写的正则匹配：location ~* /lagou {…}<br>  - 正则匹配：location ~ /lagou {…}<br>  - 普通路径前缀匹配：location /lagou {…}，</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/92112df4d02c36f181d30155b0be3f69.png"></p>
<h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. 负载均衡</h3><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>默认策略，每个请求按时间顺序逐⼀分配到不同的服务器，如果某⼀个服务器下线，能⾃动剔除</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> lagouServer{</span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8080</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8082</span>;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /abc {</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://lagouServer/;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>默认每⼀个负载的服务器都为 1，权重越⾼那么被分配的请求越多（⽤于服务器性能不均衡的场景） </p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> lagouServer{ </span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8080</span> weight=<span class="number">1</span>; </span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8082</span> weight=<span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>ip_hash：每个请求按照 ip 的 hash 结果分配，每⼀个客户端的请求会固定分配到同⼀个⽬标服务器处理，可以解决 session 问题 </p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> lagouServer{ </span><br><span class="line">  ip_hash;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8080</span>; </span><br><span class="line">  <span class="attribute">server</span> <span class="number">111.229.248.243:8082</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>一致性 Hash<br>ngx_http_upstream_consistent_hash 模块是⼀个第三⽅模块，需要我们下载安装后使⽤<br><a href="https://github.com/replay/ngx_http_consistent_hash">下载</a>并解压<br>分别执行以下命令：./configure —add-module=/root/ngx_http_consistent_hash-master、make、make install </p>
<ul>
<li>consistent_hash $remote_addr：可以根据客户端 ip 映射</li>
<li> consistent_hash $request_uri：根据客户端请求的 uri 映射</li>
<li> consistent_hash $args：根据客户端携带的参数进⾏映 <figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> myServer {</span><br><span class="line">	<span class="attribute">consistent_hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 静态资源处理，直接去 Nginx 服务器目录中加载</span></span><br><span class="line"><span class="section">location</span> /static/ {</span><br><span class="line">  <span class="attribute">root</span> staticData;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="底层进程机制"><a href="#底层进程机制" class="headerlink" title="底层进程机制"></a>底层进程机制</h2><p>Nginx 启动后，以 daemon 多进程⽅式在后台运⾏。包括⼀个 Master 进程和多个 Worker 进程</p>
<h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h3><ul>
<li>Master 进程：管理 worker 进程<ul>
<li>接收外界信号向各 worker 进程发送信号 (./nginx -s reload)</li>
<li> 监控 worker 进程的运⾏状态，当 worker 进程异常退出后 Master 进程会⾃动重新启动新的 worker 进程等</li>
</ul>
</li>
<li> Worker 进程：worker 进程具体处理⽹络请求，各进程互相之间是独⽴，⼀个 worker 进程处理一个请求。worke r 进程的个数是可以设置的，⼀般设置与机器 cpu 核数⼀致</li>
</ul>
<h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7dfc77419ac998684dafb6ae9b3dae53.png"></h3><ol>
<li><strong>fork worker 进程：</strong>master 进程创建之后，会建⽴好需要监听的的 socket，然后从 master 进程再 fork 出多个 worker 进程。所以所有 worker 进程的监听描述符 listenfd 在新连接到来时都变得可读</li>
<li><strong>进程锁：</strong>nginx 使⽤互斥锁来保证只有⼀个 workder 进程能够处理请求，拿到互斥锁的那个进程注册 listenfd 读事件，在读事件⾥调⽤ accept 接受该连接，然后解析、处理、返回客户端</li>
</ol>
<h3 id="3-nginx-多进程模型好处"><a href="#3-nginx-多进程模型好处" class="headerlink" title="3. nginx 多进程模型好处"></a>3. nginx 多进程模型好处</h3><ul>
<li>每个 worker 进程都是独⽴的，不需要加锁，节省开销</li>
<li>每个 worker 进程都是独⽴的，互不影响，⼀个异常结束，其他的照样能提供服务</li>
<li>多进程模型为 reload 热部署机制提供了⽀撑</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>Java 基础知识</title>
    <url>/08c0e288120b/</url>
    <content><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong><em>特点：</em></strong></p>
<ul>
<li>书写一次，到处运行</li>
<li>垃圾收集</li>
</ul>
<p><strong><em>解释执行：</em></strong> Java 源代码编译 -&gt; 字节码 -&gt; 运行时 JVM 解释器解释成机器码<br>** <em>编译执行：</em>_ _**JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行</p>
<span id="more"></span>
<h1 id="二、基本类型"><a href="#二、基本类型" class="headerlink" title="二、基本类型"></a>二、基本类型</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b9502dd3742800b03558805ba6923884.png" alt="image.png"><br><strong><em>缓存池：</em></strong><br>new Integer (123) 与 Integer.valueOf (123) 的区别在于：</p>
<ul>
<li>new Integer (123) 每次都会新建一个对象</li>
<li> Integer.valueOf (123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<p>Integer 缓存池的大小默认为 -128~127。</p>
<h1 id="三、类型转换"><a href="#三、类型转换" class="headerlink" title="三、类型转换"></a>三、类型转换</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/528d76fc2e6c56d448bb252ca0ffa01e.png" alt="image.png"><br><strong><em>float f = 3.4; 是否正确？</em></strong><br>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float) 3.4; 或者写成 float f =3.4F;<br><strong><em>short s1 = 1; s1 = s1 + 1; 有错吗？short s1 = 1; s1 += 1; 有错吗？</em></strong><br>对于 short s1 = 1; s1 = s1 + 1; 由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。<br>而 short s1 = 1; s1 += 1; 可以正确编译，因为 s1+= 1; 相当于 s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。<br><strong><em>计算：</em></strong><br>Java 中的 byte，short，char 进行计算时都会提升为 int 类型。<br>常量则不会</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> a + b; <span class="comment">// c = 3 不需强制转换</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><p><strong><em>Java 中 的 String，StringBuilder，StringBuffer 三者的区别：</em></strong></p>
<ul>
<li><strong>线程安全：</strong> StringBuilder 是 ** 线程不安全 ** 的，而 StringBuffer 是线程安全的</li>
<li><strong>运行速度：</strong>StringBuilder &gt; StringBuffer &gt; String</li>
<li><strong> 常量：</strong> String 为字符串常量，而后两者的对象是变量，是可以更改的。</li>
</ul>
<p><strong><em>String 不可变好处：</em></strong></p>
<ol>
<li><strong>hash 缓存：</strong> 可以缓存 hash 值。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li><strong>常量池：</strong> String Pool 的需要。如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li><strong>安全性</strong></li>
<li><strong>线程安全</strong></li>
</ol>
<h2 id="1-代码点与代码单元"><a href="#1-代码点与代码单元" class="headerlink" title="1. 代码点与代码单元"></a>1. 代码点与代码单元</h2><p><strong><em>代码点：</em></strong><br>指可用于编码字符集的数字，即 u+0000 等。<br>代码点可以分成 17 个代码级别，第一个代码级别称为 <strong>基本的多语言级别</strong>（U+0000 到 U+FFFF），其余的 16 个级别码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符。<br><strong><em>代码单元：</em></strong><br>char 类型用于存储代码单元，其使用 uft-16 编码来表示所有代码点。<br>对于 ** 基本的多语言级别 ** 的代码点用一个代码单元来表示，对于辅助字符用 ** 一对连续的代码单元 ** 来表示。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/591ccada8de0401e6f38f5c476ab7918.png" alt="image.png"><br>String 的 length () 方法返回的是 <strong>代码单元的数量</strong>，codePointCount () 方法返回的是代码点的数量<br><strong>所以尽量不要使用 char</strong></p>
<h2 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h2><p><strong><em>过程：</em></strong></p>
<ol>
<li>直接使用 双引号声明 出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ol>
<p><strong><em>例 1：</em></strong><br><code>String str = new String("abc"); </code><br>首先查看池中是否有相同的字符串</p>
<ol>
<li>如果有则拷贝一份放到堆中</li>
<li>如果池中没有则在堆中和常量池中都创建对象</li>
<li>然后返回堆中的地址，最后用栈中的引用 str 指向堆中的对象</li>
</ol>
<p><strong><em>例 2：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>生成常量池中的 “1” 和堆中的对象 “11”（由于没有声明 “11”，所以常量池中并没有”11”）</li>
<li>intern () 将 s3 放入常量池中<ol>
<li> jdk6 中常量池在持久代（Perm）中，所以常量池中会创建一个 “11” 的对象</li>
<li> jdk7 中常量池不在持久代中而在堆中，所以常量池中 不需要再存储一份对象了，而是直接存储堆中的引用，即指向 s3 指向的对象</li>
</ol>
</li>
<li> s4 获得常量池中的 “11”<ol>
<li>jdk6 中为新的 “11” 对象</li>
<li> jdk7 中 s4 就是指向 s3 指向的对象</li>
</ol>
</li>
<li>结论：jdk7 中 String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象</li>
</ol>
<p><strong><em>例 3：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9fd0942f4e2e52aebe91347ff34c7d10.png" alt="image.png"><br>JVM 确实对形如 String str = “javablog”; 的对象放在常量池中，但是它是在编译时做的。而 String s = str1 + str2; 是在 运行时候才能知道的，也就是说 str1 + str2 是在堆里创建的，所以结果为 false 了。str1 + “b” 等类似，在运行时才能知道，所以在堆中创建<br><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></p>
<h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><p>int[] a1 = {1, 2, 3};<br>int[] a2 = new int[5];<br>长度：a1.length<br>Arrays.copyOf：int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers , luckyNumbers .length);<br>Arrays.sort (a)：使用了优化的归并排序算法<br><strong><em>一个 Object 数组不能转换成自定义数组：</em></strong><br>即创建数组时 new 表达式中使用的元素类型。将一个 Employee [] 临时地转换成 Object [] 数组， 然后再把它转换回来是可以的，但一个从开始就是 Object [ ] 的数组却永远不能转换成 Employe [ ] 数组。<br><strong><em>自定义排序：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> {</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">String[] friends = {<span class="string">"Peter"</span>, <span class="string">"Paul"</span>, <span class="string">"Mary"</span>};</span><br><span class="line">Arrays.sort(friends, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></tbody></table></figure>
<h1 id="六、java-中的包"><a href="#六、java-中的包" class="headerlink" title="六、java 中的包"></a>六、java 中的包</h1><p>java.util 工具包<br>java.sql 数据库包<br>java.io 输入输出流包<br>java.net 网络包<br>java.lang 基础包</p>
<h1 id="七、Object-通用方法"><a href="#七、Object-通用方法" class="headerlink" title="七、Object 通用方法"></a>七、Object 通用方法</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></tbody></table></figure>
<h1 id="八、日期"><a href="#八、日期" class="headerlink" title="八、日期"></a>八、日期</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(cal.get(Calendar.YEAR));</span><br><span class="line">        <span class="comment">// 0-11</span></span><br><span class="line">        System.out.println(cal.get(Calendar.MONTH));</span><br><span class="line">        System.out.println(cal.get(Calendar.DATE));</span><br><span class="line">        System.out.println(cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        System.out.println(cal.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(cal.get(Calendar.SECOND));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Java 8</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(dt.getYear());</span><br><span class="line">        <span class="comment">// 1-12</span></span><br><span class="line">        System.out.println(dt.getMonthValue());</span><br><span class="line">        System.out.println(dt.getDayOfMonth());</span><br><span class="line">        System.out.println(dt.getHour());</span><br><span class="line">        System.out.println(dt.getMinute());</span><br><span class="line">        System.out.println(dt.getSecond());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="九、运算符"><a href="#九、运算符" class="headerlink" title="九、运算符"></a>九、运算符</h1><h2 id="1"><a href="#1" class="headerlink" title="1. =="></a>1. ==</h2><ul>
<li>对于引用类型，判断引用是否相同</li>
<li> equals () 判断引用类型值是否相同。但是 equals () 方法的默认行为是比较引用，因此自定义的类中需覆盖 equals () 方法</li>
</ul>
<h2 id="2-与"><a href="#2-与" class="headerlink" title="2. &amp;&amp; 与 ||"></a>2. &amp;&amp; 与 ||</h2><p>短路与 和 短路或</p>
<h2 id="3-移位运算符"><a href="#3-移位运算符" class="headerlink" title="3. 移位运算符"></a>3. 移位运算符</h2><ul>
<li><blockquote>
<blockquote>
<p>运算符用符号位填充高位，&gt;&gt;&gt; 运算符用 0 填充高位</p>
</blockquote>
</blockquote>
</li>
<li>1 &lt;&lt; 35 == 1 &lt;&lt; 3 == 8（int 类型只有 32 位）</li>
</ul>
<h1 id="十、输入输出"><a href="#十、输入输出" class="headerlink" title="十、输入输出"></a>十、输入输出</h1><h2 id="1-输入"><a href="#1-输入" class="headerlink" title="1. 输入"></a>1. 输入</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.Scanner</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  <span class="comment">//构造一个 Scanner 对象，并与 System.in 关联</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();  <span class="comment">//输入一整行</span></span><br><span class="line"><span class="comment">//String name = in.next();  输入一个单词，以空格为界</span></span><br><span class="line"><span class="comment">//int age = in.nextInt();  输入整数</span></span><br><span class="line"><span class="comment">//nextDouble......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.BufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">} <span class="keyword">catch</span>(IOException e){</span><br><span class="line">     e.printStackTrance();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Console</span></span><br><span class="line"><span class="type">Console</span> <span class="variable">cons</span> <span class="operator">=</span> System.console();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> cons.readLine(<span class="string">"User name:"</span>);</span><br><span class="line"><span class="type">char</span>[] passwd = cons.readPassword(<span class="string">"Password"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-文件输入输出"><a href="#2-文件输入输出" class="headerlink" title="2. 文件输入输出"></a>2. 文件输入输出</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">"C:\\mydirectory\\myfile.txt"</span>), <span class="string">"UTF-8"</span>);  <span class="comment">//反斜杠需要两个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">"myfile.txt"</span>); </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>从 0 到 1 快速搭建博客</title>
    <url>/58a80fbce4aa/</url>
    <content><![CDATA[<h1 id="为什么搭建博客"><a href="#为什么搭建博客" class="headerlink" title="为什么搭建博客"></a>为什么搭建博客</h1><ul>
<li>知识积累</li>
<li>分享</li>
<li>影响力</li>
</ul>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="静态页面生成"><a href="#静态页面生成" class="headerlink" title="静态页面生成"></a>静态页面生成</h2><p>我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。</p>
<p>像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress</p>
<p>为什么选择 hexo？主题较现代化、方便快捷<br><a href="https://github.com/hexojs/hexo">hexo github</a></p>
<span id="more"></span>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>_config.yml 里配置你的项目地址</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ccomma/ccomma.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></tbody></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多主题，这里推荐 Next 主题，因为 Next 的社区非常活跃，这就导致 Next 主题有非常多的配置和插件</p>
<p>Next 主题配置<br><a href="https://theme-next.js.org/docs/theme-settings/">Theme Settings</a></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>博客可以部署在阿里云等云服务器上，但是特地买一台服务器专门用来部署博客还是有点太浪费了。</p>
<p>以下几种方式可以免费部署静态 web 应用</p>
<ul>
<li>github pages<ul>
<li> 服务器地理位置：美国</li>
<li>推荐：push 即部署，简单快捷 </li>
<li>缺点：网络连接严重不稳定</li>
</ul>
</li>
<li> cloudflare pages<ul>
<li> 服务器地理位置：美国自家节点</li>
<li>推荐原因：速度稳定，在全球各地均有 CDN，支持从 Github/Gitlab 等平台自动部署 </li>
<li>缺点：部署速度较慢，但不算太影响</li>
</ul>
</li>
<li> Vercel<ul>
<li> 服务器地理位置：美国 AWS</li>
<li> 推荐原因：部署速度快，支持自动部署</li>
<li>缺点：被墙过一次，速度有可能出现不稳定</li>
</ul>
</li>
</ul>
<h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>hexo 能让我们更专心写博客，但即使是如此，我们还是要先使用 <code>hexo new "xxx"</code> 命令来新建文档。而我们平时的笔记可能是写在 notion、语雀、飞书上。</p>
<p>写作同步工具 <a href="https://github.com/LetTTGACO/elog">elog</a> 能让我们的在 notion、语雀、飞书上的笔记自动部署到 github 上</p>
<p>elog 会在本地创建缓存，每次同步只会增量更新，包括图片上传也是。</p>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>github pages 自带域名：xxxx.github.io，够用，但是有点 low</p>
<ul>
<li><a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520112.products-recent.ddomain.5c0234c0saWuKP#/overview">阿里云域名</a>：基本都是国内的，30+/ 年 </li>
<li><a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412">cloudflare</a>：国外域名，9.77～45 美元</li>
</ul>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1. 阿里云付费 SSL<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79690ec1537f107639504c426c7654f.png" alt="image.png"></p>
<p>2. 阿里个人测试证书，有效期 3 个月<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7abb7f515c8c087585cf82b749f58856.png" alt="image.png"></p>
<p> 3.<a href="https://letsencrypt.org/">Let’s Encrypt</a>：提供免费 TLS 证书的非营利证书颁发机构，就个人博客而言足以</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>阿里云 DNS：DNS 解析与域名服务捆绑，声誉一般</p>
<p>cloudflare：</p>
<ul>
<li>支持 CDN（国内减速）</li>
<li>自带 DDos 防御服务</li>
<li>支持解析 A、AAAA、CNAME、MX、LOC、SRV、SPF、TXT、NS、CAA、PTR、CERT、DNSKEY、DS、NAPTR、SMIMEA、SSHFP、TLSA、URI</li>
<li> 支持 DNSSEC</li>
<li> 免费版支持一部分其他地方收费的配套服务，例如 Worker，Page，访客规则</li>
</ul>
<h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>搜索引擎优化，让你的网站更好的被搜索引擎收录</p>
<p>google：<a href="https://search.google.com/search-console">https://search.google.com/search-console</a><br>bing：<a href="https://www.bing.com/webmasters">https://www.bing.com/webmasters</a><br>百度：<a href="https://ziyuan.baidu.com/site">https://ziyuan.baidu.com/site</a></p>
<p>以 google 为例：<br>登录到 Google Search Console，选择您要验证的网站。输入网址<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/060a5e066eda3911a4d4b938a91b23b3.png" alt="image.png"><br>将验证码复制到 DNS 记录中<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb3c64f775d04dc6ff8dabc1d6990035.png" alt="image.png"></p>
<h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>对网站流量访问进行分析</p>
<p>1.<a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412/web-analytics/sites">cloudflare</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39742d06912a9f134af70c3df193507.png" alt="image.png"></p>
<p>2.<a href="https://search.google.com/search-console?resource_id=sc-domain:ccomma.cn">google</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d5ef6ca57eb04a42125cc57f9f95af0.png" alt="image.png"></p>
<p>3. <a href="https://tongji.baidu.com/main/overview/10000609568/overview/index?siteId=20141034">百度统计</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bfbbe9f8eda65e69abc5b9b1074671cd.png" alt="image.png"></p>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>百度云 CDN：百度云加速分为免费版和付费版，免费版不支持 SSL 证书，海外网站也支持加速。</p>
<p>cloudflare CDN：<br>免费提供，对于国外的服务器还行，国内服务器反而减速。支持 SSL，无须备案</p>
<p>七牛云 CDN：<br>每个月可使用 10G 的免费存储量和 10G 的 CDN 流量与 100 万次的 Get 请求数，七牛云在海外也有众多加速节点，七牛云 TCP 压缩优化使网页中大图和样式等实现秒加载。但请注意使用七牛 CDN，须保证账户中有最低金额 10 元。国内必须备案，支持 SSL。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1Sp4y157br/?vd_source=8f8a2ec64a5f07bb8bf30a6ef4819025">将 Hexo 博客部署到 CloudFlare Pages 使用全球加速</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1987796?areaSource=102001.7&amp;traceId=zTjHWNtLK7p3TbHHsvayg">5 个免费的静态 Web 应用部署平台</a></li>
<li><a href="https://hqyman.cn/post/4255.html">国内外免费域名 DNS 解析推荐</a></li>
<li><a href="https://www.zhihu.com/question/342631132">如何使用 Notion 制作个人网站？</a></li>
<li><a href="https://www.cnblogs.com/wangyuehan/p/12743624.html">Notion 做个人博客的两种实现方式</a></li>
<li><a href="https://blog.ithuo.net/post/2023-11-07%2FNotion%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97">Notion 博客折腾指南</a></li>
<li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2">使用 hexo+github 搭建免费个人博客</a></li>
<li><a href="https://juejin.cn/post/7304540675668181003">语雀写作，Kubernetes 部署 ——Elog+Hexo 博客持续集成</a></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统从入门到入土①：概述</title>
    <url>/da53cb8a00c9/</url>
    <content><![CDATA[<p>深入理解计算机系统使用指南：<a href="https://book.douban.com/review/5627139/">https://book.douban.com/review/5627139/</a></p>
<h1 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1. 什么是操作系统"></a>1. 什么是操作系统</h1><p>操作系统所处的位置<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/590b181ef083493161a55fbaf2fdc3c3.png" alt="image.png"><br>硬件包括芯片、电路板、磁盘、键盘、显示器以及类似的设备。</p>
<p><strong>用户态和内核态</strong><br>多数计算机有两种运行模式：内核态和用户态。</p>
<ul>
<li>内核态：操作系统运行在内核态，具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。内核态的程序由硬件保护，防止用户试图对其进行修改。</li>
<li>用户态：软件的其余部分运行在用户态，只使用了机器指令中的一个子集。</li>
</ul>
<span id="more"></span>

<h2 id="1-1-操作系统分类"><a href="#1-1-操作系统分类" class="headerlink" title="1.1. 操作系统分类"></a>1.1. 操作系统分类</h2><ul>
<li><strong>单用户操作系统：</strong>单用户操作系统一次只能支持一个用户程序的运行。单用户操作系统向用户提供联机交互式的工作环境，比如 MS-DOS 就是一个经典的单用户操作系统。</li>
<li><strong>批处理操作系统：</strong>早期的一种大型机用操作系统。可对用户作业成批处理，期间无需用户干预，分为单道批处理系统和多道批处理系统。</li>
<li><strong>分时操作系统：</strong>利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</li>
<li><strong>实时操作系统：</strong>一个能够在指定或者确定的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统，实时意思就是对响应时间有严格要求，要以足够快的速度进行处理。分为硬实时和软实时两种。</li>
<li><strong>通用操作系统：</strong>同时兼有多道批处理、分时、实时处理的功能，或者其中两种以上功能的操作系统。</li>
<li><strong>网络操作系统：</strong>一种在通常操作系统功能的基础上提供网络通信和网络服务功能的操作系统。</li>
<li><strong>分布式操作系统：</strong>一种以计算机网络为基础的，将物理上分布的具有自治功能的数据处理系统或计算机系统互联起来的操作系统。分布式系统中各台计算机无主次之分，系统中若干台计算机可以并行运行同一个程序，分布式操作系统用于管理分布式系统资源。</li>
<li><strong>嵌入式操作系统：</strong>一种运行在嵌入式智能芯片环境中，对整个智能芯片以及它所操作、控制的各种部件装置等资源进行统一协调、处理、指挥和控制的系统软件。</li>
</ul>
<h2 id="1-2-操作系统接口"><a href="#1-2-操作系统接口" class="headerlink" title="1.2. 操作系统接口"></a>1.2. 操作系统接口</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/902ce2a4b8fbf79f5a078c45d91c759a.png" alt="image.png"><br>分为系统调用接口、POSIX 接口和领域应用接口</p>
<h3 id="1-2-1-系统调用接口"><a href="#1-2-1-系统调用接口" class="headerlink" title="1.2.1. 系统调用接口"></a>1.2.1. 系统调用接口</h3><p>应用程序通过操作系统内核提供的接口（例如系统调用）向内核申请服务。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f4de6dbc1320586c69e548b30db936f0.png" alt="image.png"><br>printf -&gt; lib 中的 write -&gt; svc 下陷到内核 -&gt; 下陷处理函数 sys_syscall 找到内核对应中对应的函数 -&gt; sys_write</p>
<h3 id="1-2-2-POSIX-接口"><a href="#1-2-2-POSIX-接口" class="headerlink" title="1.2.2. POSIX 接口"></a>1.2.2. POSIX 接口</h3><p>为了同一个应用程序在不同操作系统上的可移植性，逐渐形成了一些可移植操作系统接口标准。<br>POSIX（Portable Operating System Interface for uniX，可移植操作系统接口）。POSIX 标准通常通过 C library（libc）来实现，常见的 libc 包括 glibc、musl、eglibc。 Android 也实现了一个名为 bionic 的 libc。<br>应用程序只需要调用 libc 提供的接口就可以实现对操作系统功能的调用。</p>
<h3 id="1-2-3-领域应用接口"><a href="#1-2-3-领域应用接口" class="headerlink" title="1.2.3. 领域应用接口"></a>1.2.3. 领域应用接口</h3><p>在 POSIX 或操作系统调用的基础上还可以封装面向不同领域的领域应用接口。</p>
<h1 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2. 硬件"></a>2. 硬件</h1><h2 id="2-1-CPU"><a href="#2-1-CPU" class="headerlink" title="2.1. CPU"></a>2.1. CPU</h2><p>指令集架构（Instruction Set Architecture, ISA）是 CPU 和软件之间的桥梁。ISA 包含指令集、特权级、寄存器、执行模式、安全扩展、性能加速扩展等诸多方面。</p>
<h3 id="2-1-1-指令集"><a href="#2-1-1-指令集" class="headerlink" title="2.1.1. 指令集"></a>2.1.1. 指令集</h3><p>每个 CPU 都有一套可执行的专门 ** 指令集 **。所以，x86 处理器不能执行 ARM 程序，而 ARM 处理器也不能执行 x86 程序。</p>
<h3 id="2-1-2-特权级"><a href="#2-1-2-特权级" class="headerlink" title="2.1.2. 特权级"></a>2.1.2. 特权级</h3><p>AArch64（首款 64 位架构的 ARM 处理器）中的特权级被称为异常级别（Exception Level，EL）<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ed211bcc7bcc01fc8becc25b4b24223b.png" alt="image.png"></p>
<ul>
<li>EL0：最低的特权级，应用程序通常运行在该特权级，也称为 <strong>用户态</strong>。</li>
<li>EL1：操作系统通常运行在该特权级，也称为 ** 内核态 **。</li>
<li>EL2：在虚拟化场景下需要，虚拟机监控器（Virtual Machine Monitor，VMM）通常运行在该特权级。</li>
<li>EL3：TrustZone 是从 ARMv6 体系结构开始引入的安全特性，其从逻辑上将整个系统分为安全世界（能访问所有资源）和普通世界（不能访问安全世界的资源）。</li>
</ul>
<p>EL3 和安全特性 TrustZone 相关，负责普通世界和安全世界之间的切换。</p>
<p><strong>用户态切换至内核态的场景：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5daa365ab39433c1f7f95ea9d561b540.png" alt="image.png"></p>
<ol>
<li>应用程序执行 svc（特权调用，supervisor call）指令切换。</li>
<li>指令触发异常切换，如缺页异常。</li>
<li>CPU 收到来自外设的中断。</li>
</ol>
<p><strong>用户态切换至内核态过程：</strong><br>操作系统可以在异常向量表中为不同的异常类型配置相应的异常处理函数。</p>
<ol>
<li>发生特权级切换时，CPU 会读取 VBAR_EL1（向量基地址寄存器，Vector Base Address Register）来获得 <strong>异常向量表（exception vector table）</strong>的基地址。</li>
<li>然后根据异常原因（ESR_EL1 中保存的内容）调用操作系统设置的相应异常处理函数。</li>
<li>该函数通常会先保存应用程序的上下文（如通用寄存器），然后会根据异常原因进行相应的处理。</li>
</ol>
<p>例如，若特权级切换是应用程序执行 svc 指令导致的，则执行相应的系统调用；<br>若特权级切换是访存过程中缺页异常导致的，则执行相应的缺页异常处理函数。</p>
<ol start="4">
<li>异常处理完成之后，操作系统会恢复应用程序的上下文，然后执行 eret（异常返回，Exception Return）指令恢复 CPU 自动保存的 EL0 状态，并切回到 EL0，使应用程序从被中断处继续执行。</li>
</ol>
<p><strong>pipeline</strong><br>为了改善性能，CPU 设计师早就放弃了同时读取、解码和执行一条指令的简单模型。许多现代 CPU 具有同时 ** 取出多条指令 ** 的机制。这样的机制称为 <strong>流水线（pipeline）</strong>。<br>例如，一个 CPU 可以有单独的取指单元、解码单元和执行单元，于是当它执行指令 n 时，还可以对指令 n ＋1 解码，并且读取指令 n +2。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0cab757be7497b7484eb81ea077f99a6.png" alt="image.png"></p>
<p><strong>超标量 CPU</strong><br>超标量 CPU，有多个执行单元。两个或更多的指令被同时取出、解码并装入暂存缓冲区中，直至它们执行完毕。只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之。<br>有指令不按顺序执行的隐患。</p>
<blockquote>
<p>例如，一个 CPU 用于整数算术运算，一个 CPU 用于浮点算术运算，一个 CPU 用于布尔运算。</p>
</blockquote>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5e547a976ceee90d436a019295be0c8f.png" alt="image.png"></p>
<h3 id="2-1-3-寄存器"><a href="#2-1-3-寄存器" class="headerlink" title="2.1.3. 寄存器"></a>2.1.3. 寄存器</h3><p>用与 CPU 相同的材料制成，所以和 CPU 一样快。</p>
<h2 id="2-2-存储器"><a href="#2-2-存储器" class="headerlink" title="2.2. 存储器"></a>2.2. 存储器</h2><p>存储器分层结构<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/869cb1408042650ad093b5f8b9e5ea52.png" alt="image.png"></p>
<h3 id="2-2-2-高速缓存"><a href="#2-2-2-高速缓存" class="headerlink" title="2.2.2. 高速缓存"></a>2.2.2. 高速缓存</h3><p><strong>L1 缓存：</strong>总是在 CPU 中，用来将已解码的指令调入 CPU 的执行引擎，不存在任何延时。</p>
<p><strong>L2 缓存：</strong>用来存放近来使用过的若干兆字节的内存字，延时 1 或 2 个时钟周期。</p>
<ul>
<li>带有共享 L2 缓存的 4 核芯片（Intel）：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fdaffb91f95605d5f515bf1c43744278.png" alt="image.png"></p>
<ul>
<li>带有分离 L2 缓存的 4 核芯片（AMD）：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a96f844f844d6460c884f87fdb5fa325.png" alt="image.png"></p>
<p><strong>缓存行：</strong><br>CPU 缓存是由若干个缓存行（cache line）组成的。物理内存与 CPU 缓存之间的数据传输以缓存行为单位，一般为 64 字节。这比单个字节读取要快得多。<br>每个缓存行有一个用于表示其是否有效的有效位（valid bit）和一个用于标识其对应的物理地址的标记地址（tag address）。</p>
<p><strong>缓存命中：</strong><br>当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。</p>
<ul>
<li>命中，就不需要访问主存，命中通常需要两个时钟周期。</li>
<li>未命中就必须访问内存，这将花费大量时间。<blockquote>
<p>存储器读取某一个位置，接下来访问这个位置的概率非常高，尤其是紧随其后的内存位置。</p>
</blockquote>
</li>
</ul>
<p><strong>缓存结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f5410bebb3a5c861935545799d24673a.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4819fdb071292e7a1b549a75762fa5b3.png" alt="image.png"><br>物理地址在逻辑上分为 Tag、Set（也称为 Index）以及 Offset 三段。</p>
<blockquote>
<p>类似三维坐标中的 xyz 坐标</p>
</blockquote>
<p>组（Set）与路（Way）是 CPU 缓存的经典概念。</p>
<ul>
<li>物理地址中的 Set 段能表示的最大数目称为组。</li>
<li>同一组（即 Set 段相等）下，支持的最大 Tag 数则称为路，即同一组下的缓存行数目，该 CPU 缓存被称为 4 路组相联（4-Way Set Associative）。</li>
</ul>
<h3 id="2-2-3-主存"><a href="#2-2-3-主存" class="headerlink" title="2.2.3. 主存"></a>2.2.3. 主存</h3><ul>
<li>随机访问存储器（RAM）</li>
<li>只读存储器（ROM）：用于启动计算机的引导加载模块</li>
<li>电可擦除可编程 ROM（EEPROM） 和闪存：与 ROM 相比可以擦除和重写</li>
</ul>
<h3 id="2-2-4-磁盘"><a href="#2-2-4-磁盘" class="headerlink" title="2.2.4. 磁盘"></a>2.2.4. 磁盘</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2dd668189cb0c4710403d1fe3578022.png" alt="image.png"><br><strong>概念：</strong></p>
<ul>
<li>在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为 <strong>磁道</strong>（track）。</li>
<li>把一个给定臂的位置上的所有磁道合并起来，组成了一个 <strong>柱面</strong>（cylinder）。外部的柱面比内部的柱面有更多的扇区。</li>
</ul>
<p><strong>过程：</strong></p>
<ol>
<li>机械臂从一个柱面移到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，其具体时间取决于驱动器。</li>
<li>一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，这就增加了 5ms 至 10ms 的时延，其具体延时取决于驱动器的转速。</li>
<li>一旦所需要的扇区移到磁头之下，就开始读写，低端硬盘的速率是 50MB/s，而高速磁盘的速率是 160 MB/s。</li>
</ol>
<h3 id="2-2-5-I-O-设备"><a href="#2-2-5-I-O-设备" class="headerlink" title="2.2.5. I/O 设备"></a>2.2.5. I/O 设备</h3><ul>
<li><strong>实际设备：</strong>如 SATA（串行高级技术附件），标准化后任何一个 SATA 磁盘控制器就可以适配任一种 SATA 磁盘。</li>
<li><strong>设备控制器：</strong></li>
</ul>
<p>设备控制器是插在电路板上的一块芯片或一组芯片。它从操作系统接收命令，物理地控制设备。</p>
<blockquote>
<p>例如，从设备读数据，并且完成数据的处理。</p>
</blockquote>
<p>控制器的任务是为操作系统提供一个简单的接口（不过还是很复杂）。</p>
<blockquote>
<p>例如，磁盘控制器可以接受一个命令从磁盘 2 读出 11206 号扇区，然后，控制器把这个线性扇区号转化为柱面、扇区和磁头。</p>
</blockquote>
<ul>
<li><strong>设备驱动程序：</strong>与设备控制器交互的软件。每个控制器厂家必须为所支持的操作系统提供相应的设备驱动程序。<blockquote>
<p>例如，一台扫描仪会配有用于 OS X、Windows 7、Windows 8 以及 Linux 的设备驱动程序。</p>
</blockquote>
</li>
</ul>
<p>设备驱动器装入操作系统的三个途径：</p>
<ol>
<li>将内核与设备驱动程序重新链接，然后重启动系统。许多 UNIX 系统以这种方式工作。</li>
<li>在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启动系统。在系统启动时，操作系统去找寻所需的设备驱动程序并装载之。Windows 就是以这种方式工作。</li>
<li>操作系统能够在运行时接受新的设备驱动程序并且立即将其安装好，无须重启动系统。热插拔设备，像 USB 之类需要动态可装载设备驱动程序。</li>
</ol>
<ul>
<li><strong>I/O 端口空间：</strong></li>
</ul>
<p>每个设备控制器都有少量用于通信的寄存器。<br>要激活控制器，设备驱动程序从操作系统获得一条命令，然后翻译成对应的值，并写进设备寄存器中。所有设备寄存器的集合构成了 I/O 端口空间。</p>
<blockquote>
<p>例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数和方向（读或写）的寄存器。</p>
</blockquote>
<p><strong>内存映射 I/O（Memory-Mapped I/O MMIO）</strong><br>把输人输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。<br>CPU 可以使用和访问物理内存一样的指令去读写这些属于设备的地址。</p>
<p><strong>实现输入输出的三种方式：</strong></p>
<ul>
<li>忙等待（轮询）：</li>
</ul>
<p>用户程序发出一个系统调用，内核对设备驱动程序进行过程调用，然后设备驱动程序启动 I/O 并循环检查该设备是否完成了工作。<br>当 I/O 结束后，设备驱动程序把数据送到指定的地方并返回，然后操作系统将控制返回给调用者。<br>其缺点是要占据 CPU，CPU 一直轮询设备直到对应的 I/O 操作完成。</p>
<ul>
<li>中断：</li>
</ul>
<p>设备驱动程序启动设备，让该设备在操作完成时发出一个中断，设备驱动程序在这个时刻返回。<br>当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成，操作系统接着在需要时阻塞调用者并安排其他工作进行。</p>
<ul>
<li>直接存储器访问（DMA）芯片：</li>
</ul>
<p>可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。CPU 对 DMA 芯片进行设置，说明需要传送的字节数、有关的设备和内存地址以及操作方向，接着启动 DMA。当 DMA 芯片完成时，它引发一个中断。</p>
<p>MMIO 使得 CPU 可以主动地访问设备，中断使得设备能够主动地通知 CPU，这两种机制是 CPU 与设备之间交互的重要方式。</p>
<h3 id="2-2-6-总线"><a href="#2-2-6-总线" class="headerlink" title="2.2.6. 总线"></a>2.2.6. 总线</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/751efc320e7e6078af3fddf32b2bd3e3.png" alt="image.png"><br><strong>概述：</strong><br>系统有很多总线（例如高速缓存、内存、PCle、PCI、USB、SATA 和 DMI)，每条总线的传输速度和功能都不同。操作系统必须了解所有总线的配置和管理。其中主要的总线是 PCIe 总线。</p>
<p><strong>USB（Universal Serial Bus）：</strong><br>将所有慢速 I/O 设备（如键盘和鼠标）与计算机连接。USB 是一种集中式总线，其根设备每 1ms 轮询一次 IO 设备，看是否有信息收发。USB 1.0 可以处理总计 12Mb/s 的负载，USB 2.0 总线提速到 480 Mb/s，而 USB 3.0 能达到不小于 5Gb/s 的速率。</p>
<p><strong>SCSI（Small Computer System Interface）：</strong><br>是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上。主要用在服务器和工作站中，速度可以达到 640MB/s。</p>
<h3 id="2-2-7-启动计算机"><a href="#2-2-7-启动计算机" class="headerlink" title="2.2.7. 启动计算机"></a>2.2.7. 启动计算机</h3><p><strong>BIOS：</strong><br>基本输入输出系统（Basic Input Output System，BIOS）。<br>在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 IO 以及其他过程。<br>现在这个程序存放在一块闪速 RAM 中，它是非易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p>
<p><strong>BIOS 的运行过程：</strong><br>在计算机启动时，BIOS 开始运行。</p>
<ol>
<li>首先检查所安装的 RAM 数量，键盘和其他基本设备是否已安装并正常响应。</li>
<li>接着，开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。</li>
</ol>
<p>也会记录即插即用设备。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。</p>
<ol start="3">
<li>根据存储在 CMOS 存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个 BIOS 配置程序，对设备清单进行修改。</li>
</ol>
<p>如果存在 CD-ROM（有时是 USB），则系统试图从中启动，如果失败，系统将从硬盘启动。</p>
<ol start="5">
<li>启动设备上的第一个扇区，被读入内存并执行。这个扇区中包含一个检查分区表的程序，以确定哪个分区是活动的。</li>
<li>然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动。</li>
<li>然后，操作系统询问 BIOS，以获得配置信息。系统检查每个设备对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的 CD-ROM。</li>
<li>一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或 GUI。</li>
</ol>
<p><strong>即插即用（plug and play）：</strong><br>每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。</p>
<blockquote>
<p>例如，键盘的中断级别是 1，并使用 0x60 至 0x64 的 I/O 地址，<br>软盘控制器是中断 6 级并使用 Ox3F0 至 0x3F7 的 I/O 地址，<br>而打印机是中断 7 级并使用 0x378 至 0x37A 的 I/O 地址等。</p>
</blockquote>
<p>如果有一块声卡和调制解调卡，都是使用中断 4，它们就会冲突。必须得在每块 I/O 卡上提供 DIP 开关或跳接器，并指导用户对其进行设置去选择中断级别和 I/O 地址才能解决冲突。</p>
<p>即插即用让系统能自动地收集有关 I/O 设备的信息，集中赋予中断级别和 I/O 地址，然后通知每块卡所使用的数值。计算机启动时 BIOS 会记录所有的设备，如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。</p>
<h1 id="3-系统相关"><a href="#3-系统相关" class="headerlink" title="3. 系统相关"></a>3. 系统相关</h1><h2 id="3-1-文件系统"><a href="#3-1-文件系统" class="headerlink" title="3.1. 文件系统"></a>3.1. 文件系统</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7be685d0842f095478c4a8ec5d133368.png" alt="image.png"><br><strong>进程树和文件树的区别：</strong></p>
<ul>
<li>一般进程的树状结构层次不深（很少超过三层），而文件树状结构的层次常常多达四层、五层或更多层。</li>
<li>进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在数年之久。</li>
<li>所有权及保护：只有父进程能控制和访问子进程，而在文件和目录能使其他用户也可以访问。</li>
</ul>
<p><strong>文件描述符：</strong><br>在读写文件之前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作 <strong>文件描述符（file descriptor）</strong>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p>
<p><strong>安装文件系统：</strong><br>UNIX 允许把光盘上的文件系统接到主文件树上。mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3bd18a1e7aeb83e60b48cac26d32224.png" alt="image.png"></p>
<p>装配文件系统将使得装配目录中已有的任何文件都不可访问，因此装配点通常都是空的。<br>但是，系统管理人员可能需要将某些位于被装配目录中的非常重要的文件复制到装配点，使得他们在进行设备检查或修理时，可以在紧急事件中的普通路径上找到这些文件。</p>
<p><strong>特殊文件：</strong><br>提供特殊文件是为了使 I/O 设备看起来像文件一般。I/O 设备也可通过同样的系统调用进行读写。<br>按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如， <code>/dev/lp</code> 是打印机。</p>
<ul>
<li><strong>块特殊文件：</strong>指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第 4 块，程序可以直接访问设备的第 4 块而不必考虑存放该文件的文件系统结构。</li>
<li><strong>字符特殊文件：</strong>用于打印机、调制解调器和其他接收或输出字符流的设备。</li>
</ul>
<p><strong>管道：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4db296dab3b41db38c8ce5363f902b6b.png" alt="image.png"><br>管道（pipe）是一种虚文件，它可连接两个进程。如果进程 A 和 B 希望通过管道对话，它们必须提前设置该管道。</p>
<p>当进程 A 想对进程 B 发送数据时，它把数据写到管道上，进程 B 可以通过读该管道而得到数据。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p>
<p>若进程想发现它所写入的输出文件不是真正的文件而是管道，则需要使用特殊的系统调用。</p>
<h1 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h1><p><strong>read 系统调用：</strong><br>它的调用由 C 程序完成，方法是调用一个与该系统调用名称相同的库过程 read。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">count = read(fd, buffer,nbytes);</span><br></pre></td></tr></tbody></table></figure>
<p>调用过程如下<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b9c383ffb4292b3281fd9169719d85d.png" alt="image.png"></p>
<h2 id="4-1-进程管理"><a href="#4-1-进程管理" class="headerlink" title="4.1. 进程管理"></a>4.1. 进程管理</h2><table>
<thead>
<tr>
<th><strong>进程管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> pid = fork()</td>
<td> 创建与父进程相同的子进程</td>
</tr>
<tr>
<td> pid = waitpid(pid, &amp;statloc, options)</td>
<td> 等待一个子进程终止</td>
</tr>
<tr>
<td> s = execve(name, argv, environp)</td>
<td>execve () 系统调用的作用是运行另外一个指定的程序。它会把新程序加载到当前进程的内存空间内，当前的进程会被丢弃，它的堆、栈和所有的段数据都会被新进程相应的部分代替，然后会从新程序的初始化代码和 main 函数开始运行。同时，进程的 ID 将保持不变。<br><br>execve () 系统调用通常与 fork () 系统调用配合使用。从一个进程中启动另一个程序时，通常是先 fork () 一个子进程，然后在子进程中使用 execve () 变身为运行指定程序的进程。</td>
</tr>
<tr>
<td>exit(status)</td>
<td> 终止进程执行并返回状态</td>
</tr>
</tbody></table>
<p>pid：进程的 id</p>
<p><strong>fork：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define TRUE 1</span></span><br><span class="line"></span><br><span class="line">/*一直循环下去*/</span><br><span class="line">while (TRUE) {</span><br><span class="line">    /*在屏幕上显示提示符*/</span><br><span class="line">    type_prompt();</span><br><span class="line">    /*从终端读取输入*/</span><br><span class="line">    read_command(command, parameters);</span><br><span class="line">    </span><br><span class="line">    /* 派生子进程 */</span><br><span class="line">    if(fork() != 0) {</span><br><span class="line">        /* 父代码 */</span><br><span class="line">        /*等待子进程退出*/</span><br><span class="line">        waitpid(-1, &amp;status, 0);</span><br><span class="line">    } else {</span><br><span class="line">        /* 子代码 */</span><br><span class="line">        /* 执行其他命令 */</span><br><span class="line">        execve(command, parameters, 0)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>父进程从终端读取命令，创建一个子进程，等待该子进程执行命令。</p>
<ol>
<li>父进程执行 waitpid 系统调用来等待子进程结束，直至子进程终止。</li>
</ol>
<p>waitpid 参数：</p>
<ul>
<li>waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个老的子进程。</li>
<li>在 waitpid 完成之后，将把第二个参数 statloc 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。</li>
<li>有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立即返回。</li>
</ul>
<ol start="2">
<li>子进程通过使用 execve 系统调用执行用户的命令。这个系统调用会引起其整个核心映像被一个文件所替代，该文件由第一个参数给定。</li>
</ol>
<p>execve 参数：</p>
<ul>
<li>name：要执行的文件名称。如 <code>cp</code></li>
<li>argv：指向变量数组的指针。传入命令的参数</li>
<li> environp：指向环境数组的指针</li>
</ul>
<p><strong>进程存储空间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c4e8e2382c2444687c3d06817d09d4e6.png" alt="image.png"><br>在 UNIX 中的进程将其存储空间划分为三段：<strong>正文段</strong>（如程序代码）、<strong>数据段</strong>（如变量）以及 <strong>堆栈段</strong>。数据向上增长而堆栈向下增长。</p>
<h2 id="4-2-文件管理"><a href="#4-2-文件管理" class="headerlink" title="4.2. 文件管理"></a>4.2. 文件管理</h2><table>
<thead>
<tr>
<th><strong>文件管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> fd = open(file, how, …)</td>
<td> 打开一个文件供读、写或两者</td>
</tr>
<tr>
<td> s = close(fd)</td>
<td> 关闭一个打开的文件</td>
</tr>
<tr>
<td> n = read(fd, buffer, bnytes)</td>
<td> 把数据从一个文件读到缓冲区中</td>
</tr>
<tr>
<td> n= write(fd, buffer, nbytes)</td>
<td> 把数据从缓冲区写到一个文件中</td>
</tr>
<tr>
<td> position = lseek(fd, offset, whence)</td>
<td> 移动文件指针</td>
</tr>
<tr>
<td> s = stat(name, &amp;buf)</td>
<td> 取得文件的状态信息</td>
</tr>
</tbody></table>
<p>fd：文件描述符<br>n：字节数<br>position：在文件中的偏移量</p>
<p><strong>open：</strong><br>使用 open 打开文件返回文件描述符，然后可使用返回的文件描述符进行读写操作。接着可以用 close 关闭文件。</p>
<p><strong>lseek：</strong><br>每个文件有一个指向文件当前位置的指针。在顺序读（写）时，该指针通常指向要读出（写入）的下一个字节。<br>lseek 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p>
<h2 id="4-3-目录管理"><a href="#4-3-目录管理" class="headerlink" title="4.3. 目录管理"></a>4.3. 目录管理</h2><table>
<thead>
<tr>
<th><strong>目录和文件系统管理</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> s = mkdir(name, mode)</td>
<td> 创建一个新目录</td>
</tr>
<tr>
<td> s = rmdir(name)</td>
<td> 删去一个空目录</td>
</tr>
<tr>
<td> s = link(name1, name2)</td>
<td> 创建 — 个新目录项 name2，并指向 name1</td>
</tr>
<tr>
<td>s = unlink(name)</td>
<td> 删去一个目录项</td>
</tr>
<tr>
<td> s = mount(special, name, flag)</td>
<td> 安装一个文件系统</td>
</tr>
<tr>
<td> s = umount(special)</td>
<td> 卸载一个文件系统</td>
</tr>
</tbody></table>
<p><strong>link：</strong><br>允许同一个文件以两个或多个名称出现</p>
<p>在 UNIX 中，每个文件都有唯一的编号，即 <strong>i - 编号</strong>，用以标识文件。该 i - 编号是对 i - 节点表格的一个引用，它们一一对应，说明该文件的拥有者、磁盘块的位置等。</p>
<p>目录就是一个包含了（i - 编号，ASCII 名称）集合的文件。link 所做的只是利用某个已有文件的 i - 编号，创建一个新目录项（也许用一个新名称）。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/13120eed179bb298fadd9b6213436b73.png" alt="image.png"><br>上图两个目录项有相同的 i - 编号（70)，从而指向同一个文件。如果使用 unlink 系统调用将其中一个文件移走了，可以保留另一个。</p>
<p>如果两个都被移走了，UNIX 00 看到尚且存在的文件没有目录项，就会把该文件从磁盘中移去。</p>
<h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4. 其他"></a>4.4. 其他</h2><table>
<thead>
<tr>
<th><strong>杂项</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调用</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td> s = chdir(dirname)</td>
<td> 改变工作目录</td>
</tr>
<tr>
<td> s = chmod(name, mode)</td>
<td> 修改一个文件的保护位</td>
</tr>
<tr>
<td> s = kill(pid, signal)</td>
<td> 发送信号给一个进程</td>
</tr>
<tr>
<td> seconds =time(&amp;seconds)</td>
<td> 自 1970 年 1 月 1 日起的流逝时间</td>
</tr>
</tbody></table>
<p>seconds：流逝时间</p>
<h1 id="5-操作系统结构"><a href="#5-操作系统结构" class="headerlink" title="5. 操作系统结构"></a>5. 操作系统结构</h1><h2 id="5-1-策略和机制"><a href="#5-1-策略和机制" class="headerlink" title="5.1. 策略和机制"></a>5.1. 策略和机制</h2><p>策略表示要做什么，机制表示该怎么做。<br>有时会出现一个进程有多个子进程，每个子进程可能实现不同的功能（计算分析，访问磁盘等），并具有不同的优先级。这就要求调度程序需要从用户进程中获取调度决策信息。</p>
<p>将调度算法以某种形式参数化，而参数可以由用户进程填写。这样便使得策略和机制分离，算法由底层实现，而用户进程可以设置参数来对其进行调整。<br>假设内核使用优先级调度算法，并提供一条可供进程设置优先级的系统调用，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。</p>
<h2 id="5-2-内核结构"><a href="#5-2-内核结构" class="headerlink" title="5.2. 内核结构"></a>5.2. 内核结构</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/312f99ce48aa5ad6ba301199402cc63f.png" alt="image.png"></p>
<h3 id="5-2-1-简要结构（单体）"><a href="#5-2-1-简要结构（单体）" class="headerlink" title="5.2.1. 简要结构（单体）"></a>5.2.1. 简要结构（单体）</h3><p>整个操作系统在内核态以单一程序的方式运行。整个操作系统以过程集合的方式编写，链接成一个大型可执行二进制程序。</p>
<p>使用这种技术，系统中每个过程可以自由调用其他过程，只要后者提供了前者所需要的一些有用的计算工作。调用任何一个你所需要的过程或许会非常高效。</p>
<p>但上千个可以不受限制地彼此调用的过程常常导致系统笨拙且难于理解。并且，任何一个过程的崩溃都会连累整个系统。</p>
<p><strong>结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cd380e424a2d459ac19ceab59d67fa32.png" alt="image.png"><br>对于这类操作系统的基本结构，需要如下结构：</p>
<ol>
<li>需要一个主程序，用来处理服务过程请求。</li>
<li>需要一套服务过程，用来执行系统调用。</li>
<li>需要一套实用过程，用来辅助服务过程。</li>
</ol>
<p>每一个系统调用都通过一个服务过程为其工作并运行之。要有一组实用程序来完成一些服务过程所需要用到的功能，如从用户程序取数据等。</p>
<h3 id="5-2-2-宏内核"><a href="#5-2-2-宏内核" class="headerlink" title="5.2.2. 宏内核"></a>5.2.2. 宏内核</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/491287cf15c1f944680853bd043f4d52.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/84bad2763dcb858b305543c2b2542986.png" alt="image.png"><br>THE 操作系统结构，底层保证基础功能，上层依赖底层</p>
<blockquote>
<p>注：让我想起了七层网络模型</p>
</blockquote>
<h3 id="5-2-3-微内核"><a href="#5-2-3-微内核" class="headerlink" title="5.2.3. 微内核"></a>5.2.3. 微内核</h3><p>在宏内核架构下，所有内核模块均运行在特权空间，一个单点的错误就可能会导致整个系统崩溃或者被攻破。<br>为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有微内核运行在内核态，其余的模块由于功能相对弱些，则作为普通用户进程运行。</p>
<p><strong>优点：</strong><br>由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。所以，音频驱动中的错误会使声音断续或停止，但是不会使整个计算机垮掉。</p>
<p><strong>使用场景：</strong><br>通常桌面操作系统并不使用微内核。微内核在实时、工业、航空以及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。</p>
<h3 id="5-2-4-客户端-服务器模式"><a href="#5-2-4-客户端-服务器模式" class="headerlink" title="5.2.4. 客户端-服务器模式"></a>5.2.4. 客户端 - 服务器模式</h3><p>客户端 - 服务器模式将进程划分为两类</p>
<ul>
<li><strong>服务器：</strong>每个服务器提供某种服务</li>
<li><strong>客户端：</strong>使用这些服务。</li>
</ul>
<p>通常，在系统最底层是微内核，但并不是必须这样。客户端 - 服务器模式的本质是存在客户端进程和服务器进程。</p>
<p><strong>消息通信：</strong><br>客户端和服务器之间的通信是消息传递。为了获得一个服务，客户端进程构造段消息，并将其发给合适的服务器。该服务器完成工作，发送回应。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f2d774d2e4a167de32b95d9501fb6175.png" alt="image.png"><br>一个普遍方式是运行在不同计算机上的客户端和服务器，通过局域网或广域网连接。<br>其内部细节对客户端来说是屏蔽的。所以，客户端 - 服务器模式是一种可以应用在单机或者网络机器上的抽象。</p>
<h3 id="5-2-5-虚拟机"><a href="#5-2-5-虚拟机" class="headerlink" title="5.2.5. 虚拟机"></a>5.2.5. 虚拟机</h3><p><strong>虚拟机监控程序：</strong><br>VM/370 系统<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b48fee8fcee4ccbc80d43fc246d00625.png" alt="image.png"><br>这个系统的核心被称为 <strong>虚拟机监控程序（virtual machine monitor）</strong>，它在裸机上运行并且具备了多道程序功能<br>该系统向上层提供了若干台虚拟机。每台虚拟机都与裸机相同，所以不同的虛拟机可以运行不同的操作系统。</p>
<p><em>CMS：</em><br>在早期的 VM/370 系统上，有一些系统运行 OS/360 或者其他大型批处理或事务处理操作系统，而另一些虚拟机运行单用户、交互式系统供分时用户使用，这个系统称为 <strong>会话监控系统（Conversational Monitor System,CMS）</strong>。</p>
<p><em>系统调用：</em><br>当一个 CMS 程序执行系统调用时，该调用被陷入到其虚拟机的操作系统上。<br>CMS 然后发出硬件 I/O 指令读出虛拟磁盘或其他需要执行的调用。这些 I/O 指令由 VM/370 陷入并完成指令。通过对多道程序功能和提供扩展机器二者的完全分离，每个部分都变得非常简单、非常灵活且容易维护。</p>
<p><strong>第一类与第二类虚拟机管理程序：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a5e7937f43820fcebaf697e622ad0f7d.png" alt="image.png"><br><em>区别：</em><br>第二类虚拟机管理程序利用 <strong>宿主操作系统（host operatingsystem）</strong>并通过其文件系统创建进程、存储文件等。它从 CD-ROM 安装盘中读入供选择的 <strong>客户操作系统（guestoperating system）</strong>，并安装在一个虚拟盘上，该盘实际上只是宿主操作系统的文件系统中的一个大文件。</p>
<p>第一类虚拟机管理程序没有底层（宿主操作系统）支持，所以必须在原始的硬盘分区上自行管理储存。</p>
<h3 id="5-2-6-外壳"><a href="#5-2-6-外壳" class="headerlink" title="5.2.6. 外壳"></a>5.2.6. 外壳</h3><p>与虚拟机克隆真实机器不同，另一种策略是对机器进行分区，即给每个用户整个资源的一个子集。</p>
<p>外核的任务是为虚拟机分配资源，确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统从入门到入土③：内存管理</title>
    <url>/e9eb9f4d0df9/</url>
    <content><![CDATA[<h1 id="1-无存储器抽象"><a href="#1-无存储器抽象" class="headerlink" title="1. 无存储器抽象"></a>1. 无存储器抽象</h1><p>早期大型计算机（20 世纪 60 年代之前）、小型计算机（20 世纪 70 年代之前）和个人计算机（20 世纪 80 年代之前）都没有存储器抽象。<strong>每一个程序都直接访问物理内存。</strong></p>
<blockquote>
<p>例如：<code>MOV REGISTER1, 1000</code>，计算机会将位置为 1000 的物理内存中的内容移到 REGISTER1 中。</p>
</blockquote>
<span id="more"></span>

<p><strong>问题 1：保护</strong></p>
<ol>
<li>如果用户程序可以寻址内存的每个字节，就可以很容易地破坏操作系统，从而使系统慢慢地停止运行。</li>
<li>想要同时运行多个程序是很困难的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容。</li>
</ol>
<p><strong>保护键：</strong></p>
<blockquote>
<p>对比：与锁的性质类似</p>
</blockquote>
<p>IBM 360 的早期模型是这样运行多个程序的</p>
<ul>
<li>每一个内存单元都会被分配一个 4 位的保护键，保护键存储在 CPU 的特殊寄存器中。</li>
<li>每一个进程有一个 PSW（Program Status Word，程序状态字），PSW 中保存一个 4 位的码。</li>
</ul>
<p>保护键作为进程和其相关内存的唯一标识。在访问内存的时候，首先查看进程的 PSW 码和这个内存块的保护键是否相同。如果相同就可以访问，如果不同，就禁止该进程访问。因为只有操作系统才能修改保护键，这样就避免了不同程序之间的相互访问。</p>
<p><strong>问题 2：重定位</strong><br>跳转指令跳转的地址是物理地址，多个程序运行时会出现问题。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fc710c94029dbb4af262853ac5447f69.png" alt="image.png"><br>a 和 b 为两个程序，依次装载到内存后如 c 所示，b 中的 JMP28 应该跳转至地址 16412，但实际却是跳转到了 28，原因就在于这两个程序中的地址都是绝对物理地址。</p>
<p><strong>静态重定位：</strong><br> IBM 360 对上述问题的补救方案是静态重定位。只要在装载程序的时候给每一个程序地址加上装载时的地址偏移量就可以了，例如 b 程序被装载到地址 16384，那么 JMP 28 加上偏移量 16384 就行了。<br>但是这个机制会减慢装载速度，而且装载器需要区分地址和常数，所以程序需要提供区分信息。</p>
<h1 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2. 地址空间"></a>2. 地址空间</h1><p>地址空间是进程可用于寻址内存的一套地址集合，其为程序创造了一种抽象的内存。每个进程都有唯一的专属地址空间，这就使得每个程序内代码中的地址也是唯一的（如上述 JMP 28  的物理地址也有别于别的程序的 28）。</p>
<h2 id="2-1-基址寄存器与界限寄存器"><a href="#2-1-基址寄存器与界限寄存器" class="headerlink" title="2.1. 基址寄存器与界限寄存器"></a>2.1. 基址寄存器与界限寄存器</h2><p>使用动态重定位，把每个进程的私有地址空间映射到物理内存的不同部分。<br>早期计算机（Intel 8088、CDC 6600 等）使用基址寄存器与界限寄存器实现：</p>
<ul>
<li>程序装载到内存中连续的空闲位置且无须重定位。</li>
<li>进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中，根据起始点和长度就能确定一段唯一的地址。</li>
</ul>
<p>每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。<br>同时，它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超过了界限，会产生错误并中止访问。</p>
<p><strong>缺点：</strong><br>每次访问内存都需要进行加法和比较运算，加法运算由于进位传递时间的问题会比较慢。</p>
<blockquote>
<p>对比：静态重定位</p>
</blockquote>
<h2 id="2-2-交换技术"><a href="#2-2-交换技术" class="headerlink" title="2.2. 交换技术"></a>2.2. 交换技术</h2><blockquote>
<p>针对内存超载的处理方法</p>
<ul>
<li>交换：把一个进程完整调入内存运行一段时间然后把它存回磁盘。</li>
<li>虚拟内存</li>
</ul>
</blockquote>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0fbe4c1e07dbdc1d9eb13dd9d4252b02.png" alt="image.png"><br>开始时内存中只有进程 A。之后创建进程 B 和 C 或者从磁盘将它们换入内存。之后 A 被交换到磁盘，然后 D 被调入，B 被调出，最后 A 再次被调入。<br>由于 A 的位置发生变化，所以在它换入的时候通过软件或者在程序运行期间通过硬件对其地址进行重定位。例如，基址寄存器和界限寄存器就适用于这种情况。</p>
<p><strong>数据增长：</strong><br>如果进程的数据段可增长（动态分配内存）<br>若其与一个空闲区相邻，可把该空闲区分配给该进程。<br>若其与另一个进程相邻，则要么把该进程移到一个空间足够大的地方，要么把其他进程交换出去以生成一个足够大的空闲区（交换区满了就只能挂起了）。</p>
<p>另一种方法是进程进入内存时分配一些额外的内存。</p>
<h2 id="2-3-空闲内存管理"><a href="#2-3-空闲内存管理" class="headerlink" title="2.3. 空闲内存管理"></a>2.3. 空闲内存管理</h2><p>在动态分配内存时，操作系统必须对其进行管理。<br>有两种方法跟踪内存使用情况：位图和空闲区链表。</p>
<h3 id="2-3-1-位图存储管理"><a href="#2-3-1-位图存储管理" class="headerlink" title="2.3.1. 位图存储管理"></a>2.3.1. 位图存储管理</h3><p>内存被划分成几个字到几千字节的分配单元，每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cb159ef29f82477ef771ee7bf69cfd53.png" alt="image.png"></p>
<blockquote>
<p>a) 内存：有 abcde 5 个进程和 3 个空闲区<br>b) 内存对应的位图<br>c) 空闲区链表形式</p>
</blockquote>
<p><strong>缺点：</strong><br>在决定把一个占 k 个分配单元的进程调入内存时，存储管理器必须搜索位图找出有 k 个连续 0 的串，这比较耗时，因为在位图中该串可能跨越字的边界。</p>
<h3 id="2-3-2-链表存储管理"><a href="#2-3-2-链表存储管理" class="headerlink" title="2.3.2. 链表存储管理"></a>2.3.2. 链表存储管理</h3><p>维护一个记录已分配内存段和空闲内存段的链表。<br>链表中的每一个结点都包含以下字段：空闲区或进程的指示标志、起始地<br>址、长度和指向下一结点的指针。</p>
<p><strong>分配内存算法：</strong></p>
<ol>
<li>首次适配：存储管理器搜索链表，找到足够大的空闲区，并将其分为两部分，一部分供进程使用，另一部分形成新的空闲区。</li>
<li>下次适配：和首次适配类似，每次找到合适的空闲区都记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索。</li>
<li>最佳适配：搜索整个链表，找到最小适配的空闲区。最佳适配算法会生成大量无用的小空闲区，比首次适配算法浪费更多的内存。</li>
<li>最差适配：与最佳相反，总是分配最大的空闲区，使新的空闲区比较大从而可以继续使用</li>
<li>快速适配：为常用大小的空闲区维护单独的链表。例如，一个链表第一个节点指向大小近似为 4KB 的空闲链表表头的指针，第二个指向 8KB 的，第三个指向 12KB 的……</li>
</ol>
<p>如果进程和空闲区维护各自的链表，那么算法速度能得到提高，但是链表维护成本也增加了。可以对空闲区列表排序提高最佳适配算法的检索速度</p>
<h1 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h1><blockquote>
<p>对比：<a href="#lJuAx">交换</a></p>
</blockquote>
<p>每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作<strong>页面（page）</strong>。 每一页有连续的地址范围。</p>
<ul>
<li>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。</li>
<li>当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</li>
</ul>
<h2 id="3-1-分页"><a href="#3-1-分页" class="headerlink" title="3.1. 分页"></a>3.1. 分页</h2><p>页面是由虚拟地址空间分割成的块，其在物理内存中对应的单元称为<strong>页框（page frame）</strong>，页面和页框大小通常是一样的。RAM 和磁盘之间的交换是以页面为单元进行的。</p>
<p><strong>虚拟地址：</strong><br>当程序执行指令 <code>MOV REG, 1000</code> 时，它把地址为 1000 的内存单元的内容复制到 REG 中。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>由程序产生的这些地址称为<strong>虚拟地址（virtual address）</strong>，它们构成了一个<strong>虚拟地址空间（virtual addressspace）</strong>。</p>
<ul>
<li>在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字。</li>
<li>在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到<strong>内存管理单元（Memory Management Unit, MMU）</strong>，MMU 把虚拟地址映射为物理内存地址。</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/092e1c73d5b99a606760bf2c77fc1a58.png" alt="image.png"></p>
<p><strong>MMU 映射机制：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79a2a7a5bc5e46d068d10f3f1e63116.png" alt="image.png"></p>
<ul>
<li>假如程序访问地址 0：<code>MOV REG, 0</code></li>
</ul>
<p>将虚拟地址 0 送到 MMU。MMU 发现虚拟地址在页面 0（0k<del>4k），其映射到页框 2（8k</del>12k），所以把地址变换为 8192 并把变换后的地址送到总线上。</p>
<ul>
<li>假如程序访问了一个未映射的页面：<code>MOV REG, 32780</code></li>
</ul>
<p>MMU 发现虚拟页面 8（32k-36k）没有被映射，于是使 CPU 陷入到操作系统，这个陷阱称为 ** 缺页中断 ** 或 ** 缺页错误（page fault） **。<br>随后操作系统找到一个不常使用的页框并把它的内容写入磁盘，然后把需要访问的页面读到该页框中，修改映射关系，再重新启动引起陷阱的指令。</p>
<p><strong>MMU 内部结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/00b9fa96cf01785079039c2a723adddf.png" alt="image.png"><br>这是 64kb 虚拟内存的 MMU 结构，第一列为页框号，第二列表示是否存在物理内存的映射关系。<br>输入的 16 位虚拟地址。前 4 位为页号，可以表示 16 个页面；后 12 位为偏移量。</p>
<ul>
<li>第二列为 0，则说明不存在物理内存的映射关系，这将引起一个陷阱。</li>
<li>第二列为 1，则将页表中查到的页框号复制到输出寄存器的高 3 位中，再加上虚拟地址的低 12 位，就构成了 15 位的物理地址，将其送到内存总线。</li>
</ul>
<p><strong>页表：</strong><br>页表的目的是把虚拟页面映射为页框。<br>页表每一项称为页表项<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/82a69ef8b9d229a38b91499e1c6de756.png" alt="image.png"></p>
<ul>
<li>页框号：通过映射要获得的值，与低位虚拟地址结合组成物理地址。</li>
<li>“在 / 不在” 位：判断是否有页框号，如果不存在则会引起一个缺页中断。</li>
<li>保护位：指出一个页允许什么类型的访问，读、写、执行等。</li>
<li>修改位：在写入一页时由硬件自定设置修改位。</li>
<li>访问位：页面被访问时设置访问位。不再被使用的页面会在缺页中断时被重新选择。</li>
<li>高速缓存禁止位：用于禁止高速缓存</li>
</ul>
<p><strong>缺页中断过程：</strong></p>
<ol>
<li><strong>陷入内核。</strong>硬件陷入内核，在堆栈中保存程序计数器。再启动一个汇编代码例程保存通用寄存器和其他易失的信息。</li>
<li><strong>得到虚拟页面。</strong>操作系统发现缺页中断，得到需要的虚拟页面，通常在硬件寄存器中。</li>
</ol>
<p>若没有，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。</p>
<ol start="3">
<li><strong>检查地址。</strong>检查这个虚拟地址是否有效，并检查存取与保护是否一致。</li>
</ol>
<p>如果存取与保护不一致，向进程发出一个信号或杀掉该进程。</p>
<ol start="4">
<li><strong>选择页框。</strong>如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。</li>
</ol>
<p>如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。</p>
<ol start="5">
<li><strong>写回脏页框。</strong>如果选择的页框被修改过（脏的），则将该页写回磁盘。</li>
</ol>
<p>并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。<br>该页框被标记为忙，以免因为其他原因而被其他进程占用。</p>
<ol start="6">
<li><p><strong>装入磁盘地址。</strong>一旦页框是干净的（本就是干净的或写回磁盘后变干净），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。</p>
<blockquote>
<p>该页面正在被装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</p>
</blockquote>
</li>
<li><p><strong>恢复状态。</strong>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。</p>
</li>
</ol>
<p>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。</p>
<ol start="8">
<li><strong>恢复进程。</strong>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。</li>
</ol>
<p>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。</p>
<p><strong>策略和机制分离：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/97adbcd53bb76f090983e69f0c6cea49.png" alt="image.png"><br>出现缺页中断：</p>
<ol>
<li>缺页中断处理程序找出需要哪个虚拟页面，并发送一条消息给外部页面调度程序告诉它发生了什么问题。</li>
<li>外部页面调度程序从磁盘中读入所需的页面，把它复制到自己的地址空间的某一位置。然后告诉缺页中断处理程序该页面的位置。</li>
<li>缺页中断处理程序从外部页面调度程序的地址空间中清除该页面的映射，然后请求 MMU 处理程序把它放到用户地址空间的正确位置，随后就可以重新启动用户进程了。</li>
</ol>
<h2 id="3-2-TLB"><a href="#3-2-TLB" class="headerlink" title="3.2. TLB"></a>3.2. TLB</h2><p>虚拟地址到物理地址的映射必须非常快。<br>分页机制使得程序需要访问页表，从而更加频繁的访问内存。<br>程序每条指令进行一两次或更多页表访问是必要的。如果执行一条指令需要 1ns，页表查询必须在 0.2 ns 之内完成。</p>
<p>由于大多数程序总是对少量的页面进行多次访问，所以可以为计算机设置一个缓存。</p>
<p><strong>概述：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/90113bce50b23988a7ac326a0509e061.png" alt="image.png"><br>此方案为计算机设置一个 <strong>转换检测缓冲区（Translation Lookaside Buffer，TLB，也称快表）</strong>，将虚拟地址直接映射到物理地址，而不必再访问页表。<br>它通常在 MMU 中，包含少量的表项（一般不超过 256 个），这些字段与页表中的一致，有效位表示该表项是否有效。</p>
<p>程序将虚拟地址放入 MMU 中进行转换时，硬件首先会通过虚拟页面号在 TLB 中寻找匹配：</p>
<ol>
<li>能找到且操作不违反保护位则直接返回，违反保护位则产生一个保护错误。</li>
<li>若找不到则会进行正常的页表查询，将查询得到的新项替代 TLB 中的一个淘汰项。新项的所有字段都被复制到 TLB，淘汰项的会将修改位复制会内存里对应的页表项中。</li>
</ol>
<p><strong>未命中情况：</strong></p>
<ul>
<li>访问非法地址：程序可能访问了一个非法地址，系统会产生段错误，不需要往 TLB 中添加映射。</li>
<li>软失效：TLB 失效但内存页表未失效，这时只需更新一下 TLB 就行，不需要产生磁盘 I/O。</li>
<li>硬失效：TLB 失效且内存页表失效，引发缺页中断。<ul>
<li>次要缺页错误：页面可能就在内存中，但未记录在该进程的页表里。</li>
</ul>
</li>
</ul>
<p>比如该页面可能已由其他进程从硬盘中调入内存，这时只需要把所需的页面正确映射到页表中就行。</p>
<ul>
<li>严重缺页错误：页面不在内存中，需要从硬盘中重新调入。</li>
</ul>
<p><strong>硬件采用简单的 TLB 管理方式，就能够获得较高的 TLB 命中率的原因：</strong><br>应用程序在运行过程中访问内存的模式具有时间局部性和空间局部性。</p>
<ul>
<li>时间局部性：被访问过一次的内存位置在未来通常会被多次访问。</li>
<li>空间局部性：如果一个内存位置被访问，那么其附近的内存位置通常在未来也会被访问。</li>
</ul>
<p><strong>软件 TLB 管理：</strong><br>TLB 表项被操作系统显式地装载。</p>
<ol>
<li>当 TLB 访问失效时，不再是由 MMU 到页表中查找并取出需要的页表项，而是生成一个 TLB 失效并将问题交给操作系统解决。</li>
<li>系统找到该页面，然后从 TLB 中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。当然，所有这一切都必须在有限的几条指令中完成，因为 TLB 失效比缺页中断发生得更加频繁。</li>
</ol>
<p>使用软件处理 TLB 失效时，需先在内存中找到页表，以定位到页表项。<br>但是页表也有自己的虚拟地址，就像查询其他虚拟地址一样，获取页表的物理地址时也会出现 TLB 失效。</p>
<h3 id="3-2-1-TLB-刷新"><a href="#3-2-1-TLB-刷新" class="headerlink" title="3.2.1. TLB 刷新"></a>3.2.1. TLB 刷新</h3><p>由于 TLB 是使用虚拟地址进行查询的，所以操作系统在进行页表切换（应用程序切换）的时候需要主动刷新 TLB。</p>
<p><strong>标签：</strong><br>若在切换应用程序的过程中刷新 TLB，当应用程序开始执行时会发生 TLB 未命中的情况。<br>一种为 TLB 缓存项打上 “标签” 的设计避免了这样的开销。AArch64 体系结构提供了 ASID（ Address Space IDentifier）功能，x86-64 上对应的功能称为（PCID, Process Context IDentifier）。</p>
<p>操作系统可以为不同的应用程序分配不同的 ASID 作为应用程序的身份标签，再将这个标签写入应用程序的页表基地址寄存器中的空闲位（如 TTBRO_ EL1 的高 16 位）。<br>同时，TLB 中的缓存项也会包含 ASID 这个标签，从而使得 TLB 中属于不同应用程序的缓存项可以被区分开。因此，在切换页表的过程中，操作系统不再需要清空 TLB 缓存项。</p>
<h2 id="3-3-针对大内存的页表"><a href="#3-3-针对大内存的页表" class="headerlink" title="3.3. 针对大内存的页表"></a>3.3. 针对大内存的页表</h2><p>如果虚拟地址空间很大，页表也会很大。<br>假设页面大小为 4kb，32 位的地址空间将有 100 万表项，每个进程都需要自己的页表。</p>
<h3 id="3-3-1-多级页表"><a href="#3-3-1-多级页表" class="headerlink" title="3.3.1. 多级页表"></a>3.3.1. 多级页表</h3><p>引入多级页表的原因是避免把全部页表一直保存再内存中。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ea5f80ecf748133e669860571ef9ae6c.png" alt="image.png"><br>如 a) 所示，32 位地址被划分为 10 位的 PT1 域、10 位的 PT2 域、12 位的 Offset 偏移量域。<br>因为偏移量是 12 位，所以页面大小是 212 = 4KB。10 位的 PT1 和 10 位的 PT2 一共 20 位，所以共有 220 个页面。</p>
<p>当一个虚拟地址被送到 MMU 时，首先提取 PT1 域将其作为顶级页表的索引。<br>因为整个 4GB（232 B = 4GB）虚拟地址空间已经按 4KB 大小分块，所以顶级页表中这 1024 个表项的每一个都表示 4M（PT2 的 10 位和偏移量的 12 位，222B = 4M）的块地址范围。</p>
<p>顶级页表的表项 0 指向程序正文的页表，表项 1 指向数据的页表，表项 1023 指向堆栈的页表。</p>
<h3 id="3-3-2-倒排页表"><a href="#3-3-2-倒排页表" class="headerlink" title="3.3.2. 倒排页表"></a>3.3.2. 倒排页表</h3><p>实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项。</p>
<p>虽然倒排页表节省了大量的空间，但从虚拟地址到物理地址的转换会变得很困难。<br>当进程 n 访问虛拟页面 p 时，硬件不能把 p 当作指向页表的一个索引来查找物理页框，必须搜索整个倒排页表来查找某一个表项（n，p），而且每一个内存访问操作都要执行一次。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/448fc4313215b1bea76c49137f20252c.png" alt="image.png"><br>解决办法是使用 TLB。如果 TLB 能够记录所有频繁使用的页面，地址转换就可能变<br>得像通常的页表一样快。<br>但是，当发生 TLB 失效时，需要用软件搜索整个倒排页表。可以建立一张散列表，用虚拟地址来散列，相同散列值的虚拟页面被链接在一起。 <br>如果散列表中的槽数与机器中物理页面数一样多，那么散列表的冲突链的平均长度将会是 1 个表项的长度，这将会大大提高映射速度。一旦页框号被找到，新的（虚拟页号，物理页框号）对就会被装载到 TLB 中。</p>
<h2 id="3-4-页面置换算法"><a href="#3-4-页面置换算法" class="headerlink" title="3.4. 页面置换算法"></a>3.4. 页面置换算法</h2><p>缺页中断时，操作系统必须在内存中选择一个页面将其换出内存。<br>如果换出的页面在内存驻留期间被修改过，就必须把它写回磁盘；否则直接淘汰就行了。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ab0c544f905e42850e96d56a9776fa23.png" alt="image.png"></p>
<h3 id="3-4-1-最优算法"><a href="#3-4-1-最优算法" class="headerlink" title="3.4.1. 最优算法"></a>3.4.1. 最优算法</h3><p>缺页中断发生时，下一条指令的那个页面将很快被访问，其他页面则可能要到 10、100 或 1000 条指令后才会被访问，所以每个页面都可以用其被访问前要执行的指令数作为标记。</p>
<p>最优页面置换算法规定应该置换标记最大（最晚执行）的页面。这样，下次调入这个页面发生的缺页中断就会被推迟。</p>
<p>但是当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。<br>当然，通过先在仿真程序上运行程序，跟踪所有页面的访问情况，然后在第二次运行时利用第一次收集的信息是可以实现最优页面置换算法的。</p>
<p>必须清楚以上方法只针对刚刚被测试过的程序和它的一个特定的输入。虽然这个方法对评价其他页面置换算法很有用，但它在实际系统中却不能使用。</p>
<h3 id="3-4-2-最少使用算法"><a href="#3-4-2-最少使用算法" class="headerlink" title="3.4.2. 最少使用算法"></a>3.4.2. 最少使用算法</h3><p>系统为每一个页面设置了 R/M 位。</p>
<ul>
<li>当页面被访问时设置 R 位。当启动一个进程时，将其所有的页面的这两个位都设为 0，R 位定期清 0（比如在时钟中断时）</li>
<li>当页面被写入时设置 M 位。</li>
</ul>
<p>当发生缺页中断时，操作系统检查所有的页面并根据它们当前的 R 位和 M 位，有以下几种情况：</p>
<ol>
<li>未被访问，未被修改。</li>
<li>未被访问，已被修改。（可能时钟中断导致 R 位清 0）</li>
<li>已被访问，未被修改。</li>
<li>已被访问，已被修改。</li>
</ol>
<p>NRU（Not Recently Used，最近未使用）算法优先淘汰未被访问的页面，若待选页面的访问位一致，则优先淘汰未被修改的页面。<br>其原理是在最近一个时钟滴答中淘汰一个没有被访向的已修改页面要比淘汰一个被频繁使用未修改页面好。</p>
<h3 id="3-4-3-先进先出算法"><a href="#3-4-3-先进先出算法" class="headerlink" title="3.4.3. 先进先出算法"></a>3.4.3. 先进先出算法</h3><p>由操作系统维护一个内存中的页面链表，最新进入的页面放在表尾，最早进入的页面放在表头。<br>当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。FIFO 可能会淘汰常用页面，由于这一原因，很少使用纯粹的 FIFO 算法。</p>
<h3 id="3-4-4-第二次机会算法"><a href="#3-4-4-第二次机会算法" class="headerlink" title="3.4.4. 第二次机会算法"></a>3.4.4. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去。所以我们可以给经常使用的页面一次 “机会”。<br>第二次机会（second chance）算法在 FIFO 的基础上，只淘汰未被访问的页面。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f711b7fff1c0ac76753a40479bdb8f2.png" alt="image.png"><br>对 FIFO 做修改，淘汰表头时先检查其 R 位。</p>
<ul>
<li>如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉</li>
<li>如果 R 位是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续搜索。</li>
</ul>
<h3 id="3-4-5-时钟算法"><a href="#3-4-5-时钟算法" class="headerlink" title="3.4.5. 时钟算法"></a>3.4.5. 时钟算法</h3><blockquote>
<p>对比 <a href="#cIq6z">第二次机会算法</a>、<a href="#ruPN1">先进先出算法</a></p>
</blockquote>
<p>第二次机会算法经常要在链表中移动页面，既降低了效率又不是很有必要。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/84944403fb0bf8c54ae1f7bd3197f319.png" alt="image.png"><br>时钟算法把所有的页面保存再一个环形链表中（顺时针），一个指针指向最先进入的页面，代表表头。</p>
<p>当发生缺页中断时，检查指针指向的页面的 R 位：</p>
<ul>
<li>若 R = 0：淘汰该页面，将新的页面替换该页面，指针向后移动一位</li>
<li>若 R = 1：将该页面的 R 位清 0，将指针指向下个节点，继续以上流程判断节点的 R 位。</li>
</ul>
<h3 id="3-4-6-最近最少使用算法"><a href="#3-4-6-最近最少使用算法" class="headerlink" title="3.4.6. 最近最少使用算法"></a>3.4.6. 最近最少使用算法</h3><blockquote>
<p>对比 <a href="#ejVd3">最少使用算法</a></p>
</blockquote>
<p>当缺页中断发生时，置换未使用时间最长的页面，这个策略被称为 LRU（Least Recently Used）。</p>
<p>需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问内存都必须要更新整个链表。</p>
<p><strong>NFU（Not Frequently Used，最不常用）算法：</strong><br>将每个页面与一个软件计数器关联，计数器的初值为 0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的 R 位加到它的计数器上。<br>这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。</p>
<p><strong>老化（aging）算法：</strong><br>修改 NFU 以模拟 LRU，在 R 位被加进之前先将计数器右移一位，然后将 R 位加到计数器最左端的位位，这样最近被访问的页面的计数器（例如 10000000）会比之前访问过的要大（例如 00000010）。发生缺页中断时置换计算器值最小的页面。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/411fc5d1851db93b0dec9282f198896d.png" alt="image.png"><br>图中页面内存的是计数器。<br>假设在第一个时钟后，页面 0 ~ 5 的 R 位值分别是 101011。即在时钟 0 到 1 期间，访问了页面 0、2、4、5，它们的 R 位设置为 1。对应的 6 个计数器在经过移位并把 R 位插入其左端后的值，如 a) 页面中的计数器所示。</p>
<h3 id="3-4-7-工作集算法"><a href="#3-4-7-工作集算法" class="headerlink" title="3.4.7. 工作集算法"></a>3.4.7. 工作集算法</h3><p>一个进程当前正在使用的页面的集合称为它的 <strong>工作集</strong>。</p>
<ul>
<li>如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断。</li>
<li>若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度也会变得很缓慢。</li>
</ul>
<p>设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了，该方法称为 ** 工作集模型 **</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/639ebbeb3e9c243d558065f686e1ff7e.png" alt="image.png"></p>
<h3 id="3-4-8-工作集时钟算法"><a href="#3-4-8-工作集时钟算法" class="headerlink" title="3.4.8. 工作集时钟算法"></a>3.4.8. 工作集时钟算法</h3><p>当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。</p>
<p><strong>WSClock</strong>（工作集时钟）算法基于时钟算法，并且使用了工作集信息，由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4d3a995bf746854cabf7612da8e96272.png" alt="image.png"><br>每次缺页中断时，首先检查指针指向的页面。</p>
<ul>
<li>如果 R 位为 1，那么该页面在当前时钟滴答中就被使用过，不适合被淘汰。把 R 位设为 0，然后指针指向下一个页面，并重复该算法。如 a) b)。</li>
<li>如果页面的生存时间大于 r 并且该页面未被修改，它就不在工作集中，并且在磁盘上有一个有效的副本。申请此页框，并把新页面放在其中。如 c) d)。</li>
<li>如果此页面被修改过，就不能立即申请页框，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。<blockquote>
<p>原则上，所有的页面都有可能因为磁盘 I/O 在某个时钟周期被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p>
</blockquote>
</li>
</ul>
<h1 id="4-分页系统中的设计问题"><a href="#4-分页系统中的设计问题" class="headerlink" title="4. 分页系统中的设计问题"></a>4. 分页系统中的设计问题</h1><h2 id="4-1-局部分配与全局分配"><a href="#4-1-局部分配与全局分配" class="headerlink" title="4.1. 局部分配与全局分配"></a>4.1. 局部分配与全局分配</h2><p>运行多个进程时发生缺页中断，该如何进行页面置换？</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b5a66a2a41a6a9c6c4869087deb8c3fa.png" alt="image.png"><br>A、B、C 是正在运行的进程，加入 A 发生了缺页中断，有两种方法</p>
<ol>
<li>局部页面置换：淘汰该进程生存时间最短的页面（A5）</li>
<li>全局页面置换：淘汰内存中生存时间最短的页面（B3）。通常情况下工作得比局部算法好</li>
</ol>
<h2 id="4-2-负载控制"><a href="#4-2-负载控制" class="headerlink" title="4.2. 负载控制"></a>4.2. 负载控制</h2><p>即使是使用最优页面置换算法并对进程采用理想的全局页框分配，系统也可能会发生页面频繁置换的情况。</p>
<p>一个方法是将一部分进程<a href="#lJuAx">交换</a>到磁盘，并释放他们所占有的所有页面。</p>
<h2 id="4-3-共享页面"><a href="#4-3-共享页面" class="headerlink" title="4.3. 共享页面"></a>4.3. 共享页面</h2><p>只读的页面（程序文本）可以共享，数据页面不能共享。</p>
<p>共享页面上存在一个问题，假设进程 A 和进程 B 同时运行一个编辑器并共享页面。如果调度程序决定从内存中移走 A，撤销其所有的页面并用一个其他程序来填充这些空的页框，则会引起 B 产生大量的缺页中断，才能把这些页面重新调入。</p>
<p><strong>写时拷贝：</strong><br>UNIX 中 fork 系统调用后，父进程和子进程要共享程序文本和数据。</p>
<ol>
<li>让这些进程分别拥有它们自己的页表，但都指向同一个页面集合。</li>
<li>一旦某个应用程序对该内存区域进行修改，就会触发缺页异常。这里的缺页异常是由于违反权限导致的，不同于之前所说的换页机制下的缺页异常是由于未映射导致的。</li>
<li>在触发了缺页异常后，CPU 同样会将控制流传递给操作系统预先设置的缺页异常处理函数。</li>
<li>在该函数中，操作系统会发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的。</li>
</ol>
<p>于是，操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。</p>
<p>若其中一个进程更新了数据，就会触发只读保护，并引发操作系统陷阱，生成一个该页的副本，这样每个进程都有自己的专用副本。<br>这种策略意味着那些从来不会执行写操作的页面是不需要复制的，只有实际修改的数据页面需要复制。</p>
<p><strong>内存去重：</strong><br>操作系统可以定期地扫描相同内容的物理页，找到其映射的虚拟页，然后只保留其中一个物理页。<br>并将具有相同内容的其他虚拟页都用写时拷贝的方式映射到这个物理页，然后释放其他的物理页以供将来使用。</p>
<p>内存去重功能会对应用程序访存时延造成影响。当应用程序写一个被去重的内存页时，既会触发缺页异常，又会导致内存拷贝，从而可能导致性能下降。</p>
<blockquote>
<p>时间换空间</p>
</blockquote>
<h2 id="4-4-共享库"><a href="#4-4-共享库" class="headerlink" title="4.4. 共享库"></a>4.4. 共享库</h2><p>现代操作系统中，有很多大型库被众多进程使用。一个更加通用的技术是使用 <strong>共享库</strong>（在 Windows 中称作 <strong>DLL</strong> 或 ** 动态链接库 **）。</p>
<p>当链接一个程序时，要在链接器的命令中指定一个或多个目标文件，可能还包括一些库文件。链接器会在库中寻找未定义外部函数，找到了则将它们加载到可执行二进制文件中。<br>静态链接上百个这些库的程序会浪费大量的磁盘空间，装载这些程序时也会浪费大量的内存空间。<br>当一个程序和共享库链接时，链接器没有加载被调用的函数，而是加载了一小段能够在运行时绑定被调用函数的存根例程（stub routine）。如果其他程序已经装载了某个共享库，就不用再次装载了。</p>
<h1 id="5-分段"><a href="#5-分段" class="headerlink" title="5. 分段"></a>5. 分段</h1><p>对许多问题来说，有多个独立的地址空间会好得多。<br>只使用一个虚拟空间时，我们需要管理表的扩张和收缩。<br>如果一个程序中变量的数量要远比其他部分的数量多时的情况。地址空间中分给符号表的块可能会被装满，但这时其他表中还有大量的空间。</p>
<p><strong>段：</strong><br>可以在及其上提供多个互相独立的逻辑段地址空间，每个段之间都是隔离的。<br>每个段由一个从 0 到最大的地址序列构成。段的长度可以是 0 到某个允许的最大值之间的任何一个值。不同段的长度通常情况下也都不相同，并在运行期间长度可变。</p>
<p>如果每个过程都位于一个独立的段中并且起始地址是 0，那么把单独编译好的过程链接起来的操作就可以得到很大的简化。</p>
<p>程序必须提供两部分地址，一个段号和 一个段内地址。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a73916e01c1798ff10b6cb9566e3b8e6.png" alt="image.png"></p>
<h1 id="6-内存分配"><a href="#6-内存分配" class="headerlink" title="6. 内存分配"></a>6. 内存分配</h1><h2 id="6-1-伙伴系统"><a href="#6-1-伙伴系统" class="headerlink" title="6.1. 伙伴系统"></a>6.1. 伙伴系统</h2><p>伙伴系统（buddy system）的基本思想是将物理内存划分成连续的块，以块作为基本单位进行分配。不同块的大小可以不同，但每个块都由一个或多个连续的物理页组成，物理页的数量必须是 2 的 n 次幂。</p>
<p><strong>分裂与合并：</strong><br>在处理分配请求的过程中，大的块可以分裂成两个小一号的块，这两个块互为伙件。分裂得到的块可以继续分裂，直到得到一个大小合适的块去服务相应的分配请求。<br>在一个块被释放后，分配器会找到其伙伴块，若伙伴块也处于空闲的状态，则将这两个伙伴块进行合并，形成一个大一号的空闲块，然后继续尝试向上合并。由于分裂操作和合并操作都是级联的，因此能够很好地缓解外部碎片的问题。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统从入门到入土④：文件系统</title>
    <url>/80c9e654e499/</url>
    <content><![CDATA[<p>文件是进程创建的信息逻辑单元，每个文件是独立于其他文件的，是对磁盘的建模，而非对 RAM 的建模。<br>如果能把每个文件看成一个地址空间，那么就能理解文件的本质了。</p>
<span id="more"></span>
<h1 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h1><p>文件是一种抽象机制，它提供了一种在磁盘上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘工作方式等有关细节。</p>
<h2 id="1-1-文件结构"><a href="#1-1-文件结构" class="headerlink" title="1.1. 文件结构"></a>1.1. 文件结构</h2><p>字节序列：<br>操作系统所见到的就是字节。把文件看成字节序列为操作系统提供了最大的灵活性。用户程序可以向文件中加入任何内容，并以任何方便的形式命名。</p>
<p>记录序列：<br>文件是具有固定长度记录的序列，每个记录都有其内部结构。<br>读操作返回一个记录，而写操作重写或追加一个记录。</p>
<p>树：<br>按 key 排序，可对特定 key 进行快速查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/65d091a49e4597962d304520c5c9d67d.png" alt="image.png"></p>
<h2 id="1-2-文件访问"><a href="#1-2-文件访问" class="headerlink" title="1.2. 文件访问"></a>1.2. 文件访问</h2><p><strong>顺序访问（sequential access）：</strong><br>进程在这些系统中可从头按顺序读取文件的全部字节或记录，但不能跳过某一些内容。<br>顺序访问文件是可以返回到起点的，需要时可多次读取该文件。在存储介质是磁带而不是磁盘时，顺序访问文件是很方便的。</p>
<p><strong>随机访问（random access file）：</strong><br>当用磁盘来存储文件时，可以不按顺序读取文件，或者也可以按照关键字来访问记录。这种能够以任何次序读取其中字节或记录的文件称作随机访问文件。 </p>
<p>如订票程序必须能直接访问该航班记录，而不必先读出其他航班的成千上万个记录。有两种方法可以指示从何处开始读取文件。</p>
<ul>
<li>一种是每次 read 操作都给出开始读文件的位置。</li>
<li>另种是用一个特殊的 seek 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。</li>
</ul>
<h1 id="2-文件系统的实现"><a href="#2-文件系统的实现" class="headerlink" title="2. 文件系统的实现"></a>2. 文件系统的实现</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/03309c8ff0e13ecd6dbca1884b53adb0.png" alt="image.png"><br><strong>主引导记录（Master Boot Record, MBR）：</strong><br>文件系统存放在磁盘上，划分为多个分区，每个分区中都有独立的文件系统。<br>磁盘的 0 号扇区称为主引导记录，用来引导计算机。</p>
<p><strong>分区表：</strong><br>在 MBR 的结尾是分区表。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。</p>
<p><strong>引导块（boot block）：</strong><br>在计算机被引导时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一个块，称为引导块，并执行之。引导块中的程序将装载该分区中的操作系统。<br>为统一起见， 每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统。不过，未来这个分区也许会有一个操作系统的。</p>
<p><strong>超级块（superblock）：</strong><br>超级块包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。<br>超级块中的信息包括：确定文件系统类型用的魔数、文件系统中块的数量等</p>
<h2 id="2-1-文件的实现"><a href="#2-1-文件的实现" class="headerlink" title="2.1. 文件的实现"></a>2.1. 文件的实现</h2><p>文件存储实现的关键问题是：如何记录文件用到哪些磁盘块。</p>
<h3 id="2-1-1-连续分配"><a href="#2-1-1-连续分配" class="headerlink" title="2.1.1. 连续分配"></a>2.1.1. 连续分配</h3><p>把每个文件作为一串连续数据块存储在磁盘上。<br>在块大小为 1KB 的磁盘上，50KB 的文件要分配 50 个连续的块。<br>在块大小为 2KB 的磁盘上，50KB 的文件要分配 25 个连续的块。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9d2d137aa665f2c49fb1186ed6343ae1.png" alt="image.png"><br>初始状态下，磁盘是空的。接着，从磁盘开始处（块 0）开始写入长度为 4 块的文件 A。紧接着，在文件 A 的结尾开始写入一个 3 块的文件 B。</p>
<p>每个文件都从一个新的块开始，这样如果文件 A 实际上只有 3.5 块，那么其最后一块的结尾会浪费一些空间。</p>
<p><strong>缺点：</strong><br>随着时间的推移，磁盘会变得零碎。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2fde8879d2d9fcab6b8095b4f21aedd5.png" alt="image.png"><br>假设删除 D 和 F，会在磁盘上留下一堆空闲块。磁盘不会填充空闲块，因为会涉及之后的所有文件。</p>
<p>磁盘被充满后，要么压缩磁盘，要么重新使用空洞所在的空闲空间。前者由于代价太高而不可行。后者需要维护一个空洞列表，但是在当创建一个新的文件时，就必须得知道该文件的最终大小，这是不可理喻的。</p>
<p>但这个办法在 CD-ROM 上是可行的并被广泛使用。在 CD-ROM 上所有文件的大小都是已知的，并在后续使用中它们的大小也不会改变。<br>所以如果文件的大小已知且不会改变，那么连续分配是一种好方法。</p>
<h3 id="2-1-2-链表分配"><a href="#2-1-2-链表分配" class="headerlink" title="2.1.2. 链表分配"></a>2.1.2. 链表分配</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/604bbbe0e74a4b222b595328b5c6f165.png" alt="image.png"><br>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。</p>
<p><strong>优点：</strong></p>
<ul>
<li>链表分配可以充分利用每个磁盘块。不会因为磁盘碎片而浪费存储空间。</li>
<li>在目录项中，只需要存放第一块的磁盘地址，文件的其他块就可以从这个首块地址查找到。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>随机访问相当缓慢。要获得块 n，操作系统每一次都必须从头开始，并且要先读前面的 n - 1 块。</li>
<li>由于指针占去了一些字节，每个磁盘块存储数据的字节数不再是 2 的整数次幂。怪异的大小降低了系统的运行效率，因为许多程序都是以长度为 2 的整数次幂来读写磁盘块的。</li>
</ul>
<p>由于每个块的前几个字节被指向下一个块的指针所占据，所以要读出完整的一个块大小的信息，就需要从两个磁盘块中获得和拼接。</p>
<h3 id="2-1-3-采用内存中的表进行链表分配"><a href="#2-1-3-采用内存中的表进行链表分配" class="headerlink" title="2.1.3. 采用内存中的表进行链表分配"></a>2.1.3. 采用内存中的表进行链表分配</h3><p>如果取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决使用链表的两个不足。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/260adba8d2976d1deaeeca52a9fd7c6c.png" alt="image.png"><br>内存中的这样一个表格称为 <strong>文件分配表（File Allocation Table, FAT）</strong>。</p>
<ul>
<li>文件 A 依次使用了磁盘块 4、7、2、10、12。</li>
<li>文件 B 依次使用了磁盘块 6、3、11、14。</li>
<li>这两个链都以一个不属于有效磁盘编号的特殊标记 -1 结束。</li>
</ul>
<p>因为整个链都存放在内存中，所以不需要任何磁盘引用，随机访问变得也容易了。</p>
<p><strong>缺点：</strong><br>必须把整个表都存放在内存中。<br>若磁盘大小为 1TB，块大小为 1KB，那么这张表需要有 10 亿项。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 内存。<br>上述方法并不实用，FAT 的管理方式不能较好地扩展并应用于大型磁盘中。</p>
<h3 id="2-1-4-i-节点"><a href="#2-1-4-i-节点" class="headerlink" title="2.1.4. i 节点"></a>2.1.4. i 节点</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a1f2c8b312ce3415c59614cb481c8990.png" alt="image.png"><br>给每个文件赋予一个称为 i 节点的数据结构。其中列出了文件属性和文件块的磁盘地址。所以只要有 i 节点，就能找到文件的所有块。</p>
<p>相比于 FAT，i 节点只在对应文件打开时才在内存中。而 FAT 需保留所有磁盘块的关系链表。</p>
<p>当一个文件所含的磁盘块的数目超出了 i 节点所能容纳的数目怎么办？<br>一个方案是最后一个地址指向另一个用于存储额外地址的块。</p>
<h2 id="2-2-文件属性的存储位置"><a href="#2-2-文件属性的存储位置" class="headerlink" title="2.2. 文件属性的存储位置"></a>2.2. 文件属性的存储位置</h2><p>每个文件系统维护文件的文件属性，它们必须存储在某个地方。</p>
<p><strong>存至目录项：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b92159db3de68498c88943e13be37fac.png" alt="image.png"><br>一种方法是把文件属性直接存放在目录项中。目录中有一个固定大小的目录项列<br>表，每个文件对应一项，其中包含一个文件名、一个文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p>
<p><strong>存至 i 节点：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c9f3295a4bd698e2628b6c48d3ba5cc8.png" alt="image.png"><br>对于采用 i 节点的系统，还存在另一种方法，即把文件属性存放在 i 节点中而不是目录项中。目录项会只有文件名和 i 节点号。</p>
<h2 id="2-3-目录的实现"><a href="#2-3-目录的实现" class="headerlink" title="2.3. 目录的实现"></a>2.3. 目录的实现</h2><p>打开文件时，操作系统利用路径名找到相应目录项。目录项中提供了查找文件磁盘块所需要的信息。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8afb0a7f4fea11bc8c7677a71eb7db20.png" alt="image.png"></p>
<h3 id="2-3-1-实现可变长度的长文件名"><a href="#2-3-1-实现可变长度的长文件名" class="headerlink" title="2.3.1. 实现可变长度的长文件名"></a>2.3.1. 实现可变长度的长文件名</h3><p><strong>简单固定长度：</strong><br>最简单的方法是给予文件名一个长度限制，典型值为 255 个字符，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间。</p>
<p><strong>文件名分散在各自文件中：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/32c033a3c3acfb80406195c6c3121f03.png" alt="image.png"><br>一种替代方案是每个目录项分为两部分。</p>
<ol>
<li>固定部分：以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息以及其他属性。</li>
<li>任意长度的实际文件名。</li>
</ol>
<p>如上图，有三个文件，project budget、personnel 和 foo，每个文件名以一个特殊字符（通常是 0）结束。</p>
<p>缺点：</p>
<ol>
<li>当移走文件后就引入了一个长度可变的空隙，下一个进来的文件不一定正好适合这个空隙。</li>
<li>一个目录项可能会分布在多个页面上，在读取文件名时可能发生缺页中断。</li>
</ol>
<p><strong>文件名集中在一起：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0fa715ceaed2fabec2fd258f402a9c35.png" alt="image.png"><br>另一种方法是，使目录项自身都有固定长度，而将文件名放置在目录后面的堆中。</p>
<p>优点：</p>
<ol>
<li>当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。当然，必须要对堆进行管理。而在处理文件名时缺页中断仍旧会发生。</li>
<li>文件名不再需要从字的边界开始，每个文件名后面就不需要用于凑整的填充字符了。</li>
</ol>
<h3 id="2-3-2-加快文件查找速度"><a href="#2-3-2-加快文件查找速度" class="headerlink" title="2.3.2. 加快文件查找速度"></a>2.3.2. 加快文件查找速度</h3><p><strong>散列表：</strong><br>对于非常长的目录，线性查找就太慢了。加快查找速度的一个方法是在每个目录中使用散列表。</p>
<p>添加一个文件时，对散列表中对应的表项进行检查。<br>如果该表项没有被使用，就将一个指向文件目录项的指针放入。<br>如果该表项被使用了，就构造一个链表，该链表的表头指针存放在该表项中，并链接所有具有相同散列值的文件目录项。</p>
<p>查找文件按照相同的过程进行。散列处理文件名，以便选择一个散列表项。<br>检查链表头在该位置上的链表的所有表项，查看要找的文件名是否存在。如果名字不在该链上，该文件就不在这个目录中。</p>
<p>使用散列表的优点是查找非常迅速。其缺点是需要复杂的管理。只有在预计系统中的目录经常会有成百上千个文件时，才把散列方案真正作为备用方案考虑。</p>
<p><strong>高速缓存：</strong><br>另一种加快大型目录查找速度的方法是，将查找结果存入高速缓存。<br>在开始查找之前，先查看文件名是否在高速缓存中。如果是，该文件可以立即定位。当然，只有在查询目标集中在相对小范围的文件集合的时候，高速缓存的方案才有效果。</p>
<h2 id="2-4-日志结构文件系统"><a href="#2-4-日志结构文件系统" class="headerlink" title="2.4. 日志结构文件系统"></a>2.4. 日志结构文件系统</h2><p><strong>技术背景：</strong><br>磁盘高速缓存迅速地增加，这使得来自文件系统高速缓存的大部分读请求不需要磁盘访问操作。<br>未来多数的磁盘访问是写操作，但是在一些文件系统中使用的提前读机制（需要读取数据之前预取磁盘块），并不能获得更好的性能。</p>
<p>在大多数文件系统中，写操作往往都是零碎的。<br>一个 50us 的磁盘写操作之前通常需要 10ms 的寻道时间和 4ms 的旋转延迟时间。</p>
<p>在 UNIX 文件系统上创建一个新文件。为了写这个文件，必须写该文件目录的节点、目录块、文件的 i 节点以及文件本身。<br>这些写操作有可能被延迟，如果在写操作完成之前发生死机，就可能在文件系统中造成不一致。所以 i 节点的写操作一般是立即完成的。</p>
<p><strong>原理：</strong><br>LFS 系统即使面对一个大部分由零碎的随机写操作组成的任务，同样能够充分利用磁盘的带宽。</p>
<p>所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘。段可能会包括 i 节点、目录块、数据块。</p>
<p>i 节点分散在整个日志中，而不是放在磁盘的某一个固定位置。维护一个由节点编号索引组成的节点图。<br>要打开一个文件，则首先需要从 i 节点图中找到文件的节点。一旦节点定位之后就可以找到相应的块的地址。所有的块都放在段中，在日志的某个位置上。</p>
<p><strong>清理线程：</strong><br>实际的硬盘空间是有限的，最终日志将会占用整个磁盘。LFS 有一个清理线程，会程周期地扫描日志进行磁盘压缩。</p>
<ul>
<li>首先读日志中的第一个段的摘要，检查有哪些 i 节点和文件。</li>
<li>然后查看当前节点图，判断该 i 节点是否有效以及文件块是否仍在使用中。<ul>
<li>如果没有使用，则该信息被丢弃。</li>
<li>如果仍然使用，那么 i 节点和块就进入内存等待写回到下一个段中。</li>
</ul>
</li>
</ul>
<p>当一个文件块被写回到一个新段的时候，该文件的 i 节点必须首先要定位、更新，然后放到内存中准备写回到下一个段中。i 节点图接着必须更新以指向新的位置。</p>
<ul>
<li>接着，原来的段被标记为空闲。整个磁盘成为一个大的环形的缓冲区，写线程将新的段写到前面，而清理线程则将旧的段从后面移走。</li>
</ul>
<p><strong>性能：</strong><br>LFS 在处理大量的零碎的写操作时性能上比 UNIX 好上一个数量级，在读和大块写操作的性能方面并不比 UNIX 文件系统差，甚至更好。</p>
<h2 id="2-5-日志文件系统"><a href="#2-5-日志文件系统" class="headerlink" title="2.5. 日志文件系统"></a>2.5. 日志文件系统</h2><p><strong>日志文件系统：</strong><br>保存一个用于记录系统下一步将要做什么的日志。这样当系统在任务中崩溃，重新启动后，可以查看日志获取崩溃前计划完成的任务。</p>
<p><strong>系统崩溃带来的问题：</strong><br>以移除文件操作举例，移除文件操作步骤如下：</p>
<ol>
<li>在目录中删除文件；</li>
<li>释放 i 节点到空闲节点池；</li>
<li>将所有磁盘块归还空闲磁盘块池。</li>
</ol>
<p>假如在第一步完成后系统崩溃。i 节点和文件块将不会被任何文件获得，也不会被再分配，它们只存在于废物池中的某个地方。<br>如果崩溃发生在第二步后，那么只有磁盘块会丢失。</p>
<p><strong>日志事务：</strong><br>日志文件系统先写一个日志项，列出三个将要完成的动作，然后日志项被写入磁盘。只有当日志项已经被写人，不同的操作才可以进行。当所有的操作成功完成后，擦除日志项。<br>如果系统这时崩溃，系统恢复后，文件系统可以通过检查日志来查看是不是有未完成的操作。如果有，可以重新运行所有未完成的操作，直到文件被正确地删除。<br>这要求被写入日志的操作必须是幂等的。</p>
<blockquote>
<p>保证中间件的可靠性也可以用这种方法</p>
</blockquote>
<p>为了增加可靠性，一个文件系统可以引入数据库中原子事务 (atomic transaction) 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。<br>这样，文件系统就会知道它或者必须完成所有被界定的操作，或者什么也不做。</p>
<h2 id="2-6-虚拟文件系统"><a href="#2-6-虚拟文件系统" class="headerlink" title="2.6. 虚拟文件系统"></a>2.6. 虚拟文件系统</h2><p>即使在同一个操作系统下，也会使用很多不同的文件系统。</p>
<h3 id="2-6-1-Windows-处理多文件系统"><a href="#2-6-1-Windows-处理多文件系统" class="headerlink" title="2.6.1. Windows 处理多文件系统"></a>2.6.1. Windows 处理多文件系统</h3><p>Windows 通过指定不同的盘符来处理这些不同的文件系统。当一个进程打开一个文件，盘符是显式或者隐式存在的。<br>所以 Windows 知道向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一的模式。</p>
<h3 id="2-6-2-Unix-处理多文件系统"><a href="#2-6-2-Unix-处理多文件系统" class="headerlink" title="2.6.2. Unix 处理多文件系统"></a>2.6.2. Unix 处理多文件系统</h3><p>相比之下，所有现代的 UNIX 系统做了一个很认真的尝试，即将多种文件系统整合到一个统一的结构中。<br>一个 Linux 系统可以用 ext2 作为根文件系统，ext3 分区装载在 /usr 下，另一块采用 ReiserFS 文件系统的硬盘装载在 /home 下，以及一个 ISO 9660 的 CD-ROM 临时装载在 /mnt 下。<br>从用户的观点来看，只有一个文件系统层级。它们事实上是多种文件系统，对于用户和进程是不可见的。</p>
<h3 id="2-6-3-虚拟文件系统（Virtual-File-System-VFS）"><a href="#2-6-3-虚拟文件系统（Virtual-File-System-VFS）" class="headerlink" title="2.6.3. 虚拟文件系统（Virtual File System, VFS）"></a>2.6.3. 虚拟文件系统（Virtual File System, VFS）</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0b47f051e1fb1983d4e108dd3f3b5ff0.png" alt="image.png"><br>虚拟文件系统尝试将多种文件系统统一成一个有序的结构。<br>其关键思想是抽象出所有文件系统共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据。</p>
<p><strong>VFS 交互接口：</strong></p>
<ul>
<li>上层接口：被用户进程调用，是标准的 POSIX 系统调用，比如 open. read、 write 和 lseek 等。</li>
<li>下层接口：调用下层实际文件系统。VFS 接口包含许多功能调用。所以当创造一个新的文件系统和 VFS 一起工作时，设计者就必须确定它提供 VFS 所需要的功能调用。</li>
</ul>
<p><strong>用虚拟文件系统进行读操作过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a6babd0fa3d488ecd95bf7ca3c2815cf.png" alt="image.png"></p>
<ol>
<li>_装载文件系统：_文件系统在 VFS 中注册，提供一个包含 VFS 所需要的函数地址列表。VFS 知道如何执行实际文件系统提供的每一个功能。</li>
<li>_创建 v 节点：_如果一个文件系统装载在 /usr 并且一个进程调用 open (“/usr/lnclude/unistd.h”, O_RDONLY)</li>
</ol>
<p>VFS 会找到它所装载的文件的根目录，在那里查找路径 include/unistd.h，然后创建一个 v 节点并调用实际文件系统，从而返回文件 i 节点中的所有信息，并和其他信息一起复制到 v 节点中。</p>
<ol start="3">
<li>VFS 在文件描述符表中创建一个表项，并且将它指向新的 v 节点。</li>
<li>VFS 向调用者返回文件描述符，调用者可以用它去读、写或者关闭文件。</li>
<li>当进程用文件描述符进行一个读操作，VFS 通过进程表和文件描述符表确定 v 节点的位置，并跟随指针指向函数表，运行在实际文件系统中的代码。<blockquote>
<p>联想：VFS 类似一个面向用户的统一接口，具体实现由下层文件系统实现</p>
</blockquote>
</li>
</ol>
<h1 id="3-文件系统管理及优化"><a href="#3-文件系统管理及优化" class="headerlink" title="3. 文件系统管理及优化"></a>3. 文件系统管理及优化</h1><h2 id="3-1-磁盘空间管理"><a href="#3-1-磁盘空间管理" class="headerlink" title="3.1. 磁盘空间管理"></a>3.1. 磁盘空间管理</h2><p>按连续字节序列存储文件有一个明显问题，当文件扩大时，有可能需要在磁<br>盘上移动文件。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p>
<h3 id="3-1-1-块大小"><a href="#3-1-1-块大小" class="headerlink" title="3.1.1. 块大小"></a>3.1.1. 块大小</h3><p>块尺寸设的过大会导致很小的文件也会占用大量的磁盘空间。<br>块尺寸设的过小会导致大多数文件会跨越多个块，因此需要多次寻道与旋转延迟才能读出它们，从而降低了性能。</p>
<h3 id="3-1-2-记录空闲块"><a href="#3-1-2-记录空闲块" class="headerlink" title="3.1.2. 记录空闲块"></a>3.1.2. 记录空闲块</h3><p><strong>采用磁盘块链表：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b302e3be29c0fd7a4b63e189dcbfb173.png" alt="image.png"><br>链表的每个块中包含尽可能多的空闲磁盘块号。对于 1KB 大小的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲块的块号（需要有一个位置存放指向下一个块的指针）。</p>
<p><strong>采用位图：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/00a52c6a623e67ab4d59c781e5a5c9da.png" alt="image.png"><br>另一种空闲磁盘空间管理的方法是采用位图。<br>n 个块的磁盘需要 n 位位图。空闲块用 1 表示，已分配块用 0 表示（或者相反）。位图方法所需空间较少，因为每块只用一个二进制位标识，而在链表方法中，每一块要用到 32 位。</p>
<h2 id="3-2-文件系统性能"><a href="#3-2-文件系统性能" class="headerlink" title="3.2. 文件系统性能"></a>3.2. 文件系统性能</h2><p>访问磁盘比访问内存慢得多。读内存中一个 32 位字大概要 10ns。从硬盘上读的速度大约为 100MB/s，对每 32 位字来说，大约要慢 4 倍，还要加上 5~10ms 寻道时间，并等待所需的扇面抵达磁头下。</p>
<h3 id="3-2-1-磁盘高速缓存"><a href="#3-2-1-磁盘高速缓存" class="headerlink" title="3.2.1. 磁盘高速缓存"></a>3.2.1. 磁盘高速缓存</h3><p>高速缓存指的是一系列的块， 它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。<br>最常用的减少磁盘访问次数技术是 <strong>块高速缓存（block cache）</strong>或者 <strong>缓冲区高速缓存（buffer cache）</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/85532654edb9a0c1861fabf488dc2dda.png" alt="image.png"><br><strong>散列表：</strong>高速缓存使用散列表结构，方便快速查找所需要的块。</p>
<p><strong>LRU：</strong><br>使用双向链表把块以先后使用顺序链接起来。最近使用最少的块在链表的前端，最近使用最多的块在该链表的后端。</p>
<p>如果一个关键块（如 i 节点块）读进了高速缓存并做过修改，在写回磁盘前系统崩溃了，导致文件系统的不一致。如果把 i 节点块放在 LRU 链的尾部，在它到达链首并写回磁盘前，需要相当长的一段时间。</p>
<p><strong>置换策略：</strong><br>如果高速缓存已满，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入以后修改过，则要把它写回磁盘。<br>与分页相似，常用的页面置换算法适用于高速缓存。</p>
<p><strong>同步 / 异步写回：</strong><br>我们不希望数据块在告诉缓存放很久之后才写回磁盘，这样十分容易丢失数据。为此操作系统采取了策略。</p>
<ul>
<li>异步定时写回：UNIX 系统启动时会在后台运行 update 程序，每隔 30s 就执行 sync 调用。</li>
<li>同步写回： Windows 执行 FlushFileBuffers 系统调用。只要被写入高速缓存，就把每个被修改的块写回磁盘，但这样需要更多的磁盘 I/O。</li>
</ul>
<h3 id="3-2-2-块提前读"><a href="#3-2-2-块提前读" class="headerlink" title="3.2.2. 块提前读"></a>3.2.2. 块提前读</h3><p>在需要用到块之前，提前将其写入高速缓存，从而提高命中率。<br>许多文件都是顺序读的，如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作且在完成之后，会检查块 k+1 是否已经在高速缓存。如果还不在，文件系统会为块 k+1 安排一个预读。</p>
<p>块提前读策略只适用于实际顺序读取的文件。对随机访问文件，提前读丝毫不起作用。文件系统通过跟踪每一个打开文件的访问方式来确定时候是顺序访问。</p>
<p>在最初不能确定文件属于哪种存取方式时，先将该位设置成顺序访问方式，查找一完成就将该位清除。这样即便弄错了一次也只是浪费一小段磁盘的带宽而已。</p>
<h3 id="3-2-3-减少磁盘臂运动"><a href="#3-2-3-减少磁盘臂运动" class="headerlink" title="3.2.3. 减少磁盘臂运动"></a>3.2.3. 减少磁盘臂运动</h3><p>把有可能顺序访问的块放在一起，最好是在同一个柱面上，从而减少磁盘臂的移动次数。<br> </p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统从入门到入土⑤：输入 / 输出</title>
    <url>/fd6d81abe0b0/</url>
    <content><![CDATA[<h1 id="1-I-O-硬件原理"><a href="#1-I-O-硬件原理" class="headerlink" title="1. I/O 硬件原理"></a>1. I/O 硬件原理</h1><h2 id="1-1-I-O-设备"><a href="#1-1-I-O-设备" class="headerlink" title="1.1. I/O 设备"></a>1.1. I/O 设备</h2><p>I/O 设备大致可以分为 <strong>块设备（block device）</strong>和 <strong>字符设备（character device）</strong>。</p>
<p><strong>块设备：</strong><br>块设备把信息存储在固定大小的块中，大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的连续块为单位。<br>块设备的基本特征是每个块都能独立于其他块而读写。硬盘、蓝光光盘和 USB 是最常见的块设备。</p>
<p><strong>字符设备：</strong><br>字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。<br>字符设备是不可寻址的，也没有任何寻道操作。打印机、网络接口、鼠标 (用作指点设备)、以及大多数与磁盘不同的设备都可看作字符设备。</p>
<span id="more"></span>

<h2 id="1-2-设备控制器"><a href="#1-2-设备控制器" class="headerlink" title="1.2. 设备控制器"></a>1.2. 设备控制器</h2><p>I/O 设备一般由机械部件和电子部件两部分组成。机械部件则是设备本身；而电子部件又称作 ** 设备控制器（device controller）** 或 <strong>适配器（adapter）</strong>。通常是个人计算机主板上的芯片，或是（PCI）扩展槽中的印刷电路板。</p>
<p><strong>作用：</strong><br>控制一个或多个 I/O 设备，以实现 I/O 设备和计算机之间的数据交换。<br>控制器把串行的位流转换为字节块，并进行必要的错误校正工作。<br>字节块通常首先在控制器内部的一个缓冲区中按位进行组装，然后进行校验再将它复制到主存中。</p>
<blockquote>
<p>LCD 显示器的控制器也是一个位串行设备。它从内存中读入包含待显示字符的字节，产生信号以便使相应的像素改变背光的极化方式，从而将其写到屏幕上。</p>
</blockquote>
<h2 id="1-3-内存映射-I-O"><a href="#1-3-内存映射-I-O" class="headerlink" title="1.3. 内存映射 I/O"></a>1.3. 内存映射 I/O</h2><p><strong>寄存器：</strong><br>每个控制器有几个寄存器用来与 CPU 进行通信。</p>
<ul>
<li>通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。</li>
<li>通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</li>
</ul>
<p><strong>数据缓冲区：</strong><br>许多设备还有一个操作系统可以读写的数据缓冲区。</p>
<blockquote>
<p>例如，在屏幕上显示像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，可供程序或操作系统写入数据。</p>
</blockquote>
<p><strong>寻址控制器方案：</strong><br>CPU 如何与寄存器和数据缓冲区通信？</p>
<ol>
<li><strong>I/O 端口号（I/O port）：</strong></li>
</ol>
<p>每个控制寄存器被分配一个 I/O 端口号（8 位或 16 位整数），所有 I/O 端口形成 I/O 端口空间，只有操作系统可以访问。<br>在这一方案中，内存地址空间和 I/O 地址空间是不同的。可以使用一条特殊的 I/O 指令，例如 <code>IN REG, PORT</code>，CPU 可以读取控制寄存器 PORT 的内容并将结果存入到 CPU 寄存器 REG 中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb708a7c4a526a72448ac5116e88786f.png" alt="image.png"></p>
<ol start="2">
<li><strong>内存映射 I/O（memory-mapped I/O）：</strong></li>
</ol>
<p>将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，这样的系统称为内存映射 I/O。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1539db73122c168692b655dac119b9e2.png" alt="image.png"></p>
<p><strong>内存映射 I/O 优点：</strong></p>
<ol>
<li>I/O 指令读写设备控制寄存器，需要使用汇编代码，这增加了控制 I/O 的开销。而对于内存映射 I/O，I/O 设备驱动程序可以用 C 语言编写。</li>
<li>不需要特殊的保护机制来阻止用户进程执行 I/O 操作。</li>
<li>可以引用内存的每一条指令也可以引用控制寄存器。</li>
</ol>
<p>例如，如果存在一条指令 TEST 可以测试一个内存字是否为 0，那么它也可以用来测试一个控制寄存器是否为 0。<br>如果不是内存映射 I/O，必须首先将控制寄存器读入 CPU，然后再测试。</p>
<p><strong>实际工作原理：</strong><br>当 CPU 想要读入一个字的时候，将需要的地址放到总线的地址线上，然后在总线的一条控制线上置起一个 READ 信号。<br>还要用到第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。</p>
<h2 id="1-4-直接存储器存取"><a href="#1-4-直接存储器存取" class="headerlink" title="1.4. 直接存储器存取"></a>1.4. 直接存储器存取</h2><p><strong>非 DMA 数据交换过程：</strong><br>CPU 需要寻址设备控制器以便与它们交换数据，在没有使用 DMA 时磁盘读取数据效率不高，过程如下：</p>
<ol>
<li>首先控制器从磁盘驱动器串行地、一位一位地读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区中。</li>
<li>接着再计算校验和，以保证没有读错误发生。</li>
<li>然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息，并将其存人内存中。</li>
</ol>
<p><strong>DMA 数据交换过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/279ce57ad3eea8c671e2c9cffc98140e.png" alt="image.png"><br>DMA 控制器能独立于 CPU 访问系统总线，使用 DMA 时的过程：</p>
<ol>
<li>CPU 对 DMA 控制器进行编程，设置其的寄存器，以便让 DMA 控制器知道将什么数据传送到什么地方。</li>
</ol>
<p>DMA 控制器还要向磁盘控制器发送命令让它从磁盘读数据到其内部的缓冲区中，必要性：</p>
<ol>
<li>磁盘控制器可以在传送之前检验校验和。如果校验和是错误的，那么将发出一个表明错误的信号并且不会进行传送。</li>
<li>如果控制器要将数据直接写到内存，则它必须为要传送的每个字取得系统总线的控制权，会导致总线忙。</li>
</ol>
<p>如果块被放入内部缓冲区，则在 DMA 启动前不需要使用总线。</p>
<ol start="2">
<li>DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送。</li>
<li>磁盘控制器从内部缓冲区中读取字写到内存，这是另一个标准总线周期。</li>
<li>当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器。</li>
</ol>
<p>随后 DMA 控制器增加要使用的内存地址，并且减少字节计数。<br>如果字节计数仍然大于 0，则重复第 2 步到第 4 步，直到字节计数到达 0。<br>然后 DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。</p>
<p><strong>DMA 硬件集成方案：</strong><br>DMA 需要硬件的支持。DMA 控制器可以集成到磁盘控制器和其他控制器之中，这就要求每个设备有一个单独的 DMA 控制器。也可以将 DMA 控制器集成到主板上，由它调控到多个设备的数据传送。</p>
<p><strong>传输模式：</strong><br>许多总线能够以两种模式操作：每次一字模式和块模式。某些 DMA 控制器也能够以这两种模式操作。</p>
<ul>
<li><strong>周期窃取（eycle stealing）：</strong>每次一字模式下，DMA 控制器请求传送一个字并且得到这个字，传送多次。</li>
</ul>
<p>该模式下设备控制器会偶尔从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。这一机制称为周期窃取。</p>
<ul>
<li><strong>突发模式（burst mode）：</strong>在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这操作形式称为突发模式。</li>
</ul>
<p>它比周期窃取效率更高，因为获得总线占用了时间，并且以一次总线获得的代价能够传送多个字。<br>突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。</p>
<blockquote>
<p>联想：与 JVM 垃圾回收器串行收集与并行收集的区别类似。并行会暂停用户线程，专注于垃圾回收，吞吐量大，但也会加大用户响应时间，类似这里的突发模式。</p>
</blockquote>
<blockquote>
<p>某些 DMA 控制器是让设备控制器将字发送给 DMA 控制器，然后发起第 2 个总线请求将该字写到它应该去的任何地方。<br>采用这种方案，每传送一个字需要一个额外的总线周期，但是更加灵活，因为它可以执行设备到设备的复制甚至是内存到内存的复制（通过首先发起一个到内存的读，然后发起一个到不同内存地址的写）。</p>
</blockquote>
<h2 id="1-5-中断"><a href="#1-5-中断" class="headerlink" title="1.5. 中断"></a>1.5. 中断</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/848bd15e88456466d8d893cb2b556aa3.png" alt="image.png"><br><strong>产生中断信号：</strong><br>当一个 I/O 设备完成交给它的工作时，其通过在分配给它的一条总线信号线上置起信号从而产生中断。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。<br>为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。<br>如果有另一个中断正在处理中，该设备将继续在总线上置起中断信号，直到得到 CPU 的服务才被继续处理。</p>
<p>中断信号导致 CPU 停止当前正在做的工作去做其他的事情。<br>地址线上的数字是一个指向 ** 中断向量（interrupt vector）** 表格的索引，用于读取指向中断服务过程开始位置的程序计数器。</p>
<p><strong>服务开始前保存：</strong><br>在开始服务程序之前，硬件总是要保存一定的信息。必须保存程序计数器，这样被中断的进程才能够重新开<br>始。另一个极端是所有可见的寄存器和很多内部寄存器或许也要保存。</p>
<p>将这些信息保存到什么地方是一个问题：</p>
<ul>
<li>在内部寄存器中保存信息。在需要时操作系统可以读出这些内部寄存器。</li>
</ul>
<p>其缺点是，为避免第二个中断重写寄存器，以致在相关信息被读出前中断控制器无法得到应答。<br>这一策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据。</p>
<ul>
<li>在堆栈中保存信息。</li>
</ul>
<p>其带来的问题：</p>
<ul>
<li>如果使用当前堆栈，则它很可能是用户进程的堆栈，其堆栈指针甚至可能不是合法的，当硬件在其所指的地址写入时将导致致命错误。</li>
</ul>
<p>另外，若它指向一个页面的末端，那么在若干次内存写之后，页面边界可能被超出并且产生页面故障。这将会引起更大的问题：在何处保存状态以处理页面故障？</p>
<ul>
<li>如果使用内核堆栈，堆栈指针是合法的并且指向一个固定的页面。</li>
</ul>
<p>但是，切换到核心态可能要求改变 MMU 上下文，并且可能使高速缓存和 TLB 的大部分或全部失效。静态地或动态地重新装载所有这些东西将增加处理一个中断的时间，因而浪费 CPU 的时间。</p>
<p><strong>采用应答避免竞争：</strong><br>中断服务过程开始运行后，立刻通过将一个确定值写到中断控制器的某个 I/O 端口来对中断做出应答，来告诉中断控制器可以发出另一个中断。通过这种方式来避免多个同时发生的中断相互竞争。</p>
<h1 id="2-I-O-软件原理"><a href="#2-I-O-软件原理" class="headerlink" title="2. I/O 软件原理"></a>2. I/O 软件原理</h1><h2 id="2-1-I-O-软件的目标"><a href="#2-1-I-O-软件的目标" class="headerlink" title="2.1. I/O 软件的目标"></a>2.1. I/O 软件的目标</h2><p><strong>设备独立性（device independence）</strong>：设计的程序应该可以访问任意 I/O 设备。例如，读取一个文件作为输入的程序应该能够在硬盘、DVD 或者 USB 盘上读取文件，无需为每一种不同的设备修改程序。</p>
<p><strong>统一命名（uniform naming）</strong>：一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。用这种方法，所有文件和设备都采用相同的方式一路径名进行寻址。</p>
<blockquote>
<p>例如，一个 USB 盘可以安装到目录 /usr/ast/backup 下，这样复制一个文件到 /usr/ast/backup/monday 就是将文件复制到 USB 盘上。</p>
</blockquote>
<p><strong>错误处理（error handling）：</strong>一般来说，错误应该尽可能地在接近硬件的层面（低层）得到处理，只有低层软件处理不了才将错误上交高层处理。<br>当控制器发现了一个读错误时，如果它能够处理那么就应该自已设法纠正这一错误。如果控制器处理不了，则交给设备驱动程序处理，可能只需重读一次这块数据就正确了。</p>
<p><strong>同步传输（阻塞）和异步传输（中断驱动）：</strong></p>
<ul>
<li>异步：CPU 启动传输后便转去做其他工作，直到中断发生。</li>
<li>阻塞：在 read 系统调用之后，程序将自动被挂起，直到缓冲区中的数据准备好。</li>
</ul>
<p><strong>缓冲（buffering）：</strong><br>数据离开一个设备之后通常并不能直接存放到其最终的目的地。数据必须预先放置到输出缓冲区之中，从而消除缓冲区填满速率和缓冲区清空速率之间的相互影响，以避免缓冲区欠载。缓冲涉及大量的复制工作，并且经常对 I/O 性能有重大影响。</p>
<blockquote>
<p>例如，从网络上进来一个数据包时，直到将该数据包存放在某个地方并对其进行检查，操作系统才知道要将其置于何处。此外，某些设备具有严格的实时约束（如数字音频设备）。</p>
</blockquote>
<p><strong>共享设备和独占设备：</strong><br>有些 I/O 设备（磁盘）能够同时让多个用户使用。多个用户同时在同一磁盘上打开文件不会引起什么问题。<br>有些设备（磁带机）则必须由单个用户独占使用，直到该用户使用完，另一个用户才能拥有该磁带机。让多个用户随机将混杂的数据块写入同一磁带，这样是不能工作的。</p>
<h2 id="2-2-程序通知-I-O"><a href="#2-2-程序通知-I-O" class="headerlink" title="2.2. 程序通知 I/O"></a>2.2. 程序通知 I/O</h2><p>I/O 可以采用三种方式来实现。程序控制 I/O、中断驱动 I/O 和使用 DMA 的 I/O。</p>
<p><strong>程序控制 I/O（programmed I/O）：</strong>让 CPU 做全部工作。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6be16f108e5804a39fedcd6ff2634e2e.png" alt="image.png"><br>例如一个用户进程想通过串行接口在打印机上打印 8 个字符的字符串”ABCDEFGH“。</p>
<ol>
<li>软件首先要在用户空间的一个缓冲区中组装字符串，如 a) 所示。</li>
<li>然后，用户进程调用打开打印机之类的系统调用来获得打印机。</li>
</ol>
<p>如果打印机当前被另一个进程占用，该系统调用将失败并返回一个错误代码，或者将阻塞直到打印机可用。<br>成功获取打印机后，用户进程就发出一个系统调用打印字符串。</p>
<ol start="3">
<li>然后，操作系统将字符串缓冲区复制到内核空间中的一个数组中。</li>
<li>若打印机可用，操作系统就复制第一个字符到打印机的数据寄存器中，在这个例子中使用了内存映射 I/O。</li>
</ol>
<p>这一操作将激活打印机。字符也许还不会出现在打印机上，因为某些打印机在打印任何东西之前要先缓冲一行或一页。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>对 1e9 + 7 取模</title>
    <url>/6a28fa6963c0/</url>
    <content><![CDATA[<h2 id="为什么取模"><a href="#为什么取模" class="headerlink" title="为什么取模"></a>为什么取模</h2><p>OJ 上很多题目因为难度原因需要非常大的测试数据量（数据量大了自然会对算法的时间复杂度要求更高），而大数据量往往会导致溢出，虽然可以用 BigInt 等方式做题，但这就失去了这道题的原本意义。</p>
<p>这种情况题目会要求计算结果对 1e9 + 7 取模，因为对取模不会影响算法的正确性，既避免了高精度运算，又能保证极少的冲突情况。<br>这里可以先回顾下模除运算的等价性</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p</span><br><span class="line">(a - b) % p = (a % p - b % p ) % p</span><br><span class="line">(a * b) % p = (a % p * b % p) % p</span><br><span class="line">a ^ b % p = ((a % p)^b) % p</span><br></pre></td></tr></tbody></table></figure>
<p>由上述各个公式可知只要每次运算后觉得结果过大都可以对其进行取模，只要避免数据溢出，那么最终结果都是一样的。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> MOD + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + <span class="number">1</span> + a * a;</span><br><span class="line">sum %= MOD;</span><br></pre></td></tr></tbody></table></figure>
<p>只要 sum 不溢出，那么其结果和对每次运算结果都 <code>%MOD</code> 一遍是一样的。</p>
<p>所以 <strong>取模成了简化大数据的一种约定</strong>，服务端给定算法取模后的测试数据，我们写算法时也进行取模，那么依然能验证算法的正确性。</p>
<span id="more"></span>
<h2 id="为什么是-1e9-7"><a href="#为什么是-1e9-7" class="headerlink" title="为什么是 1e9 + 7"></a>为什么是 1e9 + 7</h2><p>参考：<br><a href="https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E9%99%A4#%E7%AD%89%E4%BB%B7%E6%80%A7">wiki 模除 #等价性</a><br><a href="https://blog.csdn.net/qq_46689648/article/details/122795304">为什么对 1e9+7 取模</a><br><a href="https://blog.csdn.net/cpb____/article/details/107959450?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">C++ 中 1e9（初始化、无穷大）解析</a><br><a href="https://blog.csdn.net/qq_43827595/article/details/104267327?utm_term=1e9%207java%E5%8F%96%E6%A8%A1&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-104267327&amp;spm=3001.4430">【C++ 取模 mod 易错点】由于答案可能会很大，请你将结果对 1e9+7 取模后再返回</a><br><a href="https://www.zhihu.com/question/49374703">为什么很多程序竞赛题目都要求答案对 1e9+7 取模？</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/e8fc79331955/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">790. 多米诺和托米诺平铺</a><br>做题时看到官方除了 DP，还给出了这样一种解法，有点好奇便研究了一下</p>
<p>矩阵快速幂由 **_ 矩阵运算 _** 和 **_快速幂 _** 两部分组成</p>
<span id="more"></span>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>包依赖导致的 ClassNotFoundException</title>
    <url>/2659d1283ba8/</url>
    <content><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2022</span>-08-<span class="number">25</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">31.203</span> ERROR o.s.boot.SpringApplication.reportFailure:<span class="number">860</span> Application run failed</span><br><span class="line">java.lang.TypeNotPresentException: Type com.dfire.soa.consumer.vo.DinningTableVo not present</span><br><span class="line">        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:<span class="number">117</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:<span class="number">125</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:<span class="number">49</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:<span class="number">68</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:<span class="number">138</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:<span class="number">49</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.repository.MethodRepository.getReturnType(MethodRepository.java:<span class="number">68</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.reflect.Method.getGenericReturnType(Method.java:<span class="number">255</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.common.utils.ReflectUtils.getReturnTypes(ReflectUtils.java:<span class="number">1196</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.MethodDescriptor.&lt;init&gt;(MethodDescriptor.java:<span class="number">48</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceDescriptor.initMethods(ServiceDescriptor.java:<span class="number">54</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceDescriptor.&lt;init&gt;(ServiceDescriptor.java:<span class="number">45</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceRepository.lambda$registerService$<span class="number">0</span>(ServiceRepository.java:<span class="number">64</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:<span class="number">1688</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceRepository.registerService(ServiceRepository.java:<span class="number">63</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:<span class="number">321</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:<span class="number">314</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:<span class="number">238</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.exportService(DubboBootstrap.java:<span class="number">1099</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.lambda$exportServices$<span class="number">14</span>(DubboBootstrap.java:<span class="number">1086</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at java.util.HashMap$Values.forEach(HashMap.java:<span class="number">981</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.exportServices(DubboBootstrap.java:<span class="number">1070</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.start(DubboBootstrap.java:<span class="number">886</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onContextRefreshedEvent(DubboBootstrapApplicationListener.java:<span class="number">70</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onApplicationContextEvent(DubboBootstrapApplicationListener.java:<span class="number">63</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at com.alibaba.spring.context.OnceApplicationContextEventListener.onApplicationEvent(OnceApplicationContextEventListener.java:<span class="number">52</span>) ~[spring-context-support-<span class="number">1.0</span><span class="number">.11</span>.jar:na]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:<span class="number">176</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:<span class="number">169</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:<span class="number">143</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:<span class="number">421</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:<span class="number">378</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:<span class="number">938</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">586</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="number">144</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">771</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">763</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="number">438</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">339</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at com.dfire.soa.SpringbootApplication.main(SpringbootApplication.java:<span class="number">21</span>) [cash-platform-soa.jar:na]</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.dfire.soa.consumer.vo.DinningTableVo</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">382</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">418</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">352</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">351</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.Class.forName0(Native Method) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.Class.forName(Class.java:<span class="number">348</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:<span class="number">114</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        ... <span class="number">38</span> common frames omitted</span><br></pre></td></tr></tbody></table></figure>
<p>dubbo:2.7.15，spring-boot:2.4.13</p>
<p>今天遇到一个问题，本地启动项目没有问题，发布到测试环境提示 ClassNotFoundException。<br>报的错都是一些新加的 jar 包下的类，都是 SNAPSHOT 包。看起来像是找不到类导致 Spring 无法创建 bean，但是明明包里是有这个类的。<br>经过一天的修改发布观察，发现是 maven 依赖的问题，只要引用了多个相同的依赖包就会遇到这样的问题。比如 consumer 包，该项目直接引用了 consumer 包，还引用了一个包，那个包也引用了 consumer 包，导致 consumer 包出现了两次，如图。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f77aac19c0f35efc3359d8f1ac0894a0.png" alt="image.png"></p>
<p>按理来说只是包重复引用应该不会出现这样的问题，更何况版本都是一样的。所以目前原因暂不明，可能和快照包有关，也可能和 dubbo 等一系列包升级有关。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速定位问题</title>
    <url>/6c827d88b19c/</url>
    <content><![CDATA[<p>这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。</p>
<p>整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再去更新打印状态。</p>
<p>排查了很久发现是客户端接收不到消息，客户端同学也表示不知所措，问了消息通道那边的同学后发现安卓客户端在这之前就断开连接了，重新连接后立马就接收到了消息。一度怀疑是消息通道的问题，后来才发现客户端一直运行在后台，且自动刷新是关闭的。</p>
<p>因整个排查浪费了太多时间故在此做个复盘<br>整个链路很长，任何环节都有可能出现问题。</p>
<ol>
<li>先尽可能排除用户误操作产生的影响</li>
<li>有些地方不好排查（如消息通道），排查必须得有侧重点</li>
<li>需要有一个负责人协调多位项目相关人，依次推进进度，提高效率</li>
</ol>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>并行流导致接口慢调用问题</title>
    <url>/cb2072810346/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。</p>
<span id="more"></span>

<p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8ff9b37602e5bee3be548af291c7348e.png" alt="image.png"><br>根据 ARMS 分析该接口的调用量在 18:31-18:41 出现断崖式增长，每分钟请求数从 5.1k 增加到 14.7k，10 分钟增长了 9.6k。（后续调查表明在该时间段内大部分接口调用量都出现了断崖式增长）<br>异常时刻的 qps 大致为 236.1，几乎是一周前的 2 倍。</p>
<p><strong>响应时间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3dd26f56b4afe1a4bfcb5a79450452d1.png" alt="image.png"><br>每分钟响应时间平均为 3747 ms，整个异常过程中该接口最长的响应时间达到 8s 多。</p>
<p><strong>dubbo 线程池：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d7b54ac7097680e22af442ccbd6b276.png" alt="image.png"><br>所有接口的每分钟 dubbo 请求调用量在 18:35-18:45 内从 14.2k 增长至 35.6k<br>也是在这段时间内 dubbo 线程池被打满，在 18:40 左右基本被打满<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/decb4154e9d3362f4dd2e3b7dbd1892f.png" alt="image.png"></p>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>初步判断流量突增的原因是客户端开放灰度，使得预定业务中的一个轮询调用的接口调用次数上升。<br>该接口调用桌位状态服务的一个较为通用的查询接口，里面使用 parallelStream 来进行 RPC 调用获取账单。<br>parallelStream 使用与 CPU 核数一致的线程数来处理任务，当请求量增大时线程池中的线程全部被打满，导致后续的任务一直在排队等待延迟处理，最终 dubbo 线程池也被占满。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>从问题的核心代码到外部调用，可优化的点如下：</p>
<ol>
<li>取消并行流</li>
<li>加大批量获取数，让调用量减小</li>
<li>经查看代码发现出现问题的使用并行流查账单是为了设置桌位状态的 payStatus，但是上层并不关心这个字段，所以可以让上层调用更轻量级的接口</li>
<li>降低客户端轮询次数，轮询调用需谨慎，轮询策略需要好好设计</li>
</ol>
<h2 id="2023-08-13（代码修改后）"><a href="#2023-08-13（代码修改后）" class="headerlink" title="2023.08.13（代码修改后）"></a>2023.08.13（代码修改后）</h2><p>141 部署了优化后的代码，取消了并行流，分页大小增加到 10<br>142 没有改动，以此作为对照。</p>
<p>总体应用每分钟调用量峰值也有 14.7k，但是 13 号这天的曲线明显更加平滑，没有出现 dubbo 线程池被打满的情况，慢调用的数量和时长都在正常范围内。</p>
<p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b6f1ef4f96f597a9b716feb0c2990204.png" alt="image.png"></p>
<p><strong>响应时间：</strong><br>141 比 142 更缓和</p>
<ul>
<li>141：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4cbe6c1f08b59f911f0a0aa91140deae.png" alt="image.png"></p>
<ul>
<li>142：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4573954d3923199d395b8c80d3cb6909.png" alt="image.png"></p>
<p><strong>dubbo 线程数：</strong></p>
<ul>
<li>141：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/50b9cd579f52f5b56e2e28be3205d865.png" alt="image.png"></p>
<ul>
<li>142：</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1f735878b6e9667f825e70e452c8492.png" alt="image.png"></p>
<p>08.13 修改优化后至今，142 会依然出现一定量的慢调用，141 没有出现过<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/532b6fca9a1b64382d8ac364a4851385.png" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次问题应该是由于短时间内的调用量突增，加上使用并发流处理 RPC 调用引起的。<br>根据 13 号的对照来看，流量平滑增加的情况不会出现特别严重的线程池等待现象，但依然有慢调用，存在隐患。</p>
<p>取消并行流，增加分页大小的方案是可行的，以后并行流需要谨慎使用。后续也和客户端讨论了上层接口的调整方案。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>并行流</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 知识点</title>
    <url>/e3b16e356deb/</url>
    <content><![CDATA[<h1 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h1><h1 id="Spring-和-SpringBoot"><a href="#Spring-和-SpringBoot" class="headerlink" title="Spring 和 SpringBoot"></a>Spring 和 SpringBoot</h1><p>Spring 缺点：重配置<br>Spring Boot 优点</p>
<ul>
<li>起步依赖：将多个 maven 包的坐标整合到一起，并提供一些默认的功能</li>
<li>自动配置：会自动将一些配置类的 bean 注册进 IoC 容器</li>
</ul>
<span id="more"></span>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li>@SpringBootTest：标记该类为 SpringBoot 单元测试类，并加载 applicationContext 上下文环境</li>
<li> @RunWith (SpringRunner.class)：测试启动器，并加载 SpringBoot 测试注解</li>
</ul>
<h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><p>依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>IDEA 开启自动编译</li>
<li> Ctrl + Shift + Alt + /-&gt; Registry -&gt; compiler.automake.allow.when.app.running √：用于指定 IDEA 在程序运行过程中自动编译</li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="5-1-ConfigurationProperties"><a href="#5-1-ConfigurationProperties" class="headerlink" title="5.1 ConfigurationProperties"></a>5.1 <a href="https://blog.csdn.net/yusimiao/article/details/97622666">ConfigurationProperties</a></h2><p>依赖包</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<pre><code>  -  [@ConfigurationProperties(prefix ](/ConfigurationProperties(prefix ) = "person")：将配置文件中以 person 开头的属性注入到类中  
</code></pre>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// set and get</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><a href="/Value">@Value </a>  </p>
<ul>
<li>无需 set 方法 </li>
<li>不支持 Map、对象及行内写法 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="meta">@Value("${person.id}")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>@PropertySource：加载配置文件 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:text.properties")</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// set and get</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>随机值设置<br>使用 Spring Boot 内嵌的 RandomValuePropertySource 类 </p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">${random.value}</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">${random.int} </span></span><br><span class="line"><span class="attr">my.bignumber</span>=<span class="string">${random.long} </span></span><br><span class="line"><span class="attr">my.uuid</span>=<span class="string">${random.uuid}</span></span><br><span class="line"><span class="comment"># 配置小于 10 的随机整数</span></span><br><span class="line"><span class="attr">my.number.less.than.ten</span>=<span class="string">${random.int(10)}</span></span><br><span class="line"><span class="comment"># 配置范围在 [1024,65536] 之间的随机整数</span></span><br><span class="line"><span class="attr">my.number.in.range</span>=<span class="string">${random.int[1024,65536]}</span></span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>参数引用 </p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp </span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">${app.name} is a Spring Boot application</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="SpringBootApplication-源码"><a href="#SpringBootApplication-源码" class="headerlink" title="@SpringBootApplication 源码"></a>@SpringBootApplication 源码</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.TYPE})</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 表明该类为配置类</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> </span><br><span class="line"><span class="comment">// 启用自动配置功能</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> </span><br><span class="line"><span class="comment">// 包扫描</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">	excludeFilters = {</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), </span></span><br><span class="line"><span class="meta">        @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})</span></span><br><span class="line"><span class="meta">    })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>@SpringBootConfiguration<br>组合了 @Configuration，配置类 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.TYPE})</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="comment">// 配置 IoC 容器</span></span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration { </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>@EnableAutoConfiguration </p>
<ul>
<li>@AutoConfigurationPackage：将 AutoConfigurationPackages.Registrar 类导入到 IoC 容器中。拿到启动类所在的包名 </li>
<li>@Import (AutoConfigurationImportSelector.class) ：将 AutoConfigurationImportSelector 类导入到 IoC 容器中。 <ul>
<li>AutoConfigurationMetadataLoader#loadMetadata：加载 spring-boot-autoconfigure.jar 依赖包中 <code>spring-autoconfigure-metadata.properties</code> 文件中的属性，其定义了各个自动配置类及其加载条件。最终生成 AutoConfigurationMetadata 对象。 </li>
<li>AutoConfigurationImportSelector#getAutoConfigurationEntry： <ol>
<li>AutoConfigurationImportSelector#getAttributes：获得注解的属性 </li>
<li><strong>AutoConfigurationImportSelector#getCandidateConfigurations：</strong> 获取默认支持的自动配置类名列表<br>Spring Boot 在启动的时候，使用内部工具类 SpringFactoriesLoader 查找 classpath 上所有 jar 包中的 <code>META-INF/spring.factories</code> 文件。找到将 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的键值对，其值为多个工厂类名称。取出生成 <code>自动配置类名列表</code>。 </li>
<li>AutoConfigurationImportSelector#removeDuplicates：对 <code>自动配置类名列表</code> 去重 </li>
<li>AutoConfigurationImportSelector#getExclusions：得到需排除的自动配置类，后续操作对列表集合进行排除 </li>
<li>AutoConfigurationImportSelector#filter：根据配置类的 <a href="/ConditionalXXX">@ConditionalXXX </a> 注解指定的条件对列表集合进行筛选，并对 AutoConfigurationMetadataLoader#loadMetadata 生成的 AutoConfigurationMetadata 对象进行筛选  </li>
<li>AutoConfigurationImportSelector#fireAutoConfigurationImportEvents：将自动配置导入事件通知监听器。<br>过滤完成后会自动加载类路径下 Jar 包中 <code>META-INF/spring.factories</code> 文件中 AutoConfigurationImportListener 的实现类，并触发 fireAutoConfigurationImportEvents 事件。进行自动配置类的加载创建 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 自动配置包：会把 @SpringbootApplication 注解标注的类所在包名拿到，并且对该包及其子包进行扫描，将组件添加到容器中</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="comment">// 可以帮助springboot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器(ApplicationContext)中</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="自定义-starter"><a href="#自定义-starter" class="headerlink" title="自定义 starter"></a>自定义 starter</h1><ul>
<li><p>导入依赖 </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>SimpleBean </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(SimpleBean.class)</span> </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "simplebean")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleBean</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// setter and getter</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>MyAutoConfiguration<br>@ConditionalOnClass：当类路径 classpath 下有指定的类的情况下才进行自动配置 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(SimpleBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> {</span><br><span class="line">	<span class="keyword">static</span> { </span><br><span class="line">        System.out.println(<span class="string">"MyAutoConfiguration init...."</span>); </span><br><span class="line">    }</span><br><span class="line">	<span class="meta">@Bean</span> <span class="keyword">public</span> SimpleBean <span class="title function_">simpleBean</span><span class="params">()</span>{ </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleBean</span>();</span><br><span class="line">	} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>resources 下创建 /META-INF/spring.factories </p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\ com.ccomma.config.MyAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="SpringApplication-run-源码"><a href="#SpringApplication-run-源码" class="headerlink" title="SpringApplication#run 源码"></a>SpringApplication#run 源码</h1><ul>
<li>静态方法 SpringApplication#run <ul>
<li>创建 SpringApplication 实例：new SpringApplication (primarySources)，其中 primarySources 为启动类的 Class 对象 <ol>
<li>存储项目启动类的 Class 对象至属性字段中</li>
<li>设置应用类型是 SERVLET 应用（Spring 5 之前的传统 MVC 应用）还是 REACTIVE 应用（Spring 5 开始出现的 WebFlux 交互式应用）</li>
<li>SpringApplication#getSpringFactoriesInstances (ApplicationContextInitializer.class)：在 <code>spring.factories</code> 中获取以 ApplicationContextInitializer 全类名为键的所有值（值为初始化器的全类名），并创建实例返回。即返回了 ApplicationContextInitializer 这一类的所有初始化器实例。然后进行设置</li>
<li> SpringApplication#getSpringFactoriesInstances (ApplicationListener.class)：同上，获取 ApplicationListener 这一键下的所有监听器并进行设置</li>
<li>初始化 mainApplicationClass 属性：用于推断并设置项目 main () 方法启动的主程序启动类</li>
</ol>
</li>
<li>调用 SpringApplication 实例的 run 方法 <ol>
<li>获取并启动监听器：调用 SpringApplication#getRunListeners 方法从 <code>spring.factories</code> 中获取键为 SpringApplicationRunListener.class 的所有值（全类名），放入 SpringApplicationRunListeners 对象中，并调用其 starting 方法启动监听器</li>
<li>项目运行环境 Environment 的预配置：调用 SpringApplication#prepareEnvironment 方法创建并配置当前 SpringBoot 应用将要使用的 Environment，并遍历调用所有的 SpringApplicationRunListener 的 environmentPrepared () 方法。最后调用 SpringApplication#configureIgnoreBeanInfo 配置环境 <ol>
<li>SpringApplication#getOrCreateEnvironment：获取或创建环境</li>
<li> SpringApplication#configureEnvironment：配置环境。配置 PropertySources 和 Active Profiles</li>
<li>SpringApplicationRunListeners#environmentPrepared：Listeners 环境准备（广播 ApplicationEnvironmentPreparedEvent 事件）</li>
<li>SpringApplication#bindToSpringApplication：将环境绑定到 SpringApplication 中</li>
</ol>
</li>
<li>创建 Spring 容器：调用 SpringApplication#createApplicationContext 创建一个 AnnotationConfigServletWebServerApplicationContext 容器</li>
<li>获得异常报告器（SpringBootExceptionReporter 集合）：调用 SpringApplication#getSpringFactoriesInstances 从 <code>spring.factories</code> 中获取键为 BootExceptionReporter.class 的所有类，即所有异常报告器</li>
<li> Spring 容器前置处理：调用 SpringApplication#prepareContext 方法，在容器刷新之前的准备动作，比如触发监听器的响应事件、加载资源、设置上下文环境等。并将启动类注入容器为后续开启自动化配置奠定基础 <ol>
<li>SpringApplication#load：将启动类注入容器，为后续开启自动化配置奠定基础</li>
</ol>
</li>
<li>刷新容器：调用 SpringApplication#refreshContext <ol>
<li>SpringApplication#refresh：初始化 IoC 容器，包括 Bean 资源的定位、解析、注册等</li>
<li> ConfigurableApplicationContext#registerShutdownHook：注册 JVM 关闭钩子。在 JVM 关机时关闭这个上下文</li>
</ol>
</li>
<li> Spring 容器后置处理：钩子，无实现可拓展</li>
<li>发出结束执行的事件通知：调用 SpringApplicationRunListeners#started 方法执行所有监听器的 SpringApplicationRunListener#started 方法</li>
<li> SpringApplication#callRunners：获取并执行 ApplicationRunner 和 CommandLineRunner 的所有实现类。Runner 运行器用于在服务启动时进行一些业务初始化操作，这些操作只在服务启动后执行一次。Spring Boot 提供了 ApplicationRunner 和 CommandLineRunner 两种服务接口</li>
<li>发布应用上下文就绪事件：调用 SpringApplicationRunListeners#running 方法来持续运行配置好的应用上下文 ApplicationContext</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h1><ul>
<li>注解方式：未使用缓存管理器则默认使用 Simple 缓存组件进行缓存 <ul>
<li><p><a href="/EnableCaching">@EnableCaching </a>  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot04CacheApplication</span> {</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> { </span><br><span class="line">        SpringApplication.run(Springboot04CacheApplication.class, args);</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>@Cacheable：缓存数据，用于查询方法</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames = "comment")</span> </span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">findById</span><span class="params">(<span class="type">int</span> comment_id)</span>{ </span><br><span class="line">    Optional&lt;Comment&gt; optional = commentRepository.findCommentById(comment_id); </span><br><span class="line">    <span class="keyword">if</span>(optional.isPresent()){ </span><br><span class="line">        <span class="keyword">return</span> optional.get();</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<pre><code>  -  @CachePut：更新数据库后更新缓存，用于更新方法 
  -  @CacheEvict：删除数据库数据后删除缓存，用于删除方法 
</code></pre>
<ul>
<li><p>API 方式 </p>
<ul>
<li>RedisTemplate <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiCommentService</span> {</span><br><span class="line">	<span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> CommentRepository commentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> Comment <span class="title function_">findCommentById</span><span class="params">(Integer id)</span> {</span><br><span class="line">		<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">"comment_"</span> + id); </span><br><span class="line">    	<span class="keyword">if</span> (o != <span class="literal">null</span>) { </span><br><span class="line">            <span class="keyword">return</span> (Comment) o;</span><br><span class="line">		} <span class="keyword">else</span> { </span><br><span class="line">            <span class="comment">// 缓存中没有，从数据库中查询</span></span><br><span class="line">            Optional&lt;Comment&gt; byId = commentRepository.findById(id);</span><br><span class="line">            <span class="keyword">if</span> (byId.isPresent()) {</span><br><span class="line">                <span class="type">Comment</span> <span class="variable">comment</span> <span class="operator">=</span> byId.get();</span><br><span class="line">                <span class="comment">// 将查询结果存入到缓存中</span></span><br><span class="line">				redisTemplate.opsForValue().set(<span class="string">"comment_"</span>+id,comment,<span class="number">1</span>,TimeUnit.DAYS); </span><br><span class="line">                <span class="keyword">return</span> comment;</span><br><span class="line">			} <span class="keyword">else</span> { </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> Comment <span class="title function_">updateComment</span><span class="params">(Comment comment)</span> { </span><br><span class="line">        commentRepository.updateComment(comment.getAuthor(), comment.getaId()); </span><br><span class="line">        <span class="comment">// 更新数据后进行缓存更新</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"comment_"</span>+comment.getId(),comment); </span><br><span class="line">        <span class="keyword">return</span> comment;</span><br><span class="line">	} </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteComment</span><span class="params">(<span class="type">int</span> comment_id)</span> {</span><br><span class="line">		commentRepository.deleteById(comment_id); </span><br><span class="line">        redisTemplate.delete(<span class="string">"comment_"</span>+comment_id);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>自定义 Redis 缓存序列化机制 </p>
<ul>
<li>RedisTemplate#afterPropertiesSet 方法中判断如果默认序列化参数 defaultSerializer 为空，则指定 JdkSerializationRedisSerializer 为默认序列化方式，所以进行缓存的实体类必须实现 Serializable 接口 </li>
<li>RedisConfig <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> { </span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>(); </span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory); </span><br><span class="line">        <span class="comment">// 使用 Json 格式序列化对象，对缓存数据 key 和 value 进行转换</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); </span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); </span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); </span><br><span class="line">        jacksonSeial.setObjectMapper(om); </span><br><span class="line">        <span class="comment">// 设置 RedisTemplate 模版 API 的序列化方式为 Jsonz</span></span><br><span class="line">        template.setDefaultSerializer(jacksonSeial); <span class="keyword">return</span> template;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring AOP 详解</title>
    <url>/f8bf585b0820/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><strong>AOP:</strong><br>⾯向切⾯编程，让程序员关注于类中方法的某个切点上<br>在不改变原有业务逻辑情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复<br>默认情况下，Spring 会根据被代理对象是否实现接⼝来选择使⽤ JDK 还是 CGLIB。当被代理对象没有实现 任何接⼝时，Spring 会选择 CGLIB。当被代理对象实现了接⼝，Spring 会选择 JDK 官⽅的代理技术，不过 我们可以通过配置的⽅式，让 Spring 强制使⽤ CGLIB。</p>
<ul>
<li><strong>通知（Advice）：</strong>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题<ul>
<li><strong>前置通知（@Before）：</strong>在目标方法被调用之前调用通知功能</li>
<li><strong>后置通知（@After）：</strong>在目标方法完成之后调用通知，此时不会关心方法的输出是什么</li>
<li><strong>返回通知（@AfterReturning）：</strong>在目标方法成功执行之后调用通知</li>
<li><strong>异常通知（@AfterThrowing）：</strong>在目标方法抛出异常后调用通知</li>
<li><strong>环绕通知（@Around）：</strong>通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
</li>
<li><strong>连接点（Joinpoint）：</strong>要增强代码的地方（方法开始、结束、异常时等时机点）。只是候选点，最终是否增强代码得看后续逻辑</li>
<li><strong>切点（Pointcut）：</strong>已经把增强代码加入到业务主线之后的连接点</li>
<li><strong>引入：</strong>引入允许我们向现有的类添加新方法或属性</li>
<li><strong>织入（Weaving）：</strong>把增强应用到目标对象老创建新的代理对象的过程。Spring 采用动态代理织入，而 Aspect 采用编译期织入和类装载期织入</li>
<li><strong>切面（Aspect）：</strong>切面 = 通知 + 切点。通知和切点共同定义了切面的全部内容 </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.1</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.8</span><span class="number">.13</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h1 id="二、切点"><a href="#二、切点" class="headerlink" title="二、切点"></a>二、切点</h1><p>Spring 借助 AspectJ 的切点表达式语言来定义 Spring 切面</p>
<table>
<thead>
<tr>
<th><strong>AspectJ 指示器</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> arg()</td>
<td> 限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr>
<td> @args()</td>
<td> 限制连接点匹配参数由指定注解标注的执行方法</td>
</tr>
<tr>
<td> execution()</td>
<td> 用于匹配是连接点的执行方法</td>
</tr>
<tr>
<td> this()</td>
<td> 限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td>
</tr>
<tr>
<td> target</td>
<td> 限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr>
<td> @target()</td>
<td> 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td>
</tr>
<tr>
<td> within()</td>
<td> 限制连接点匹配指定的类型</td>
</tr>
<tr>
<td> @within()</td>
<td> 限制连接点匹配指定注解锁标注的类型（当使用 Spring AOP 时，方法定义在由指定的注解所标注的类里）</td>
</tr>
<tr>
<td>@annotation</td>
<td> 限定匹配带有指定注解的连接点</td>
</tr>
</tbody></table>
<p><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3e50af79311608e8c1970b9f7411403b.png" alt="image.png"></p>
<h2 id="1-限定-Bean-的-ID"><a href="#1-限定-Bean-的-ID" class="headerlink" title="1. 限定 Bean 的 ID"></a>1. 限定 Bean 的 ID</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">execution(* concert.Performance.perform()) and <span class="title function_">bean</span><span class="params">(<span class="string">'woodstock'</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-通过注解定义"><a href="#2-通过注解定义" class="headerlink" title="2. 通过注解定义"></a>2. 通过注解定义</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut("execution(** concert.Performance.perform(..))")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performance</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before("performance()")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">silenceCellPhones</span><span class="params">()</span> {    </span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-使用参数化通知"><a href="#3-使用参数化通知" class="headerlink" title="3. 使用参数化通知"></a>3. 使用参数化通知</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Player.play(int)：被通知方法的参数类型 </span></span><br><span class="line"><span class="comment">// args(trackNumber)：被通知方法参数传递给通知方法中的 trackNumber 形参，即 pointcut 方法中的 trackNumber </span></span><br><span class="line"><span class="meta">@Pointcut("execution(* com.san.spring.aop.Player.play(int)) &amp;&amp; args(trackNumber)")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">(<span class="type">int</span> trackNumber)</span> {} </span><br><span class="line"></span><br><span class="line"><span class="meta">@Around("pointcut(trackNumber)")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countTrack</span><span class="params">(ProceedingJoinPoint pjp, <span class="type">int</span> trackNumber)</span> {    </span><br><span class="line">    <span class="keyword">try</span> {        </span><br><span class="line">        pjp.proceed();        </span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> getTrackCurrentCount(trackNumber);        </span><br><span class="line">        map.put(trackNumber, ++currentCount);    </span><br><span class="line">    } <span class="keyword">catch</span> (Throwable e) {        </span><br><span class="line">        ...    </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="三、创建切面"><a href="#三、创建切面" class="headerlink" title="三、创建切面"></a>三、创建切面</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Audience</span> {</span><br><span class="line">    <span class="meta">@Before("execution(** cocert.Performance.perform(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">silenceCellPhones</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before("execution(** concert.Performance.perform(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeSeats</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning("execution(** concert.Performance.perform(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applause</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing("execution(** concert.Performance.perform(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demandRefund</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around("performance()")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Taking seats"</span>);</span><br><span class="line">            <span class="comment">// 执行目标方法</span></span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1-使用自动代理"><a href="#1-使用自动代理" class="headerlink" title="1. 使用自动代理"></a>1. 使用自动代理</h2><p><strong>JavaConfig：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcertConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Audience <span class="title function_">audience</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Audience</span>();    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong>XML：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:context=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"concert"</span> /&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">    &lt;bean class=<span class="string">"concert.Audience"</span> /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-在-XML-中声名切面"><a href="#2-在-XML-中声名切面" class="headerlink" title="2. 在 XML 中声名切面"></a>2. 在 XML 中声名切面</h2><table>
<thead>
<tr>
<th><strong>AOP 配置元素</strong></th>
<th><strong>用途 </strong></th>
</tr>
</thead>
<tbody><tr>
<td><a href="aop:advisor">aop:advisor</a></td>
<td> 定义 AOP 通知器 </td>
</tr>
<tr>
<td><a href="aop:after">aop:after</a></td>
<td> 定义 AOP 后置通知 </td>
</tr>
<tr>
<td><a href="aop:after-returning">aop:after-returning</a></td>
<td> 定义 AOP 返回通知 </td>
</tr>
<tr>
<td><a href="aop:after-throwing">aop:after-throwing</a></td>
<td> 定义 AOP 异常通知 </td>
</tr>
<tr>
<td><a href="aop:around">aop:around</a></td>
<td> 定义 AOP 环绕通知 </td>
</tr>
<tr>
<td><a href="aop:aspect">aop:aspect</a></td>
<td> 定义一个切面 </td>
</tr>
<tr>
<td><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a></td>
<td> 启用 @AspectJ <br> 注解驱动的切面 </td>
</tr>
<tr>
<td><a href="aop:before">aop:before</a></td>
<td> 定义一个 AOP 前置通知 </td>
</tr>
<tr>
<td><a href="aop:config">aop:config</a></td>
<td> 顶级的 AOP 配置元素。大多数的 <a href="aop:*">aop:*</a> 元素必须包含在 <a href="aop:config">aop:config</a> 元素内 </td>
</tr>
<tr>
<td><a href="aop:declare-parents">aop:declare-parents</a></td>
<td> 以透明的方式为被通知的对象引入额外的接口 </td>
</tr>
<tr>
<td><a href="aop:pointcut">aop:pointcut</a></td>
<td> 定义一个切点</td>
</tr>
</tbody></table>
<p><em>具体方法：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Audience</span> {    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">silenceCellPhones</span><span class="params">()</span> {        </span><br><span class="line">        System.out.println(<span class="string">"Silencing cell phones"</span>);    </span><br><span class="line">    }        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeSeats</span><span class="params">()</span> {        </span><br><span class="line">        System.out.println(<span class="string">"Taking seats"</span>);    </span><br><span class="line">    }        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applause</span><span class="params">()</span> {        </span><br><span class="line">        System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);    </span><br><span class="line">    }        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demandRefund</span><span class="params">()</span> {        </span><br><span class="line">        System.out.println(<span class="string">"Demanding a refund"</span>);    </span><br><span class="line">    }        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchPerformance</span><span class="params">(ProceedingJoinPoint jp)</span> {        </span><br><span class="line">        <span class="keyword">try</span> {            </span><br><span class="line">            System.out.println(<span class="string">"Silencing cell phones"</span>);            </span><br><span class="line">            System.out.println(<span class="string">"Taking seats"</span>);            </span><br><span class="line">            <span class="comment">// 执行目标方法            </span></span><br><span class="line">            jp.proceed();            </span><br><span class="line">            System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);        </span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {            </span><br><span class="line">            System.out.println(<span class="string">"Demanding a refund"</span>);        </span><br><span class="line">        }    </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>XML 配置：</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"performance"</span> <span class="attr">expression</span>=<span class="string">"execution(** concert.Performance.perform(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"silenceCellPhones"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"takeSeats"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">"execution(** concert.Performance.perform(..))"</span> <span class="attr">method</span>=<span class="string">"applause"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut</span>=<span class="string">"execution(** concert.Performance.perform(..))"</span> <span class="attr">method</span>=<span class="string">"demandRefund"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">"performance"</span> <span class="attr">method</span>=<span class="string">"watchPerformance"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-1-为通知传递参数-——-XML"><a href="#2-1-为通知传递参数-——-XML" class="headerlink" title="2.1. 为通知传递参数 —— XML"></a>2.1. 为通知传递参数 —— XML</h3><p><em>具体方法：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrackCounter</span> {    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; trackCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countTrack</span><span class="params">(<span class="type">int</span> trackNumber)</span> {        </span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> getPlayCount(trackNumber);        </span><br><span class="line">        trackCounts.put(trackNumber, currentCount + <span class="number">1</span>);    </span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPlayCount</span><span class="params">(<span class="type">int</span> trackNumber)</span> {        </span><br><span class="line">        <span class="keyword">return</span> trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : <span class="number">0</span>;    </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>XML 配置：</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"trackCounter"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"trackPlayed"</span> <span class="attr">expression</span>=<span class="string">"execution(* soundsystem.CompactDisc.playTrack(int)) </span></span></span><br><span class="line"><span class="string"><span class="tag">            and args(trackNumber)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"trackPlayed"</span> <span class="attr">method</span>=<span class="string">"countTrack"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-通过切面引入新的功能-——-XML"><a href="#2-2-通过切面引入新的功能-——-XML" class="headerlink" title="2.2. 通过切面引入新的功能 —— XML"></a>2.2. 通过切面引入新的功能 —— XML</h3><ul>
<li><strong>type-matching：</strong> 指定目标接口</li>
<li><strong> implement-interface：</strong> 指定要增加的方法所在的接口</li>
<li><strong> default-impl：</strong> 指定要增加的方法的实现，也可以由 delegate-ref=”beanID” 来代替从而导入 Spring 容器中的 Bean</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:declare-parents</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">"concert.Performance+"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">"concert.Encoreable"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">"concert.DefaultEncoreable"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="四、通过注解引入新功能"><a href="#四、通过注解引入新功能" class="headerlink" title="四、通过注解引入新功能"></a>四、通过注解引入新功能</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c6f1f9cff941eeb554ecd0dd4ebac000.png"></p>
<p>通过建立一个代理类同时代理 A 和 B，调用者调用该代理时，就可以同时 A 和 B 中的方法了。</p>
<p><em>目标类：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Women</span> <span class="keyword">implements</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">likePerson</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"我是女生，我喜欢帅哥"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>被引入的类：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FemaleAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"我是雌性，我比雄性更喜欢吃零食"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>切面：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectConfig</span> {</span><br><span class="line">    <span class="comment">// "+"表示 person 的所有子类；defaultImpl 表示默认需要添加的新的类</span></span><br><span class="line">    <span class="meta">@DeclareParents(value = "com.ccomma.annotation.Person+", defaultImpl = FemaleAnimal.class)</span></span><br><span class="line">    <span class="keyword">public</span> Animal animal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h1><ul>
<li>在 bean 的后初始化方法（后置处理器）applyBeanPostProcessorsAfterInitialization 中执行了 AbstractAutoProxyCreator#postProcessAfterInitialization 方法<ul>
<li>内部执行了 AbstractAutoProxyCreator#wrapIfNecessary 方法<ul>
<li> getAdvicesAndAdvisorsForBean：查找出和当前 bean 匹配的 advisor</li>
<li>AbstractAutoProxyCreator#createProxy：把委托对象的 aop 增强和通用拦截进行合并，最终给代理对象，内部通过代理工厂 ProxyFactory#getProxy 创建代理<ul>
<li>代理工厂内部最终调用 DefaultAopProxyFactory#createAopProxy 来依据情况创建 jdk 代理或 cglib 代理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>类型转换异常 sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</title>
    <url>/fb2b1fd4b701/</url>
    <content><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">    Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第四行 <code>Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[0]</code> 报 <code>java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</code> 错误</p>
<p>这个代码是子类想要拿到泛型参数时出现的类型转换异常</p>
<span id="more"></span>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上述问题中的类结构简化如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request2</span> <span class="keyword">extends</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request3</span> <span class="keyword">extends</span> <span class="title class_">Request2</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request</span>&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request2</span>&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;R&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&lt;Request3&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>1/ <code>(new C).requestHandle()</code><br>因为 C 继承 B<request3>，所以 <code>parameterizedType.getActualTypeArguments()[0]</code> 拿到的其实就是 <code>Request3.class</code> </request3></p>
<p>2/ <code>(new B).requestHandle()</code><br>这种情况 <code>parameterizedType.getActualTypeArguments()[0]</code> 返回的是 <code>TypeVariable</code>，不是 Class<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/266de73a45592b057e2f6005b846e830.png" alt="image.png"><br>很好理解，因为 B 类的定义是 B<r extends="" request2="">，这里很容易因为泛型的类型擦除误认为 <code>parameterizedType.getActualTypeArguments()[0]</code> 会返回 <code>Request2.class</code></r></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>仔细观察 <code>TypeVariable</code> 接口定义</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeVariable</span>&lt;D <span class="keyword">extends</span> <span class="title class_">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title class_">Type</span>, AnnotatedElement {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上边界</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 Request2.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取泛型声明的类型，即这个类型变量的声明来源</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 B.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    D <span class="title function_">getGenericDeclaration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该类型变量名称</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 R</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带注解的上边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以调用 <code>getBounds()</code> 来获取泛型的上边界</p>
<p>最终调整如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> Class) {</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> TypeVariable) {</span><br><span class="line">            <span class="type">TypeVariable</span> <span class="variable">v</span> <span class="operator">=</span> (TypeVariable) actualTypeArgument;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) v.getBounds()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC 知识图</title>
    <url>/399332595808/</url>
    <content><![CDATA[<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/29b91a598275bc659cb7d19be1c1b875.png"></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-IoC-与-DI"><a href="#1-IoC-与-DI" class="headerlink" title="1. IoC 与 DI"></a>1. IoC 与 DI</h2><p><em>IoC：</em> 控制反转。把对象创建（实例化、管理）的控制权交给外部环境（spring 框架、IoC 容器）<br><em>DI：</em> 依赖注入。容器把被依赖对象注入到依赖对象中</p>
<h2 id="2-BeanFactory-与-ApplicationContext-区别"><a href="#2-BeanFactory-与-ApplicationContext-区别" class="headerlink" title="2. BeanFactory 与 ApplicationContext 区别"></a>2. BeanFactory 与 ApplicationContext 区别</h2><h3 id="2-1-BeanFactory-基础容器"><a href="#2-1-BeanFactory-基础容器" class="headerlink" title="2.1. BeanFactory 基础容器"></a>2.1. BeanFactory 基础容器</h3><ul>
<li>顶层容器（根容器），不能被实例化。 </li>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。 </li>
<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>
</ul>
<h3 id="2-2-ApplicationContext-高级容器"><a href="#2-2-ApplicationContext-高级容器" class="headerlink" title="2.2. ApplicationContext 高级容器"></a>2.2. ApplicationContext 高级容器</h3><ul>
<li>包含了基础容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。</li>
<li>支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等</li>
<li>即时加载、自己创建和管理资源对象、支持国际化、支持基于依赖的注解</li>
</ul>
<span id="more"></span>
<h1 id="二、XML-方式"><a href="#二、XML-方式" class="headerlink" title="二、XML 方式"></a>二、XML 方式</h1><h2 id="1-实例化-Bean-方式"><a href="#1-实例化-Bean-方式" class="headerlink" title="1. 实例化 Bean 方式"></a>1. 实例化 Bean 方式</h2><h3 id="1-1-使用无参构造函数"><a href="#1-1-使用无参构造函数" class="headerlink" title="1.1. 使用无参构造函数"></a>1.1. 使用无参构造函数</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 service 对象 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.lagou.service.impl.TransferServiceImpl"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2-使用静态方法创建"><a href="#1-2-使用静态方法创建" class="headerlink" title="1.2. 使用静态方法创建"></a>1.2. 使用静态方法创建</h3><p>class 属性： 指定静态方法所在的类<br>factory-method： 指定静态方法名</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使⽤静态⽅法创建对象的配置⽅式 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.lagou.factory.BeanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getTransferService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-3-使用实例化方法创建"><a href="#1-3-使用实例化方法创建" class="headerlink" title="1.3. 使用实例化方法创建"></a>1.3. 使用实例化方法创建</h3><p>factory-bean： 指定实例化方法所在的 bean<br>factory-method： 指定 factory-bean 中的实例化方法</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使⽤实例⽅法创建对象的配置⽅式 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactory"</span> <span class="attr">class</span>=<span class="string">"com.lagou.factory.instancemethod.BeanFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">factory-bean</span>=<span class="string">"beanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getTransferService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-属性装配"><a href="#2-属性装配" class="headerlink" title="2. 属性装配"></a>2. 属性装配</h2><h3 id="2-1-构造函数注入"><a href="#2-1-构造函数注入" class="headerlink" title="2.1. 构造函数注入"></a>2.1. 构造函数注入</h3><p>构造函数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcAccountDaoImpl</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdbcAccountDaoImpl</span><span class="params">(ConnectionUtils connectionUtils, String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对应 bean 配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.lagou.edu.dao.impl.JdbcAccountDaoImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constractor-arg</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>&gt;</span><span class="tag">&lt;/<span class="name">constractor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constractor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">constractor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-set-方法注入"><a href="#2-2-set-方法注入" class="headerlink" title="2.2. set 方法注入"></a>2.2. set 方法注入</h3><p>property 对应类中的字段属性</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.lagou.edu.dao.impl.JdbcAccountDaoImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionUtils"</span> <span class="attr">ref</span>=<span class="string">"connectionUtils"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- list --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myArray"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>array1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>array2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- set --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>set1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>set2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- map --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key1"</span> <span class="attr">value</span>=<span class="string">"value1"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key2"</span> <span class="attr">value</span>=<span class="string">"value2"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProperties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop1"</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop2"</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="三、注解方式"><a href="#三、注解方式" class="headerlink" title="三、注解方式"></a>三、注解方式</h1><h2 id="1-实例化-Bean-方式-1"><a href="#1-实例化-Bean-方式-1" class="headerlink" title="1. 实例化 Bean 方式"></a>1. 实例化 Bean 方式</h2><ul>
<li>_@Configuration：_表明该类为配置类</li>
<li>_@ComponentScan：_这个注解能够在 Spring 中启用组件扫描。 默认会扫描与配置类相同的包</li>
<li>_@PropertySource：_引⼊外部属性配置⽂件</li>
<li>_@Import：_引⼊其他配置类</li>
<li>_@ImportResource：_引用 XML 配置</li>
<li>_@Value：_对变量赋值，可以直接赋值，也可以使⽤ ${} 读取资源配置⽂件中的信息 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Import({CDPlayerConfig.class, CDConfig.class})</span></span><br><span class="line"><span class="meta">@ImportResource("classpath:cd-config.xml")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoundSystemConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-1-组件实现实例化"><a href="#1-1-组件实现实例化" class="headerlink" title="1.1. 组件实现实例化"></a>1.1. 组件实现实例化</h3><p>通过 @ComponentScan  类路径扫描来自动侦测以及自动装配到 Spring 容器中 <br>用于自定义类</p>
<ul>
<li>@Component：基本注解，标识了一个受 Spring 管理的组件</li>
<li> @Respository：标识持久层组件</li>
<li> @Service：标识服务层（业务层）组件</li>
<li> @Controller：标识表现层组件</li>
</ul>
<h3 id="1-2-Bean-实现实例化"><a href="#1-2-Bean-实现实例化" class="headerlink" title="1.2. @Bean  实现实例化"></a>1.2. @Bean  实现实例化</h3><p>在 @Configuration  定义的配置类中使用可注册并获得 bean <br>通常同于第三方插件实例化</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayConfig</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(name="lonelyHeartsClubBand")</span></span><br><span class="line">    <span class="keyword">public</span> CompactDisc <span class="title function_">sgtPeppers</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SgtPeppers</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-属性装配-1"><a href="#2-属性装配-1" class="headerlink" title="2. 属性装配"></a>2. 属性装配</h2><ul>
<li><p><strong>@Autowired：</strong> 按照类型注⼊ </p>
</li>
<li><p><strong>@Qualifier：</strong> 告诉 Spring 具体去装配哪个对象 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> {</span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="meta">@Qualifier(name="jdbcAccountDaoImpl")</span> </span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>@Resource：</strong> 注解由 J2EE 提供，默认按照 ByName ⾃动注⼊ </p>
</li>
<li><p><strong>@Primary：</strong> 可以通过 @Primary  来表达最喜欢的方案  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IceCream</span> <span class="keyword">implements</span> <span class="title class_">Dessert</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bean 方法</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> Dessert <span class="title function_">iceCream</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IceCream</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="四、启动容器方式"><a href="#四、启动容器方式" class="headerlink" title="四、启动容器方式"></a>四、启动容器方式</h1><h2 id="1-Java-环境下启动-IoC-容器"><a href="#1-Java-环境下启动-IoC-容器" class="headerlink" title="1. Java 环境下启动 IoC 容器"></a>1. Java 环境下启动 IoC 容器</h2><ul>
<li>ClassPathXmlApplicationContext：从类的根路径下加载配置⽂件（推荐使⽤）</li>
<li>FileSystemXmlApplicationContext：从磁盘路径上加载配置⽂件</li>
<li> AnnotationConfigApplicationContext：纯注解模式下启动 Spring 容器</li>
</ul>
<h2 id="2-Web-环境下启动-IoC-容器"><a href="#2-Web-环境下启动-IoC-容器" class="headerlink" title="2. Web 环境下启动 IoC 容器"></a>2. Web 环境下启动 IoC 容器</h2><p><em>从 xml 启动容器：</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span> <span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Spring IoC 容器的配置⽂件 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 使⽤监听器启动 Spring 的 IoC 容器 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>从配置类启动容器：</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span> <span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 告诉 ContextloaderListener 知道我们使⽤注解的⽅式启动 IoC 容器 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置启动类的全限定类名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.lagou.edu.SpringConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 使⽤监听器启动 Spring 的 IoC 容器 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="五、bean-的作用域"><a href="#五、bean-的作用域" class="headerlink" title="五、bean 的作用域"></a>五、bean 的作用域</h1><h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h2><ul>
<li><em>单例（Singleton）：</em> 在整个应用中，只创建 bean 的一个实例</li>
<li>_原型（Prototype）_： 每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的 bean 实例</li>
<li><em>会话（Session）：</em> 在 Web 应用中，为每个会话创建一个 bean 实例</li>
<li><em>请求（Request）：</em> 在 Web 应用中，为每个请求创建一个 bean 实例</li>
</ul>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p><em>xml：</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.lagou.service.impl.TransferServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>注解：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notepad</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="六、高级特性"><a href="#六、高级特性" class="headerlink" title="六、高级特性"></a>六、高级特性</h1><h2 id="1-lazy-Init"><a href="#1-lazy-Init" class="headerlink" title="1. lazy-Init"></a>1. lazy-Init</h2><p>_懒加载：_不会在容器初始化时加载这个 bean ，⽽是第⼀次向容器通过 getBean 索取 bean 时实例化<br><em>xml：</em><code>&lt;bean id="testBean" calss="cn.lagou.LazyBean" lazy-init="true" /&gt;</code><br><em>注解：</em><code>@Lazy</code></p>
<h2 id="2-FactoryBean"><a href="#2-FactoryBean" class="headerlink" title="2. FactoryBean"></a>2. FactoryBean</h2><p><a href="https://blog.csdn.net/weixin_42195284/article/details/109339203">(63 条消息) Spring - FactoryBean 的使用场景和源码_阿里巴巴首席技术官的博客 - CSDN 博客_factorybean 使用场景</a><br>可以⽣成某⼀个类型的 Bean 实例，可以借助于它⾃定义 Bean 的创建过程</p>
<p><em>CompanyFactoryBean：</em></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以让我们⾃定义 Bean 的创建过程（完成复杂 Bean 的定义）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Company&gt; {</span><br><span class="line">    <span class="comment">/** 公司名称,地址,规模 */</span></span><br><span class="line">    <span class="keyword">private</span> String companyInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyInfo</span><span class="params">(String companyInfo)</span> { </span><br><span class="line">        <span class="built_in">this</span>.companyInfo = companyInfo;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 FactoryBean 创建的Bean实例，如果 isSingleton 返回 true，则该实例会放到 Spring 容器的单例对象缓存池中 Map</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Company <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">		<span class="comment">// 模拟创建复杂对象</span></span><br><span class="line">        Company <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        String[] strings = companyInfo.split(<span class="string">","</span>);</span><br><span class="line">        company.setName(strings[<span class="number">0</span>]); </span><br><span class="line">        company.setAddress(strings[<span class="number">1</span>]); </span><br><span class="line">        company.setScale(Integer.parseInt(strings[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> company; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 FactoryBean 创建的 Bean 类型</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() {</span><br><span class="line">        <span class="keyword">return</span> Company.class;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回作⽤域是否单例 </span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>bean 定义：</em><br>当获取 id 为 companyBean 的 bean 时会返回 Company 类型的 bean<br>获取 FactoryBean，需要在 id 之前添加 “&amp;”，如：”&amp;companyBean”</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"companyBean"</span> <span class="attr">class</span>=<span class="string">"com.lagou.edu.factory.CompanyFactoryBean"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"companyInfo"</span> <span class="attr">value</span>=<span class="string">"xx,中关村,500"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-profile-bean"><a href="#3-profile-bean" class="headerlink" title="3. profile bean"></a>3. profile bean</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile("dev")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevelopmentProfileConfig</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">        .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">        .addScript(<span class="string">"classpath:schema.sql"</span>)</span><br><span class="line">        .addScript(<span class="string">"classpath:test-data.sql"</span>)</span><br><span class="line">        .build();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><em>spring.profiles.active：</em> 如果设置了 <code>spring.profiles.active</code> 属性的话，那么它的值就会用来确定哪个 profile 是激活的 </li>
<li><em>spring.profiles.default：</em> 如果没有设置 <code>spring.profiles.active</code> 属性的话，那 Spring 将会查 <code>spring.profiles.default</code> 的值</li>
</ul>
<p><em>设置属性方式：</em></p>
<ul>
<li>作为 DispatcherServlet 的初始化参数</li>
<li>作为 Web 应用的上下文参数</li>
<li>作为 JNDI 条目</li>
<li>作为环境变量</li>
<li>作为 JVM 的系统属性</li>
<li>在集成测试类上，使用 @ActiveProfiles  注解</li>
</ul>
<h2 id="4-条件化配置-Bean"><a href="#4-条件化配置-Bean" class="headerlink" title="4. 条件化配置 Bean"></a>4. 条件化配置 Bean</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">// 条件化创建 Bean</span></span><br><span class="line"><span class="meta">@Conditional(MagicExistsCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> MagicBean <span class="title function_">magicBean</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MagicBean</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MagicExistsCondition</span> implement Condition {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class="line">        <span class="type">Environment</span> <span class="variable">env</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line">        <span class="comment">// 检查 magic 属性</span></span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 ConditionContext，我们可以做到如下几点：</p>
<ul>
<li>借助 getRegistry () 返回的 BeanDefinitionRegistry 检查 bean 定义</li>
<li>借助 getBeanFactory () 返回的 ConfigurableListableBeanFactory 检查 bean 是否存在，甚至探查 bean 的属性</li>
<li>借助 getEnvironment () 返回的 Environment 检查环境变量是否存在以及它的值是什么</li>
<li>读取并探查 getResourceLoader () 返回的 ResourceLoader 所加载的资源</li>
<li>借助 getClassLoader () 返回的 ClassLoader 加载并检查类是否存在</li>
</ul>
<h2 id="5-使用-Enviroment-注入"><a href="#5-使用-Enviroment-注入" class="headerlink" title="5. 使用 Enviroment 注入"></a>5. 使用 Enviroment 注入</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Configuration</span><br><span class="line"><span class="comment">// 声明属性源</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:/com/soundsystem/app.properties")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressiveConfig</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BlankDisc <span class="title function_">disc</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查属性值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlankDisc</span>(env.getProperty(<span class="string">"disc.title"</span>), env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="七、Bean-生命周期"><a href="#七、Bean-生命周期" class="headerlink" title="七、Bean 生命周期"></a>七、Bean 生命周期</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e5ab871d89cf20cc90c74400e0106716.webp"></p>
<ol>
<li><p>容器启动后会创建 BeanFactory，并加载配置的 bean 信息成 BeanDefinition 放入 Map<br>这之后会执行自定义的 Bean 工厂后置处理器（实现 BeanFactoryPostProcessor 接口）中的 postProcessBeanFactory 方法。可从中获得 bean 配置信息（BeanDefinition） </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>这之后会对 scope 为 singleton 且非懒加载的 bean 进行实例化 </p>
</li>
<li><p>按照 Bean 定义信息配置信息，注入所有的属性 </p>
</li>
<li><p>如果 Bean 实现了 BeanNameAware 接口，会回调该接口的 setBeanName () 方法，传入该 Bean 的 id。此时该 Bean 就获得了自己在配置文件中的 id </p>
</li>
<li><p>如果 Bean 实现了 BeanFactoryAware 接口，会回调该接口的 setBeanFactory () 方法，传入该 Bean 的 BeanFactory。这样该 Bean 就获得了自己所在的 BeanFactory</p>
</li>
<li><p>如果 Bean 实现了 ApplicationContextAware 接口，会回调该接口的 setApplicationContext () 方法，传入该 Bean 的 ApplicationContext。这样该 Bean 就获得了自己所在的 ApplicationContext </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, BeanFactoryAware, ApplicationContextAware {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> {</span><br><span class="line">        System.out.println(<span class="string">"该对象注册成 bean 时定义的 id："</span> + name);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        System.out.println(<span class="string">"该对象的 beanFactory："</span> + beanFactory);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        System.out.println(<span class="string">"applicationContext："</span> + applicationContext);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果有 Bean 实现了 BeanPostProcessor 接口，会回调该接口的 postProcessBeforeInitialzation () 方法 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init-method 方法执行之前被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"lazyResult"</span>.equalsIgnoreCase(beanName)) {</span><br><span class="line">            System.out.println(<span class="string">"MyBeanPostProcessor before 方法拦截处理 lazyResult"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果 Bean 实现了 InitializingBean 接口，则会回调该接口的 afterPropertiesSet () 方法，@PostConstruct  注解的方法在该方法之前被调用  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 afterPropertiesSet 之前执行</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"postConstruct"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="string">"afterPropertiesSet"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果 Bean 配置了 init-method 方法，则会执行 init-method 配置的方法，@PostConstruct  注解的方法在该方法之前被调用  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 afterPropertiesSet 之后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"initMethod"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"lazyResult"</span> class=<span class="string">"com.xxx.beans.Result"</span> init-method=<span class="string">"initMethod"</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果有 Bean 实现了 BeanPostProcessor 接口，则会回调该接口的 postProcessAfterInitialization () 方法 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * initmethod 方法执行之后被调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object beanm String beanName)</span> {</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"lazyResult"</span>.equalsIgnoreCase(beanName)) {</span><br><span class="line">           System.out.println(<span class="string">"MyBeanPostProcessor after 方法拦截处理 lazyResult"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> bean;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用该 Bean</p>
</li>
</ol>
<ul>
<li>scope 为 singleton 的 Bean：Spring 的 IoC 容器中会缓存一份该 bean 的实例（singletonObjects 中）</li>
<li>scope 为 prototype 的 Bean：每次使用都会 new 一个新的对象，对象的生命周期不归 IoC 容器管理，对象的销毁交给垃圾回收器</li>
</ul>
<ol start="12">
<li><p>容器关闭后，如果 Bean 实现了 DisposableBean 接口，则会回调该接口的 destroy () 方法，@PreDestory  注解的方法在该方法之前被调用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 destroy 之前执行</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"preDestroy"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="string">"destroy"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果 Bean 配置了 destroy-method 方法，则会执行 destroy-method 配置的方法 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 destroy 之后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"destroyMethod"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="八、源码分析"><a href="#八、源码分析" class="headerlink" title="八、源码分析"></a>八、源码分析</h1><p><strong><em>Spring IoC 的容器体系：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6ae6fb4bcf1239b690ac2d13357e975a.png"></p>
<h2 id="1-容器初始化分析"><a href="#1-容器初始化分析" class="headerlink" title="1. 容器初始化分析"></a>1. 容器初始化分析</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 容器初始化</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"classpath:applicationContext.xml"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>最终调用 AbstractApplicationContext#refresh 方法进行容器初始化</p>
<p><em>refresh 主要流程：</em></p>
<ol>
<li>初始化工厂</li>
</ol>
<ul>
<li><strong> obtainFreshBeanFactory 方法：</strong> 获取 DefalutListableBeanFactory 工厂、解析 xml 加载 BeanDefinition 并注册到 BeanDefinitionRegistry <ol>
<li>调用 refreshBeanFactory 方法：关闭以前的工厂，初始化一个新工厂（DefaultListableBeanFactory）并自定义属性 </li>
<li>调用 <code>**loadBeanDefinitions**</code> 方法：最终调用 XmlBeanDefinitionReader#loadBeanDefinitions 加载 BeanDefinition</li>
</ol>
</li>
<li><strong>invokeBeanFactoryPostProcessors 方法：</strong> 生成实现了 BeanFactoryPostProcessor 的 bean，并调用其方法</li>
</ul>
<ol start="2">
<li>初始化 Bean</li>
</ol>
<ul>
<li><strong>registerBeanPostProcessors 方法：</strong> 注册 BeanPostProcessor 后置处理器（目前阶段尚未执行） </li>
<li><strong>finishBeanFactoryInitialization 方法：</strong><br>调用 ConfigurableListableBeanFactory#preInstantiateSingletons 来实例化所有非懒加载的单例 bean<br>遍历所有 beanName，若是非抽象、单例、非懒加载的 beanDefinition 则调用 <code>**AbstractBeanFactory#getBean**</code></li>
</ul>
<p>下面重点介绍 <code>loadBeanDefinitions</code> 和 <code>getBean</code> 方法</p>
<h3 id="1-1-loadBeanDefinitions"><a href="#1-1-loadBeanDefinitions" class="headerlink" title="1.1. loadBeanDefinitions"></a>1.1. loadBeanDefinitions</h3><p>XmlBeanDefinitionReader#loadBeanDefinitions<br><em>作用：</em> 加载 bean 配置信息<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/df5c2921910f43558036912fa017253d.jpg"><br><em>重要步骤：</em></p>
<ul>
<li><ol start="2">
<li>doLoadDocument：获取 XML DOM 文档</li>
</ol>
</li>
<li><ol start="3">
<li> registerBeanDefinitions：从 DOM 文档中读取 beanDefinition 并将它们注册到 readerContext 里的注册表中</li>
</ol>
<ul>
<li><ol start="5">
<li> createDelegate：创建委托类进行初始化</li>
</ol>
</li>
<li><ol start="6">
<li> parseBeanDefinitions：解析标签注册 beanDefinition</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-getBean"><a href="#1-2-getBean" class="headerlink" title="1.2. getBean"></a>1.2. getBean</h3><p>获取 bean 方法，从中可以看出 bean 的生命周期<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d2af32e43815f745ca2afa88b44e9c7.jpg"><br><em>重要步骤：</em></p>
<ul>
<li><ol start="2">
<li>getSingleton：分别从一二三级缓存中获取 bean，若有缓存则直接返回</li>
</ol>
</li>
<li><ol start="4">
<li> getSingleton：生成一个新的 bean 实例</li>
</ol>
<ul>
<li><ol start="5">
<li>加锁并再次从缓存中获取，与 <code>2) getSingleton</code> 组成双重检验锁（DCL）</li>
</ol>
</li>
<li><ol start="7">
<li>createBean：创建 bean 并进行一系列初始化操作，实际调用 doCreateBean 方法</li>
</ol>
<ul>
<li><ol start="8">
<li> createBeanInstance：创建 bean 实例，但尚未设置属性</li>
</ol>
</li>
<li><ol start="9">
<li> addSingletonFactory：将该 bean 加入三级缓存 singletonFactories 中，提前暴露该 bean 的引用</li>
</ol>
</li>
<li><ol start="11">
<li> populateBean：为 bean 设置属性值，若遇到依赖的 bean 会调用 <code>13) resolveValueIfNecessary</code> 方法，内部会重新调用 getBean 方法来获取依赖 bean 的引用<br>由于最初要获取的 bean 已经加入三级缓存暴露了引用，所以其依赖的 bean 若出现循环引用则会调用 <code>2) getSingleton</code> 从三级缓存中获取该引用，并把该引用转移到二级缓存中</li>
</ol>
</li>
<li><ol start="15">
<li> initializeBean：初始化 bean</li>
</ol>
<ul>
<li>invokeAwareMethods：调用 setBeanName、setBeanFactory、setApplicationContext 三个 aware 类型的方法</li>
<li> applyBeanPostProcessorsBeforeInitialization：后置处理器的 before 方法（与初始化方法）</li>
<li>invokeInitMethods：初始化方法</li>
<li> applyBeanPostProcessorsAfterInitialization：后置处理器的 after 方法（后初始化方法）</li>
</ul>
</li>
</ul>
</li>
<li><ol start="16">
<li>registerDisposableBeanIfNecessary：注册销毁方法</li>
</ol>
</li>
<li><ol start="19">
<li> addSingleton：初始化 bean 后将其放入一级缓存以便后续使用</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-循环依赖"><a href="#2-循环依赖" class="headerlink" title="2. 循环依赖"></a>2. 循环依赖</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4c5fdac59e50eb6fd4819395ac04777f.png"></p>
<p><em>概述：</em><br>循环引用，两个或两个以上的 Bean 互相持有对方，最终形成闭环</p>
<p><em>解决：</em><br>采用三级缓存。在 bean 创建后尚未设置属性时先将 bean 的引用（称为早期引用）暴露，这样后续依赖的 bean 就能获取到这个引用。</p>
<ul>
<li>因为需要将 bean 的早期引用放入缓存，所以无法解决构造器注入下的循环依赖 </li>
<li>因为 prototype 原型 bean 生成实例后不被容器管理，所以也无法解决 scope 为 prototype 的 bean 循环依赖</li>
</ul>
<p><em>原理：</em></p>
<ul>
<li>三级缓存 singletonFactories：bean 实例化后尚未设置属性时放入三级缓存中提前暴露引用</li>
<li>二级缓存 earlySingletonObjects：当 A 对象依赖 B 对象，B 对象又依赖 A 对象时，B 可从三级缓存中获取 A 的早期引用，并放入二级缓存。在这过程中可做一些扩展操作</li>
<li>一级缓存 singletonObjects：存放完整初始化后的 bean</li>
</ul>
<h1 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h1><p><em>其他资料：</em></p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">Spring Boot 参考指南</a></li>
<li><a href="https://springcloud.cc/spring-reference.html">Spring 官方文档中文版</a></li>
<li><a href="http://www.imooc.com/article/34150">Spring IOC 容器源码分析 - 循环依赖的解决办法</a></li>
<li><a href="https://blog.csdn.net/u011246915/article/details/82716009">Spring 加载过程</a></li>
</ul>
<p><em>面试题：</em></p>
<ul>
<li><a href="http://ifeve.com/spring-interview-questions-and-answers/">69 道 Spring 面试题和答案</a></li>
<li><a href="https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.md">Spring 面试题</a></li>
<li><a href="http://www.importnew.com/15851.html">Spring 面试问答 Top 25</a></li>
<li><a href="https://www.cnblogs.com/wang-meng/p/5701982.html">Spring 总结以及在面试中的一些问题</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 事件原理</title>
    <url>/01a10f7c716a/</url>
    <content><![CDATA[<h1 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/77cdb749d6378906d4e03ee1f7fc911a.png" alt="image.png"><br>自定义事件继承 ApplicationEvent 即可</p>
<span id="more"></span>
<h1 id="二、事件监听者"><a href="#二、事件监听者" class="headerlink" title="二、事件监听者"></a>二、事件监听者</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c32ab68e117b017b6d1c1e7608e3dfdb.png" alt="image.png"><br>SmartApplicationListener</p>
<h1 id="三、事件发布者"><a href="#三、事件发布者" class="headerlink" title="三、事件发布者"></a>三、事件发布者</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e8556596c3e85d62d256a931620a50c4.png" alt="image.png"></p>
<h2 id="1-ApplicationEventPublisher"><a href="#1-ApplicationEventPublisher" class="headerlink" title="1. ApplicationEventPublisher"></a>1. ApplicationEventPublisher</h2><ul>
<li>publishEvent(ApplicationEvent)</li>
<li>publishEvent(Object)</li>
</ul>
<h3 id="1-1-AbstractApplicationContext"><a href="#1-1-AbstractApplicationContext" class="headerlink" title="1.1. AbstractApplicationContext"></a>1.1. AbstractApplicationContext</h3><p>调用了 ApplicationEventMulticaster 中的 multicastEvent 方法来具体实现发布事件给监听者的操作</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">    Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) {</span><br><span class="line">        <span class="built_in">this</span>.logger.trace(<span class="string">"Publishing event in "</span> + <span class="built_in">this</span>.getDisplayName() + <span class="string">": "</span> + event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Object applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) {</span><br><span class="line">        applicationEvent = (ApplicationEvent)event;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>(<span class="built_in">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="literal">null</span>) {</span><br><span class="line">            eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了 ApplicationEventMulticaster 中的 multicastEvent 方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">this</span>.getApplicationEventMulticaster().multicastEvent((ApplicationEvent)applicationEvent, eventType);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) {</span><br><span class="line">            ((AbstractApplicationContext)<span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-ApplicationEventMulticaster"><a href="#2-ApplicationEventMulticaster" class="headerlink" title="2. ApplicationEventMulticaster"></a>2. ApplicationEventMulticaster</h2><p>定义了对 ApplicationListener 的维护操作（比如新增、 移除等）<br>以及将 ApplicationEvent 多播给可用 ApplicationListener 的操作</p>
<ul>
<li>multicastEvent(ApplicationEvent)</li>
<li>multicastEvent(ApplicationEvent, ResolvableType)</li>
</ul>
<h3 id="2-1-SimpleApplicationEventMulticaster"><a href="#2-1-SimpleApplicationEventMulticaster" class="headerlink" title="2.1. SimpleApplicationEventMulticaster"></a>2.1. SimpleApplicationEventMulticaster</h3><p><strong>步骤：</strong></p>
<ol>
<li>调用父类中的 getApplicationListeners (ApplicationEvent, ResolvableType) 获取相关监听器</li>
<li>遍历并执行各个监听器 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">   <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">   <span class="comment">// 执行所有监听器</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">      <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">      <span class="keyword">if</span> (executor != <span class="literal">null</span>) {</span><br><span class="line">         executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">         invokeListener(listener, event);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="2-2-AbstractApplicationEventMulticaster"><a href="#2-2-AbstractApplicationEventMulticaster" class="headerlink" title="2.2. AbstractApplicationEventMulticaster"></a>2.2. AbstractApplicationEventMulticaster</h3><p><strong>步骤：</strong></p>
<ol>
<li>从缓存中取监听器集合（包括预加载的监听器）</li>
<li>若无则检索监听器并加入缓存</li>
</ol>
<p><strong>思考：</strong></p>
<ul>
<li>考虑并发（ConcurrentHashMap、synchronized）</li>
<li>利用 Map 进行缓存</li>
<li>对键和值分别进行包装（ListenerCacheKey、ListenerRetriever），可附加额外功能（可扩展性）<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 ConcurrentHashMap 对监听器进行缓存</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;ListenerCacheKey, ListenerRetriever&gt; retrieverCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">      ApplicationEvent event, ResolvableType eventType) {</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">   Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 以事件类型和源类型作为缓存的键</span></span><br><span class="line">   <span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Quick check for existing entry on ConcurrentHashMap...</span></span><br><span class="line">   <span class="type">ListenerRetriever</span> <span class="variable">retriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">   <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> retriever.getApplicationListeners();</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.beanClassLoader == <span class="literal">null</span> ||</span><br><span class="line">         (ClassUtils.isCacheSafe(event.getClass(), <span class="built_in">this</span>.beanClassLoader) &amp;&amp;</span><br><span class="line">               (sourceType == <span class="literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="built_in">this</span>.beanClassLoader)))) {</span><br><span class="line">      <span class="comment">// Fully synchronized building and caching of a ListenerRetriever</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.retrievalMutex) {</span><br><span class="line">         retriever = <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">         <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> retriever.getApplicationListeners();</span><br><span class="line">         }</span><br><span class="line">         retriever = <span class="keyword">new</span> <span class="title class_">ListenerRetriever</span>(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">// 检索监听器</span></span><br><span class="line">         Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners =</span><br><span class="line">               retrieveApplicationListeners(eventType, sourceType, retriever);</span><br><span class="line">         <span class="built_in">this</span>.retrieverCache.put(cacheKey, retriever);</span><br><span class="line">         <span class="keyword">return</span> listeners;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// No ListenerRetriever caching -&gt; no synchronization necessary</span></span><br><span class="line">      <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, <span class="literal">null</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给出的事件类型和源类型检索相关监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">      ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> ListenerRetriever retriever) {</span><br><span class="line"></span><br><span class="line">   LinkedList&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">   Set&lt;String&gt; listenerBeans;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.retrievalMutex) {</span><br><span class="line">      listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">      listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) {</span><br><span class="line">      <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) {</span><br><span class="line">         <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">            retriever.applicationListeners.add(listener);</span><br><span class="line">         }</span><br><span class="line">         allListeners.add(listener);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (!listenerBeans.isEmpty()) {</span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">      <span class="keyword">for</span> (String listenerBeanName : listenerBeans) {</span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; listenerType = beanFactory.getType(listenerBeanName);</span><br><span class="line">            <span class="keyword">if</span> (listenerType == <span class="literal">null</span> || supportsEvent(listenerType, eventType)) {</span><br><span class="line">               ApplicationListener&lt;?&gt; listener =</span><br><span class="line">                     beanFactory.getBean(listenerBeanName, ApplicationListener.class);</span><br><span class="line">               <span class="keyword">if</span> (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) {</span><br><span class="line">                  <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">                     retriever.applicationListenerBeans.add(listenerBeanName);</span><br><span class="line">                  }</span><br><span class="line">                  allListeners.add(listener);</span><br><span class="line">               }</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">            <span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line">            <span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">   <span class="keyword">return</span> allListeners;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 配置多数据源</title>
    <url>/f5c90de53682/</url>
    <content><![CDATA[<h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/36dae00c61d2e0b88d541ce04d03af8e.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="2-启动文件"><a href="#2-启动文件" class="headerlink" title="2. 启动文件"></a>2. 启动文件</h2><p>禁止数据源自动配置</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</span></span><br><span class="line"><span class="meta">@ServletComponentScan("com.chemyun.mall.api.filter")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenApiApplication</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(OpenApiApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-Properties-文件"><a href="#3-Properties-文件" class="headerlink" title="3. Properties 文件"></a>3. Properties 文件</h2><p><strong><em>application.yml：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    master:</span><br><span class="line">      url: jdbc:mysql:<span class="comment">//172.19.253.52:9527/chemme?autoCommit=true&amp;useUnicode=true&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br><span class="line">      username: chemme</span><br><span class="line">      password: hEJpiLR162xRCBqYcNEwck4Ulr3A66OtfGUalzDAOMwvtB3RaPsfD0nylr7mOry8kOyd2BQiYIgNyzXF8q1T3A==</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">      filters: stat,slf4j,config</span><br><span class="line">      initial-size: <span class="number">1</span></span><br><span class="line">      min-idle: <span class="number">1</span></span><br><span class="line">      max-active: <span class="number">10</span></span><br><span class="line">      max-wait: <span class="number">60000</span></span><br><span class="line">      use-global-data-source-stat: <span class="literal">true</span></span><br><span class="line">      connectProperties:</span><br><span class="line">        druid.stat.slowSqlMillis: <span class="number">5000</span></span><br><span class="line">        config.decrypt: <span class="literal">true</span></span><br><span class="line">        config.decrypt.key: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ3JZ3D6h+2OasZg1OMptc1KPKabNAp1IaqL9CeoLrsrDlQAdTpJZrRvKxISiWuwPb96KaW+vkOxfhWrWm9txukCAwEAAQ==</span><br><span class="line">    slave:</span><br><span class="line">      url: jdbc:sqlserver:<span class="comment">//124.160.116.211:1434;DatabaseName=chemcndata</span></span><br><span class="line">      username: chemme</span><br><span class="line">      password: chemme@<span class="number">20181121</span></span><br><span class="line">      driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver</span><br></pre></td></tr></tbody></table></figure>


<p><strong><em>AbstractDataBaseProperties：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDataBaseProperties</span> {</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">filters</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">initialSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxActive</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxWait</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useGlobalDataSourceStat</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; connectProperties;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><em>MasterDataBaseProperties：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = "spring.datasource.master")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataBaseProperties</span> <span class="keyword">extends</span> <span class="title class_">AbstractDataBaseProperties</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><em>SlaveDataBaseProperties：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = "spring.datasource.slave")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataBaseProperties</span> <span class="keyword">extends</span> <span class="title class_">AbstractDataBaseProperties</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-数据源配置"><a href="#4-数据源配置" class="headerlink" title="4. 数据源配置"></a>4. 数据源配置</h2><p><strong><em>MasterDataSourceConfig：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MasterDataBaseProperties.class)</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = "masterSqlSessionFactory")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataSourceConfig</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PACKAGE</span> <span class="operator">=</span> <span class="string">"com.chemyun.mall.api.dal.mapper"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPER_LOCATION</span> <span class="operator">=</span> <span class="string">"classpath:com/chemyun/mall/api/dal/mapper/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MasterDataBaseProperties masterDataBaseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = "masterDataSource")</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setDriverClassName(masterDataBaseProperties.getDriverClassName());</span><br><span class="line">        druidDataSource.setUrl(masterDataBaseProperties.getUrl());</span><br><span class="line">        druidDataSource.setUsername(masterDataBaseProperties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(masterDataBaseProperties.getPassword());</span><br><span class="line"></span><br><span class="line">        druidDataSource.setFilters(masterDataBaseProperties.getFilters());</span><br><span class="line"></span><br><span class="line">        druidDataSource.setInitialSize(masterDataBaseProperties.getInitialSize());</span><br><span class="line">        druidDataSource.setMinIdle(masterDataBaseProperties.getMinIdle());</span><br><span class="line">        druidDataSource.setMaxActive(masterDataBaseProperties.getMaxActive());</span><br><span class="line">        druidDataSource.setMaxWait(masterDataBaseProperties.getMaxWait());</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(masterDataBaseProperties.isUseGlobalDataSourceStat());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connectProperties</span></span><br><span class="line">        Map&lt;String, String&gt; connectProperties = masterDataBaseProperties.getConnectProperties();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(connectProperties)) {</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; connectPropertie : connectProperties.entrySet()) {</span><br><span class="line">                properties.setProperty(connectPropertie.getKey(), connectPropertie.getValue());</span><br><span class="line">            }</span><br><span class="line">            druidDataSource.setConnectProperties(properties);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = "masterTransactionManager")</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">masterTransactionManager</span><span class="params">()</span> <span class="keyword">throws</span> SQLException {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(masterDataSource());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = "masterSqlSessionFactory")</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">masterSqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier("masterDataSource")</span> DataSource masterDataSource)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sessionFactory.setDataSource(masterDataSource);</span><br><span class="line">        sessionFactory.setMapperLocations(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(MasterDataSourceConfig.MAPPER_LOCATION));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><em>SlaveDataSourceConfig：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SlaveDataBaseProperties.class)</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = SlaveDataSourceConfig.PACKAGE, sqlSessionFactoryRef = "slaveSqlSessionFactory")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataSourceConfig</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PACKAGE</span> <span class="operator">=</span> <span class="string">"com.chemyun.mall.api.dal.slave"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPER_LOCATION</span> <span class="operator">=</span> <span class="string">"classpath:com/chemyun/mall/api/dal/slave/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SlaveDataBaseProperties slaveDataBaseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = "slaveDataSource")</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(slaveDataBaseProperties.getDriverClassName());</span><br><span class="line">        dataSource.setUrl(slaveDataBaseProperties.getUrl());</span><br><span class="line">        dataSource.setUsername(slaveDataBaseProperties.getUsername());</span><br><span class="line">        dataSource.setPassword(slaveDataBaseProperties.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = "slaveTransactionManager")</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">slaveTransactionManager</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(slaveDataSource());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = "slaveSqlSessionFactory")</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">slaveSqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier("slaveDataSource")</span> DataSource slaveDataSource)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sessionFactory.setDataSource(slaveDataSource);</span><br><span class="line">        sessionFactory.setMapperLocations(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(SlaveDataSourceConfig.MAPPER_LOCATION));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土②：常用命令</title>
    <url>/ed1836dca5d2/</url>
    <content><![CDATA[<h2 id="1-ls-path-watch"><a href="#1-ls-path-watch" class="headerlink" title="1. ls path [watch]"></a>1. ls path [watch]</h2><p>查看某个路径下有多少个节点</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h2 id="2-ls2-path-watch"><a href="#2-ls2-path-watch" class="headerlink" title="2. ls2 path [watch]"></a>2. ls2 path [watch]</h2><p>= ls + stat</p>
<h2 id="3-get-path-watch"><a href="#3-get-path-watch" class="headerlink" title="3. get path [watch]"></a>3. get path [watch]</h2><p>获取值</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] get /test</span><br><span class="line">test</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0x8</span><br><span class="line">mtime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">pZxid = 0x8</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4 </span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-stat-path-watch"><a href="#4-stat-path-watch" class="headerlink" title="4. stat path [watch]"></a>4. stat path [watch]</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] stat /</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0 </span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>cZxid：Create ZXID，表示节点被创建时的事务 ID。</li>
<li>ctime：Create Time，表示节点创建时间。</li>
<li>mZxid：Modified ZXID，表示节点最后⼀次被修改时的事务 ID。</li>
<li>mtime：Modified Time，表示节点最后⼀次被修改的时间。</li>
<li>pZxid：该节点的⼦节点列表最后⼀次被修改时的事务 ID。只有⼦节点列表变更才会更新 pZxid， ⼦节点内容变更不会更新。</li>
<li>cversion：⼦节点的版本号。</li>
<li>dataVersion：内容版本号。</li>
<li>aclVersion：标识 acl 版本</li>
<li> ephemeralOwner：创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 0</li>
<li>dataLength：数据⻓度。</li>
<li>numChildren：直系⼦节点数。</li>
</ul>
<h2 id="5-create-s-e-path-data-acl"><a href="#5-create-s-e-path-data-acl" class="headerlink" title="5. create [-s] [-e] path data acl"></a>5. create [-s] [-e] path data acl</h2><p><em>-s： sequence。顺序节点，为节点自动添加</em></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] create -s /test/sec seq</span><br><span class="line">Created test/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] ls /test</span><br><span class="line">[sec0000000001]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] create -s /test/sec seq</span><br><span class="line">Created test/sec0000000002</span><br><span class="line">[zk: localhost:2181(CONNECTED) 18] ls /test</span><br><span class="line">[sec0000000001, sec0000000002]</span><br></pre></td></tr></tbody></table></figure>

<p><em>-e： ephemeral。Session 创建临时节点</em></p>
<ul>
<li>非持久化，临时节点</li>
<li>客户端与服务端之间维持心跳联系，无心跳则删除</li>
<li><strong> ephemeralOwner</strong> 为非 0x0<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] create -e /test/tmp test-data</span><br><span class="line">Created test/tmp</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] get /test/tmp</span><br><span class="line">test-data</span><br><span class="line">cZxid = 0x9</span><br><span class="line">ctime = Mon May 27 14:26:43 CST 2019</span><br><span class="line">mZxid = 0x9</span><br><span class="line">mtime = Mon May 27 14:26:43 CST 2019</span><br><span class="line">pZxid = 0x9</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x16adeeddbe80003</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="6-set-path-data-version"><a href="#6-set-path-data-version" class="headerlink" title="6. set path data [version]"></a>6. set path data [version]</h2><p><em>dataVersion 会 +1</em></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 23] set /test new-test-data</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0xc</span><br><span class="line">mtime = Mon May 27 14:53:38 CST 2019</span><br><span class="line">pZxid = 0xb</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 13</span><br><span class="line">numChildren = 3</span><br></pre></td></tr></tbody></table></figure>

<p><strong>version： 验证版本号</strong><br>若填写的版本号与当前版本号不一致则 set 失败</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 25] set /test new-test-data-2 1</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0xd</span><br><span class="line">mtime = Mon May 27 15:15:12 CST 2019</span><br><span class="line">pZxid = 0xb</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 15</span><br><span class="line">numChildren = 3</span><br><span class="line">[zk: localhost:2181(CONNECTED) 26] set /test new-test-data-2 1</span><br><span class="line">version No is not valid : /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 27] set /test new-test-data-2 3</span><br><span class="line">version No is not valid : /test</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-delete-path-version"><a href="#7-delete-path-version" class="headerlink" title="7. delete path [version]"></a>7. delete path [version]</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 31] delete /test/sec</span><br><span class="line">[zk: localhost:2181(CONNECTED) 32] ls /test</span><br><span class="line">[tmp]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>version： 验证版本号</strong><br>若填写的版本号与当前版本号不一致则 delete 失败（ 同 set）</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 事务原理</title>
    <url>/167946db8cf4/</url>
    <content><![CDATA[<h1 id="一、事务管理器"><a href="#一、事务管理器" class="headerlink" title="一、事务管理器"></a>一、事务管理器</h1><p><strong>概述：</strong><br>Spring 提供了事务管理器的接口，具体实现由 ORM 框架提供</p>
<p>PlatformTransactionManager：事务管理器核⼼接⼝。提供标准</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> { </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取事务状态信息 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 提交事务 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 回滚事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h1 id="二、事务属性"><a href="#二、事务属性" class="headerlink" title="二、事务属性"></a>二、事务属性</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> {</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回事务的名字</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回事务超时时间</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回是否优化为只读事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隔离级别、传播行为</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1-事务隔离级别"><a href="#1-事务隔离级别" class="headerlink" title="1. 事务隔离级别"></a>1. 事务隔离级别</h2><ul>
<li><p><strong>ISOLATION_DEFAULT：</strong> 使用后端数据库默认的隔离级别</p>
<blockquote>
<p>Mysql 默认采用的 REPEATABLE_READ 隔离级别<br>Oracle 默认采用的 READ_COMMITTED 隔离级别</p>
</blockquote>
</li>
<li><p><strong>ISOLATION_READ_UNCOMMITTED：</strong> 未提交读，允许读取尚未提交的数据变更，<em>可能会导致脏读、幻读或不可重复读</em></p>
</li>
<li><p><strong>ISOLATION_READ_COMMITTED：</strong> 已提交读，允许读取并发事务已经提交的数据，<em>可以阻止脏读，但是幻读或不可重复读仍有可能发生</em></p>
</li>
<li><p><strong>ISOLATION_REPEATABLE_READ：</strong> 可重复读，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<em>可以阻止脏读和不可重复读，但幻读仍有可能发生</em></p>
</li>
<li><p><strong>ISOLATION_SERIALIZABLE：</strong> 可串行化，所有的事务依次逐个执行， _可以防止脏读、不可重复读以及幻读。_但是这将严重影响程序的性能。通常情况下也不会用到该级别</p>
</li>
</ul>
<h2 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2. 事务传播行为"></a>2. 事务传播行为</h2><p><strong>概述：</strong>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播</p>
<ul>
<li>支持当前事务：<ul>
<li><strong>PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</li>
<li><strong> PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</li>
<li><strong> PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</li>
</ul>
</li>
<li>不支持当前事务：<ul>
<li><strong>PROPAGATION_REQUIRES_NEW：</strong> 如果当前存在事务，则把当前事务挂起；如果当前没有事务，则创建一个新的事务</li>
<li><strong> PROPAGATION_NOT_SUPPORTED：</strong> 如果当前存在事务，则把当前事务挂起；如果当前没有事务，则以非事务方式运行</li>
<li><strong> PROPAGATION_NEVER：</strong>如果当前存在事务，则抛出异常；如果当前没有事务，则以非事务方式运行</li>
</ul>
</li>
<li>其他情况：<ul>
<li><strong>PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土③：Watcher</title>
    <url>/27d6899ac71a/</url>
    <content><![CDATA[<p><em>概述：</em> 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p>
<h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h2><ul>
<li><em>一次性：</em> watcher 触发后立即销毁。</li>
<li><em>轻量级：</em> watch 是轻量级的，其实就是本地 JVM 的 Callback，服务器端只是存了是否有设置了 watcher 的布尔类型</li>
<li><em>可见性：</em> Watch 被触发的同时再次读取数据，客户端会得到 Watch 消息再看到更新后的数据。</li>
<li><em>可能会丢失：</em> 对于一个未创建的 znode 的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 Watch 事件可能会被丢失。</li>
</ul>
<span id="more"></span>
<h2 id="2-设置-watcher"><a href="#2-设置-watcher" class="headerlink" title="2. 设置 watcher"></a>2. 设置 watcher</h2><p>只有 stat、get、ls 才能设置 watcher</p>
<h2 id="3-事件类型"><a href="#3-事件类型" class="headerlink" title="3. 事件类型"></a>3. 事件类型</h2><p><em>NodeCreated：</em> 创建节点事件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 38] stat /ccomma watch</span><br><span class="line">Note does not exist: /ccomma</span><br><span class="line">[zk: localhost:2181(CONNECTED) 39] create /ccomma data</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteCreated path:/ccomma</span><br><span class="line">Created /ccomma</span><br></pre></td></tr></tbody></table></figure>

<p><em>NodeDataChanged：</em> 修改节点数据事件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 40] get /ccomma watch</span><br><span class="line">data</span><br><span class="line">cZxid = 0x15</span><br><span class="line">ctime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">mZxid = 0x15</span><br><span class="line">mtime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">pZxid = 0x15</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] set /ccomma 123</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteDataChanged path:/ccomma</span><br><span class="line">cZxid = 0x15</span><br><span class="line">ctime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">mZxid = 0x16</span><br><span class="line">mtime = Mon May 27 16:17:17 CST 2019</span><br><span class="line">pZxid = 0x15</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure>

<p><em>NodeDeleted：</em> 删除节点事件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 43] delete /ccomma</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteDeleted path:/ccomma</span><br></pre></td></tr></tbody></table></figure>

<p><em>NodeChildrenChanged：</em> 子节点变更事件（修改子节点不会触发事件）</p>
<ul>
<li><p>创建： </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 47] ls /ccomma watch</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 48] create /ccomma/abc data</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteChildrenChanged path:/ccomma</span><br><span class="line">Created /ccomma/abc</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>删除： </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 49] ls /ccomma watch</span><br><span class="line">[abc]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 48] delete /ccomma/abc</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteChildrenChanged path:/ccomma</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="4-watcher-原理框架"><a href="#4-watcher-原理框架" class="headerlink" title="4. watcher 原理框架"></a>4. watcher 原理框架</h2><p><strong>过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3a61f750e1698c43d402acc21740487.png"></p>
<ul>
<li>zk 客户端向 zk 服务器注册 watcher 的同时，会将 watcher 对象存储在客户端的 watchManager。</li>
<li>zk 服务器触发 watcher 事件后，会向客户端发送通知，客户端线程从 watchManager 中回调 watcher 执行相应的功能。</li>
</ul>
<p><strong>watchManager：</strong><br>Zk 服务器端 watcher 的管理者。负责 watcher 事件的触发。</p>
<p>从两个维度维护 watcher</p>
<ul>
<li>watchTable：从数据节点的粒度来维护</li>
<li> watch2Paths：从 watcher 的粒度来维护 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WatchManager</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; watchTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Watcher, Set&lt;String&gt;&gt; watch2Paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Watcher, Set&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type)</span> { </span><br><span class="line">        <span class="keyword">return</span> triggerWatch(path, type, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土①：概述</title>
    <url>/1fd0ebc36d45/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ZooKeeper 是一个分布式协调中间件，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p><strong><em>特性：</em></strong></p>
<ul>
<li><em>顺序一致性：</em> 客户端的更新将按顺序执行。因其写操作完全由单一 Leader 节点来执行（事务 id）</li>
<li><em>原子性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 操作要么成功要么失败（事务）</li>
<li><em>单一视图：</em> &nbsp; &nbsp; 无论连接到哪个节点，客户端都能看到相同的视图。（恢复模式 + 广播模式）</li>
<li><em>及时性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 在特定时间范围内的数据是最新的。由最终一致性保证，同步需一定时间（数据同步）</li>
<li><em>可靠性：</em> <ul>
<li>数据不会丢失。zk 是将数据存储到内存中的，所以肯定会有持久化（日志 + 快照）</li>
<li>快速恢复 Leader。恢复模式（选主 + 数据同步）</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p><strong><em>conf/zoo.cfg：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算时间的基本单元 ms</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许从节点连接并同步到主节点的初始化连接时间，以 tickTime 为单位</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点与从节点请求和应答（心跳）的时间长度，以 tickTime 为单位</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快照及 Log 存储位置</span></span><br><span class="line">dataDir=/usr/local/zookeeper/dataDir</span><br><span class="line">dataLogDir=/usr/local/zookeeper/dataLogDir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端口</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host4，observer 角色</span></span><br><span class="line">server.4=49.56.165.144:2888:3888:observer</span><br></pre></td></tr></tbody></table></figure>

<p><strong>集群：</strong></p>
<ol>
<li>创建 dataDir/myid，内容为 1 代表 id 为 1。其他实例同上创建不同 id 的 myid 文件 </li>
<li>server. 服务器 id = 服务器 ip: 服务器之间的通信端口：服务器之间的投票选举端口 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1 当前机器的 host，用 0.0.0.0 表示</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h1><p>启动服务：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></tbody></table></figure>

<p>启动客户端：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./zkCli.sh</span><br></pre></td></tr></tbody></table></figure>

<p>查看启动状态：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h1><ul>
<li>每当客户端连接到服务端会创建一个 SessionId。<strong>创建 / 删除 SessionId 也是事务操作，会有 zxid，会被同步到所有节点中</strong> </li>
<li> Session 过期，则根据该 Session 创建的临时节点 znode 都会被抛弃 </li>
<li>可设置超时时间。未超时的情况下，客户端 api 若保存了 SessionId，重连后 Session 不会消失（还是原来的 Session） </li>
<li>心跳机制</li>
</ul>
<h1 id="5-基本模型"><a href="#5-基本模型" class="headerlink" title="5. 基本模型"></a>5. 基本模型</h1><h2 id="5-1-Zookeeper-抽象模型"><a href="#5-1-Zookeeper-抽象模型" class="headerlink" title="5.1. Zookeeper 抽象模型"></a>5.1. Zookeeper 抽象模型</h2><p>Zookeeper 提供了一种树形结构级的命名空间<br>为了保证高吞吐和低延迟，Zookeeper 在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper <strong>不能用于存放大量的数据</strong>，每个节点的存放数据上限为 <strong>1M</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/71cee598f8577e486a102cf8e2e06ba4.png"></p>
<h2 id="5-2-节点类型"><a href="#5-2-节点类型" class="headerlink" title="5.2. 节点类型"></a>5.2. 节点类型</h2><ul>
<li><strong>永久无序节点：</strong> 不会因为会话结束或者超时而消失</li>
<li><strong>永久有序节点：</strong> 不会因为会话结束或者超时而消失，且有序</li>
<li><strong>临时无序节点：</strong> 如果会话结束或者超时就会消失</li>
<li><strong>临时有序节点：</strong> 如果会话结束或者超时就会消失，且有序<blockquote>
<p>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土④：ACL 权限</title>
    <url>/a4d32f43a4f8/</url>
    <content><![CDATA[<h2 id="1-ACL-构成"><a href="#1-ACL-构成" class="headerlink" title="1. ACL 构成"></a>1. ACL 构成</h2><p><strong>概述：</strong> 针对节点可以设置相关读写权限，保障数据安全</p>
<p>通过 <code>scheme:id:permissions</code> 来构成权限列表</p>
<ul>
<li><strong>scheme：</strong> &nbsp; &nbsp; &nbsp; &nbsp; 代表采用的某种权限机制</li>
<li><strong> id：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 代表允许访问的用户</li>
<li><strong> permissions：</strong> 代表允许的操作权限</li>
</ul>
<p><em>例：</em> setAcl path world:anyone:d 代表为 path 下的节点设置权限为所有人都只能删除该节点</p>
<h3 id="1-1-scheme-类型"><a href="#1-1-scheme-类型" class="headerlink" title="1.1. scheme 类型"></a>1.1. scheme 类型</h3><ul>
<li><strong>world（world:anyone:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 默认权限。只有一个用户 —— anyone</li>
<li><strong>auth（auth:user:password:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;代表认证登录，需要注册用户拥有权限</li>
<li><strong> digest（digest:username:BASE64(SHA1(password)):[permissions]）：</strong> 需要对密码加密才能访问</li>
<li><strong> ip（ip:192.168.1.1:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;限制 ip 进行访问</li>
<li><strong> super：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 超级管理员，拥有所有权限</li>
</ul>
<h3 id="1-2-permissions"><a href="#1-2-permissions" class="headerlink" title="1.2. permissions"></a>1.2. permissions</h3><p><em>crdwa 代表的权限含义：</em></p>
<ul>
<li><strong>CREATE：</strong> 创建 <strong>子节点</strong></li>
<li><strong> READ：</strong> &nbsp; &nbsp; 读取节点数据</li>
<li><strong> WRITE：</strong> &nbsp; &nbsp;往节点写入数据</li>
<li><strong> DELETE：</strong> 删除 <strong>子节点，对于 delete 权限，要谨慎规划</strong></li>
<li><strong> ADMIN：</strong> &nbsp; 可以使用 setAcl 命令设置权限</li>
</ul>
<span id="more"></span>
<h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h2><h3 id="2-1-addauth-scheme-auth"><a href="#2-1-addauth-scheme-auth" class="headerlink" title="2.1. addauth scheme auth"></a>2.1. addauth scheme auth</h3><p><strong>概述：</strong><br>添加认证授权信息到 Zookeeper 库中（注册）<br>并使用该认证作为当前客户端的认证信息（登录），这之后进行的所有操作会以该认证为前提<br>密码需输入明文，但在 Zookeeper 中密码以加密形式存储</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] addauth digest ccomma:ccomma</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-setAcl-path-schemepwd-permissions"><a href="#2-2-setAcl-path-schemepwd-permissions" class="headerlink" title="2.2. setAcl path schemepwd:permissions"></a>2.2. setAcl path scheme<img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/da6180df7a470ee728d47348410724ae.svg">pwd:permissions</h3><p><strong>auth：</strong></p>
<ul>
<li><p>设置某个节点的 acl 权限信息 </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] setAcl /ccomma auth:ccomma:ccomma:crdwa</span><br><span class="line">cZxid = 0x18</span><br><span class="line">ctime = Mon May 27 16:36:40 CST 2019</span><br><span class="line">mZxid = 0x2b</span><br><span class="line">mtime = Mon May 30 16:10:49 CST 2019</span><br><span class="line">pZxid = 0x1f</span><br><span class="line">cversion = 5</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>当使用 addauth 添加认证后，setAcl 账号和密码可以省略，默认取第一个认证 </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] setAcl /ccomma auth::crdwa</span><br><span class="line">cZxid = 0x18</span><br><span class="line">ctime = Mon May 27 16:36:40 CST 2019</span><br><span class="line">mZxid = 0x2b</span><br><span class="line">mtime = Mon May 30 16:10:49 CST 2019</span><br><span class="line">pZxid = 0x1f</span><br><span class="line">cversion = 5</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>digest：</strong> 密码加密</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] setAcl /ccomma digest:ccomma:91PXC4WimSDWZikp99kGvvjeVnY=:crdwa</span><br><span class="line">cZxid = 0x60</span><br><span class="line">ctime = Fri May 31 13:33:42 CST 2019</span><br><span class="line">mZxid = 0x60</span><br><span class="line">mtime = Fri May 31 13:33:42 CST 2019</span><br><span class="line">pZxid = 0x60</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 1</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure>

<p><strong>ip：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] setAcl /ccomma/ip ip:192.168.1.7:crdwa</span><br><span class="line">cZxid = 0x62</span><br><span class="line">ctime = Fri May 31 13:36:51 CST 2019</span><br><span class="line">mZxid = 0x62</span><br><span class="line">mtime = Fri May 31 13:36:51 CST 2019</span><br><span class="line">pZxid = 0x62</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 2</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] getAcl /ccomma/ip</span><br><span class="line">'ip,'192.168.1.7</span><br><span class="line">:crdwa</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-getAcl-path"><a href="#2-3-getAcl-path" class="headerlink" title="2.3. getAcl path"></a>2.3. getAcl path</h3><p>获取某个节点的 acl 权限信息<br>密码以密文形式存储</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /ccomma</span><br><span class="line">'digest,'ccomma:91PXC4WimSDWZikp99kGvvjeVnY=</span><br><span class="line">:crdwa</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-super-auth"><a href="#3-super-auth" class="headerlink" title="3. super auth"></a>3. super auth</h2><p><strong>添加超级用户：</strong><br>在 nohup “JAVA” “-Dzookeeper.log.dir={ZOO_LOG_DIR}” “-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}” &nbsp;后面加上 “-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:9iPCX4WimSDWZikp99kGvvjeVnY=”</p>
<p>代表添加超级用户 admin:9iPCX4WimSDWZikp99kGvvjeVnY= （明文：ccomma）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">    echo  -n "Starting zookeeper ... "</span><br><span class="line">    if [ -f "$ZOOPIDFILE" ]; then</span><br><span class="line">      if kill -0 `cat "$ZOOPIDFILE"` &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">         echo $command already running as process `cat "$ZOOPIDFILE"`.</span><br><span class="line">         exit 0</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">    nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" </span><br><span class="line">    "-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:9iPCX4WimSDWZikp99kGvvjeVnY=" \</span><br><span class="line">    -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG" &gt; "$_ZOO_DAEMON_OUT" 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">      case "$OSTYPE" in</span><br><span class="line">      *solaris*)</span><br><span class="line">        /bin/echo "${!}\\c" &gt; "$ZOOPIDFILE"</span><br><span class="line">        ;;</span><br><span class="line">      *)</span><br><span class="line">        /bin/echo -n $! &gt; "$ZOOPIDFILE"</span><br><span class="line">        ;;</span><br><span class="line">      esac</span><br><span class="line">      if [ $? -eq 0 ];</span><br><span class="line">      then</span><br><span class="line">        sleep 1</span><br><span class="line">        echo STARTED</span><br><span class="line">      else</span><br><span class="line">        echo FAILED TO WRITE PID</span><br><span class="line">        exit 1</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">      echo SERVER DID NOT START</span><br><span class="line">      exit 1</span><br><span class="line">    fi</span><br><span class="line">    ;;</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑨：ZAB 协议</title>
    <url>/154d52f4ac2d/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Zookeeper 使用⼀个单⼀的主进程来接收并处理客户端的所有事务请求</p>
<p>并采用 ZAB （ Zookeeper Atomic Broadcast，原子广播协议），将服务器数据的状态变更以事务 Proposal 的形式广播到所有的副本进程中</p>
<p><strong>读写请求官方压测：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7bee1d45d9132d4cc362f7b83d99edd3.png"></p>
<p><strong>3888 端口通信模型：</strong><br>任何两个节点都互通<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2540cbee09bd8a4e1f2ef002e8b61d7b.png"></p>
<span id="more"></span>
<h2 id="2-恢复模式（选-Master-数据同步）"><a href="#2-恢复模式（选-Master-数据同步）" class="headerlink" title="2. 恢复模式（选 Master + 数据同步）"></a>2. 恢复模式（选 Master + 数据同步）</h2><p>官方压测 200ms 恢复</p>
<p><strong>步骤：</strong></p>
<ol>
<li><em>Leader 选举过程：</em> Leader 与过半 Follower 失去联系，Follower 服务器都会将自己的服务器状态变更为 LOOKING，并进⼊ Leader 选举过程。 </li>
<li><em>数据同步：</em> ZAB 会选举产生新的 Leader 服务器，然后有过半（防止脑裂）的机器与该 Leader 服务器完成了数据同步之后会退出恢复模式。</li>
</ol>
<p><strong>注意的问题：</strong></p>
<ul>
<li>ZAB 协议需要确保那些已经在 Leader 上提交的事务最终被所有服务器都提交</li>
<li> ZAB 协议需要确保丢弃那些只在 Leader 上被提出但尚未发出的事务</li>
</ul>
<p>ZAB 保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）事务 Id 的 Proposal 来解决上述问题</p>
<h3 id="2-1-Leader-选举"><a href="#2-1-Leader-选举" class="headerlink" title="2.1. Leader 选举"></a>2.1. Leader 选举</h3><p>Leader 所在的机器挂了或者失去大多数的 Follower 会进入恢复模式，进行新⼀轮的 Leader 选举。<br>服务器运行期间的 Leader 选举和启动时期的 Leader 选举基本过程是⼀致的。</p>
<p><strong><em>选举算法：</em></strong><br>通过 zoo.cfg 配置文件中的 electionAlg 属性指定（0-3）<br>FastLeaderElection 算法（值为 3。TCP 实现，zk 3.4.0 之后只保留了该算法，废弃了 0-2）</p>
<p><strong><em>过程：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3bed488b8c94c6165de6883718f48f04.png"></p>
<ol>
<li><p>每个 Server 会将自身的（myid，ZXID）发送给集群以便通知其他 Server 自己的选择。 </p>
<blockquote>
<p>这是投给自己的票，因为此时还不知道其他 Server 的状态。例如 Server1 的 myid 为 1，ZXID 为 0，则发送（1, 0）</p>
</blockquote>
</li>
<li><p>接受来自各个服务器的投票 </p>
</li>
<li><p>集群的每个服务器收到投票后，判断该投票的有效性，如检查是否是本轮投票、是否来⾃ LOOKING 状态的服务器。</p>
</li>
<li><p>针对每⼀个投票，服务器都需要将别人的投票和自己的投票进行选择，以确定是否变更投票 </p>
<ul>
<li>比较 ZXID：如果接收到的投票的 ZXID 比自己的大，则当前 Server 认可收到的投票，并再次将该投票发送出去。反之，若接收到的投票的 ZXID 比自己的小，则不做任何操作</li>
<li>比较 myid：如果 ZXID 相同则比较 myid。myid 较⼤的投票会被认可并再次发送出去。反之，若接收到的 myid 比自己的小，则不做任何操作</li>
</ul>
</li>
<li><p>统计投票<br>Server 都接收到其他 Server 的变更投票后会开始统计投票，如果一台 Server 中相同的投票超过半数则该投票对应的 myid 的 Server 成为 Leader。 </p>
<blockquote>
<p>为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂</p>
</blockquote>
</li>
<li><p>改变服务器状态<br>⼀旦确定了 Leader，每个服务器就会更新⾃⼰的状态：如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，那么就变更为 LEADING。</p>
</li>
</ol>
<h3 id="2-2-数据同步"><a href="#2-2-数据同步" class="headerlink" title="2.2. 数据同步"></a>2.2. 数据同步</h3><p><em>数据同步消息方式：</em></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>发送方向</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td> DIFF</td>
<td>Leader -&gt; Learner</td>
<td> 通知 Learner 即将与 Learner 进行增量方式的数据同步</td>
</tr>
<tr>
<td> TRUNC</td>
<td>Leader -&gt; Learner</td>
<td> 触发 Learner 进行其内存数据库的回滚操作</td>
</tr>
<tr>
<td> SNAP</td>
<td>Leader -&gt; Learner</td>
<td> 通知 Learner 即将与 Learner 进行全量方式的数据同步</td>
</tr>
<tr>
<td> UPTODATE</td>
<td>Leader -&gt; Learner</td>
<td> 通知 Learner 已完成数据同步，可对外提供服务</td>
</tr>
</tbody></table>
<p><em>服务器初始化消息类型：</em></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>发送方向</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td> OBSERVERINFO</td>
<td>Observer -&gt; Leader</td>
<td>Observer 启动时发送自身的（myid，zxid）给 Leader，用于向 Leader 表明角色并注册自己</td>
</tr>
<tr>
<td> FOLLOWERINFO</td>
<td>Follower -&gt; Leader</td>
<td>Follower 启动时发送自身的（myid，zxid）给 Leader，用于向 Leader 表明角色并注册自己</td>
</tr>
<tr>
<td> LEADERINFO</td>
<td>Leader -&gt; Learner</td>
<td>Leader 接收到来自 Learner 的上述两类消息后会将当前 Leader 的 epoch 发送 Learner</td>
</tr>
<tr>
<td>ACKEPOCH</td>
<td>Learner -&gt; Leader</td>
<td>Learner 收到 LEADERINFO 消息后会将自己最新的 zxid 和 epoch 发送给 Leader</td>
</tr>
<tr>
<td>NEWLEAEDER</td>
<td>Leader -&gt; Learner</td>
<td> 足够多的 Follower 连上 Leader 或完成数据同步后，Leader 会向 Learner 发送当前 Leader 最新的 zxid</td>
</tr>
</tbody></table>
<p><strong><em>过程：</em></strong></p>
<ol>
<li><p><em>Leader 加载快照：</em> 重新加载本地磁盘上的数据快照至内存，并从日志文件中取出快照之后的所有事务操作，逐条应用至内存，并添加到已提交事务缓存 commitedProposals。 </p>
<blockquote>
<p>这样能保证日志文件中的事务操作，必定会应用到 leader 的内存数据库中。</p>
</blockquote>
</li>
<li><p><em>确定同步方式：</em> </p>
</li>
<li><p>获取 Learner 发送的 <code>OBSERVERINFO/FOLLOWERINFO</code> 信息（myid，zxid），即 id 和已提交过的最大消息 zxid。 </p>
</li>
<li><p>用 Learner 的最大 zxid 与 Leader 提交过的消息（commitedProposals）中的最小 zxid（min_zxid）和最大 zxid（max_zxid）分别作比对，确定采用哪种同步方式（DIFF 同步、TRUNC+DIFF 同步、SNAP 同步）。<br>  - 如果该 zxid 介于 min_zxid 与 max_zxid 之间，但又不存在于 commitedProposals 中时，说明该 zxid 对应的事务需要 TRUNC 回滚<br>  - 如果该 zxid 介于 min_zxid 与 max_zxid 之间且存在于 commitedProposals 中，则 Leader 需要将 zxid+1~max_zxid 间所有事务同步给 Learner（DIFF）<br>  - 如果该 zxid == max_zxid，说明已经完全同步了</p>
</li>
<li><p><em>数据同步：</em> Leader 主动向所有 Learner 发送同步数据消息，每个 Learner 有自己的发送队列。<br>同步结束时，Leader 会向 Learner 发送 NEWLEADER 消息，同时 Learner 会反馈一个 ACK。当 Leader 接收到来自 Learner 的 ACK 消息后，就认为当前 Learner 已经完成了数据同步，然后进入 等待是否过半阶段。 </p>
</li>
<li><p><em>同步完成：</em> 当 Leader 统计到收到了一半已上的 ACK 时，会向所有已经完成数据同步的 Learner 发送一个 <code>UPTODATE</code> 消息，用来通知 Learner 集群已经完成了数据同步，可以对外服务了。</p>
</li>
</ol>
<h2 id="3-广播模式（事务操作节点同步）"><a href="#3-广播模式（事务操作节点同步）" class="headerlink" title="3. 广播模式（事务操作节点同步）"></a>3. 广播模式（事务操作节点同步）</h2><p><strong>原子广播协议特性：</strong></p>
<ul>
<li>原子性：要么成功，要么失败，不存在中间状态。（队列 + 2PC 实现）</li>
<li>广播：Leader 通知所有节点进行操作</li>
</ul>
<p>有过半的 Follower 服务器完成了和 Leader 服务器的数据同步，那么就会进⼊消息⼴播模式。<br>扩容加入的新服务器会与 Leader 进行数据同步然后参与到消息⼴播流程中<br>Leader/Follower/Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9f27cd7993e2ce58e318a97357e40a8c.png"></p>
<ol>
<li><em>转发请求：</em> Follower 接收到写请求后会转发给 Leader 来处理</li>
<li><em>发送事务消息：</em> Leader 接收到写请求后会把该写请求转换成带有各种状态的事务，并会分配给 Proposal 一个单调递增的唯一 id（zxid）。然后 Leader 会将广播的事务 Proposal 依次添加到 <strong>发送队列</strong> 中，并且根据 FIFO 策略进行消息发送。<strong>保证最终一致性</strong></li>
<li><em>返回应答：</em> 每⼀个 Follower 接收到这个事务 Proposal 之后，都会将其以事务日志的形式写入到本地磁盘中去，然后向 Leader 返回 Ack 进行投票。Observer 不参与投票</li>
<li><em>提交事务：</em> Leader 接收到超过半数 Ack，会给所有的 Follower 广播⼀个 COMMIT 消息进行事务提交，给所有的 Observer 广播 INFORM 消息进行提交，同时 Leader 也会进行事务提交</li>
</ol>
<p>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<h2 id="4-ZAB-与-Paxos-的异同"><a href="#4-ZAB-与-Paxos-的异同" class="headerlink" title="4. ZAB 与 Paxos 的异同"></a>4. ZAB 与 Paxos 的异同</h2><p><strong>相同点：</strong></p>
<ul>
<li>都存在⼀个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</li>
<li> Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将⼀个提议进行提交</li>
<li>在 ZAB 协议中，每个 Proposal 中都包含了⼀个 epoch 值，用来代表当前的 Leader 周期。在 Paxos 算法中为 Ballot</li>
</ul>
<p><strong>不同点：</strong> ZAB 协议主要⽤于构建⼀个⾼可⽤的分布式数据主备系统，Paxos 算法则⽤于构建⼀个分布式的⼀致性状态机系统</p>
<ul>
<li>Paxos 算法中，新选举产⽣的主进程会进⾏两个阶段的⼯作，第⼀阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第⼆阶段称为写阶段，当前主进程开始提出自己的提议。</li>
<li>ZAB 协议在 Paxos 基础上添加了同步阶段。新选出的 Leader 会确保存在过半的 Follower 提交<br>了之前接收到的所有事务 Proposal。这⼀同步阶段的引入，能够有效地保证 Leader 在新的周期中提出事务 Proposal 之前，所有的进程都已经完成了对之前所有事务 Proposal 的提交</li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑧：集群</title>
    <url>/1474e6bd8a26/</url>
    <content><![CDATA[<h2 id="1-事务-Id"><a href="#1-事务-Id" class="headerlink" title="1. 事务 Id"></a>1. 事务 Id</h2><p><strong>概述：</strong></p>
<ul>
<li><em>变更状态：</em> 事务是指能够改变 ZooKeeper 服务器状态的操作，我们也称之为事务操作或更新操作。⼀般包括数据节点创建与删除、数据节点内容更新等操作。 </li>
<li><em>ZXID：</em> 对于每⼀个事务请求（proposal 提议），ZooKeeper 都会为其分配⼀个全局唯⼀（zk 中唯一）且有序的事务 ID，用 ZXID 来表示，通常是⼀个 64 位的数字。 <ul>
<li>高 32 位是 epoch（投票轮次），用来标识 Leader 是否发生改变。从 1 开始，如果有新的 Leader 产生出来，epoch 会自增。</li>
<li>低 32 位用来递增计数。每次 epoch 变化，都将低 32 位的序号重置。</li>
</ul>
</li>
</ul>
<p><strong>作用：</strong> 标识节点同步状态。</p>
<span id="more"></span>
<h2 id="2-Server-工作状态"><a href="#2-Server-工作状态" class="headerlink" title="2. Server 工作状态"></a>2. Server 工作状态</h2><ol>
<li><em>LOOKING：</em> 不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举。</li>
<li><em>FOLLOWING：</em> 跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁。</li>
<li><em>OBSERVING：</em> 观察者状态。表明当前服务器角色是 Observer</li>
<li><em>LEADING：</em> 领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳。</li>
</ol>
<h2 id="3-服务器角色"><a href="#3-服务器角色" class="headerlink" title="3. 服务器角色"></a>3. 服务器角色</h2><ul>
<li>Leader</li>
<li>Follower：参与选举，参与写操作时的投票。对外提供读服务。</li>
<li>Observer：与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票。对外提供读服务。</li>
</ul>
<p>Follower 与 Observer 统称 Learner</p>
<h3 id="3-1-Leader"><a href="#3-1-Leader" class="headerlink" title="3.1. Leader"></a>3.1. Leader</h3><p><strong>主要工作</strong></p>
<ul>
<li>有且仅有一个。事务请求的唯⼀调度和处理者，保证集群事务处理的顺序性。</li>
<li>集群内部各服务器的调度者。</li>
</ul>
<p><strong>请求处理链</strong><br>使⽤责任链来处理每个客户端的请求<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9e09d263ffe7352b95ec92aedf683899.png"></p>
<ol>
<li><strong>预处理器（PrepRequestProcessor）：</strong> 识别出当前客户端请求是否是事务请求，并对其进行预处理。<br>对事务请求进⾏⼀系列预处理，如创建请求事务头、事务体、会话检查、ACL 检查和版本检查等 </li>
<li><strong>事务处理器（ProposalRequestProcessor）：</strong> Leader 事务处理流程的发起者。</li>
</ol>
<ul>
<li>非事务性请求：将请求转发到 CommitProcessor 处理器</li>
<li>事务性请求：将请求转发到 CommitProcessor 处理器。根据请求类型创建对应的 Proposal 提议广播给所有的 Follower。还会将 Proposal 交付给 SyncRequestProcessor 进⾏事务⽇志的记录。</li>
</ul>
<ol start="3">
<li><strong>事务⽇志处理器（SyncRequestProcessor）：</strong> ⽤来将事务请求记录到事务⽇志⽂件中，同时<br>会触发 Zookeeper 进⾏数据快照。 </li>
<li><strong>应答处理器（AckRequestProcessor）：</strong> 负责在 SyncRequestProcessor 完成事务⽇志记录后，向 Proposal 的投票收集器发送 ACK 反馈，以通知投票收集器当前服务器已经完成了对该 Proposal 的事务⽇志记录。 </li>
<li><strong>事务提交处理器（CommitProcessor）：</strong></li>
</ol>
<ul>
<li>对于非事务请求：该处理器会直接将其交付给下⼀级处理器处理</li>
<li>对于事务请求：其会等待集群内针对 Proposal 的投票直到该 Proposal 可被提交，利⽤ CommitProcessor，每个服务器都可以很好地控制对事务请求的顺序处理。</li>
</ul>
<ol start="6">
<li><strong>应用队列处理器（ToBeAppliedRequestProcessor）：</strong> 该处理器有⼀个 toBeApplied 队列，用来存储那些已经被 CommitProcessor 处理过的可被提交的 Proposal。其会将这些请求交付给 FinalRequestProcessor 处理器处理，待其处理完后，再将其从 toBeApplied 队列中移除。 </li>
<li><strong>最终处理器（FinalRequestProcessor）：</strong> ⽤来进⾏返回请求前的操作，包括创建客户端请求的响应。针对事务请求，该处理器还会负责将事务应⽤到内存数据库中。</li>
</ol>
<h3 id="3-2-Follower"><a href="#3-2-Follower" class="headerlink" title="3.2. Follower"></a>3.2. Follower</h3><p><strong>主要工作</strong></p>
<ul>
<li>处理客户端非事务性请求（读取数据），转发事务请求给 Leader。</li>
<li>参与事务请求 Proposal 的投票。</li>
<li>参与 Leader 选举投票。</li>
</ul>
<p><strong>请求处理链</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1f49db44f526ef48b7667901bd083a56.png"></p>
<ol>
<li>FollowerRequestProcessor：当前请求若是事务请求则会将该请求转发给 Leader， Leader 在接收到这个事务请求后，就会将其提交到请求处理链，按照正常事务请求进行处理。</li>
<li>SendAckRequestProcessor：承担了事务日志记录反馈的角色，在完成事务日志记录后，会向 Leader 发送 ACK 消息以表明⾃身完成了事务日志的记录工作</li>
</ol>
<h3 id="3-3-Observer"><a href="#3-3-Observer" class="headerlink" title="3.3. Observer"></a>3.3. Observer</h3><p>Observer 是 ZooKeeper 自 3.3.0 版本开始引⼊的⼀个全新的服务器角色。<br>和 Follower 唯⼀的区别在于，Observer 不参与任何形式的投票，包括事务请求 Proposal 的投票和 Leader 选举投票。<br>Observer 服务器只提供非事务服务，通常⽤于在不影响集群事务处理能⼒的前提下提升集群的非事务处理能力。</p>
<h2 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h2><h3 id="4-1-数据快照"><a href="#4-1-数据快照" class="headerlink" title="4.1. 数据快照"></a>4.1. 数据快照</h3><p><strong>概述：</strong> 用来记录 zk 服务器上某一时刻的全量内存数据内容，并将其写入到指定的磁盘文件中，可通过 dataDir 配置文件目录。</p>
<p><strong>snapCount 参数：</strong> 设置两次快照之间的事务操作个数。zk 节点记录完事务日志时，若距离上次快照，事务操作次数等于 <strong>snapCount/2~snapCount</strong> 中的某个值时，会触发快照生成操作，随机值是为了避免所有节点同时生成快照，导致集群影响缓慢）。</p>
<h3 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2. 事务日志"></a>4.2. 事务日志</h3><p>所有事务操作都是需要记录到日志文件中的，可通过 dataLogDir 配置文件目录，文件是以写入的第一条事务 zxid 为后缀，方便后续的定位查找。</p>
<p>zk 会采取 “磁盘空间预分配” 的策略，来避免磁盘 Seek 频率，提升 zk 服务器对事务请求的影响能力。默认设置下，每次事务日志写入操作都会实时刷入磁盘，也可以设置成非实时（写到内存文件流，定时批量写入磁盘），但那样断电时会带来丢失数据的风险。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑩：相关源码阅读</title>
    <url>/f668d8876330/</url>
    <content><![CDATA[<h2 id="1-搭建"><a href="#1-搭建" class="headerlink" title="1. 搭建"></a>1. 搭建</h2><p>版本：3.7<br>github clone 下来之后用 IDEA 打开，maven clean install<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1a0a1a4b76e08bad4113feeb143f891d.png"></p>
<p>服务端 debug 配置：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b3f81e08916f00be69061801b48fa2b8.png"></p>
<p>客户端 debug 配置</p>
<span id="more"></span>
<h2 id="2-Server-启动流程"><a href="#2-Server-启动流程" class="headerlink" title="2. Server 启动流程"></a>2. Server 启动流程</h2><p>QuorumPeerMain#initializeAndRun 启动类：</p>
<ol>
<li><strong>解析配置文件：</strong> QuorumPeerConfig#parse。zoo.cfg 配置运行时的基本参数，如 tickTime、dataDir、clientPort 等参数</li>
<li><strong>创建并启动历史文件清理器：</strong> DatadirCleanupManager#start。对事务日志和快照数据文件进行定时清理。</li>
<li><strong>判断是否是集群模式：</strong> QuorumPeerConfig#isDistributed</li>
</ol>
<h3 id="2-1-集群模式"><a href="#2-1-集群模式" class="headerlink" title="2.1. 集群模式"></a>2.1. 集群模式</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/521dfdd47784c4e23b4ae0b345019080.png"></p>
<p>是集群模式则调用 QuorumPeerMain#runFromConfig</p>
<ol>
<li><strong>开启集群模式：</strong> QuorumPeerMain#runFromConfig </li>
<li><strong>创建并配置 ServerCnxnFactory：</strong><br>调用 ServerCnxnFactory#createFactory () 创建 ServerCnxnFactory。<br>调用 ServerCnxnFactory#configure (java.net.InetSocketAddress, int, int, boolean) 配置 ServerCnxnFactory。 </li>
<li><strong>获取 QuorumPeer 并设置相关组件：</strong><br>调用 QuorumPeerMain#getQuorumPeer 获取 QuorumPeer。其父类继承了 Thread<br>调用 QuorumPeer#setTxnFactory 设置数据管理器<br>调用 QuorumPeer#setZKDatabase 设置 zkDataBase<br>调用 QuorumPeer#initialize 进行初始化 </li>
<li><strong>启动服务：</strong> QuorumPeer#start。<br>  1. 恢复本地数据：QuorumPeer#loadDataBase<br>  2. 启动主线程：QuorumPeer#startServerCnxnFactory<br>  3. 初始化 Leader 选举：QuorumPeer#startLeaderElection。创建选举环境，启动相关线程 <ol>
<li>创建选给自身的选票</li>
<li>初始化选举算法：QuorumPeer#createElectionAlgorithm (electionType) <ol>
<li>开启监听：<code>QuorumCnxManager.Listener listener = qcm.listener; listener.start();</code>。</li>
<li>开启选举：FastLeaderElection#start</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>  4. 启动 QuorumPeer：Thread#start，调用其 run() 方法。一直循环判断状态 
     1. 节点状态为 LOOKING：调用 lookForLeader() 方法。`setCurrentVote(makeLEStrategy().lookForLeader())`。进行选举
     2. 节点状态为 OBSERVING：设置当前节点启动模式为 Observer，调用 Observer#observeLeader 与 Leader 节点进行数据同步
     3. 节点状态为 FOLLOWER：设置当前节点启动模式为 Follower，调用 Follower#followLeader 与 Leader 节点进行数据同步
     4. 节点状态为 Leader：设置当前节点启动模式为 Leader，调用 Leader#lead 发送自己是 Leader 的通知
</code></pre>
<h3 id="2-2-单机模式"><a href="#2-2-单机模式" class="headerlink" title="2.2. 单机模式"></a>2.2. 单机模式</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/33788250631fa23974c6f54c17942828.png"></p>
<p>是单机模式则调用 ZooKeeperServerMain#main：把启动工作委派给 ZooKeeperServerMain 类。调用 ZooKeeperServerMain#initializeAndRun</p>
<ol>
<li><strong>重新解析配置文件：</strong> ServerConfig#parse (java.lang.String)。创建服务配置对象，重新解析 </li>
<li><strong>运行服务：</strong> ZooKeeperServerMain#runFromConfig </li>
<li><strong>创建数据管理器：</strong> new FileTxnSnapLog(config.dataLogDir, config.dataDir) </li>
<li><strong>创建 Server 实例：</strong> <code>new ZooKeeperServer()</code>。<br>Zookeeper 服务器首先会进行服务器实例的创建<br>然后对该服务器实例进行初始化，包括连接器、内存数据库、请求处理器等组件的初始化 </li>
<li><strong>创建 admin 服务：</strong> AdminServerFactory#createAdminServer。用于接收请求（创建 jetty 服务） </li>
<li><strong>创建并配置 ServerCnxnFactory：</strong><br>调用 ServerCnxnFactory#createFactory () 负责客户端与服务器的连接<br>调用 ServerCnxnFactory#configure (java.net.InetSocketAddress, int, int, boolean) 配置 ServerCnxnFactory </li>
<li><strong>启动服务：</strong> ServerCnxnFactory#startup(ZooKeeperServer)<br>  1.  启动相关线程：NIOServerCnxnFactory#startxup <blockquote>
<pre><code>  1. new WorkerService("NIOWorker", numWorkerThreads, false)：初始化 worker 线程池
  2. 开启所有 SelectorThread 线程，用于处理客户端请求
  3. 启动 acceptThread 线程，用于处理接收连接进行事件
  4. 启动 expirerThread 线程，用于处理过期连接
</code></pre>
</blockquote>
</li>
</ol>
<pre><code>  2.  加载数据到 zkDataBase：ZooKeeperServer#startdata。ZooKeeperServer#loadData：加载磁盘上已经存储的数据 
  3.  ZooKeeperServer#startup： 
     1.  初始化 Session 追踪器：ZooKeeperServer#createSessionTracker 
     2.  启动 Session 追踪器：ZooKeeperServer#startSessionTracker 
     3.  建立请求处理链路：ZooKeeperServer#setupRequestProcessors 
</code></pre>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setupRequestProcessors</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">RequestProcessor</span> <span class="variable">finalProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalRequestProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">RequestProcessor</span> <span class="variable">syncProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncRequestProcessor</span>(<span class="built_in">this</span>, finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor) syncProcessor).start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> <span class="title class_">PrepRequestProcessor</span>(<span class="built_in">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor) firstProcessor).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<pre><code>     4.  注册 JMX：ZooKeeperServer#registerJMX 
</code></pre>
<h2 id="3-Leader-选举"><a href="#3-Leader-选举" class="headerlink" title="3. Leader 选举"></a>3. Leader 选举</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Election</span> {</span><br><span class="line">    <span class="comment">// 寻找 Leader</span></span><br><span class="line">    Vote <span class="title function_">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 关闭服务端之间的连接</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>选举类图：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8c34e37f7a5f4819fb28a38db7cbbb08.png"></p>
<p><strong>FastLeaderElection#lookForLeader：</strong></p>
<ol>
<li><strong>更新时钟：</strong> <code>logicalclock.incrementAndGet()</code>。logicalclock 为 AtomicLong 类型。</li>
<li><strong>初始化选票为自身的选票（myid，zxid，epoch）：</strong> FastLeaderElection#updateProposal(long leader, long zxid, long epoch)</li>
<li><strong> 发送选票：</strong> FastLeaderElection#sendNotifications。将选票信息封装成 ToSend 对象，由 workerSender（LinkedBlockingQueue）发送出去</li>
<li>（循环）判断是否为 LOOKING 状态 <ol>
<li><strong>接收外部投票：</strong> <code>Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS)</code>。每台服务器会不断的从 recvqueue 中获取外部投票 </li>
<li><strong>处理接收到的投票（选票 PK）</strong> </li>
<li>接收到的投票的 epoch &gt; 当前投票的 epoch 时：<code>n.electionEpoch &gt; logicalclock.get()</code><br>  1.  更新 epoch（选举轮次）为接收到的外部投票的 epoch：<code>logicalclock.set(n.electionEpoch)</code><br>  2.  清空之前所有已经收到的投票：<code>recvset.clear()</code>。recvset（HashMap&lt;Long, Vote&gt;，意在收集本轮收到的选票）<br>  3.  选票 PK：用 FastLeaderElection#totalOrderPredicate (long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) 方法判断。返回 true 则更新为接收到的选票，false 则更新为当前自身生成的选票。<br>此次 PK 为 <strong>接收到的外部选票</strong> 与 <strong>自身生成的选票（myid，zxid，epoch）</strong> 之间的 PK。 <ul>
<li>newEpoch &gt; curEpoch：更新为接收到的选票 </li>
<li>newEpoch == curEpoch &amp;&amp; newZxid &gt; curZxid：更新为接收到的选票 </li>
<li>newEpoch == curEpoch &amp;&amp; newZxid == curZxid &amp;&amp; newId &gt; curId：更新为接收到的选票 </li>
<li>其余情况更新为当前自身生成的选票</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>依然用 FastLeaderElection#updateProposal 方法更新选票 </p>
<pre><code>     4.  发送更新完的选票：FastLeaderElection#sendNotifications 
  1.  接收到的投票的 epoch &lt; 当前投票的 epoch 时：忽略 
  2.  接收到的投票的 epoch == 当前投票的 epoch 时： 
     1.  FastLeaderElection#totalOrderPredicate 选票 PK，与第一种情况类似，返回 true 则更新为接收到的选票，false 则更新为当前持有的选票。&lt;br /&gt;此次 PK 为 **接收到的外部选票** 与 **当前持有的选票** 之间的 PK。 
     2.  发送更新完的选票：FastLeaderElection#sendNotifications 
</code></pre>
<ol>
<li><strong>记录选票：</strong> 记录收到的选票到 Map 中 <code>recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch))</code> </li>
<li><strong>统计选票：</strong> 判断当前 Server 收到的票数是否可以结束选举<br>  1. 遍历 recvset 中的所有投票信息，将等于当前投票的 <code>&lt;sid, vote&gt;</code> 放入 voteSet 中<br>  2. 统计投票：SyncedLearnerTracker#hasAllQuorums。查看投给某个 sid（myid） 的票数是否超过一半，过半则更新服务器状态</li>
</ol>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑦：应用场景</title>
    <url>/3b9c328b0e7b/</url>
    <content><![CDATA[<h2 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1. 数据发布/订阅"></a>1. 数据发布 / 订阅</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><p>即所谓的配置中⼼，顾名思义就是发布者将数据发布到 ZooKeeper 的⼀个或⼀系列节点上，供订阅者进⾏数据订阅，进⽽达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p>
<p><em>两种设计模式：</em></p>
<ul>
<li>推（Push）模式：服务端主动将数据更新发送给所有订阅的客户端 </li>
<li>拉（Pull）模式：由客户端主动发起请求来获取最新数据，通常客户端都采⽤定时进⾏轮询拉取的⽅式 </li>
<li>ZooKeeper 采⽤的是推拉相结合的⽅式： <ul>
<li>客户端向服务端注册⾃⼰需要关注的节点，⼀旦该节点的数据 发⽣变更，那么服务端就会向相应的客户端发送 Watcher 事件通知。 </li>
<li>客户端接收到这个消息通知之后， 需要主动到服务端获取最新的数据。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="1-2-配置中心"><a href="#1-2-配置中心" class="headerlink" title="1.2. 配置中心"></a>1.2. 配置中心</h3><ul>
<li>配置获取：应⽤在启动的时候都会主动到 ZooKeeper 服务端上进⾏⼀次配置信息的获取。同时，在指定节点上注册⼀个 Watcher 监听。</li>
<li>配置变更：当配置信息发⽣变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。</li>
</ul>
<h2 id="2-命名服务"><a href="#2-命名服务" class="headerlink" title="2. 命名服务"></a>2. 命名服务</h2><p>通过调⽤ ZooKeeper 节点创建的 API 接⼝可以创建⼀个顺序节点，并且在 API 返回值中会返回这个节点的完整名字。利⽤这个特性，我们就可以借助 ZooKeeper 来⽣成全局唯⼀的 ID</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/872ac0d047ee554d2bc6134cc2c7b4ae.png"></p>
<h2 id="3-集群管理"><a href="#3-集群管理" class="headerlink" title="3. 集群管理"></a>3. 集群管理</h2><p>我们经常会有类似于如下的需求：</p>
<ul>
<li>如何快速的统计出当前⽣产环境下⼀共有多少台机器</li>
<li>如何快速的获取到机器上下线的情况</li>
<li>如何实时监控集群中每台主机的运⾏时状态</li>
</ul>
<h3 id="3-1-分布式日志收集系统"><a href="#3-1-分布式日志收集系统" class="headerlink" title="3.1. 分布式日志收集系统"></a>3.1. 分布式日志收集系统</h3><p><strong>问题：</strong><br>如何快速、合理、动态地为每个日志收集器分配对应的⽇志生产机器。<br>⽇志生产机器和日志收集机器的扩容和缩容</p>
<p><strong>步骤：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/172876d295f806af735b9948b1cb3e59.png"></p>
<ol>
<li><p><em>注册收集器：</em> 每个收集机器启动时，都会在总节点下创建⾃⼰的节点，例如 <code>/logs/collector/[Hostname]</code> </p>
<blockquote>
<p>节点类型为持久节点。若为临时节点，其在会话结束后会被删除，分配的日志生产节点也会消失。</p>
<p>所以可以通过定期维护 status 子节点来表明机器状态</p>
</blockquote>
</li>
<li><p><em>任务分发：</em> 系统根据收集器节点下⼦节点的个数，将所有⽇志生产机器分成对应的若⼲组，然后将分组后的机器列表分别写到这些收集器机器创建的⼦节点上去 </p>
</li>
<li><p><em>状态汇报：</em></p>
</li>
</ol>
<ul>
<li>每个收集器在创建完节点后，还需要在其⼦节点上创建⼀个⼦节点代表状态，例如 <code>/logs/collector/host1/status</code>。</li>
<li>每个收集器需要定期向该节点写⼊⾃⼰的状态信息（⼼跳检测机制），通常写⼊⽇志收集进度信息。⽇志系统根据该节点的最后更新时间来判断对应的收集器是否存活。</li>
</ul>
<ol start="4">
<li><em>动态分配：</em> ⽇志系统始终关注 <code>/logs/collector</code> 这个节点下所有⼦节点的变更，⼀旦检测到有收集器停⽌汇报或是有新的收集器加⼊，就要开始进⾏任务的重新分配。 <blockquote>
<p>若采⽤ Watcher 机制，那么通知的消息量的⽹络开销⾮常⼤。</p>
<p>可采⽤⽇志系统主动轮询收集器节点的策略，这样可以节省⽹络流量，但是存在⼀定的延时。</p>
</blockquote>
</li>
</ol>
<h2 id="4-Master-选举"><a href="#4-Master-选举" class="headerlink" title="4. Master 选举"></a>4. Master 选举</h2><p><strong>作用：</strong> 达到只使用一台 Master 处理逻辑，同步至多台 Follower 的效果<br><strong>原理：</strong> ZooKeeper 在分布式高并发下能使节点的创建保证全局唯⼀性，Master 选举可理解成多机器抢分布式锁的过程。<br><strong>过程：</strong></p>
<ol>
<li>Client 集群每天定时会通过 ZooKeeper 来实现 Master 选举 <ol>
<li>在 ZooKeeper 上创建⼀个⽇期节点，例如 2020-11-11。</li>
<li>Client 集群每天都会定时创建⼀个临时节点，例如 <code>/master_election/2020-1111/binding</code>。创建成功的客户端成为 Master。其他成功创建节点的客户端，都会在节点 <code>/master_election/2020-11-11</code> 上注册⼀个子节点变更的 Watcher，⽤于监控当前的 Master 机器是否存活。</li>
<li>⼀旦发现当前的 Master 挂了，那么其余的客户端将会重新进行 Master 选举。</li>
</ol>
</li>
<li>Master 会负责进⾏⼀系列的海量数据处理，最终计算得到⼀个数据结果，并将其放置在⼀个内存 / 数据库中。同时，Master 还需要通知集群中其他所有的客户端从这个内存 / 数据库中共享计算结果。</li>
</ol>
<p><strong>缺点：</strong><br>负载大，扩展性差。如果有上万个客户端都参与竞选，意味着同时会有上万个写请求。<br>由于 ZooKeeper 会把写请求转发到 Leader 来处理，再广播到 Follower，所以其写性能不高。<br>同时一旦 Leader 放弃领导权，ZooKeeper 需要同时通知上万个 Follower，负载较大。</p>
<h2 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. 分布式锁</h2><h3 id="5-1-排他锁（非公平）"><a href="#5-1-排他锁（非公平）" class="headerlink" title="5.1. 排他锁（非公平）"></a>5.1. 排他锁（非公平）</h3><p><strong>概述：</strong> 加锁期间，只允许持有锁的对象对数据进⾏读取和更新操作<br><strong>实现：</strong></p>
<ul>
<li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，例如 <code>/exclusive_lock/lock</code> 节点就可以被定义为⼀个锁</li>
<li><em>获取锁：</em> 在 <code>/exclusive_lock</code> 节点下创建临时⼦节点 <code>/exclusive_lock/lock</code>，成功创建的客户端就被认为获取了锁。所有没有获取到锁的客户端就需要到 <code>/exclusive_lock</code> 节点上注册⼀个⼦节点变更的 Watcher 监听</li>
<li><em>释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知所有在 <code>/exclusive_lock</code> 节点上注册了⼦节点变更 Watcher 监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li>
</ul>
<h3 id="5-2-排他锁（公平）"><a href="#5-2-排他锁（公平）" class="headerlink" title="5.2. 排他锁（公平）"></a>5.2. 排他锁（公平）</h3><p><strong>实现：</strong></p>
<ul>
<li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，<code>/shared_lock/[Hostname]-请求类型-序号</code> 的临时顺序节点 </li>
<li><em>获取锁：</em> 所有客户端都会到 <code>/shared_lock</code> 这个节点下⾯创建⼀个临时顺序节点，然后获取 <code>/shared_lock</code> 节点下所有⼦节点 <ol>
<li>若自己不是序号最小的子节点，那么客户端调用 <code>exist()</code> 方法监听前一个节点。</li>
<li>接收到 Watcher 通知后，检查自己是不是最小子节点（可能只是前面的未持锁节点宕机了）</li>
</ol>
</li>
<li><em>释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li>
</ul>
<h3 id="5-3-共享锁"><a href="#5-3-共享锁" class="headerlink" title="5.3. 共享锁"></a>5.3. 共享锁</h3><p><strong>概述：</strong> 加锁期间，只允许所有持锁对象对数据进行读取操作，不允许写操作。<br><strong>实现：</strong> 与公平排他锁类似</p>
<ul>
<li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，<code>/shared_lock/[Hostname]-请求类型-序号</code> 的临时顺序节点 <img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8a9f71d3efc49a65b07fe21eceb64447.png"> </li>
<li><em>获取锁：</em> 所有客户端都会到 <code>/shared_lock</code> 这个节点下⾯创建⼀个临时顺序节点，然后获取 <code>/shared_lock</code> 节点下所有⼦节点 <ol start="3">
<li><em>对于读请求：</em> 若没有比自己序号小的子节点或所有比自己序号小的⼦节点都是读请求，那么表明自己已经成功获取到共享锁，同时开始执行读取逻辑。否则客户端调用 <code>exist()</code> 方法监听前一个 <strong>写请求</strong> 节点。</li>
<li><em>对于写请求：</em> 若⾃⼰不是序号最小的⼦节点，那么客户端调用 <code>exist()</code> 方法监听前一个节点。</li>
<li>接收到 Watcher 通知后，重复步骤 1</li>
</ol>
</li>
<li><em> 释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li>
</ul>
<h2 id="6-分布式队列"><a href="#6-分布式队列" class="headerlink" title="6. 分布式队列"></a>6. 分布式队列</h2><p>ZooKeeper 不适合作为队列</p>
<ul>
<li><em>节点大小不足：</em> ZK 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含的消息非常大。</li>
<li><em>内存空间不足：</em> ZK 的数据库完全放在内存中。 大量的 Queue 意味着会占用很多的内存空间。</li>
<li><em>启动慢：</em> 如果有很多节点，ZK 启动时相当的慢。 而使用 queue 会导致好多 ZNode. 你需要显著增大 initLimit 和 syncLimit。</li>
<li><em>性能差：</em> 包含成千上万的子节点的 ZNode 时， ZK 的性能变得不好</li>
</ul>
<h3 id="6-1-FIFO-先入先出队列"><a href="#6-1-FIFO-先入先出队列" class="headerlink" title="6.1. FIFO 先入先出队列"></a>6.1. FIFO 先入先出队列</h3><p>和锁的实现相似<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/45d398e97319878e6f0f72aabc3ae369.png"></p>
<ol>
<li>创建持久顺序节点（由于创建的节点是持久化的，所以不必担心队列消息的丢失问题）</li>
<li>获取列表判断是否为最小顺序节点 <ol>
<li>最小：处理逻辑，之后删除</li>
<li>不是最小：监听并等待前一个节点</li>
</ol>
</li>
</ol>
<h3 id="6-2-Barrier-分布式屏障（同步队列）"><a href="#6-2-Barrier-分布式屏障（同步队列）" class="headerlink" title="6.2. Barrier 分布式屏障（同步队列）"></a>6.2. Barrier 分布式屏障（同步队列）</h3><p><strong>概述：</strong> 特指系统之间的⼀个协调条件，规定了⼀个队列的元素必须都集聚后才能统⼀进⾏安排，否则⼀直等待<br><strong>应⽤场景：</strong> ⼤规模分布式并⾏计算，最终的合并计算需要基于很多并⾏计算的⼦结果来进⾏<br><strong>过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d7ca5543eda4547bae7f6f90e287bb7e.png"></p>
<ol>
<li>/queque_barrier 节点值为 10，客户端再该节点下创建子节点</li>
<li>获取 /queue_barrier 节点的数据内容：10</li>
<li> 获取全部节点列表并注册对 /queque_barrier 子节点变化的监听</li>
<li>若子节点个数不足 10 个则等待直到个数等于 10</li>
<li> 若子节点个数等于 10 则进行业务处理</li>
</ol>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土③：过期策略与数据淘汰</title>
    <url>/9e6a2758b52d/</url>
    <content><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1. 过期策略"></a>1. 过期策略</h2><p><strong><em>定期删除：</em></strong> 默认每隔 <strong>100ms 随机抽取 <strong>进行检查，是否有过期的 key，有过期 key 则删除。因此没抽查到的需要惰性删除进一步筛选<br></strong><em>惰性删除：</em></strong> 获取某个 key 的时候，如果该 key 已过期，则删除。</p>
<span id="more"></span>
<h2 id="2-数据淘汰"><a href="#2-数据淘汰" class="headerlink" title="2. 数据淘汰"></a>2. 数据淘汰</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰。<br>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> volatile-lru</td>
<td> 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td> volatile-ttl</td>
<td> 从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td> volatile-random</td>
<td> 从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td> allkeys-lru</td>
<td> 从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td> allkeys-random</td>
<td> 从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td> noeviction</td>
<td> 禁止驱逐数据</td>
</tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。<br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。<br>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土②：数据类型与结构</title>
    <url>/a428f26c6b50/</url>
    <content><![CDATA[<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>可以存储的值</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td> STRING</td>
<td> 字符串、整数或者浮点数</td>
<td>计数（秒杀、点赞）、缓存</td>
</tr>
<tr>
<td> LIST</td>
<td> 列表</td>
<td>消息队列、排行榜、关注列表</td>
</tr>
<tr>
<td> SET</td>
<td> 无序集合</td>
<td>集群部署全局去重<br>共同喜好，自己独有的喜好</td>
</tr>
<tr>
<td> ZSET</td>
<td> 有序集合</td>
<td>排行榜</td>
</tr>
<tr>
<td> HASH</td>
<td> 包含键值对的无序散列表</td>
<td>单点登录，以 cookieId 作为 key<br>模拟 session、<br>存储对象</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><ol>
<li><strong>计数器</strong><ol>
<li>可以对 String 进行自增自减运算，从而实现计数器功能</li>
<li> Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量</li>
</ol>
</li>
<li><strong>缓存</strong><ol>
<li>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率</li>
</ol>
</li>
<li><strong>查找表</strong><ol>
<li>例如 DNS 记录就很适合使用 Redis 进行存储</li>
<li>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源</li>
</ol>
</li>
<li><strong>消息队列</strong><ol>
<li> List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件</li>
</ol>
</li>
<li><strong>会话缓存</strong><ol>
<li>可以使用 Redis 来统一存储多台应用服务器的会话信息</li>
<li>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性</li>
</ol>
</li>
<li><strong>分布式锁实现</strong><ol>
<li>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现</li>
</ol>
</li>
<li><strong>并发</strong><ol>
<li>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 redis 做一个缓冲操作，让请求先访问到 redis，而不是直接访问数据库</li>
</ol>
</li>
<li><strong>其它</strong><ol>
<li> Set 可以实现交集、并集等操作，从而实现共同好友等功能</li>
<li> ZSet 可以实现有序性操作，从而实现排行榜等功能</li>
</ol>
</li>
</ol>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><h3 id="3-1-字典"><a href="#3-1-字典" class="headerlink" title="3.1. 字典"></a>3.1. 字典</h3><p><strong><em>dictht 结构：</em></strong> dictht 是一个散列表结构，使用拉链法保存哈希冲突</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment">* implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> {</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">} dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> {</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="type">void</span> *val;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">    <span class="type">int64_t</span> s64;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">} v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">} dictEntry;</span><br></pre></td></tr></tbody></table></figure>

<p><strong><em>dict rehash 操作：</em></strong><br>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作<br>在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> {</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">} dict;</span><br></pre></td></tr></tbody></table></figure>

<p><strong><em>渐进方式：</em></strong> rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担<br>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict [0] rehash 到 dict [1]，这一次会把 dict [0] 上 table [rehashidx] 的键值对 rehash 到 dict [1] 上，dict [0] 的 table [rehashidx] 指向 null，并令 rehashidx++<br>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash<br>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) {</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) {</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) {</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        }</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) {</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-跳跃表"><a href="#3-2-跳跃表" class="headerlink" title="3.2. 跳跃表"></a>3.2. 跳跃表</h3><p><strong><em>概述：</em></strong> 是有序集合的底层实现之一。跳跃表是基于多指针有序链表实现的，可以看成多个有序链表<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/283bf4e292bcb9e64563c5eb79844e91.png" alt="image.png"><br><strong><em>查找：</em></strong> 在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。<br>下图演示了查找 22 的过程：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9825611b39a36e97e8916ee681b6aacb.png" alt="image.png"><br><strong><em>优点：</em></strong> 与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</li>
<li>更容易实现</li>
<li>支持无锁操作</li>
</ul>
<p><strong><em>原理：</em></strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> {</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    } level[];</span><br><span class="line">} zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">} zskiplist;</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4667bef9826a52b9d27a17410dd369da.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑤：四字命令（Four Letter Words）</title>
    <url>/b4e159ffd1c4/</url>
    <content><![CDATA[<p><strong>安装 nc：</strong> <code>yum install nc</code><br><strong>命令格式：</strong> echo [commond] | nc [ip] [port]<br><strong>stat：</strong> 查看 zk 的状态信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo stat | nc localhost 2181</span><br><span class="line">Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients:</span><br><span class="line">/127.0.0.1:55394 [0] (queued-0, recved=1, sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 2</span><br><span class="line">Sent: 1</span><br><span class="line">Connections: 1</span><br><span class="line">Outatanding: 0</span><br><span class="line">Zxid: 0xed</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 29</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p><strong>conf：</strong> 查看服务器配置</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo conf | nc localhost 2181</span><br><span class="line">clientFort=2181</span><br><span class="line">dataDir=/uar/local/zookeeper-3.4.9/dataDir/version-2</span><br><span class="line">dataLogDir=/usr/local/zookeeper-3.4.9/dataLoaDir/version-2</span><br><span class="line">tickTime=2000</span><br><span class="line">maxClientCnxns=60</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=40000</span><br><span class="line">serverId=0</span><br></pre></td></tr></tbody></table></figure>

<p><strong>cons：</strong> 显示连接到服务器的客户端信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo cons | nc localhost 2181</span><br><span class="line">/127.0.0.1:55442[1](queued-0,recved=1,sent=1,sid=0x16b1af459260001,lop=SESS,est=1559532063700,to=30000,lcxid=0x0,lzxid=0x0,lresp=1559532063718,llat=5,minlat=0,avglat=5,maxlat=5)</span><br><span class="line">/127.0.0.1:55444[0](queued=0,recved=1,sent=0)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>envi：</strong> 环境变量</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo envi | nc localhost 2181</span><br><span class="line">Environment:</span><br><span class="line">zookeeper.version=3.4.9-1757313, built on 08/23/2016 06:50 GMT</span><br><span class="line">host,name=izbp101vzs716yznuegsliz</span><br><span class="line">java.version=1.8.0_201</span><br><span class="line">java.vendor=Oracle Corporation</span><br><span class="line">java.home=/usr/jdk/jdk1.8.0_ 201/jre</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p><strong>mntr：</strong> 监控 zk 健康信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo mntr | nc localhost 2181</span><br><span class="line">zk_version  3.4.9-1757313, built on o8/23/2016 06:50 GMT</span><br><span class="line">zk_avg_latency 0</span><br><span class="line">zk_max_latency 25</span><br><span class="line">zk_min_latency 0</span><br><span class="line">zk_packets_received  78</span><br><span class="line">zk_packets_sent 77</span><br><span class="line">zk_num_alive_connections</span><br><span class="line">zk_outstanding_requests 0</span><br><span class="line">zk_server_state standalone</span><br><span class="line">zk_znode_count 29</span><br><span class="line">zk_watch_count 0</span><br><span class="line">zk_ephemerals_count 0</span><br><span class="line">zk_approximate_data_size  553</span><br><span class="line">zk_open_file_descriptor_count 27</span><br><span class="line">zk_max_file_descriptor_count 65535</span><br></pre></td></tr></tbody></table></figure>

<p><strong>wchs：</strong> 显示 watch 的信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchs | nc localhost 2181</span><br><span class="line">1 connections watching 1 paths</span><br><span class="line">Total watches:1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>wchc：</strong> watch 的 session 与 watch</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchc | nc localhost 2181</span><br><span class="line">0x16b1af459260001</span><br><span class="line">		/zookeeper</span><br></pre></td></tr></tbody></table></figure>

<p><strong>wchp：</strong> watch 的 path 与 watch 信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchp | nc localhost 2181</span><br><span class="line">/zookeeper</span><br><span class="line">		0x16b1af459260001</span><br></pre></td></tr></tbody></table></figure>

<p><strong>ruok（Are you OK？）：</strong> 查看当前 &nbsp;zkServer 是否启动，返回 imok（I am OK）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo ruok | nc localhost 2181</span><br><span class="line">imok</span><br></pre></td></tr></tbody></table></figure>

<p><strong>dump：</strong> 列出未经处理的会话和临时节点</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo dump | nc localhost 2181</span><br><span class="line">SessionTracker dump:</span><br><span class="line">Session Sets (4):</span><br><span class="line">0 expire at Mon Jun 03 11:11:24 CST 2019:</span><br><span class="line">0 expire at Mon Jun 03 11:11:34 CST 2019:</span><br><span class="line">0 expire at Mon Jun 03 11:11:44 CST 2019:</span><br><span class="line">1 expire at Mon Jun 03 11:11:48 CST 2019:</span><br><span class="line">		0x16b1af459260000</span><br><span class="line">ephemeral nodes dump:</span><br><span class="line">Sessions with Ephemerals (1):</span><br><span class="line">0x16b1af459260000:</span><br><span class="line">		/test/temg</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土①：概述及问题</title>
    <url>/6f11515c0e71/</url>
    <content><![CDATA[<p>Redis 是速度非常快的 <strong>非关系型（NoSQL）内存键值数据库</strong>，可以存储键和五种不同类型的值之间的映射</p>
<h2 id="1-与-Memcached-的不同"><a href="#1-与-Memcached-的不同" class="headerlink" title="1. 与 Memcached 的不同"></a>1. 与 Memcached 的不同</h2><ol>
<li><strong>数据类型：</strong><ol>
<li>Redis 支持五种不同的数据类型，可以更灵活地解决问题</li>
<li> Memcached <strong>仅支持字符串类型</strong></li>
</ol>
</li>
<li><strong>数据持久化：</strong><ol>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志</li>
<li> Memcached <strong>不支持持久化</strong></li>
</ol>
</li>
<li><strong>分布式：</strong><ol>
<li>Redis Cluster 实现了分布式的支持</li>
<li> Memcached <strong>不支持分布式</strong>，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</li>
</ol>
</li>
<li><strong>内存管理机制：</strong><ol>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中</li>
<li> Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了</li>
</ol>
</li>
</ol>
<span id="more"></span>
<h2 id="2-遇到的问题"><a href="#2-遇到的问题" class="headerlink" title="2. 遇到的问题"></a>2. 遇到的问题</h2><p><a href="https://zhuanlan.zhihu.com/p/34545249">缓存世界中的三大问题及解决方案</a></p>
<h3 id="2-1-缓存和数据库双写一致性问题"><a href="#2-1-缓存和数据库双写一致性问题" class="headerlink" title="2.1. 缓存和数据库双写一致性问题"></a>2.1. 缓存和数据库双写一致性问题</h3><ul>
<li>** 只能降低 ** 不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存</li>
<li><strong>不能先写缓存再写数据库</strong>，万一数据库事务回滚会产生数据不一致</li>
<li>采取 <strong>正确更新策略</strong>，先更新数据库，再删缓存</li>
<li>因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用 <strong>消息队列</strong></li>
</ul>
<h3 id="2-2-缓存雪崩问题"><a href="#2-2-缓存雪崩问题" class="headerlink" title="2.2. 缓存雪崩问题"></a>2.2. 缓存雪崩问题</h3><p><strong><em>概念：</em></strong> 即缓存 <strong>同一时间大面积 失效</strong>，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常<br><strong><em>思路：</em></strong></p>
<ol>
<li>不同时间</li>
<li>双缓存</li>
</ol>
<p><strong><em>解决：</em></strong></p>
<ol>
<li>给缓存的失效时间，加上一个 <strong>随机值</strong>，避免集体失效<ol>
<li>零点补课避免出现大量过期，不宜使用随机</li>
<li>与时点性无关，可以使用随机</li>
</ol>
</li>
<li>使用 <strong>互斥锁</strong>，但是该方案吞吐量明显下降了</li>
<li><strong>双缓存</strong>。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作<ol>
<li>从缓存 A 读数据库，有则直接返回</li>
<li> A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程。更新线程同时更新缓存 A 和缓存 B</li>
</ol>
</li>
</ol>
<p><strong>2.3. 击穿</strong><br>缓存过期了</p>
<ol>
<li>利用 <strong>互斥锁</strong>，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
</ol>
<h3 id="2-3-缓存穿透问题"><a href="#2-3-缓存穿透问题" class="headerlink" title="2.3. 缓存穿透问题"></a>2.3. 缓存穿透问题</h3><p><strong><em>概念：</em></strong> 黑客故意去 ** 请求 ** 缓存中 ** 不存在 ** 的数据，导致所有的请求都怼到数据库上，从而数据库连接异常<br><strong>直接原因：</strong></p>
<ol>
<li>频繁请求</li>
<li>值不存在直接请求数据库</li>
</ol>
<p><strong>思路：</strong></p>
<ol>
<li>对请求做拦截（锁、拦截器）</li>
<li>不直接访问数据库</li>
</ol>
<p><strong><em>解决：</em></strong></p>
<ol>
<li>利用 <strong>互斥锁</strong>，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>采用 <strong>异步更新策略</strong>，无论 key 是否取到值，都直接返回<ol>
<li> value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存</li>
<li>需要做缓存预热（项目启动前，先加载缓存）操作</li>
</ol>
</li>
<li>提供一个能迅速判断请求是否有效的 <strong>拦截机制</strong>，比如，利用布隆过滤器，内部维护一系列合法有效的 key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回</li>
</ol>
<h3 id="2-4-并发竞争-key-问题"><a href="#2-4-并发竞争-key-问题" class="headerlink" title="2.4. 并发竞争 key 问题"></a>2.4. 并发竞争 key 问题</h3><p><strong><em>概念：</em></strong> 同时有多个子系统去 set 一个 key</p>
<ol>
<li>如果对这个 key 操作，不要求顺序<ol>
<li><strong>分布式锁</strong></li>
</ol>
</li>
<li>如果对这个 key 操作，要求顺序<ol>
<li>写入数据库的时候，需要保存一个 <strong>时间戳</strong></li>
</ol>
</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d85bc71e099cf375eface009480e95c.png" alt="image.png"><br>采用队列模式将并发访问变为串行访问</p>
<h2 id="3-单线程快速的原因"><a href="#3-单线程快速的原因" class="headerlink" title="3. 单线程快速的原因"></a>3. 单线程快速的原因</h2><ol>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞 I/O 多路复用机制</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/98c6a0c7b7f6830366cd40bd8676cc66.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土⑤：事务与事件</title>
    <url>/4ee5322c6d14/</url>
    <content><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><p>一个事务包含了 <strong>多个命令</strong>，服务器在执行事务期间，<strong>不会改去执行其它客户端的命令请求</strong><br>事务中的多个命令被 ** 一次性 ** 发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。<br>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<span id="more"></span>
<h1 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h1><p>Redis 服务器是一个事件驱动程序。</p>
<h2 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h2><p><strong><em>概述：</em></strong> 服务器通过套接字与客户端或者其它服务器进行通信，<strong>文件事件就是对套接字操作的抽象</strong>。<br>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 **I/O 多路复用程序 ** 来同时监听多个套接字，并将到达的事件传送给 <strong>文件事件分派器</strong>，分派器会根据套接字产生的事件类型调用相应的 <strong>事件处理器</strong>。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a1f750912f7a07dac7d91d18f89b3aeb.png" alt="image.png"></p>
<h2 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2. 时间事件"></a>2. 时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。<br>时间事件又分为：</p>
<ul>
<li><strong>定时事件：</strong> 是让一段程序在指定的时间之内执行一次</li>
<li><strong>周期性事件：</strong> 是让一段程序每隔指定时间就执行一次</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h2 id="3-事件的调度与执行"><a href="#3-事件的调度与执行" class="headerlink" title="3. 事件的调度与执行"></a>3. 事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。<br>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">def aeProcessEvents():</span><br><span class="line">    # 获取到达时间离当前时间最接近的时间事件</span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    # 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br><span class="line">    if remaind_ms &lt; 0:</span><br><span class="line">        remaind_ms = 0</span><br><span class="line">    # 根据 remaind_ms 的值，创建 timeval</span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    # 处理所有已产生的文件事件</span><br><span class="line">    procesFileEvents()</span><br><span class="line">    # 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></tbody></table></figure>

<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 初始化服务器</span><br><span class="line">    init_server()</span><br><span class="line">    # 一直处理事件，直到服务器关闭为止</span><br><span class="line">    while server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    # 服务器关闭，执行清理操作</span><br><span class="line">    clean_server()</span><br></pre></td></tr></tbody></table></figure>

<p>从事件处理的角度来看，服务器运行流程如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/63c539a813dc898a9f8aa3669cb5caf3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土④：持久化</title>
    <url>/d4581e6c9497/</url>
    <content><![CDATA[<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<span id="more"></span>
<h2 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1. RDB 持久化"></a>1. RDB 持久化</h2><p><strong><em>概述：</em></strong><br>将 ** 某个时间点 ** 的所有数据都存放到硬盘上<br>可以将 <strong>快照 <strong>复制到其它服务器从而创建具有相同数据的服务器副本<br></strong><em>缺点：</em></strong></p>
<ul>
<li>如果数据量很大，保存快照的 <strong>时间会很长</strong></li>
<li>如果系统发生故障，将会 ** 丢失 ** 最后一次创建快照之后的数据</li>
<li>不支持拉链，只有一个 dump.rdb</li>
</ul>
<p><strong><em>优点：</em></strong> 回复速度相对快<br><strong><em>场景：</em></strong> 关机维护<br><strong><em>三种触发机制：</em></strong></p>
<ul>
<li><strong>save 命令：</strong><ul>
<li>同步</li>
<li>直接生成 rdb 二进制文件</li>
<li>若有老的备份，新的备份会替换老的备份</li>
</ul>
</li>
<li><strong> bgsave 命令：</strong><ul>
<li>异步</li>
<li>通过 fork () 创建一个子进程去创建 rdb 文件</li>
<li> fork ()：浅拷贝 + copy on write：可以做到快速拷贝，且父子互不影响<ul>
<li>快速拷贝</li>
<li>写时复制触发次数不多（不可能父子进程把所有数据都改一遍）</li>
</ul>
</li>
</ul>
</li>
<li><strong>配置：</strong><ul>
<li>save seconds changes（save 900 1）</li>
<li>本质为执行 bgsave</li>
<li> 一般都会把配置关闭</li>
<li>推荐配置如下 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份命名为 dump-<span class="variable">${port}</span>.rdb</span></span><br><span class="line">dbfilename "dump-${port}.rdb"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份存储位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bgsave 错误时停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩格式</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验和</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2. AOF 持久化"></a>2. AOF 持久化</h2><p><strong><em>概述：</em></strong> 将写命令添加到 AOF 文件（Append Only File）的末尾<br><strong><em>过程：</em></strong> 每次执行写命令时会把命令加入缓冲区，缓冲区根据策略进行持久化<br><strong><em>缺点：</em></strong> 体量无限变大</p>
<h3 id="2-1-同步选项"><a href="#2-1-同步选项" class="headerlink" title="2.1. 同步选项"></a>2.1. 同步选项</h3><p>使用 AOF 持久化需要设置同步选项，从而确保写命令 ** 什么时候 ** 会同步到磁盘文件上<br>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>同步频率</strong></th>
</tr>
</thead>
<tbody><tr>
<td> always</td>
<td> 每个写命令都同步</td>
</tr>
<tr>
<td> everysec</td>
<td> 每秒同步一次</td>
</tr>
<tr>
<td> no</td>
<td> 让操作系统来决定何时同步</td>
</tr>
</tbody></table>
<ul>
<li><strong> always：</strong> 会严重减低服务器的性能</li>
<li><strong> everysec：</strong> 比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li>
<li><strong> no：</strong> 并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</li>
</ul>
<h3 id="2-2-AOF-重写（4-0-以前）"><a href="#2-2-AOF-重写（4-0-以前）" class="headerlink" title="2.2. AOF 重写（4.0 以前）"></a>2.2. AOF 重写（4.0 以前）</h3><p>随着服务器写请求的增多，AOF 文件会越来越大<br>Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令<br><strong><em>原理：</em></strong> 删除抵消的命令，合并重复的命令<br><strong><em>两种方式：</em></strong></p>
<ul>
<li>bgrewriteaof 命令：<ul>
<li>异步</li>
<li>通过 fork () 创建一个子进程来在内存中执行 AOF 重写</li>
</ul>
</li>
<li>配置：<ul>
<li>推荐配置如下 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 AOF</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份名</span></span><br><span class="line">appendfilename "appendonly-${port}.aof"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">持久化策略为每秒进行</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份存储位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 重写时不会执行 AOF</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 文件重写所需的最小大小</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 文件增长率</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-3-AOF-重写（4-0-以后）"><a href="#2-3-AOF-重写（4-0-以后）" class="headerlink" title="2.3. AOF 重写（4.0 以后）"></a>2.3. AOF 重写（4.0 以后）</h3><p>RDB 和 AOF 混合</p>
<ul>
<li>将老的数据 RDB 到 AOF 文件中</li>
<li>将增量的数据以指令的方式 append 到 AOF 中</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土⑦：高级特性</title>
    <url>/56926004f999/</url>
    <content><![CDATA[<h1 id="一、慢查询"><a href="#一、慢查询" class="headerlink" title="一、慢查询"></a>一、慢查询</h1><h2 id="1-Redis-请求过程"><a href="#1-Redis-请求过程" class="headerlink" title="1. Redis 请求过程"></a>1. Redis 请求过程</h2><p>慢查询发生在 执行命令阶段<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e54533b87280e919df50ae491be9c654.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h2><p>保存在内存中的长度固定的 <strong>先进先出队列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d8834ce0eb85fc2f1215b30305114cc7.png" alt="image.png"></p>
<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p><strong><em>slowlog-max-len：</em></strong> 最大长度，默认为 128<br><strong><em>slowlog-log-slower-than=1000：</em></strong> 超过 1s 则加入慢查队列中，默认为 10000</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">// 动态配置</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config set slowlog-log-slower-than=10000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><p><strong><em>slowlog get [n]：</em></strong> 获取慢查询队列，n 为条数<br><strong><em>slowlog len：</em></strong> 获取慢查询队列长度<br><strong><em>slowlog reset：</em></strong> 清空慢查询队列</p>
<h1 id="二、流水线（pipeline）"><a href="#二、流水线（pipeline）" class="headerlink" title="二、流水线（pipeline）"></a>二、流水线（pipeline）</h1><p><strong><em>作用：</em></strong> 解决批量执行 hset、hget 等操作的问题<br><strong><em>非原子命令</em></strong><br><strong><em>只能作用在一个 Redis 节点上</em></strong><br><strong><em>例：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Jedis jedis = new Jedis("127.0.0.1", 6379);</span><br><span class="line">for (int i = 0; i &lt; 100; i++) {</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    for (int j = i * 100; j &lt; (i + 1) * 100; j++) {</span><br><span class="line">        pipeline.hset("hashkey:" + j, "field" + j, "value" + j);</span><br><span class="line">    }</span><br><span class="line">    pipeline.syncAndReturnAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三、位图（Bitmap）"><a href="#三、位图（Bitmap）" class="headerlink" title="三、位图（Bitmap）"></a>三、位图（Bitmap）</h1><p><strong><em>setbit key offset value：</em></strong> 给位图指定索引设置值，返回之前位的值<br><strong>例：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bb66464075181714bc5d0e455049de93.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bca2b6ea3715c2b07d6589450a2542ef.png" alt="image.png"><br><strong><em>get key offset：</em></strong> 返回位图指定索引的值<br><strong><em>bitcount key [start] [end]：</em></strong> 获取位图指定范围值为 1 的个数<br><strong><em>bitops key targetBit [start] [end]：</em></strong> 计算位图指定范围内第一个值等于 targetBit 的位置<br><strong><em>bitop op destkey key [key…]：</em></strong> 把多个 Bitmap 的 与、或、非、异或 操作的结果保存在 destkey 中</p>
<ul>
<li>op： and（与）、or（或）、not（非）、xor（异或）</li>
</ul>
<h1 id="四、HyperLogLog"><a href="#四、HyperLogLog" class="headerlink" title="四、HyperLogLog"></a>四、HyperLogLog</h1><p><strong><em>概述：</em></strong> 以极小的空间统计独立数量，本质还是 string 类型</p>
<h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><p><strong><em>pfadd key element [element…]：</em></strong> 添加元素<br><strong><em>pfcount key [key…]：</em></strong> 计算总数<br><strong><em>pfmerge destkey key [key…]：</em></strong> 合并多个 hyperloglog</p>
<h2 id="2-缺陷"><a href="#2-缺陷" class="headerlink" title="2. 缺陷"></a>2. 缺陷</h2><p><strong><em>错误率：</em></strong> 0.81%</p>
<h1 id="五、GEO"><a href="#五、GEO" class="headerlink" title="五、GEO"></a>五、GEO</h1><p><strong><em>概述：</em></strong> 地理信息定位。存储经纬度，计算两地距离和范围等，本质是 zset 类型</p>
<h2 id="1-命令-1"><a href="#1-命令-1" class="headerlink" title="1. 命令"></a>1. 命令</h2><p><strong><em>geo key longitude latitude member [longitude latitude member…]：</em></strong> 添加地理位置信息<br><strong><em>geopos key member：</em></strong> 获取地理位置信息<br><strong><em>geodist key member1 member2 [unit]：</em></strong> 获取两个地理位置的距离</p>
<ul>
<li>unit： m、km、mi、ft</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper 从入门到入土⑥：API</title>
    <url>/5d0f9080cef8/</url>
    <content><![CDATA[<p>zk 有 Session，没有线程池的概念</p>
<h2 id="1-原生-API"><a href="#1-原生-API" class="headerlink" title="1. 原生 API"></a>1. 原生 API</h2><p>Zookeeper API 共包含五个包：</p>
<ul>
<li>org.apache.zookeeper</li>
<li>org.apache.zookeeper.data</li>
<li>org.apache.zookeeper.server</li>
<li>org.apache.zookeeper.server.quorum</li>
<li>org.apache.zookeeper.server.upgrade</li>
</ul>
<p>依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h3 id="1-1-建立会话"><a href="#1-1-建立会话" class="headerlink" title="1.1. 建立会话"></a>1.1. 建立会话</h3><p>ZooKeeper 客户端和服务端会话的建⽴是⼀个异步的过程。<br>所以如果在 <code>new ZooKeeper</code> 后立即结束方法会话不能建立完毕，会话的⽣命周期中处于 CONNECTING 的状态。<br>当会话真正创建完毕后 ZooKeeper 服务端会向会话对应的客户端发送⼀个事件通知以告知客户端。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateSession</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			客户端可以通过创建⼀个 zk 实例来连接 zk 服务器</span></span><br><span class="line"><span class="comment">			- connectString：连接地址：IP：端⼝</span></span><br><span class="line"><span class="comment">			- sesssionTimeOut：会话超时时间：单位毫秒</span></span><br><span class="line"><span class="comment">			- Wather：监听器(当特定事件触发监听时，zk 会通过 watcher 通知到客户端)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181,10.211.55.5:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        System.out.println(zooKeeper.getState());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"=========Client Connected to zookeeper=========="</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2-创建节点"><a href="#1-2-创建节点" class="headerlink" title="1.2. 创建节点"></a>1.2. 创建节点</h3><p><em>ZooKeeper#create(String path, byte[] data, List<acl> acl, CreateMode createMode)：</acl></em></p>
<ul>
<li>path：节点创建的路径</li>
<li> data：节点创建要保存的数据</li>
<li> acl：节点创建的权限信息（4 种类型） <ul>
<li>ZooDefs.Ids.ANYONE_ID_UNSAFE：表示任何⼈</li>
<li> ZooDefs.Ids.AUTH_IDS：此 ID 仅可⽤于设置 ACL。它将被客户机验证的 ID 替换。</li>
<li>ZooDefs.Ids.OPEN_ACL_UNSAFE：这是⼀个完全开放的 ACL （常⽤）–&gt; world:anyone</li>
<li>ZooDefs.Ids.CREATOR_ALL_ACL：此 ACL 授予创建者身份验证 ID 的所有权限</li>
</ul>
</li>
<li> createMode：创建节点的类型（4 种类型） <ul>
<li>CreateMode.PERSISTENT：持久节点</li>
<li> CreateMode.PERSISTENT_SEQUENTIAL：持久顺序节点</li>
<li> CreateMode.EPHEMERAL：临时节点</li>
<li> CreateMode.EPHEMERAL_SEQUENTIAL：临时顺序节点 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateNote</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调⽤创建节点⽅法</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                createNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodePersistent</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_persistent"</span>, <span class="string">"持久节点内容"</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodePersistentSequential</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_persistent_sequential"</span>, <span class="string">"持久节点内容"</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodeEpersistent</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_ephemeral"</span>, <span class="string">"临时节点内容"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"创建的持久节点是:"</span> + nodePersistent);</span><br><span class="line">        System.out.println(<span class="string">"创建的持久顺序节点是:"</span> + nodePersistentSequential);</span><br><span class="line">        System.out.println(<span class="string">"创建的临时节点是:"</span> + nodeEpersistent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="1-3-获取节点数据"><a href="#1-3-获取节点数据" class="headerlink" title="1.3. 获取节点数据"></a>1.3. 获取节点数据</h3><ol>
<li><em>ZooKeeper#getData(String path, boolean watch, Stat stat)：</em></li>
</ol>
<ul>
<li>path：获取数据的路径</li>
<li> watch：是否开启监听。ture 代表使用创建 zk 的那个监听</li>
<li> stat：节点状态信息，null 则表示获取最新版本的数据</li>
</ul>
<ol start="2">
<li><em> ZooKeeper#getChildren(String path, boolean watch)</em></li>
</ol>
<ul>
<li>path：路径</li>
<li> watch：是否要启动监听，当⼦节点列表发⽣变化，会触发监听 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNoteData</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">10000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    getNoteData();</span><br><span class="line">                    getChildren();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ⼦节点列表发⽣变化时，服务器会发出 NodeChildrenChanged 通知，但不会把变化情况告诉给客户端</span></span><br><span class="line">            <span class="comment">// 需要客户端⾃⾏获取，且通知是⼀次性的，需反复注册监听</span></span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getType() == Watcher.Event.EventType.NodeChildrenChanged) {</span><br><span class="line">                <span class="comment">// 再次获取节点数据</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    List&lt;String&gt; children = zooKeeper.getChildren(watchedEvent.getPath(), <span class="literal">true</span>);</span><br><span class="line">                    System.out.println(children);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException | InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNoteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException {</span><br><span class="line">        List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">"/lg_persistent"</span>, <span class="literal">true</span>);</span><br><span class="line">        System.out.println(children);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-4-修改节点数据"><a href="#1-4-修改节点数据" class="headerlink" title="1.4. 修改节点数据"></a>1.4. 修改节点数据</h3><p>Stat ZooKeeper#setData(String path, byte[] data, int version)</p>
<ul>
<li>path：路径</li>
<li> data：要修改的内容</li>
<li> version：为 -1，表示对最新版本的数据进⾏修改 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateNote</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                updateNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">"/lg_persistent"</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改前的值:"</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 stat:状态信息对象</span></span><br><span class="line">        <span class="comment">// version: -1 代表最新版本</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.setData(<span class="string">"/lg_persistent"</span>, <span class="string">"客户端修改内容"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data2 = zooKeeper.getData(<span class="string">"/lg_persistent"</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改后的值:"</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data2));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-5-删除节点"><a href="#1-5-删除节点" class="headerlink" title="1.5. 删除节点"></a>1.5. 删除节点</h3><ol>
<li><em>ZooKeeper#exists(String path, boolean watch)：</em> 判断节点是否存在</li>
<li><em> ZooKeeper#delete(String path, int version)：</em> 删除节点 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteNote</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                deleteNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException {</span><br><span class="line">        <span class="type">Stat</span> <span class="variable">exists</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(exists == <span class="literal">null</span> ? <span class="string">"该节点不存在"</span>:<span class="string">"该节点存在"</span>);</span><br><span class="line"></span><br><span class="line">        zooKeeper.delete(<span class="string">"/lg_persistent/lg-children"</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">exists2</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(exists2 == <span class="literal">null</span> ? <span class="string">"该节点不存在"</span>:<span class="string">"该节点存在"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="2-Curator"><a href="#2-Curator" class="headerlink" title="2. Curator"></a>2. Curator</h2><ol>
<li><a href="http://cmsblogs.com/?p=4121">【跟着实例学习 ZooKeeper】–队列</a></li>
<li><a href="http://cmsblogs.com/?p=4123">【跟着实例学习 ZooKeeper】–缓存</a></li>
<li><a href="http://cmsblogs.com/?p=4125">【跟着实例学习 ZooKeeper】–计数器</a></li>
<li><a href="http://cmsblogs.com/?p=4127">【跟着实例学习 ZooKeeper】–Curator 扩展库</a></li>
<li><a href="http://cmsblogs.com/?p=4129">【跟着实例学习 ZooKeeper】–Barrier</a></li>
<li><a href="http://cmsblogs.com/?p=4131">【跟着实例学习 ZooKeeper】–临时节点</a></li>
<li><a href="http://cmsblogs.com/?p=4133">【跟着实例学习 ZooKeeper】–Curator 框架应用</a></li>
<li><a href="http://cmsblogs.com/?p=4135">【跟着实例学习 ZooKeeper】– Leader 选举</a></li>
<li><a href="http://cmsblogs.com/?p=4137">【跟着实例学习 ZooKeeper】–分布式锁</a></li>
</ol>
<h3 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1. 连接"></a>2.1. 连接</h3><p><strong>重试策略：</strong></p>
<ul>
<li><strong>RetryNTimes：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;重试 n 次</li>
<li><strong> RetryOneTime：</strong> &nbsp; &nbsp; &nbsp; &nbsp;重试 1 次</li>
<li><strong> RetryForever：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;永远重试</li>
<li><strong> RetryUntilElapsed：</strong> 重试直到超过最大重试时间 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 同 RetryNTimes</span></span><br><span class="line"><span class="comment">// RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 5);</span></span><br><span class="line"><span class="comment">// 实际调用 CuratorFrameworkFactory.builder().build();</span></span><br><span class="line"><span class="comment">// CuratorFramework client = CuratorFrameworkFactory.newClient("192.168.1.110:2181", retryPolicy);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 重试 3 次，每次间隔 5s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 只重试 1 次</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryOneTime</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 永远重试，每次间隔 3s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryForever</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 重试直到超过 2s，每次间隔 3s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryUntilElapsed</span>(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">"192.168.1.110:2181"</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .namespace(<span class="string">"workspace"</span>)</span><br><span class="line">        .build();</span><br><span class="line">client.start();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-2-创建"><a href="#2-2-创建" class="headerlink" title="2.2. 创建"></a>2.2. 创建</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create()</span><br><span class="line">    	<span class="comment">// 1.递归创建节点</span></span><br><span class="line">        <span class="comment">//.creatingParentsIfNeeded()</span></span><br><span class="line">        <span class="comment">//.withMode(createMode)</span></span><br><span class="line">    	<span class="comment">// 2.ACL</span></span><br><span class="line">        <span class="comment">//.withACL(aclList)</span></span><br><span class="line">        .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-设置节点数据"><a href="#2-3-设置节点数据" class="headerlink" title="2.3. 设置节点数据"></a>2.3. 设置节点数据</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">client.setData()</span><br><span class="line">    <span class="comment">// 可带版本</span></span><br><span class="line">    <span class="comment">//.withVersion(version)</span></span><br><span class="line">    .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4-删除"><a href="#2-4-删除" class="headerlink" title="2.4. 删除"></a>2.4. 删除</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">    <span class="comment">// 1.如果删除失败，那么在后端还是继续会删除，直到成功（强制删除）</span></span><br><span class="line">    <span class="comment">//.guaranteed()</span></span><br><span class="line">    <span class="comment">// 2.如果有子节点，就删除</span></span><br><span class="line">    <span class="comment">//.deletingChildrenIfNeeded()</span></span><br><span class="line">    <span class="comment">// 3.指定版本</span></span><br><span class="line">    <span class="comment">//.withVersion(1)</span></span><br><span class="line">    .forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-5-读取节点数据"><a href="#2-5-读取节点数据" class="headerlink" title="2.5. 读取节点数据"></a>2.5. 读取节点数据</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">    <span class="comment">// 包含状态查询</span></span><br><span class="line">    <span class="comment">//.storingStatIn(stat)</span></span><br><span class="line">    .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"节点"</span> + nodePath + <span class="string">"的数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">System.out.println(<span class="string">"该节点的版本号为："</span>+ stat.getVersion());</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-6-获取子节点"><a href="#2-6-获取子节点" class="headerlink" title="2.6. 获取子节点"></a>2.6. 获取子节点</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; nodeList = client.getChildren().forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-7-检查节点是否存在"><a href="#2-7-检查节点是否存在" class="headerlink" title="2.7. 检查节点是否存在"></a>2.7. 检查节点是否存在</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkExists</span><span class="params">(String nodePath)</span> {</span><br><span class="line">    <span class="keyword">return</span> client.checkExists().forPath(nodePath) != <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-8-监听器"><a href="#2-8-监听器" class="headerlink" title="2.8. 监听器"></a>2.8. 监听器</h3><p>usingWatcher<br><strong>概述：</strong> 监听只会触发一次</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">            .usingWatcher(event -&gt; System.out.println(<span class="string">"触发watcher，节点路径为："</span> + event.getPath()))</span><br><span class="line">            .forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure>

<p>NodeCache<br><strong>概述：</strong> 永久监听 <strong>当前路径的节点</strong> 的创建、更新、删除</p>
<p><em>start()：</em></p>
<ul>
<li>NodeCache#start()</li>
<li>NodeCache#start (boolean buildInitial)： true 表示初始化时获取 node 的值并保存 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, nodePath);</span><br><span class="line"><span class="comment">// true 表示初始化时获取 node 的值并保存</span></span><br><span class="line">nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">nodeCache.getListenable().addListener(() -&gt; {</span><br><span class="line">    <span class="type">ChildData</span> <span class="variable">currentData</span> <span class="operator">=</span> nodeCache.getCurrentData();</span><br><span class="line">    System.out.println(<span class="string">"节点 "</span>+ currentData.getPath() + <span class="string">" 的数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(currentData.getData()));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>PathChildrenCache<br><strong>概述：</strong> 永久监听 <strong>当前路径下的子节点</strong> 的创建、更新、删除</p>
<p><strong>start()：</strong></p>
<ul>
<li><strong>NodeCache#start()：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;默认 buildInitial 为 false </li>
<li><strong>NodeCache#start(boolean buildInitial)：</strong> true 表示初始化时获取 node 的值并保存 </li>
<li><strong>NodeCache#start(StartMode mode)：</strong> </li>
<li><ul>
<li>StartMode.<em>POST_INITIALIZED_EVENT：</em> 异步初始化，并触发 INITIALIZED 事件</li>
<li> StartMode.<em>NORMAL：</em> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 异步初始化</li>
<li> StartMode.<em>BUILD_INITIAL_CACHE：</em> &nbsp; &nbsp; &nbsp; &nbsp;同步初始化</li>
</ul>
</li>
</ul>
<p><strong>事件类型：</strong></p>
<ul>
<li><strong>INITIALIZED：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 初始化事件</li>
<li><strong> CHILD_ADDED：</strong> &nbsp; &nbsp; &nbsp;子节点添加事件</li>
<li><strong> CHILD_REMOVED：</strong> 子节点删除事件</li>
<li><strong> CHILD_UPDATED：</strong> &nbsp;子节点更新事件 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// true 表示把节点内容放入 stat 里</span></span><br><span class="line"><span class="type">PathChildrenCache</span> <span class="variable">childrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, nodePath, <span class="literal">true</span>);</span><br><span class="line">childrenCache.start(StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步初始化后可获取子节点数据</span></span><br><span class="line">List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line"><span class="keyword">for</span> (ChildData childData : childDataList) {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(childData.getData()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听子节点</span></span><br><span class="line">childrenCache.getListenable().addListener((client, event) -&gt; {</span><br><span class="line">    <span class="type">ChildData</span> <span class="variable">eventData</span> <span class="operator">=</span> event.getData();</span><br><span class="line">    <span class="comment">// 初始化事件</span></span><br><span class="line">    <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) {</span><br><span class="line">        System.out.println(<span class="string">"子节点初始化完成"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点添加事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) {</span><br><span class="line">        System.out.println(<span class="string">"添加子节点 "</span> + eventData.getPath() + <span class="string">": "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(eventData.getData()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点删除事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {</span><br><span class="line">        System.out.println(<span class="string">"删除子节点 "</span> + eventData.getPath());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点更新事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {</span><br><span class="line">        System.out.println(<span class="string">"修改子节点 "</span> + eventData.getPath() + <span class="string">": "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(eventData.getData()));</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ①：线程</title>
    <url>/3ccff5d7e907/</url>
    <content><![CDATA[<h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h2><p><strong>继承 Thread 类</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="comment">//重写 run（）方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//输出...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> {</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">          <span class="type">SubThread</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread</span>();</span><br><span class="line">          <span class="comment">//调用start（）方法运行线程</span></span><br><span class="line">          st.start();</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现 Runnable 接口</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNum1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">          ...</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread1</span> {</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">          <span class="type">PrintNum1</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNum1</span>();</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">          t1.start();</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现 Callable 接口</strong><br>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<span id="more"></span>
<h2 id="2-线程方法"><a href="#2-线程方法" class="headerlink" title="2. 线程方法"></a>2. 线程方法</h2><h3 id="2-1-调度"><a href="#2-1-调度" class="headerlink" title="2.1. 调度"></a>2.1. 调度</h3><ul>
<li>Thread.sleep (millisec)：睡眠</li>
<li> Thread.yield ()：调用此方法的线程释放当前 cpu 的执行权（可能会再次调用该线程）<br>声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</li>
<li>join ()：等其他线程调用结束<br>在线程中调用另一个线程的 join () 方法，会将当前线程挂起，直到目标线程结束。<br>例：A 线程中调用 B 线程的 join，当执行到 join 方法时 A 停止，直到 B 执行完，A 再接着 join 之后的代码执行</li>
</ul>
<h3 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2. 优先级"></a>2.2. 优先级</h3><p><strong>Api：</strong></p>
<ul>
<li>getPriority ()：返回线程优先值</li>
<li> setPriority (int newPriority)：改变线程的优先级</li>
</ul>
<p><strong>概述：</strong><br>优先级高只能是说明，它获得时间片的概率大，但不是一定会执行它<br>线程创建时继承父线程的优先级</p>
<ul>
<li>1（MIN_PRIORITY）</li>
<li>5（NORMAL_PRIORITY）</li>
<li>10（MAX_PRIORITY）</li>
</ul>
<h3 id="2-3-中断"><a href="#2-3-中断" class="headerlink" title="2.3. 中断"></a>2.3. 中断</h3><ul>
<li><p>void interrupt ()：向线程发送中断请求。线程的中断状态将被设置为 true。如果该线程被 sleep 调用阻塞、限期等待或者无限期等待状态，抛出 InterruptedException 异常。 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        } <span class="keyword">catch</span>(InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">    <span class="comment">// 线程在 sleep 时中断，抛出异常</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>static boolean interrupted ()：测试当前线程是否被中断，并将当前线程的中断状态重置为 false </p>
</li>
<li><p>boolean isInterrupted ()：测试线程是否被终止，不改变线程的中断状态</p>
</li>
</ul>
<h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h2><p>新建、就绪、运行、阻塞、死亡</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/aefed34583c4eb2ca8cce9552e6e9241.png"></p>
<h2 id="4-线程异常"><a href="#4-线程异常" class="headerlink" title="4. 线程异常"></a>4. 线程异常</h2><p><a href="https://www.cnblogs.com/rouqinglangzi/p/10843701.html">多线程中的异常处理</a></p>
<h2 id="5-线程安全场景"><a href="#5-线程安全场景" class="headerlink" title="5. 线程安全场景"></a>5. 线程安全场景</h2><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为</p>
<h3 id="5-1-不可变"><a href="#5-1-不可变" class="headerlink" title="5.1. 不可变"></a>5.1. 不可变</h3><p>不可变（Immutable）的对象一定是线程安全的。</p>
<ul>
<li><strong>final</strong> 关键字修饰的基本数据类型 </li>
<li><strong>String</strong> </li>
<li><strong> 枚举类型</strong> </li>
<li><strong> Number 部分子类</strong>，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的 </li>
<li><strong>不可变集合：</strong>可以使用 Collections.unmodifiableXXX () 方法来获取一个不可变的集合。对集合进行修改的方法都直接抛出异常。 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Exception in thread "main" java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)</span></span><br><span class="line"><span class="comment">    at ImmutableExample.main(ImmutableExample.java:9) */</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="5-2-同步"><a href="#5-2-同步" class="headerlink" title="5.2. 同步"></a>5.2. 同步</h3><ul>
<li>阻塞同步：悲观锁：synchronized 和 ReentrantLock </li>
<li>非阻塞同步 <ul>
<li>CAS（Compare-and-Swap，CAS）乐观锁</li>
<li> AtomicInteger 等原子类</li>
</ul>
</li>
</ul>
<h3 id="5-3-无同步"><a href="#5-3-无同步" class="headerlink" title="5.3. 无同步"></a>5.3. 无同步</h3><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</p>
<ul>
<li><strong>栈封闭：</strong><br>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的 </li>
<li><strong>ThreadLocal：</strong><br>把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题 </li>
<li><strong>可重入代码：</strong><br>这种代码也叫做 <strong>纯代码（Pure Code）</strong>，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。<br>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</li>
</ul>
<h2 id="6-进程、线程、纤程（协程）"><a href="#6-进程、线程、纤程（协程）" class="headerlink" title="6. 进程、线程、纤程（协程）"></a>6. 进程、线程、纤程（协程）</h2><p>线程在内核态<br>纤程在用户态，可以启动的数据比线程多</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>redis.conf 配置参考</title>
    <url>/a3bb20bb5445/</url>
    <content><![CDATA[<ul>
<li>daemonize no</li>
<li>port 6379</li>
<li>dir /usr/local/redis/data</li>
<li>logfile “6379.log”</li>
</ul>
<span id="more"></span>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis配置文件样例</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note on units: when memory size is needed, it is possible to specifiy</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it <span class="keyword">in</span> the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 1k =&gt; 1000 bytes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用<span class="built_in">yes</span>启用守护进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Redis监听端口，默认端口为6379</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果指定0端口，表示Redis不监听TCP连接</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定的主机地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the path <span class="keyword">for</span> the unix socket that will be used to listen <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on a unix socket when not specified.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># unixsocket /tmp/redis.sock</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unixsocketperm 755</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">debug (很多信息, 对开发／测试比较有用)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">notice (moderately verbose, what you want <span class="keyword">in</span> production probably)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel verbose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span></span><br><span class="line">logfile stdout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">enable</span> logging to the system logger, just <span class="built_in">set</span> <span class="string">'syslog-enabled'</span> to <span class="built_in">yes</span>,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-enabled no</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the syslog identity.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-ident redis</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-facility local0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置数据库的数量，默认数据库为0，可以使用<span class="keyword">select</span> &lt;dbid&gt;命令在连接上指定数据库<span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dbid是从0到‘databases’-1的数目</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################### SNAPSHOTTING  #################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Save the DB on disk:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  number of write operations against the DB occurred.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   满足以下条件将会同步数据:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  900秒（15分钟）内有1个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  300秒（5分钟）内有10个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  60秒内有10000个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定存储至本地数据库时是否压缩数据，默认为<span class="built_in">yes</span>，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定本地数据库文件名，默认值为dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作目录.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Also the Append Only File will be created inside this directory.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 注意，这里只能指定一个目录，不能指定文件名</span></span></span><br><span class="line">dir ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ REPLICATION #################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so <span class="keyword">for</span> example it is possible to configure the slave to save the DB with a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">different interval, or to listen to another port, and so on.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当master服务设置了密码保护时，slav服务连接master的密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下文的“requirepass”配置项可以指定密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When a slave lost the connection with the master, or when the replication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is still <span class="keyword">in</span> progress, the slave can act <span class="keyword">in</span> two different ways:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   still reply to client requests, possibly with out of data data, or the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   data <span class="built_in">set</span> may just be empty <span class="keyword">if</span> this is the first synchronization.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 2) if slave-serve-stale data is set to 'no' the slave will reply with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   an error <span class="string">"SYNC with master in progress"</span> to all the kind of commands</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   but to INFO and SLAVEOF.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">slave-serve-stale-data <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Slaves send PINGs to server <span class="keyword">in</span> a predefined interval. It<span class="string">'s possible to change</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">this interval with the repl_ping_slave_period option. The default value is 10</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">seconds.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># repl-ping-slave-period 10</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The following option sets a timeout for both Bulk transfer I/O timeout and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">master data or ping response timeout. The default value is 60 seconds.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is important to make sure that this value is greater than the value</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">specified for repl-ping-slave-period otherwise a timeout will be detected</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">every time there is low traffic between the master and the slave.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># repl-timeout 60</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################# SECURITY ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Warning: since Redis is pretty fast an outside user can try up to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">150k passwords per second against a good box. This means that you should</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use a very strong password otherwise it will be very easy to break.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">requirepass foobared</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Command renaming.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is possilbe to change the name of dangerous commands in a shared</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">environment. For instance the CONFIG command may be renamed into something</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of hard to guess so that it will be still available for internal-use</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">tools but not available for general clients.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Example:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is also possilbe to completely kill a command renaming it into</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">an empty string:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># rename-command CONFIG ""</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################## LIMITS ####################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">maxclients 128</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Don'</span>t use more memory than the specified amount of bytes.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When the memory <span class="built_in">limit</span> is reached Redis will try to remove keys with an</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EXPIRE <span class="built_in">set</span>. It will try to start freeing keys that are going to expire</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> little time and preserve keys with a longer time to live.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis will also try to remove objects from free lists <span class="keyword">if</span> possible.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If all this fails, Redis will start to reply with errors to commands</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that will use more memory, like SET, LPUSH, and so on, and will <span class="built_in">continue</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to reply to most read-only commands like GET.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">'state'</span> server or cache, not as a real DB. When Redis is used as a real</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">database the memory usage will grow over the weeks, it will be obvious <span class="keyword">if</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it is going to use too much memory <span class="keyword">in</span> the long run, and you<span class="string">'ll have the time</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to upgrade. With maxmemory after the limit is reached you'</span>ll start to get</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">errors <span class="keyword">for</span> write operations, and this may even lead to DB inconsistency.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAXMEMORY POLICY: how Redis will <span class="keyword">select</span> what to remove when maxmemory</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is reached? You can <span class="keyword">select</span> among five behavior:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">volatile-random -&gt; remove a random key with an expire <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allkeys-&gt;random -&gt; remove a random key, any key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">noeviction -&gt; don<span class="string">'t expire at all, just return an error on write operations</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Note: with all the kind of policies, Redis will return an error on write</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      operations, when there are not suitable keys for eviction.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash">#       At the date of writing this commands are: set setnx setex append</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      getset mset msetnx exec sort</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># The default is:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># maxmemory-policy volatile-lru</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">LRU and minimal TTL algorithms are not precise algorithms but approximated</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">algorithms (in order to save memory), so you can select as well the sample</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">size to check. For instance for default Redis will check three keys and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">pick the one that was used less recently, you can change the sample size</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">using the following configuration directive.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># maxmemory-samples 3</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">############################# APPEND ONLY MODE ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Note that you can have both the async dumps and the append only file if you</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">like (you have to comment the "save" statements above to disable the dumps).</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Still if append only mode is enabled Redis will load the data from the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">log file at startup ignoring the dump.rdb file.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">log file in background when it gets too big.</span></span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定更新日志文件名，默认为appendonly.aof</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">appendfilename appendonly.aof</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The fsync() call tells the Operating System to actually write data on disk</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">instead to wait for more data in the output buffer. Some OS will really flush</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">data on disk, some other OS will just try to do it ASAP.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定更新日志条件，共有3个可选值：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">no:表示等操作系统进行数据缓存同步到磁盘（快）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">everysec:表示每秒同步一次（折衷，默认值）</span></span></span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">appendfsync no</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">When the AOF fsync policy is set to always or everysec, and a background</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">saving process (a background save or AOF log background rewriting) is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">performing a lot of I/O against the disk, in some Linux configurations</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Redis may block too long on the fsync() call. Note that there is no fix for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">this currently, as even performing fsync in a different thread will block</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">our synchronous write(2) call.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># In order to mitigate this problem it'</span>s possible to use the following option</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that will prevent fsync() from being called <span class="keyword">in</span> the main process <span class="keyword">while</span> a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BGSAVE or BGREWRITEAOF is <span class="keyword">in</span> progress.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This means that while another child is saving the durability of Redis is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the same as <span class="string">"appendfsync none"</span>, that <span class="keyword">in</span> pratical terms means that it is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">possible to lost up to 30 seconds of <span class="built_in">log</span> <span class="keyword">in</span> the worst scenario (with the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default Linux settings).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If you have latency problems turn this to "yes". Otherwise leave it as</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">"no"</span> that is the safest pick from the point of view of durability.</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis is able to automatically rewrite the <span class="built_in">log</span> file implicitly calling</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BGREWRITEAOF when the AOF <span class="built_in">log</span> size will growth by the specified percentage.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">latest rewrite (or <span class="keyword">if</span> no rewrite happened since the restart, the size of</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the AOF at startup is used).</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This base size is compared to the current size. If the current size is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">you need to specify a minimal size <span class="keyword">for</span> the AOF file to be rewritten, this</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is useful to avoid rewriting the AOF file even <span class="keyword">if</span> the percentage increase</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is reached but it is still pretty small.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Specify a precentage of zero in order to disable the automatic AOF</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################# SLOW LOG ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The Redis Slow Log is a system to <span class="built_in">log</span> queries that exceeded a specified</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">but just the time needed to actually execute the <span class="built_in">command</span> (this is the only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stage of <span class="built_in">command</span> execution <span class="built_in">where</span> the thread is blocked and can not serve</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">other requests <span class="keyword">in</span> the meantime).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">what is the execution time, <span class="keyword">in</span> microseconds, to exceed <span class="keyword">in</span> order <span class="keyword">for</span> the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slow <span class="built_in">log</span>. When a new <span class="built_in">command</span> is logged the oldest one is removed from the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">queue of logged commands.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following time is expressed <span class="keyword">in</span> microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to one second. Note that a negative number disables the slow <span class="built_in">log</span>, <span class="keyword">while</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a value of zero forces the logging of every <span class="built_in">command</span>.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">There is no <span class="built_in">limit</span> to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can reclaim memory used by the slow <span class="built_in">log</span> with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 1024</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################### VIRTUAL MEMORY ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## WARNING! Virtual Memory is deprecated in Redis 2.4</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The use of Virtual Memory is strongly discouraged.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## WARNING! Virtual Memory is deprecated in Redis 2.4</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The use of Virtual Memory is strongly discouraged.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Virtual Memory allows Redis to work with datasets bigger than the actual</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">amount of RAM needed to hold the whole dataset <span class="keyword">in</span> memory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">In order to <span class="keyword">do</span> so very used keys are taken <span class="keyword">in</span> memory <span class="keyword">while</span> the other keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">are swapped into a swap file, similarly to what operating systems <span class="keyword">do</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with memory pages.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定是否启用虚拟内存机制，默认值为no，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把vm-enabled设置为<span class="built_in">yes</span>，根据需要设置好接下来的三个VM参数，就可以启动VM了</span></span><br><span class="line">vm-enabled no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vm-enabled <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the path of the Redis swap file. As you can guess, swap files</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">can<span class="string">'t be shared by different Redis instances, so make sure to use a swap</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">file for every redis process you are running. Redis will complain if the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">swap file is already in use.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Redis交换文件最好的存储是SSD（固态硬盘）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">*** WARNING *** if you are using a shared hosting the default of putting</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">the swap file under /tmp is not secure. Create a dir with access granted</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">only to Redis user and configure Redis to create the swap file there.</span></span></span><br><span class="line">vm-swap-file /tmp/redis.swap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">With vm-max-memory 0 the system will swap everything it can. Not a good</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">default, just specify the max amount of RAM you can in bytes, but it'</span>s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">better to leave some margin. For instance specify an amount of RAM</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that<span class="string">'s more or less between 60 and 80% of your free RAM.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</span></span></span><br><span class="line">vm-max-memory 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</span></span></span><br><span class="line">vm-page-size 32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">swap空间总容量为 vm-page-size * vm-pages</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># With the default of 32-bytes memory pages and 134217728 pages Redis will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use a 4 GB swap file, that will use 16 MB of RAM for the page table.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It'</span>s better to use the smallest acceptable value <span class="keyword">for</span> your application,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">but the default is large <span class="keyword">in</span> order to work <span class="keyword">in</span> most conditions.</span></span><br><span class="line">vm-pages 134217728</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Max number of VM I/O threads running at the same time.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This threads are used to <span class="built_in">read</span>/write data from/to swap file, since they</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">also encode and decode objects from disk to memory or the reverse, a bigger</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">number of threads can <span class="built_in">help</span> with big objects even <span class="keyword">if</span> they can<span class="string">'t help with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">I/O itself as the physical device may not be able to couple with many</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">reads/writes operations at the same time.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</span></span></span><br><span class="line">vm-max-threads 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">############################## ADVANCED CONFIG ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Hashes are encoded in a special way (much more memory efficient) when they</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">have at max a given numer of elements, and the biggest element does not</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">exceed a given threshold. You can configure this limits with the following</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">configuration directives.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></span></span><br><span class="line">hash-max-zipmap-entries 512</span><br><span class="line">hash-max-zipmap-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Similarly to hashes, small lists are also encoded in a special way in order</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to save a lot of space. The special representation is only used when</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">you are under the following limits:</span></span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Sets have a special encoding in just one case: when a set is composed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of just strings that happens to be integers in radix 10 in the range</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of 64 bit signed integers.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The following configuration setting sets the limit in the size of the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set in order to use this special memory saving encoding.</span></span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Similarly to hashes and lists, sorted sets are also specially encoded in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">order to save a lot of space. This encoding is only used when the length and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">elements of a sorted set are below the following limits:</span></span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">order to help rehashing the main Redis hash table (the one mapping top-level</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">keys to values). The hash table implementation redis uses (see dict.c)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">performs a lazy rehashing: the more operation you run into an hash table</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">that is rhashing, the more rehashing "steps" are performed, so if the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">server is idle the rehashing is never complete and some more memory is used</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">by the hash table.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># The default is to use this millisecond 10 times every second in order to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">active rehashing the main dictionaries, freeing memory when possible.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># If unsure:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use "activerehashing no" if you have hard latency requirements and it is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">not a good thing in your environment that Redis can reply form time to time</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to queries with 2 milliseconds delay.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定是否激活重置哈希，默认为开启</span></span></span><br><span class="line">activerehashing yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################# INCLUDES ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">include /path/to/local.conf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">include /path/to/other.conf</span></span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Java I/O</title>
    <url>/7145cd83ec33/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li><strong>磁盘操作：</strong> File</li>
<li><strong> 字节操作：</strong> InputStream 和 OutputStream</li>
<li><strong> 字符操作：</strong> Reader 和 Writer</li>
<li><strong> 对象操作：</strong> Serializable</li>
<li><strong> 网络操作：</strong> Socket</li>
<li><strong> 新的输入 / 输出：</strong> NIO</li>
</ul>
<span id="more"></span>
<h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容<br>从 Java7 开始，可以使用 ** Paths** 和 <strong>Files</strong> 代替 File</p>
<h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><p><strong><em>实现文件复制：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line">    </span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = in.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) {</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><em>装饰者模式：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ab0b0b452df8594befa39d53f6fbf128.png" alt="image.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></tbody></table></figure>
<h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><h2 id="1-编码-与-解码"><a href="#1-编码-与-解码" class="headerlink" title="1. 编码 与 解码"></a>1. 编码 与 解码</h2><p><strong><em>概述：</em></strong> 编码就是把字符转换为字节，而解码是把字节重新组合成字符<br><strong><em>乱码：</em></strong> 如果编码和解码过程使用不同的编码方式那么就出现了乱码</p>
<h2 id="2-String-的编码方式"><a href="#2-String-的编码方式" class="headerlink" title="2. String 的编码方式"></a>2. String 的编码方式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"中文"</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-Reader-与-Writer"><a href="#3-Reader-与-Writer" class="headerlink" title="3. Reader 与 Writer"></a>3. Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li><strong>InputStreamReader</strong> 实现从字节流解码成字符流；</li>
<li><strong>OutputStreamWriter</strong> 实现字符流编码成为字节流。</li>
</ul>
<p><strong><em>实现逐行输出文本文件的内容：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><h2 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1. Serializable"></a>1. Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常</p>
<h2 id="2-transient"><a href="#2-transient" class="headerlink" title="2. transient"></a>2. transient</h2><p>transient 关键字可以使一些属性不会被序列化</p>
<h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持</p>
<ul>
<li><strong>InetAddress：</strong> 用于表示网络上的硬件资源，即 IP 地址</li>
<li><strong> URL：</strong> 统一资源定位符</li>
<li><strong> Sockets：</strong> 使用 TCP 协议实现网络通信</li>
<li><strong> Datagram：</strong> 使用 UDP 协议实现网络通信</li>
</ul>
<h2 id="1-InetAddress"><a href="#1-InetAddress" class="headerlink" title="1. InetAddress"></a>1. InetAddress</h2><p><strong><em>创建：</em></strong> 没有公有的构造函数，只能通过静态方法来创建实例</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="type">byte</span>[] address);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h2><p>可以直接从 URL 中读取字节流数据</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) {</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-Sockets"><a href="#3-Sockets" class="headerlink" title="3. Sockets"></a>3. Sockets</h2><ul>
<li><strong>ServerSocket：</strong> 服务器端类</li>
<li><strong> Socket：</strong> 客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b76a160e0789333425e1f91d52f175eb.png" alt="image.png"></p>
<h2 id="4-Datagram"><a href="#4-Datagram" class="headerlink" title="4. Datagram"></a>4. Datagram</h2><ul>
<li><strong>DatagramSocket：</strong> 通信类</li>
<li><strong> DatagramPacket：</strong> 数据包类</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>I/O</category>
      </categories>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/f8044fb7915e/</url>
    <content><![CDATA[<h1 id="一、流与块"><a href="#一、流与块" class="headerlink" title="一、流与块"></a>一、流与块</h1><p><strong><em>NIO 与 IO 主要区别：</em></strong> I/O 与 NIO 最重要的区别是 ** 数据打包 ** 和 ** 传输 ** 的方式。NIO 是 ** 非阻塞 ** 的。<br>I/O 以 ** 流 ** 的方式处理数据<br>NIO 以 ** 块 ** 的方式处理数据</p>
<h2 id="1-IO-特点"><a href="#1-IO-特点" class="headerlink" title="1. IO 特点"></a>1. IO 特点</h2><ol>
<li><strong>一次处理一个字节数据：</strong>一个输入流产生一个字节数据，一个输出流消费一个字节数据</li>
<li><strong>创建过滤器非常容易</strong>，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分</li>
<li><strong>速度慢</strong></li>
</ol>
<h2 id="2-NIO-特点"><a href="#2-NIO-特点" class="headerlink" title="2. NIO 特点"></a>2. NIO 特点</h2><ol>
<li><strong>一次处理一个数据块</strong></li>
<li><strong>速度快</strong></li>
<li>面向块的 I/O ** 缺少 ** 一些面向流的 I/O 所具有的 <strong>优雅性和简单性</strong></li>
</ol>
<p><strong><span id="more"></span></strong></p>
<h1 id="二、通道与缓冲区"><a href="#二、通道与缓冲区" class="headerlink" title="二、通道与缓冲区"></a>二、通道与缓冲区</h1><h2 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h2><p><strong><em>概念：</em></strong> 通道 Channel 是对原 I/O 包中的 <strong>流的模拟</strong>，可以通过它读取和写入数据。<br><strong><em>通道 与 流 的区别：</em></strong></p>
<ul>
<li>流只能在 ** 一个方向上 ** 移动（一个流必须是 InputStream 或者 OutputStream 的子类）</li>
<li>通道是 <strong>双向的</strong>，可以用于读、写或者 <strong>同时用于读写</strong></li>
</ul>
<p><strong><em>类型：</em></strong></p>
<ul>
<li><strong>FileChannel：</strong> 从 ** 文件 ** 中读写数据</li>
<li><strong> DatagramChannel：</strong> 通过 <strong>UDP</strong> 读写网络中数据</li>
<li><strong> SocketChannel：</strong> 通过 <strong>TCP</strong> 读写网络中数据</li>
<li><strong> ServerSocketChannel：</strong> 可以 <strong>监听新进来的 TCP 连接</strong>，对每一个新进来的连接都会创建一个 SocketChannel</li>
</ul>
<h2 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h2><p><strong><em>概念：</em></strong> 不会直接对通道进行读写数据，要 <strong>先经过缓冲区</strong>。<br>发送给一个通道的所有数据都必须首先放到缓冲区中。<br>同样地，从通道中读取的任何数据都要先读到缓冲区中。<br><strong><em>原理：</em></strong> 缓冲区实质上是一个 <strong>数组</strong>，但它不仅仅是一个数组。<br><strong><em>作用：</em></strong> 缓冲区提供了 <strong>对数据的结构化访问</strong>，而且还可以 <strong>跟踪系统的读 / 写进程</strong>。<br><strong><em>类型：</em></strong></p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h3 id="2-1-缓冲区状态变量"><a href="#2-1-缓冲区状态变量" class="headerlink" title="2.1. 缓冲区状态变量"></a>2.1. 缓冲区状态变量</h3><ul>
<li><strong>capacity：</strong> 最大容量</li>
<li><strong> position：</strong> 当前已经读写的字节数</li>
<li><strong> limit：</strong> 可读写的容量限制（写入时为最大容量大小，读取时为当前数据大小）</li>
</ul>
<p><strong><em>状态变量的改变过程例子：</em></strong></p>
<ol>
<li>新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/af98fd402b47216cb4b34b8ab718282e.png" alt="image.png"></p>
<ol start="2">
<li>从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/72b5571ba6ed6fc4a557d256f3a7f0e1.png" alt="image.png"></p>
<ol start="3">
<li>在将缓冲区的数据写到输出通道之前，需要先调用 flip () 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/aac689067eabb2fa1d2714e90a0bf146.png" alt="image.png"></p>
<ol start="4">
<li>从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c27d2c139b23340fd81af13fbdfe96e4.png" alt="image.png"></p>
<ol start="5">
<li>最后需要调用 clear () 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/56b4a3574a4306129eb3f153c3f87f97.png" alt="image.png"></p>
<h2 id="3-文件-NIO-实例"><a href="#3-文件-NIO-实例" class="headerlink" title="3. 文件 NIO 实例"></a>3. 文件 NIO 实例</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcin</span> <span class="operator">=</span> fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的文件通道 */</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fcout</span> <span class="operator">=</span> fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="三、选择器"><a href="#三、选择器" class="headerlink" title="三、选择器"></a>三、选择器</h1><p><strong><em>非阻塞 IO：</em></strong> NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。<br><strong><em>Selector 监听实现多路复用：</em></strong></p>
<ol>
<li>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去 <strong>监听多个通道</strong> Channel 上的事件，从而让一个线程就可以处理多个事件。</li>
<li>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，Selector 就 ** 不会进入阻塞状态 ** 一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</li>
</ol>
<p><strong><em>良好性能：</em></strong> 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。<br><strong><em>注意：</em></strong> 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/58f75a853576584d67af9c9b6bcf4313.png" alt="image.png"></p>
<h2 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h2><p><code>Selector selector = Selector.open();</code></p>
<h2 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></tbody></table></figure>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰<br><strong><em>指定要注册的具体事件类型：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h2><p><code>int num = selector.select();</code><br>使用 select () 来监听到达的事件，它会一直阻塞直到有至少一个事件到达</p>
<h2 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) {</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h2><p>因为一次 select () 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) {</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-套接字-NIO-实例"><a href="#6-套接字-NIO-实例" class="headerlink" title="6. 套接字 NIO 实例"></a>6. 套接字 NIO 实例</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ssChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) {</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line"></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line"></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">            <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit; i++) {</span><br><span class="line">                dst[i] = (<span class="type">char</span>) buffer.get(i);</span><br><span class="line">            }</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="四、内存映射文件"><a href="#四、内存映射文件" class="headerlink" title="四、内存映射文件"></a>四、内存映射文件</h1><p><strong><em>概念：</em></strong> 内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。<br>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。<br>下面代码行将文件的前 1024 个字节映射到内存中，map () 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。<br><code>MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);</code></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>I/O</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土⑧：常用命令</title>
    <url>/b4ce99d25d0d/</url>
    <content><![CDATA[<h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><h2 id="1-redis-cli"><a href="#1-redis-cli" class="headerlink" title="1. redis-cli"></a>1. redis-cli</h2><p>执行命令<br><strong><em>例：</em></strong><br>远程 redis 服务上执行命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-ping"><a href="#2-ping" class="headerlink" title="2. ping"></a>2. ping</h2><p>该命令用于检测 redis 服务是否启动<br><strong><em>例：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PING</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h1 id="二、Redis-键"><a href="#二、Redis-键" class="headerlink" title="二、Redis 键"></a>二、Redis 键</h1><h2 id="1-增删查改"><a href="#1-增删查改" class="headerlink" title="1. 增删查改"></a>1. 增删查改</h2><p><strong>1.1. set key value</strong><br>赋值</p>
<ul>
<li>setnx key value：key 不存在时设置</li>
<li> set key value xx：key 存在时才设置</li>
</ul>
<p><strong>1.2. get key</strong><br>取值<br><strong>1.3. del key [key…..]</strong><br>可以删除一个或多个键，返回值是删除的键的个数，不支持通配符删除<br><strong>1.4. mget key1 key2 key3</strong><br>批量获取 key，原子操作<br>取不到的 key 返回 null<br><strong>1.5. mset key1 value1 key2 value2</strong><br>批量设置 key-value<br><strong>1.6. getset key newvalue</strong><br>设值后返回旧值<br><strong>1.7. append key value</strong><br>追加值</p>
<h2 id="2-key-信息"><a href="#2-key-信息" class="headerlink" title="2. key 信息"></a>2. key 信息</h2><p><strong>2.1. keys</strong></p>
<ul>
<li>? 匹配一个字符</li>
<li><ul>
<li>匹配任意个（包括 0 个）字符</li>
</ul>
</li>
<li> [] 匹配括号间的任一个字符，可以使用 “-“ 符号表示一个范围，如 a [b-d] 可以匹配 “ab”,”ac”,”ad”</li>
<li>\x 匹配字符 x，用于转义符号，如果要匹配 “?” 就需要使用？</li>
</ul>
<p>注： 一般不在生产环境中使用<br><strong>2.2. dbsize</strong><br>计算 key 的总数<br><strong>2.3. exists key</strong><br>如果存在，返回整数类型 1 ，否则返回 0<br><strong>2.4. type key</strong><br>获得键值的数据类型<br>返回值可能是 string (字符串类型) hash (散列类型) list (列表类型) set (集合类型) zset (有序集合类型)</p>
<h2 id="3-自增-自减"><a href="#3-自增-自减" class="headerlink" title="3. 自增/自减"></a>3. 自增 / 自减</h2><p><strong>3.1. incr key</strong><br>当存储的字符串是整数形式时，redis 提供了一个使用的命令 incr 作用是让当前的键值递增，并返回递增后的值<br>当要操作的键不存在时会默认键值为 0 ，所以第一次递增后的结果是 1 ，当键值不是整数时 redis 会提示错误<br><strong>3.2. incrby key increment</strong><br>通过 increment 参数指定一次增加的数值<br>incrby num 2<br><strong>3.3. decr key</strong><br>自减<br>同 incr key<br><strong>3.4. decrby key</strong><br>自减<br>同 incrby key increment</p>
<h2 id="4-过期时间"><a href="#4-过期时间" class="headerlink" title="4. 过期时间"></a>4. 过期时间</h2><p><strong>4.1. expire key seconds</strong><br>设置过期时间<br><strong>4.2. ttl key</strong><br>查询 key 的剩余过期时间<br>-2： 不存在 key<br>-1： 未设置过期时间<br><strong>4.3. persist key</strong><br>去掉 key 的过期时间</p>
<h2 id="5-hash"><a href="#5-hash" class="headerlink" title="5. hash"></a>5. hash</h2><p><strong>5.1. hset key field value</strong><br>设置 hash key 对应 的 field 的 value<br><strong>5.2. hget key field</strong><br>获取 hash key 对应 的 field 的 value<br><strong>5.3. hdel key field</strong><br>删除 hash key 对应 的 field 的 value<br><strong>5.4. hexists key field</strong><br>判断 hash key 是否有 field<br><strong>5.5. hlen key</strong><br>获取 hash key field 的数量<br><strong>5.6. hgetall key</strong><br>获取 hash key 所有的 field 和 value<br><strong>5.7. hkeys key</strong><br>获取 hash key 所有的 field<br><strong>5.8. hvals key</strong><br>获取 hash key 所有的 field 中的 value</p>
<h2 id="6-list"><a href="#6-list" class="headerlink" title="6. list"></a>6. list</h2><p><strong>6.1. 插入</strong></p>
<ul>
<li><strong>rpush key value1 value2 value3：</strong> 列表右端插入多个值</li>
<li><strong> lpush key value1 value2 value3：</strong> 列表左端插入多个值</li>
<li><strong> linsert key before|after value newValue：</strong> 在键为 key 的 list 的指定值 value 的 前 | 后 插入 newValue</li>
</ul>
<p><strong>6.2. 删除</strong></p>
<ul>
<li><strong>lpop key：</strong> 从列表左侧弹出一个元素</li>
<li><strong> rpop key：</strong> 从列表右侧弹出一个元素</li>
<li><strong> lrem key count value：</strong> 删除 count 个与 value 的值相等的值<ul>
<li> count &gt; 0： 从左到右删除 count 个与 value 的值相等的值</li>
<li> count &lt; 0： 从右到左删除 count 个与 value 的值相等的值</li>
<li> count = 0： 删除所有与 value 的值相等的值</li>
</ul>
</li>
<li><strong> ltrim key start end：</strong> 按索引截取 [start, end] 范围内的值，范围外的值删除。索引从 0 开始</li>
</ul>
<p><strong>6.3. 查找</strong></p>
<ul>
<li><strong>lrange key start end：</strong> 获取索引在 [start, end] 范围内的值。左边索引从 0 开始递增，右边索引从 -1 开始递减</li>
<li><strong> lindex key index：</strong> 按索引获取值。左边索引从 0 开始递增，右边索引从 -1 开始递减</li>
<li><strong> llen：</strong> 获取列表长度</li>
</ul>
<p><strong>6.4. 更新</strong></p>
<ul>
<li><strong>lset key index newValue：</strong> 设置列表指定索引值为 newValue</li>
</ul>
<h2 id="7-set"><a href="#7-set" class="headerlink" title="7. set"></a>7. set</h2><p><strong>7.1. 添加</strong></p>
<ul>
<li><strong>sadd key element：</strong> 添加 element（若已存在，则添加失败）</li>
</ul>
<p><strong>7.2. 删除</strong></p>
<ul>
<li><strong>spop key：</strong> 随机弹出一个元素</li>
<li><strong> srem key element：</strong> 删除 element</li>
</ul>
<p><strong>7.3. 查找</strong></p>
<ul>
<li><strong>scard key：</strong> 获取元素总数</li>
<li><strong> sismember key element：</strong> 判断键为 key 的 set 中是否存在 element</li>
<li><strong>srandmember key count：</strong> 从键为 key 的 set 中随机选出 count 个元素</li>
<li><strong> smembers key：</strong> 获取键为 key 的 set 的全部元素（无序）</li>
</ul>
<p><strong>7.4. 差集、交集、并集</strong></p>
<ul>
<li><strong>sdiff key1 key2：</strong> 求得键为 key1 、key2 的两个 set 的差集（key1 - key2）</li>
<li><strong>sinter key1 key2：</strong> 求得键为 key1、key2 的两个 set 的交集</li>
<li><strong> sunion key1 key2：</strong> 求得键为 key1、key2 的两个 set 的并集</li>
</ul>
<h2 id="8-zset"><a href="#8-zset" class="headerlink" title="8. zset"></a>8. zset</h2><p><strong>8.1. 添加</strong></p>
<ul>
<li><strong>zadd key score element：</strong> 添加 score 和 element（可以多对）</li>
<li><strong>zincrby key increScore element：</strong> 使 element 的分数增加 increScore</li>
</ul>
<p><strong>8.2. 删除</strong></p>
<ul>
<li><strong>zrem key element：</strong> 删除 element</li>
<li><strong>zremrangebyrank key startRank endRank：</strong> 删除排名在 [startRank, endRank] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li>
<li><strong>zremrangebyscore key startScore endScore：</strong> 删除分数在 [startScore, endScore] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li>
</ul>
<p><strong>8.3. 查询</strong></p>
<ul>
<li><strong>zcard key：</strong> 获取元素总数</li>
<li><strong> zount key startScore endScore：</strong> 获取分数在 [startScore, endScore] 范围内的元素个数，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li>
<li><strong>zrank key element：</strong> 获取 element 的排名（升序）</li>
<li><strong>zscore key element：</strong> 获取 element 的分数</li>
<li><strong> zrange key startRank endRank [withscores]：</strong> 获取排名在 [startRank, endRank] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。<ul>
<li>withscores：携带分数</li>
</ul>
</li>
<li> **zrangebyscore key startScore endScore [withscores]： ** 获取分数在 [startScore, endScore] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。<ul>
<li>withscores：携带分数</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://redis.io/commands">commands</a></li>
<li><a href="https://www.cnblogs.com/kevinws/p/6281395.html">Redis 常用命令整理</a></li>
<li><a href="http://doc.redisfans.com/?tdsourcetag=s_pctim_aiomsg#redis">Redis 命令参考</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ③：Synchronized</title>
    <url>/fb02556d0484/</url>
    <content><![CDATA[<p>synchronized 发生异常会释放锁<br>不能拿 String、Integer、Long 等基础类型做锁<br>synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。但是同步块里的非原子操作依旧可能发生指令重排</p>
<span id="more"></span>
<h2 id="1-notify"><a href="#1-notify" class="headerlink" title="1. notify"></a>1. notify</h2><ul>
<li>wait ()：令当前资源挂起并放弃 CPU、同步资源，不再抢资源，除非唤醒</li>
<li> notify ()：当其他线程的运行使得这个条件满足时，其它线程会调用 notify () 唤醒正在排队等待同步资源的下城中优先级最高者结束等待</li>
<li> notifyAll ()：当其他线程的运行使得这个条件满足时，其它线程会调用 notifyAll () 唤醒正在排队等待资源的所有线程结束等待<br>这三个方法只有在 synchrozied 方法或 synchrozied 代码块中才能使用</li>
</ul>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p><strong>同步方法：</strong>锁为当前对象，即 this，所以不能用在继承方法的线程上</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; amount) {</span><br><span class="line">            wait();</span><br><span class="line">        }</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>同步阻塞：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Window2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 锁（同步监视器）</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 所有线程必须共用同一把锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="comment">// 若是静态方法可用当前类.class</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (InterrupteException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(...);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-用户态与内核态"><a href="#3-用户态与内核态" class="headerlink" title="3. 用户态与内核态"></a>3. 用户态与内核态</h2><p>synchronized 加锁需要程序由用户态切换到内核态，效率低</p>
<p>Intel x86 架构的 CPU 来说一共有 0~3 四个特权级，0 级最高，3 级最低。</p>
<p>硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查。相关的概念有 CPL、DPL 和 RPL。</p>
<p>Linux 中当程序运行在 3 级特权级上时称之运行在用户态，运行在 0 级特权级上时称之运行在内核态。</p>
<p>用户态通过申请外部资源（申请堆内存、读写磁盘文件。。。）切换至内核态</p>
<p><strong>用户态切换到内核态的 3 种方式：</strong></p>
<ul>
<li>系统调用</li>
<li>中断</li>
<li>异常</li>
</ul>
<p><strong>具体的切换操作：</strong> 以 open 函数调用为例<br>open 函数调用时，会通过中断陷入内核，从而调用 sys_open 函数。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fe6975c6c94589bcdde8d46b8a9dc29f.png"></p>
<ol>
<li><strong>系统调用触发 0x80 中断：</strong> 并且将系统调用号存储在 eax 寄存器中，然后陷入内核，内核开始执行中断处理程序，在系统调用表中查找系统调用号对应的系统内核函数并且调用，执行完成后又将返回值通过 eax 寄存器返回给用户空间 </li>
<li><strong>中断机制：</strong> 中断处理程序（内核 ）<br>计算机处于执行期间，系统内发生了非寻常或非预期的急需处理事件，CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，处理完毕后返回原来被中断处继续执行 <blockquote>
<p>处理中断源的程序称为中断处理程序。中断的实现由软件和硬件综合完成，硬件部分叫做硬件装置，软件部分称为软件处理程序。</p>
</blockquote>
</li>
</ol>
<h2 id="4-锁升级"><a href="#4-锁升级" class="headerlink" title="4. 锁升级"></a>4. 锁升级</h2><p>对象头 markword 记录了<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d325ec9b4034693a353bc34160b7c15f.png"></p>
<p><strong>锁升级步骤：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9b99a7fd2e54ea4e9acd1e9898459c97.png"></p>
<h3 id="4-1-偏向锁"><a href="#4-1-偏向锁" class="headerlink" title="4.1. 偏向锁"></a>4.1. 偏向锁</h3><p>偏向锁假定将来只有第一个申请锁的线程会使用锁。因此，只需要在 Markword 中 CAS 记录 当前线程指针，如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁。</p>
<p>以后当前线程记录的这个线程就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</p>
<p><strong>源码：</strong> fast_enter 方法中在 safepoint 的时候上锁，失败则调用 slow_enter 方法升级为自旋锁。</p>
<blockquote>
<p>在明确知道会有多个线程竞争的情况下，偏向锁会涉及锁撤销，比自旋锁效率低，所以这时不会启用偏向锁</p>
<p>例如：JVM 启动过程会有很多线程竞争，所以默认情况启动时不打开偏向锁，过一段时间才会打开</p>
<p>-XX:BiasedLockingStartupDelay=4（默认 4 秒），刚开始未偏向任何一个线程，所以称为匿名偏向</p>
</blockquote>
<h3 id="4-2-自旋锁"><a href="#4-2-自旋锁" class="headerlink" title="4.2. 自旋锁"></a>4.2. 自旋锁</h3><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步。详情查看<a href="https://www.yuque.com/ccomma/rzm7ab/pb3cim#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a>。</p>
<p><strong>原理：</strong><br>每个线程在其线程栈内部生成一个 LockRecord，拿到锁后记录在 markword 中。即演化为多个 LockRecord 使用 CAS 竞争写入 markword 的场景。</p>
<p>对应 slow_enter 方法，首先进入自旋，自旋锁不行则调用 inflate 方法膨胀为重量级锁。</p>
<p><strong>升级：</strong></p>
<ul>
<li>1.6 之前，有线程超过 10 次自旋（-XX:PreBlockSpin），或者自旋线程数超过 CPU 核数的一半。则升级为重量级锁。</li>
<li>1.6 之后，加入自适应自旋 Adapative Self Spinning，由 JVM 自己控制何时升级成重量级锁。</li>
</ul>
<h3 id="4-3-重量级锁"><a href="#4-3-重量级锁" class="headerlink" title="4.3. 重量级锁"></a>4.3. 重量级锁</h3><p>synchronized 编译为字节码后代码由 <code>monitorenter</code> 和 <code>monitorexit</code> 包围，表示上锁和释放锁。</p>
<p>synchronized 加锁需要程序由用户态切换到内核态，效率低。</p>
<p>内核态 ObjectMonitor 对象中有 WaitSet 队列，抢锁的线程都会进入等待队列，不需要消耗 CPU 资源，由操作系统进程调度</p>
<h3 id="4-4-可重入锁"><a href="#4-4-可重入锁" class="headerlink" title="4.4. 可重入锁"></a>4.4. 可重入锁</h3><p>重入次数必须记录，因为加锁次数必须和解锁次数对应</p>
<ul>
<li>偏向锁 / 自旋锁：记录在线程栈中，每重入一次，LockRecord + 1。LockRecord 指向备份的 markword（displace head），里面记录了 HashCode，重入的 LockRecord 指向 null</li>
<li> 重量级锁：记录在 ObjectMonitor 一个字段上</li>
</ul>
<h2 id="5-锁优化"><a href="#5-锁优化" class="headerlink" title="5. 锁优化"></a>5. 锁优化</h2><h3 id="5-1-锁消除"><a href="#5-1-锁消除" class="headerlink" title="5.1. 锁消除"></a>5.1. 锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除</p>
<p><strong>如下 concatString 方法：</strong></p>
<p>每个 append () 方法中都有一个 synchronized 同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString () 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString () 方法之外，其他线程无法访问到它，因此可以进行消除</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>原理：</strong> 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除</p>
<h3 id="5-2-锁粗化"><a href="#5-2-锁粗化" class="headerlink" title="5.2. 锁粗化"></a>5.2. 锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗</p>
<p>虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，则会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<h2 id="6-Monitor"><a href="#6-Monitor" class="headerlink" title="6. Monitor"></a>6. Monitor</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/de3169fd89ed9876967ad2791a46716c.png"></p>
<ol>
<li>Monitor 是一种用来实现同步的工具 </li>
<li>与每个 java 对象相关联，所有的 Java 对象是天生携带 monitor </li>
<li>Monitor 是实现 Sychronized（内置锁）的基础 </li>
<li>Monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现 </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ObjectMonitor() {</span><br><span class="line">    <span class="comment">// 用来记录该对象被线程获取锁的次数</span></span><br><span class="line">    _count        = <span class="number">0</span>; </span><br><span class="line">    _waiters      = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 锁的重入次数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 指向持有 ObjectMonitor 对象的线程 </span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; </span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ②：线程池</title>
    <url>/b9fa8c7b4232/</url>
    <content><![CDATA[<h2 id="1-ThreadPoolExecutor"><a href="#1-ThreadPoolExecutor" class="headerlink" title="1. ThreadPoolExecutor"></a>1. ThreadPoolExecutor</h2><p>线程数计算公式： 线程数 = CPU 核数 * 期望 CPU 使用率 0~1_ *_（1 + 等待时间 / 计算时间）</p>
<h3 id="1-1-七大参数"><a href="#1-1-七大参数" class="headerlink" title="1.1. 七大参数"></a>1.1. 七大参数</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">60</span>, TimeUnit.SECONDS, </span><br><span class="line">                                                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), </span><br><span class="line">                                                Executors.defaultThreadFactory(),</span><br><span class="line">                                                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>corePoolSize：核心线程数。保留在线程池中的线程数，即使它们处于空闲状态，除非设置了 <code>allowCoreThreadTimeOut</code>。</li>
<li>maximumPoolSize：最大线程数。线程池中允许的最大线程数，在阻塞队列满了之后加入的任务会创建非核心线程进行处理。</li>
<li>keepAliveTime：当线程数大于 <code>corePoolSize</code> 时，非核心线程在终止之前等待新任务的最大时间。</li>
<li>unit：<code>keepAliveTime</code> 参数的时间单位。</li>
<li>workQueue：阻塞队列。在执行任务之前用于保存任务的队列。 这个队列将只保存 <code>execute</code> 方法提交的 <code>Runnable</code> 任务。提交的线程后若发现线程总数超过 <code>corePoolSize</code> 但是不超过 <code>keepAliveTime</code> 的情况下。</li>
<li>threadFactory：用来执行的时候创建线程的线程工厂，可用于线程命名。</li>
<li>handler：在执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量。 <ul>
<li>AbortPolicy：直接抛出异常，这是默认策略。</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务。</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务。</li>
<li>DiscardPolicy：直接丢弃任务。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>随着任务不断增加</p>
<ol>
<li>如果核心线程还没创建： 创建并执行任务。核心线程不会被销毁，会一直存在。</li>
<li>如果所有的核心线程都在执行任务： 把当前任务加入阻塞队列。</li>
<li>如果阻塞队列满了且线程数小于最大线程数： 创建非核心线程去执行。</li>
<li>如果阻塞队列满了且线程数满了，也都在执行任务： 进行拒绝策略。</li>
</ol>
<h3 id="1-2-API"><a href="#1-2-API" class="headerlink" title="1.2. API"></a>1.2. API</h3><ul>
<li>execute (Runnable runnable)：开启线程 </li>
<li>shutdown ()：会等待线程都执行完毕之后再关闭 </li>
<li>shutdownNow ()：相当于调用每个线程的 interrupt () 方法 </li>
<li>submit ()：如果只想中断 Executor 中的一个线程，可以通过使用 submit () 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel (true) 方法就可以中断线程。 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">});</span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-3-线程池状态"><a href="#1-3-线程池状态" class="headerlink" title="1.3. 线程池状态"></a>1.3. 线程池状态</h3><ol>
<li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务 </li>
<li>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown () 方法会使线程池进入到该状态。（finalize () 方法在执行过程中也会调用 shutdown () 方法进入该状态） </li>
<li>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow () 方法会使线程池进入到该状态 </li>
<li>TIDYING：如果所有的任务都已终止了，workerCount（有效线程数）为 0，线程池进入该状态后会调用 terminated () 方法进入 TERMINATED 状态 </li>
<li>TERMINATED：在 terminated () 方法执行完后进入该状态，默认 terminated () 方法中什么也没有做</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a524451c52f0d1fde0b3ececf269069c.png"></p>
<h3 id="1-4-源码"><a href="#1-4-源码" class="headerlink" title="1.4. 源码"></a>1.4. 源码</h3><p><strong>ctl：</strong>高 3 位表示线程池状态，低 29 位表示 worker 数量</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 状态|工作数的一个 32 bit 的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. 29 bit 代表线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. 线程池允许的最大线程数。1 左移 29 位，然后减 1，即为 2^29 - 1</span></span><br><span class="line"><span class="comment">// 0001-1111-1111-1111-1111-1111-1111-1111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 线程池有 5 种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="comment">// 1110-0000-0000-0000-0000-0000-0000-0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 0000-0000-0000-0000-0000-0000-0000-0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 0010-0000-0000-0000-0000-0000-0000-0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 0100-0000-0000-0000-0000-0000-0000-0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 0110-0000-0000-0000-0000-0000-0000-0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 获取线程池状态，通过按位与操作，低 29 位将全部变成 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     { <span class="keyword">return</span> c &amp; ~CAPACITY; }</span><br><span class="line"><span class="comment">// 6. 获取线程池 worker 数量，通过按位与操作，高 3 位将全部变成 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  { <span class="keyword">return</span> c &amp; CAPACITY; }</span><br><span class="line"><span class="comment">// 7. 根据线程池状态和线程池 worker 数量，生成 ctl 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> { <span class="keyword">return</span> rs | wc; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 线程池状态小于 xx</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 9. 线程池状态大于等于 xx</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>execute (Runnable command) 方法：</strong></p>
<ol>
<li>worker 数量 &lt;核心线程数 -&gt; 直接创建 worker 执行任务</li>
<li> worker 数量 &gt;= 核心线程数 &amp;&amp; 线程池是运行状态 -&gt; 任务直接进入队列 <ol>
<li><em>双重检查状态：</em> 入队后再次检查状态，若线程池状态不是 RUNNING 状态，说明执行过 shutdown 命令，需要对新加入的任务执行 reject () 操作。</li>
<li><em>核心线程数为 0 的情况：</em> 若是 RUNNING 状态，且当前线程数为 0。该任务因核心线程数已满才加入阻塞队列，表明核心线程数为 0（在线程池构造方法中，核心线程数允许为 0）。这种情况会创建非核心线程去执行该任务</li>
</ol>
</li>
<li>如果线程池不是运行状态，或者任务进入队列失败（例如队列满了），则尝试创建 worker 执行任务。如果创建 worker 失败，说明线程池 shutdown 或者饱和了，这时会执行拒绝。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.worker 数量 &lt; 核心线程数 -&gt; 直接创建 worker 执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 没有成功 addWorker()，再次获取 c（凡是需要再次用 ctl 做判断时，都会再次调用ctl.get()）</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.worker 数量超过核心线程数 &amp;&amp; 线程池是运行状态 -&gt; 任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="comment">// 任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是 RUNNING 状态，说明执行过 shutdown 命令，需要对新加入的任务执行 reject() 操作。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 在线程池构造方法中，核心线程数允许为 0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建 worker 执行任务。</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker 内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker 第 2 个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker 返回 false，则说明任务执行失败，需要执行 reject 操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>addworker (Runnable firstTask, boolean core) 方法：</strong></p>
<ol>
<li>增加 worker 数量：使用两层自旋，第一层用于判断线程池状态，第二层使用 CAS 增加 worker 数量（CAS 自旋） <ol>
<li>外层自旋：判断线程池状态。 <ul>
<li>状态 == RUNNING，通过</li>
<li>状态 == SHUTDOWN，任务为空且队列不为空，通过</li>
<li>其余情况返回 false</li>
</ul>
</li>
<li> 内层自旋：CAS 自旋 <ol>
<li>worker 数量超过容量，直接返回 false</li>
<li> 使用 CAS 的方式增加 worker 数量。若成功则直接跳出整个外层自旋</li>
<li>否则重新获取状态，若状态发生变化，重新执行外层循环普判断状态</li>
<li>若状态没发生变化，意味着还可以继续竞争 CAS，直接继续内层循环</li>
</ol>
</li>
</ol>
</li>
<li>创建 worker 并执行 <ol>
<li>创建 Worker 对象 worker</li>
<li> 加锁，把 worker 加入 workers（HashSet）</li>
<li>如果添加成功则调用 worker 内部线程的 start () 方法执行任务。实际上会执行 <code>ThreadPoolExecutor#runWorker</code> 方法 </li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> {</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN 时，直接返回 false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于 SHUTDOWN，且 firstTask 不为 null，直接返回 false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于 SHUTDOWN，且队列为空，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层 CAS 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker 数量超过容量，直接返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 使用 CAS 的方式增加 worker 数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker 的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) {</span><br><span class="line">                    <span class="comment">// worker 已经调用过了 start() 方法，则不再创建 worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// worker 创建并添加到 workers 成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 启动 worker 线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// worker 线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown 相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Worker 类：</strong><br>既是一个同步队列也是一个 Runnable</p>
<ol>
<li>自身维护了一个 <code>Thread thread</code> （任务执行器）和一个 <code>Runnable firstTask</code>（任务） </li>
<li>在构造器中会把传入的任务赋值给 <code>firstTask</code>，然后把当前自己传入 <code>thread</code> </li>
<li>当调用 <code>thread.start()</code> 时会执行这个 worker 的 run () 方法，最终调用 <code>ThreadPoolExecutor#runWorker</code></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) {</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是 Worker 的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>runworker (Worker w)：核心线程执行逻辑</strong></p>
<ol>
<li>如果 firstTask 不为 null，则执行 firstTask</li>
<li> 如果 firstTask 为 null，则调用 getTask () 从队列获取任务执行</li>
<li>加锁 <code>w.lock();</code>。Worker 实现了 AQS，所以自己也是一把锁，并重写了 tryAcquire 方法（非重入）</li>
<li>判断写线程池状态，如果线程池正在停止，则对当前线程进行中断操作</li>
<li>执行任务 <code>task.run();</code></li>
<li>已完成任务数加一 <code>w.completedTasks++;</code></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 调用 unlock() 是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while 循环）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果 firstTask 不为 null，则执行 firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果 firstTask 为 null，则调用 getTask() 从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 这儿对 worker 进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个 worker 执行的任务是串行的</span></span><br><span class="line">             <span class="comment">// 开始运行，不允许中断</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过 beforeExecute() 和 afterExecute() 来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();</span><br><span class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Error x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable x) {</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 帮助 gc</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-ForkJoinPool"><a href="#2-ForkJoinPool" class="headerlink" title="2. ForkJoinPool"></a>2. ForkJoinPool</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b3a261fd0f4312836f80a9834517e5ec.png" alt="image.png"><br><strong>概述：</strong><br>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数<br>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算</p>
<p>Fork/Join 主要采用分而治之的理念来处理问题，对于一个比较大的任务，首先将它拆分 (fork) 为两个小任务 task1 与 task2。<br>使用新的线程 thread1 去处理 task1，thread2 去处理 task2。<br>如果 thread1 认为 task1 还是太大，则继续往下拆分成新的子任务 task3 与 task4。<br>thread2 认为 task2 任务量不大，则立即进行处理，形成结果 result2。<br>之后将 task3 和 task4 的处理结果合并 (join) 成 result1，最后将 result1 与 result2 合并成最后的结果。</p>
<p><strong>原理：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/61e541943ae4cdcba0390b1158b4528a.png"></p>
<ul>
<li>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。 </li>
<li>窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争</li>
</ul>
<h3 id="2-1-RecursiveAction"><a href="#2-1-RecursiveAction" class="headerlink" title="2.1. RecursiveAction"></a>2.1. RecursiveAction</h3><p>不带返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> {</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line">    AddTask(<span class="type">int</span> s, <span class="type">int</span> e) {</span><br><span class="line">        start = s;</span><br><span class="line">        end = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_NUM) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) {</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"from:"</span> + start + <span class="string">" to:"</span> + end + <span class="string">" = "</span> + sum);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">AddTask</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(start, middle);</span><br><span class="line">            <span class="type">AddTask</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(middle, end);</span><br><span class="line">            subTask1.fork();</span><br><span class="line">            subTask2.fork();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">ForkJoinPool</span> <span class="variable">fjp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">		<span class="type">AddTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(<span class="number">0</span>, nums.length);</span><br><span class="line">		fjp.execute(task);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-RecursiveTask"><a href="#2-2-RecursiveTask" class="headerlink" title="2.2. RecursiveTask"></a>2.2. RecursiveTask</h3><p>带返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> last;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinExample</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> last)</span> {</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) {</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) {</span><br><span class="line">                result += i;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(first, middle);</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="type">ForkJoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">Future</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.submit(example);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">        <span class="comment">// forkJoinPool.execute(example);</span></span><br><span class="line">        <span class="comment">// long result = example.join();</span></span><br><span class="line">        <span class="comment">// System.out.println(result);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Executors"><a href="#3-Executors" class="headerlink" title="3. Executors"></a>3. Executors</h2><ul>
<li><p>CachedThreadPool： 一个任务创建一个线程 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    }</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>FixedThreadPool： 所有任务只能使用固定大小的线程 </p>
</li>
<li><p>SingleThreadExecutor： 相当于大小为 1 的 FixedThreadPool </p>
</li>
<li><p>WorkStealingPool：工作窃取线程池 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ④：ReentrantLock</title>
    <url>/75f42c054e7b/</url>
    <content><![CDATA[<ul>
<li><em>boolean tryLock(long time, TimeUnit unit)：</em> 尝试获得锁，阻塞时间不会超过给定的值；如果成功返回 true</li>
<li><em>void &nbsp;lockInterruptibly()：</em> 获得锁，但是会不确定地发生阻塞。如果线程被中断，抛出一个 InterruptedException 异常</li>
</ul>
<span id="more"></span>
<h2 id="1-条件对象"><a href="#1-条件对象" class="headerlink" title="1. 条件对象"></a>1. 条件对象</h2><p><strong>作用：</strong> 条件对象用来管理那些已经进入被保护的代码段但还不能运行的线程。一个 Condition 对象为一个队列。</p>
<p><strong>方法：</strong><br>ReentrantLock &lt;==&gt; synchronized</p>
<ul>
<li>await () &lt;==&gt; wait ()： 将该线程放到条件的等待集中</li>
<li> signalAll () &lt;==&gt; notifyAll ()： 解除该条件的等待集中的所有线程的阻塞状态</li>
<li> signal () &lt;==&gt; notify ()： 从该条件的等待集中随机地选择一个线程，解除其阻塞状态 </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Condition</span> <span class="variable">sufficientFunds</span> <span class="operator">=</span> bankLock.newCondition();</span><br><span class="line"><span class="comment">// 当前线程不满足条件，进入该条件的等待集，放弃锁</span></span><br><span class="line"><span class="keyword">while</span> (!(ok to proceed)) {</span><br><span class="line">    sufficientFunds.await();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其他线程的操作应使该线程重新判断条件。</span></span><br><span class="line"><span class="comment">// 重新激活因为这一条件而等待的所有线程。</span></span><br><span class="line">sufficientFunds.signalAll();</span><br></pre></td></tr></tbody></table></figure>

<p>可以创建多个不同的 Condition，实现不同的等待队列</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Condition</span> <span class="variable">producer</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">comsumer</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (isProducer) {</span><br><span class="line">    comsumer.await();</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">producer.signalAll();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h2><ul>
<li>Lock readLock ()： 得到一个可以被多个读操作共用的读锁，但会排斥所有写操作</li>
<li> Lock writeLock ()： 得到一个写锁，排斥所有其他的读操作和写操作 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对所有的获取方法加读锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> doule <span class="title function_">getTotalBalance</span><span class="params">()</span> {</span><br><span class="line">   readLock.lock();</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">       readLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对所有的修改方法加写锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> {</span><br><span class="line">   writeLock.lock();</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">       writeLock.unlock();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ol>
<li><em>锁的实现：</em> synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</li>
<li><em>性能：</em> 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同</li>
<li><em>等待可中断：</em> 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情<br>ReentrantLock 可中断，而 synchronized 不行</li>
<li><em>公平锁：</em> 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的</li>
<li><em>锁绑定多个条件：</em> 一个 ReentrantLock 可以同时绑定多个 Condition 对象</li>
</ol>
<h2 id="4-CAS"><a href="#4-CAS" class="headerlink" title="4. CAS"></a>4. CAS</h2><p><a href="https://www.jianshu.com/p/bd68ddf91240">深入解析 volatile 、CAS 的实现原理</a><br><a href="https://blog.csdn.net/v123411739/article/details/79561458">面试必问的 CAS，你懂了吗？</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484178&amp;idx=1&amp;sn=9002eff9605ac67ee0440e8ce93903d8&amp;chksm=fd985573caefdc65f39a17d464f067303780707617689ff7e701c0f6a96671e8d15e443603f2#rd">《面试必备之乐观锁与悲观锁》</a></p>
<p><strong>并发策略：</strong></p>
<ul>
<li><em>乐观并发策略（乐观锁）：</em> 乐观地认为本次操作没有其他线程竞争。<br>先尝试进行操作，如果没有其它线程争用共享数据，那操作就成功了。否则采取补偿措施（不断地重试）直到成功为止。 </li>
<li><em>悲观并发策略（悲观锁）：</em> 悲观地认为本次操作有其他线程竞争。<br>直接使用互斥量进行加锁阻塞。</li>
</ul>
<p><strong>原理：</strong> CAS 指令是原子操作，有 3 个操作数。分别是内存地址 V、旧的预期值 A 和新值 B。</p>
<p>当执行操作时，只有当 V 的值等于 A（即认为未被其他线程修改过），才将 V 的值更新为 B。</p>
<p>若失败了则重新获取这三个值再次进行判断，直到操作成功。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></p>
<h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1. ABA 问题"></a>1. ABA 问题</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>
<p><strong>解决：</strong> J.U.C 包提供了一个带有标记的原子引用类 <strong>AtomicStampedReference</strong> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。</p>
<p>改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="2-Atomic-类"><a href="#2-Atomic-类" class="headerlink" title="2. Atomic 类"></a>2. Atomic 类</h3><p><strong>LongAdder：</strong><br>思想：分段锁 CAS，分片执行，结果汇总</p>
<p>例：1000 个线程分为 4 个任务，每个任务 250 个线程，执行完后汇总</p>
<h3 id="3-Unsafe"><a href="#3-Unsafe" class="headerlink" title="3. Unsafe"></a>3. Unsafe</h3><p>J.U.C 包里面的 AtomicInteger 等原子类的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>AtomicInteger：</p>
<ol>
<li><p>内部调用 <code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code> 本地方法，compareAndSwapInt 定义在 jdk8u: unsafe.cpp 中 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>compareAndSwapInt 调用 cmpxchg（compare and exchange）方法</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk8u: unsafe.cpp</span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>cmpxchg 方法执行逻辑<br>以下是 cmpxchg 在 JDK 8，Linux 操作系统，X86 处理器环境下的实现： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk8u: atomic_linux_x86.inline.hpp</span></span><br><span class="line"><span class="keyword">inline</span> jint <span class="title function_">Atomic::cmpxchg</span><span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> {</span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm__ <span class="title function_">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span><br><span class="line"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span><br><span class="line"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span><br><span class="line"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>其详细执行逻辑如下： </p>
</li>
<li><p>is_MP（Multi Processor）方法判断 <strong>是否为多个处理器</strong>，保存到变量 mp 中。 </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk8u: os.hpp</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">is_MP</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>LOCK_IF_MP </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk8u: atomic_linux_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_IF_MP(mp) <span class="string">"cmp $0, "</span> #mp <span class="string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<pre><code>  -  如果是在多处理器上运行就为 cmpxchg 指令加上 `lock` 前缀（lock cmpxchg）。**这就使 cmpxchg 指令变成原子操作** 
  -  如果是在单处理器上运行就省略 `lock` 前缀 
</code></pre>
<ol start="3">
<li>执行 cmpxchgl：<strong>比较并交换</strong>，操作成功返回比较值（旧值），操作失败返回目标地址中的值 <blockquote>
<p>“cmpxchgl %1,(%3)”<br>: “=a” (exchange_value)<br>: “r” (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)<br>: “cc”, “memory”</p>
<ul>
<li>输入 exchange_value（交换值，即更新值，%1）、compare_value（比较值，即期待值，%2）、dest（目标地址值，%3）、mp（是否多核，%4） 四个值 </li>
<li>输出 exchange_value（%0）</li>
</ul>
</blockquote>
</li>
</ol>
<p><br><code>cmpxchgl %1,(%3)</code> 即表示 <code>cmpxchgl exchange_value,(dest)</code> </p>
<pre><code>  1. 输入：`"r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)`，代表把 compare_value 存入 eax 寄存器，把 exchange_value、dest、mp 的值存入任意的通用寄存器
  2. cmpxchgl 有个隐含操作数 eax，会先比较 eax 的值（也就是 compare_value）和 dest 地址所存的值是否相等
  3. 相等则把 exchange_value 的值写入 dest 指向的地址
  4. 不相等则把 dest 地址所存的值更新到 eax 中（因为最终输出 eax 中的值，写入 dest 的值代表更新失败）
  5. 输出：`"=a" (exchange_value)`，把 eax 中存的值写入 exchange_value 变量中。
  6. 如果输出的是比较值（说明操作成功），Unsafe_CompareAndSwapInt 方法中 `return (jint)(Atomic::cmpxchg(x, addr, e)) == e;` 会返回 `ture`，即表示 CAS 成功！否则表示 CAS失败。
</code></pre>
<ol>
<li>最终实现 cmpxchg = cas 修改变量值<br>lock 指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式） <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 从入门到入土⑥：分片</title>
    <url>/045695264e87/</url>
    <content><![CDATA[<p>分片位置：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上</li>
<li>服务器分片：Redis Cluster</li>
</ul>
<span id="more"></span>
<h2 id="1-顺序分片"><a href="#1-顺序分片" class="headerlink" title="1. 顺序分片"></a>1. 顺序分片</h2><p><strong><em>概述：</em></strong> 将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分片可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000<br><strong><em>优点：</em></strong></p>
<ul>
<li>能保持数据 <strong>原有的顺序</strong></li>
<li>并且能够 <strong>准确控制每台服务器存储的数据量</strong>，从而使得存储空间的利用率最大</li>
</ul>
<h2 id="2-哈希分片"><a href="#2-哈希分片" class="headerlink" title="2. 哈希分片"></a>2. 哈希分片</h2><p><strong><em>概述：</em></strong> 哈希分片就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash (key)% N<br><strong><em>问题：</em></strong> 传统的哈希分片算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移</p>
<h2 id="3-一致性哈希"><a href="#3-一致性哈希" class="headerlink" title="3. 一致性哈希"></a>3. 一致性哈希</h2><p><strong><em>概述：</em></strong> Distributed Hash Table（DHT）是一种哈希分片方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题<br><strong><em>基本原理：</em></strong><br>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34b25f0e3b87856daa5e01354922f618.png" alt="image.png"></p>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点<br>例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba169b2511d0030a34be78d0f88bc2b0.png" alt="image.png"></p>
<h2 id="4-虚拟节点（Redis-Cluster）"><a href="#4-虚拟节点（Redis-Cluster）" class="headerlink" title="4. 虚拟节点（Redis Cluster）"></a>4. 虚拟节点（Redis Cluster）</h2><p><strong><em>问题：</em></strong> 上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同<br><strong><em>原因：</em></strong> 数据不均匀主要是因为 <strong>节点在哈希环上分布的不均匀</strong>，这种情况在节点数量很少的情况下尤其明显<br><strong><em>解决方式：</em></strong> 通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/823cf8a9c7593081a5d5e6ddea68e730.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ⑥：volatile</title>
    <url>/492a0017fe9d/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/bd68ddf91240">深入解析 volatile 、CAS 的实现原理</a></p>
<p><strong>处理器如何实现原子操作</strong><br>处理器提供 <strong>总线锁定</strong> 和 <strong>缓存锁</strong> 定两个机制来保证复杂内存操作的原子性。</p>
<ul>
<li>使用总线锁保证原子性<br>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占使用共享内存。 </li>
<li>使用缓存锁保证原子性</li>
</ul>
<p>底层用 lock 实现，如果是多核添加 lock 指令。<br>lock 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效<br>另外还提供了有序的指令无法越过这个内存屏障的作用<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b34bb9acc5bd5c00a775c0077bd2f9c0.png"></p>
<p>volatile 变量自身具有以下特性：</p>
<ul>
<li>[可见性](#1. 保证线程可见性)：对一个 volatile 变量的读，总是能看到 <strong>（任意线程）</strong> 对这个 volatile 变量最后的写入。</li>
<li>[禁止指令重排](#2. 禁止指令重排)</li>
</ul>
<p>想了解以上特性的原理，需先了解 [处理器缓存](#0. 处理器缓存)。</p>
<span id="more"></span>

<h2 id="0-处理器缓存"><a href="#0-处理器缓存" class="headerlink" title="0. 处理器缓存"></a>0. 处理器缓存</h2><p>CPU 缓存（Cache Memory）是位于 CPU 与内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。</p>
<p>L1（一级缓存）分为 <em>数据缓存</em> 和 _指令缓存_，L2（二级缓存）和 L3（三级缓存）只有 <em>数据缓存</em></p>
<p><strong>作用：</strong><br>缓存的出现主要是为了解决 CPU 运算速度与内存读写速度不匹配的矛盾，因为 CPU 运算速度要比内存读写速度快很多，这样会使 CPU 花费很长时间等待数据到来或把数据写入内存。</p>
<p><strong>读缓存：</strong> CPU 依次从一级缓存、二级缓存、三级缓存中获取数据，若未命中则到内存中获取，再去更新缓存</p>
<p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是 2 的整数幂个连续字节，一般为 32-256 个字节。最常见的缓存行大小是 64 个字节。</p>
<p>因此当 CPU 在执行一条读内存指令时，它是会将内存地址所在的缓存行大小的内容都加载进缓存中的。也就是说，一次加载一整个缓存行。</p>
<p><strong>写操作：</strong> 两种模式</p>
<ul>
<li>直写（write-through）：<strong>更新内存数据再更新缓存（或丢弃）。</strong>保证该数据在缓存与内存中一致<br>透过本级缓存，直接把数据写到下一级缓存（或直接到内存）中。<br>如果对应的段被缓存了，会同时更新缓存中的内容（甚至直接丢弃）。 </li>
<li>回写（write-back）：<strong>先更新缓存，再由缓存回写至内存。</strong>缓存暂时与内存不一致，但最终会写回内存。<br>仅修改本级缓存中的数据，并且把对应的缓存段标记为 “脏” 段。<br>脏段会触发回写，也就是把里面的内容写到对应的内存或下一级缓存中。</li>
</ul>
<h2 id="1-保证线程可见性"><a href="#1-保证线程可见性" class="headerlink" title="1. 保证线程可见性"></a>1. 保证线程可见性</h2><p>对一个 volatile 变量的读，总是能看到 (任意线程) 对这个 volatile 变量最后的写入。</p>
<h3 id="1-1-窥探技术"><a href="#1-1-窥探技术" class="headerlink" title="1.1. 窥探技术"></a>1.1. 窥探技术</h3><p>所有内存传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。</p>
<ul>
<li>同一个指令周期中，只有一个缓存可以读写内存，会通知其他处理器</li>
<li>缓存不断地窥探总线上发生的数据交换。只要某个处理器写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的缓存行已经失效。</li>
</ul>
<h3 id="1-2-MESI-协议"><a href="#1-2-MESI-协议" class="headerlink" title="1.2. MESI 协议"></a>1.2. MESI 协议</h3><p><strong>缓存一致性协议：</strong><br>在多核处理器系统中，每个处理器核心都有它们自己的一级缓存、二级缓存等。</p>
<p>这样一来当多个处理器核心在对共享的数据进行写操作时，就需要 <strong>保证该缓存数据在所有处理器核心中的可见性 / 一致性</strong>。</p>
<p>MESI 是缓存行四种状态的首字母缩写，任何多核系统中的缓存行都处于这四种状态之一。</p>
<ul>
<li><strong>失效（Invalid）：</strong> 该处理器缓存中无该缓存行，或缓存中的缓存行已经失效了。 </li>
<li><strong>共享（Shared）：</strong> 多组缓存都可以拥有指向同一内存地址的缓存行。且缓存行只能被读取，不能被写入。<br>该状态下缓存行数据是主内存的一份拷贝，其数据与主内存数据保持一致。 </li>
<li><strong>独占（Exclusive）：</strong> 如果一个处理器持有了某个「独占」状态的缓存行，其他处理器中的同一缓存行会变成「失效」状态。<br>缓存行数据是主内存的一份拷贝，其数据与主内存数据保持一致。 </li>
<li><strong>已修改（Modified）：</strong> 属于脏段，表示该缓存行已经被所属的处理器修改了。如果一个缓存行处于「已修改」状态，那么它在其他处理器缓存中的拷贝马上会变成「失效」状态。<br>已修改缓存行如果被丢弃或标记为「失效」状态，那么先要把它的内容回写到内存中，即需保证已经修改的数据一定要回写至内存。</li>
</ul>
<p><strong>写操作过程：</strong><br>只有当缓存行处于「独占」状态或「已修改」状态时处理器才能对其进行写操作</p>
<p>当处理器想对某个缓存段进行写操作时，如果它没有独占权</p>
<ol>
<li>会先发送一条申请独占权的请求给总线，这会通知其他处理器</li>
<li>其他处理器把它们拥有的同一缓存行的拷贝改为「失效」状态</li>
<li>修改数据，更改状态为「已修改」状态</li>
</ol>
<p><strong>读操作过程：</strong><br>当处理器想对某个缓存段进行读操作时</p>
<ol>
<li>若缓存行处于「独占」状态或「已修改」状态时，直接读 </li>
<li>若其他处理器中有同一缓存行的拷贝且处于「独占」状态或「已修改」状态时（由于窥探总线技术，所以也会知道）需把状态改为「共享」状态才能进行读操作 <blockquote>
<p>其他处理器中的缓存行若为「已修改」状态需先把它的内容回写到内存中</p>
</blockquote>
</li>
</ol>
<p>操作系统通过内存屏障保证缓存间的可见性，JVM 通过给 volatile 变量加入内存屏障保证线程之间的可见性。</p>
<p>其实，volatile 对于可见性的实现，内存屏障也起着至关重要的作用。因为内存屏障相当于一个数据同步点，他要保证在这个同步点之后的读写操作必须在这个点之前的读写操作都执行完之后才可以执行。并且在遇到内存屏障的时候，缓存数据会和主存进行同步，或者把缓存数据写入主存、或者从主存把数据读取到缓存。</p>
<p><strong>已经有了缓存一致性协议，为什么还需要 volatile？</strong></p>
<ol>
<li>并不是所有的硬件架构都提供了相同的一致性保证，Java 作为一门跨平台语言，JVM 需要提供一个统一的语义。 </li>
<li>操作系统中的缓存和 JVM 中线程的本地内存并不是一回事，通常我们可以认为：MESI 可以解决缓存层面的可见性问题。使用 volatile 关键字，可以解决 JVM 层面的可见性问题。 </li>
<li>缓存可见性问题的延伸：由于传统的 MESI 协议的执行成本比较大。所以 CPU 通过 Store Buffer 和 Invalidate Queue 组件来解决，但是由于这两个组件的引入，也导致缓存和主存之间的通信并不是实时的。也就是说，缓存一致性模型只能保证缓存变更可以保证其他缓存也跟着改变，但是不能保证立刻、马上执行。</li>
</ol>
<h2 id="2-禁止指令重排"><a href="#2-禁止指令重排" class="headerlink" title="2. 禁止指令重排"></a>2. 禁止指令重排</h2><p>DCL 单例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// 若 singleton 没有加 volatile 会出现指令重排问题</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>创建对象步骤：</strong> <code>T t = new T();</code></p>
<p>对应指令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0 new #2 &lt;com/test/jvm/volatile/T&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;com/test/jvm/volatile/T.&lt;init&gt;&gt;</span><br><span class="line">7 astore_1</span><br><span class="line">8 return</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>申请内存：new 命令</li>
<li>初始化成员变量：invokespecial 命令</li>
<li>赋值：astore_1 将对象引用返回给 t</li>
</ol>
<p>由于指令重排，2 和 3 可能会互换位置。这时变量可能会先拿到一个尚未初始化成员变量的对象，若刚好此时有线程进入 DCL 会直接拿到该变量去使用</p>
<p>读写屏障</p>
<ul>
<li>loadfence</li>
<li>storefence</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ⑤：自旋锁</title>
    <url>/08479805e3e3/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_34337272/article/details/81252853">面试必备之深入理解自旋锁</a></p>
<p>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</p>
<p><strong>缺点：</strong> 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗 CPU。使用不当会造成 CPU 使用率极高。</p>
<span id="more"></span>
<h2 id="1-实现"><a href="#1-实现" class="headerlink" title="1. 实现"></a>1. 实现</h2><p>非公平不可重入：</p>
<p>当第一个线程 A 获取锁的时候，能够成功获取到，不会进入 while 循环，如果此时线程 A 没有释放锁，另一个线程 B 又来获取锁，此时由于不满足 CAS，所以就会进入 while 循环，不断判断是否满足 CAS，直到 A 线程调用 unlock 方法释放了该锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> {</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用 CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) {</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-可重入"><a href="#2-可重入" class="headerlink" title="2. 可重入"></a>2. 可重入</h2><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> {</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == cas.get()) { <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) {</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cur</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (cur == cas.get()) {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">                count--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">                cas.compareAndSet(cur, <span class="literal">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-TicketLock"><a href="#3-TicketLock" class="headerlink" title="3. TicketLock"></a>3. TicketLock</h2><p>TicketLock 主要解决的是公平性的问题</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketLock</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">serviceNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock:获取锁，如果获取成功，返回当前线程的排队号，获取排队号用于释放锁. &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentTicketNum</span> <span class="operator">=</span> ticketNum.incrementAndGet();</span><br><span class="line">        <span class="keyword">while</span> (currentTicketNum != serviceNum.get()) {</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> currentTicketNum;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unlock:释放锁，传入当前持有锁的线程的排队号 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">int</span> ticketnum)</span> {</span><br><span class="line">        serviceNum.compareAndSet(ticketnum, ticketnum + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的实现方式是，线程获取锁之后，将它的排队号返回，等该线程释放锁的时候，需要将该排队号传入。但这样是有风险的，因为这个排队号是可以被修改的，一旦排队号被不小心修改了，那么锁将不能被正确释放。一种更好的实现方式如下：</p>
<p><strong>缺点：</strong><br>多处理器系统上，每个进程 / 线程占用的处理器都在读写同一个变量 serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketLockV2</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">serviceNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个ThreadLocal，用于存储每个线程的排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentTicketNum</span> <span class="operator">=</span> ticketNum.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁的时候，将当前线程的排队号保存起来</span></span><br><span class="line">        ticketNumHolder.set(currentTicketNum);</span><br><span class="line">        <span class="keyword">while</span> (currentTicketNum != serviceNum.get()) {</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 释放锁，从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">currentTickNum</span> <span class="operator">=</span> ticketNumHolder.get();</span><br><span class="line">        serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-CLHLock"><a href="#4-CLHLock" class="headerlink" title="4. CLHLock"></a>4. CLHLock</h2><p>CLH 锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CLH的发明人是：Craig，Landin and Hagersten。</span></span><br><span class="line"><span class="comment"> * 代码来源：http://ifeve.com/java_lock_see2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个节点，默认的lock状态为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CLHNode</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾部节点,只用一个节点即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;CLHNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = </span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, <span class="string">"tail"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 新建节点并将节点与当前线程保存起来</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHNode</span>();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新建的节点设置为尾部节点，并返回旧的节点（原子操作）</span></span><br><span class="line">        <span class="comment">// 这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 前驱节点不为null表示当锁被其他线程占用</span></span><br><span class="line">            <span class="comment">// 通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) {</span><br><span class="line">            }</span><br><span class="line">            preNode = <span class="literal">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">        <span class="comment">// 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态置为false，表示当前线程释放了锁</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="built_in">this</span>, node, <span class="literal">null</span>)) {</span><br><span class="line">            node.isLocked = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-MCSLock"><a href="#5-MCSLock" class="headerlink" title="5. MCSLock"></a>5. MCSLock</h2><p>MCSLock 则是对本地变量的节点进行循环。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MCS:发明人名字John Mellor-Crummey和Michael Scott</span></span><br><span class="line"><span class="comment"> * 代码来源：http://ifeve.com/java_lock_see2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点，记录当前节点的锁状态以及后驱节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MCSNode</span> {</span><br><span class="line">        <span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;MCSNode&gt; NODE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;MCSNode&gt;();</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="meta">@SuppressWarnings("unused")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MCSNode queue;</span><br><span class="line">    <span class="comment">// queue更新器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = </span><br><span class="line">                AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, <span class="string">"queue"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 创建节点并保存到 ThreadLocal 中</span></span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MCSNode</span>();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        <span class="comment">// 将queue设置为当前节点，并且返回之前的节点</span></span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, currentNode);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果之前节点不为null，表示锁已经被其他线程持有</span></span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            <span class="comment">// 循环判断，直到当前节点的锁标志位为false</span></span><br><span class="line">            <span class="keyword">while</span> (currentNode.isLocked) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> NODE.get();</span><br><span class="line">        <span class="comment">// next为null表示没有正在等待获取锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.next == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 更新状态并设置queue为null</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="built_in">this</span>, currentNode, <span class="literal">null</span>)) {</span><br><span class="line">                <span class="comment">// 如果成功了，表示queue==currentNode,即当前节点后面没有节点了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待</span></span><br><span class="line">                <span class="comment">// 如果当前节点的后续节点为null，则需要等待其不为null（参考加锁方法）</span></span><br><span class="line">                <span class="keyword">while</span> (currentNode.next == <span class="literal">null</span>) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false，同时将当前线程的后继节点设为null</span></span><br><span class="line">            currentNode.next.isLocked = <span class="literal">false</span>;</span><br><span class="line">            currentNode.next = <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-CLHLock-和-MCSLock-比较"><a href="#6-CLHLock-和-MCSLock-比较" class="headerlink" title="6. CLHLock 和 MCSLock 比较"></a>6. CLHLock 和 MCSLock 比较</h2><ul>
<li>都是基于链表，不同的是 CLHLock 是基于隐式链表，没有真正的后续节点属性，MCSLock 是显示链表，有一个指向后续节点的属性</li>
<li>将获取锁的线程状态借助节点（node）保存，每个线程都有一份独立的节点，这样就解决了 TicketLock 多处理器缓存同步的问题</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java 并发详解 ⑦：AQS</title>
    <url>/26d195955dea/</url>
    <content><![CDATA[<h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p><strong>概述：</strong> 用来控制一个线程等待多个线程</p>
<p><strong>原理：</strong><br>维护了一个计数器 cnt，每次调用 countDown () 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await () 方法而在等待的线程就会被唤醒</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/859b76a0bc977dc9c5274854fdf6fbaa.png"></p>
<p><strong>API：</strong></p>
<ul>
<li><strong>await()：</strong> 调用 await () 方法的线程会被挂起，它会等待直到 count 值为 0 才继续执行</li>
<li><strong> await(long timeout, TimeUnit unit)：</strong> 和 await () 类似，只不过等待一定的时间后 count 值还没变为 0 的话就会继续执行</li>
<li><strong> countDown()：</strong> 将 count 值减 1</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountdownLatchExample</span> {</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// run..run..run..run..run..run..run..run..run..run..end</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>场景：</strong></p>
<ol>
<li>启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行 </li>
<li>实现多个线程开始执行任务的最大并行性<br>CountDownLatch (1)，多个线程挂起，当主线程调用 countDown () 时，多个线程同时被唤醒</li>
</ol>
<p><strong>不足：</strong><br>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>
<span id="more"></span>
<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p><strong>概述：</strong> 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行</p>
<p><strong>原理：</strong><br>线程执行 await () 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await () 方法而在等待的线程才能继续执行</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34d25411ae97dcbd9bf972dc9b81c829.png"></p>
<p><strong>方法：</strong></p>
<ul>
<li><strong>await()</strong></li>
<li><strong>await(long timeout, TimeUnit unit)：</strong> 设置超时时间，超过该时间仍然还有线程还没到达屏障则忽略这些线程，将等待的线程全部释放</li>
</ul>
<p><strong>区别：</strong> CyclicBarrier 和 CountdownLatch 的区别是，CyclicBarrier 的计数器通过调用 reset () 方法可以 <strong>循环使用</strong>，所以它才叫做循环屏障</p>
<p><strong>构造器：</strong> CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会选择一个线程执行一次</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> {</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> {</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>重用：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(N);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Writer</span>(barrier).start();</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Writer</span>(barrier).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line"> </span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">catch</span>(BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Phaser"><a href="#3-Phaser" class="headerlink" title="3. Phaser"></a>3. Phaser</h2><p>main：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"p"</span> + i)).start();</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"新郎"</span>)).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"新娘"</span>)).start();</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Phaser：指定什么阶段做什么事</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ass MarriagePhaser <span class="keyword">extends</span> <span class="title class_">Phaser</span> {</span><br><span class="line">    <span class="comment">// phase: 阶段编号： registeredParties: 此阶段注册人数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAdvance</span><span class="params">(<span class="type">int</span> phase, <span class="type">int</span> registeredParties)</span> {</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (phase) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>run：如何到达阶段逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// doing something</span></span><br><span class="line">        <span class="comment">// 等待所有注册的线程全部到达后执行</span></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"新郎"</span>) || name.equals(<span class="string">"新娘"</span>)) {</span><br><span class="line">            System.out.printf(<span class="string">"%s 洞房！\n"</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 指定注销</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            phaser.arriveAndDeregister();</span><br><span class="line">            <span class="comment">//phaser.register()</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-ReadWriteLock"><a href="#4-ReadWriteLock" class="headerlink" title="4. ReadWriteLock"></a>4. ReadWriteLock</h2><p>StampedLock</p>
<ul>
<li>共享锁</li>
<li>排它锁 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5. Semaphore"></a>5. Semaphore</h2><p><strong>概述：</strong> Semaphore 类似于操作系统中的信号量，可以 <strong>控制对互斥资源的访问线程数</strong></p>
<p><strong>原理：</strong><br>acquire () 获取一个许可，如果没有就等待<br>release () 释放一个许可<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/fcd57279bb6fbe23660b6fb53d4c0848.png"></p>
<p><strong>构造器：</strong></p>
<ul>
<li><strong>Semaphore(int permits)：</strong> 参数 permits 表示许可数目，即同时可以允许多少线程进行访问</li>
<li><strong> Semaphore(int permits, boolean fair)：</strong> 这个多了一个参数 fair 表示是否是公平的，即等待时间越久的越先获取许可</li>
</ul>
<p><strong>API：</strong></p>
<ul>
<li><strong>acquire()：</strong> 获取一个许可</li>
<li><strong> acquire(int permits)：</strong> 获取 permits 个许可</li>
<li><strong> release()：</strong> 释放一个许可</li>
<li><strong> release(int permits)：</strong> 释放 permits 个许可</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalRequestCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(clientCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalRequestCount; i++) {</span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-Exchanger"><a href="#6-Exchanger" class="headerlink" title="6. Exchanger"></a>6. Exchanger</h2><p>线程交换</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"T1"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 阻塞等待交换，交换后才能继续执行</span></span><br><span class="line">        s1 = exchanger.exchange(s1);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + s1);</span><br><span class="line">}, <span class="string">"t1"</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"T2"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        s2 = exchanger.exchange(s2);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + s2);</span><br><span class="line">}, <span class="string">"t2"</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// t1:T2</span></span><br><span class="line"><span class="comment">// t2:T1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-LockSupport"><a href="#7-LockSupport" class="headerlink" title="7. LockSupport"></a>7. LockSupport</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) {</span><br><span class="line">            <span class="comment">// 停止当前线程</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">t.start();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 继续执行</span></span><br><span class="line">LockSupport.unpark(t);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-CompletableFuture"><a href="#8-CompletableFuture" class="headerlink" title="8. CompletableFuture"></a>8. CompletableFuture</h2><p><a href="https://blog.csdn.net/sermonlizhi/article/details/123356877">CompletableFuture 使用详解</a><br><a href="https://www.jianshu.com/p/8c9dc192fa63">CompletableFuture 避坑 1—— 需要自定义线程池</a><br><a href="https://zhuanlan.zhihu.com/p/339203275">使用 CompletableFuture 时，那些令人头疼的问题</a><br>管理多个线程运行后返回的结果</p>
<ul>
<li>allOf ()：所有任务全部完成才结束</li>
<li> anyOf ()：任意一个任务完成才结束 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; futureTM = CompletableFuture.supplyAsync(() -&gt; priceOfTM())</span><br><span class="line">    <span class="comment">// 对结果进行处理</span></span><br><span class="line">    .thenApply(String::valueOf)</span><br><span class="line">    .thenApply(str -&gt; <span class="string">"price "</span> + str)</span><br><span class="line">    .thenAccept(System.out::println);</span><br><span class="line">CompletableFuture&lt;Double&gt; futureTB = CompletableFuture.supplyAsync(() -&gt; priceOfTB());</span><br><span class="line">CompletableFuture&lt;Double&gt; futureJD = CompletableFuture.supplyAsync(() -&gt; priceOfJD());</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(futureTM, futureTB, futureJD).join();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 循环线程获取订单数</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">7</span>;</span><br><span class="line">List&lt;ReserveOrderCountVO&gt; resultList = Lists.newArrayListWithExpectedSize(totalCount);</span><br><span class="line">CompletableFuture[] completableFutures = Stream.iterate(<span class="number">0</span>, n -&gt; ++n).limit(totalCount)</span><br><span class="line">    .map(num -&gt; CompletableFuture.supplyAsync(() -&gt; <span class="built_in">this</span>.getReserveCountByDate(reserveCountQuery, now.plusDays(num)), COUNT_EXECUTOR)</span><br><span class="line">         .whenComplete((result, e) -&gt; resultList.add(result)))</span><br><span class="line">    .toArray(CompletableFuture[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞直到所有任务运行结束</span></span><br><span class="line">CompletableFuture.allOf(completableFutures).join();</span><br></pre></td></tr></tbody></table></figure>
<h2 id="9-AQS-源码"><a href="#9-AQS-源码" class="headerlink" title="9. AQS 源码"></a>9. AQS 源码</h2><p><a href="https://www.jianshu.com/p/da9d051dcc3d">Java 技术之 AQS 详解</a></p>
<p>内部维护一个 state 和一个双向线程链表</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/37dad34951493ee77b1058a67e6356b0.png"></p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/82c79dff8f34a6e45717d561477e01ac.png"></p>
<ol>
<li>ReentrantLock#lock <ol>
<li><p>AbstractQueuedSynchronizer#compareAndSetState：CAS 把 state 从 0 变为 1，若成功则代表拿到锁 </p>
</li>
<li><p>AbstractOwnableSynchronizer#setExclusiveOwnerThread：若抢到锁，则设置当前线程为独占线程 </p>
</li>
<li><p>AbstractQueuedSynchronizer#acquire </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>ReentrantLock.NonfairSync#tryAcquire<br>  1. ReentrantLock.Sync#nonfairTryAcquire： </p>
<ul>
<li>state 为 0，则继续调用 compareAndSetState 抢锁（尝试把 state 变为 1，成功则接着调用 setExclusiveOwnerThread）</li>
<li>state 为 &gt; 0，且当前线程是独占访问的那个线程（说明锁重入），则 state++（此时 state 代表重入线程数）</li>
<li>否则 TryAcquire 失败</li>
</ul>
</li>
<li><p> TryAcquire 失败则调用 AbstractQueuedSynchronizer#addWaiter：使用 CAS 加入链表队列</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// jdk 9 使用 VarHandler.set(this, pred)。</span></span><br><span class="line">        <span class="comment">// VarHandler 内部有 CAS 的方法</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) {</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>jdk 9 使用 <code>VarHandler.set(this, pred)</code> 代替 <code>node.prev = pred;</code>，其调用 native 实现（相当于直接操纵二进制码），效率比反射高<br>VarHandler 指向一个变量  </p>
<pre><code>     1. AbstractQueuedSynchronizer#acquireQueued：加入队列后不断监听前一个节点，若前节点为头结点（已拿到锁），则试图去抢锁，成功则返回 false（不中断）
</code></pre>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>可重入锁实现</title>
    <url>/f8c8b8272337/</url>
    <content><![CDATA[<p>在做项目时遇到需要可重入的缓存锁场景，缓存锁用的是 Redis 分布式锁，于是考虑用 ThreadLocal 来实现本机上的可重入锁</p>
<span id="more"></span>

<p>ReentrantCacheLockManager：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReentrantCacheLockManager implements ICacheLockManager {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ICacheService cacheService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(String key, int expireSecond) {</span><br><span class="line">        return tryLock(Collections.singletonList(key), expireSecond);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(List&lt;String&gt; keyList, int expireSecond) {</span><br><span class="line">        Assert.isTrue(CollectionUtils.isNotEmpty(keyList), "获取锁失败：key 不能为空");</span><br><span class="line"></span><br><span class="line">        // 1.从未获取过锁的 key 先去获取锁</span><br><span class="line">        List&lt;String&gt; unCacheKeyList = keyList.stream()</span><br><span class="line">                .filter(k -&gt; !LockKeyCountHolder.exist(k))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量获取锁</span><br><span class="line">        if (CollectionUtils.isNotEmpty(unCacheKeyList)) {</span><br><span class="line">            Map&lt;String, String&gt; lockMap = unCacheKeyList.stream().collect(Collectors.toMap(Function.identity(), k -&gt; "1", (a, b) -&gt; b));</span><br><span class="line">            long msetnx = cacheService.msetnx(lockMap, expireSecond);</span><br><span class="line">            // 未取到锁</span><br><span class="line">            if (Objects.equals(msetnx, 0L)) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 2.重入计数 +1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            LockKeyCountHolder.increment(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(String key) {</span><br><span class="line">        unlock(Collections.singletonList(key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(List&lt;String&gt; keyList) {</span><br><span class="line">        List&lt;String&gt; releaseKeyList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        // 重入 -1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            if (LockKeyCountHolder.decrement(key) == 0) {</span><br><span class="line">                releaseKeyList.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 释放锁</span><br><span class="line">        cacheService.del(releaseKeyList.toArray(new String[0]));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LockKeyCountHolder：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 已锁的 key 重入计数</span><br><span class="line"> *</span><br><span class="line"> * @author mianxian</span><br><span class="line"> * 2023/8/2 14:56</span><br><span class="line"> */</span><br><span class="line">public class LockKeyCountHolder {</span><br><span class="line"></span><br><span class="line">    private LockKeyCountHolder() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * lockKey -&gt; 重入次数</span><br><span class="line">     */</span><br><span class="line">    private static final ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; THREAD_LOCAL = ThreadLocal.withInitial(Maps::newConcurrentMap);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 +1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int increment(String key) {</span><br><span class="line">        int count = get(key);</span><br><span class="line">        THREAD_LOCAL.get().put(key, ++count);</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取计数</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int get(String key) {</span><br><span class="line">        Map&lt;String, Integer&gt; keyMap = THREAD_LOCAL.get();</span><br><span class="line">        return keyMap.getOrDefault(key, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数是否 &gt; 0</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 是否 &gt; 0</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static boolean exist(String key) {</span><br><span class="line">        return get(key) &gt; 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 -1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int decrement(String key) {</span><br><span class="line">        if (!exist(key)) {</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int count = get(key) - 1;</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            THREAD_LOCAL.get().remove(key);</span><br><span class="line">        } else {</span><br><span class="line">            THREAD_LOCAL.get().put(key, count);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>1106. 解析布尔表达式</title>
    <url>/ef40641adb89/</url>
    <content><![CDATA[<p>给你一个以字符串形式表述的&nbsp;布尔表达式（boolean） expression，返回该式的运算结果。<br>有效的表达式需遵循以下约定：</p>
<ul>
<li>“t”，运算结果为 True</li>
<li>“f”，运算结果为 False</li>
<li>“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）</li>
<li>“&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）</li>
<li>“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）</li>
</ul>
<span id="more"></span>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>截取子表达式字符串，每个字符串递归，效率较低</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"t"</span>.equals(expression)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"f"</span>.equals(expression)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取标志位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> expression.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 分解内部表达式 </span></span><br><span class="line">        <span class="comment">// e.g.|(&amp;(t,f,t),!(t)) =&gt; [&amp;(t,f,t), !(t)]</span></span><br><span class="line">        List&lt;String&gt; innerExps = getInnerExpression(expression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'!'</span>) <span class="keyword">return</span> !parseBoolExpr(innerExps.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &amp;</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'&amp;'</span>) {</span><br><span class="line">            <span class="keyword">for</span> (String innerExp : innerExps) {</span><br><span class="line">                <span class="keyword">if</span> (!parseBoolExpr(innerExp)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// |</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'|'</span>) {</span><br><span class="line">            <span class="keyword">for</span> (String innerExp : innerExps) {</span><br><span class="line">                <span class="keyword">if</span> (parseBoolExpr(innerExp)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getInnerExpression</span><span class="params">(String exp)</span> {</span><br><span class="line">        <span class="comment">// exp &lt;=&gt; !(innerExpStr)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">innerExpStr</span> <span class="operator">=</span> exp.substring(<span class="number">2</span>, exp.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">char</span>[] innerExpCharArray = innerExpStr.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bracketsNumDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; innerExpCharArray.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (innerExpCharArray[i] == <span class="string">'('</span>) {</span><br><span class="line">                bracketsNumDiff++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (innerExpCharArray[i] == <span class="string">')'</span>) {</span><br><span class="line">                bracketsNumDiff--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逗号时判断</span></span><br><span class="line">            <span class="keyword">if</span> (bracketsNumDiff == <span class="number">0</span> &amp;&amp; innerExpCharArray[i] == <span class="string">','</span>) {</span><br><span class="line">                result.add(innerExpStr.substring(preIndex, i));</span><br><span class="line">                <span class="comment">// preIndex 设为逗号后的点，i 跳过 preIndex</span></span><br><span class="line">                preIndex = i++ + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        result.add(innerExpStr.substring(preIndex));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优化后的递归，使用全局索引</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> {</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'t'</span>) {</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'f'</span>) {</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'!'</span>) {</span><br><span class="line">                index += <span class="number">2</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> parseBoolExpr(expression);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> !t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'&amp;'</span>) {</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    index++;</span><br><span class="line">                    t &amp;= parseBoolExpr(expression);</span><br><span class="line">                } <span class="keyword">while</span> (expression.charAt(index) == <span class="string">','</span>);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'|'</span>) {</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    index++;</span><br><span class="line">                    t |= parseBoolExpr(expression);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (expression.charAt(index) == <span class="string">','</span>);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2>]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>1620. 网络信号最好的坐标</title>
    <url>/9dc3e8a4d1b1/</url>
    <content><![CDATA[<p>给你一个数组 towers&nbsp;和一个整数 radius 。<br>数组&nbsp; towers&nbsp; 中包含一些网络信号塔，其中&nbsp;towers [i] = [xi, yi, qi]&nbsp;表示第&nbsp;i&nbsp;个网络信号塔的坐标是&nbsp;(xi, yi)&nbsp;且信号强度参数为&nbsp;qi&nbsp;。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;整数&nbsp;坐标。两个坐标之间的距离用 欧几里得距离&nbsp;计算。<br>整数&nbsp;radius&nbsp;表示一个塔 能到达&nbsp;的 最远距离&nbsp;。如果一个坐标跟塔的距离在 radius&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius&nbsp;以外的距离该塔是 不能到达的&nbsp;。<br>如果第 i&nbsp;个塔能到达 (x, y)&nbsp;，那么该塔在此处的信号为&nbsp;⌊qi / (1 + d)⌋&nbsp;，其中&nbsp;d&nbsp;是塔跟此坐标的距离。一个坐标的 信号强度 是所有 能到达&nbsp;该坐标的塔的信号强度之和。<br>请你返回数组 [cx, cy] ，表示 信号强度 最大的 整数 坐标点&nbsp;(cx, cy) 。如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。<br>注意：</p>
<ul>
<li>坐标&nbsp;(x1, y1)&nbsp;字典序比另一个坐标&nbsp;(x2, y2) 小，需满足以下条件之一：<ul>
<li>要么&nbsp;x1 &lt; x2&nbsp;，</li>
<li>要么&nbsp;x1 == x2 且&nbsp;y1 &lt; y2&nbsp;。</li>
</ul>
</li>
<li>⌊val⌋&nbsp;表示小于等于&nbsp;val&nbsp;的最大整数（向下取整函数）。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 详解</title>
    <url>/a39820b4ce4b/</url>
    <content><![CDATA[<p>把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>
<span id="more"></span>

<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        });</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        });</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1c45d75a23f37590ab5f8138426690ad.png"></p>
<p>ThreadLocal#set：把值存到当前线程的 ThreadLocalMap 中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> {</span><br><span class="line">    <span class="comment">// 线程中的 ThreadLocalMap 类型字段</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"> </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>ThreadLocal 对象 new 后有强引用，而当前线程中的 ThreadLocalMap 对象的键也有 ThreadLocal 对象的弱引用，所以当 ThreadLocal 对象失去强引用时 ThreadLocalMap 中对应的键也会变为 null，防止了内存泄露。</p>
<p>虽然 ThreadLocalMap 的键为 null 了，但是其 value 值还存在所以依然会有内存泄露，所以需要执行 ThreadLocal#remove 方法。<br><a href="https://www.jianshu.com/p/da9d051dcc3d">Java 技术之 AQS 详解</a></p>
<p>内部维护一个 state 和一个双向线程链表</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/37dad34951493ee77b1058a67e6356b0.png"></p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/82c79dff8f34a6e45717d561477e01ac.png"></p>
<ol>
<li>ReentrantLock#lock <ol>
<li><p>AbstractQueuedSynchronizer#compareAndSetState：CAS 把 state 从 0 变为 1，若成功则代表拿到锁 </p>
</li>
<li><p>AbstractOwnableSynchronizer#setExclusiveOwnerThread：若抢到锁，则设置当前线程为独占线程 </p>
</li>
<li><p>AbstractQueuedSynchronizer#acquire </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>ReentrantLock.NonfairSync#tryAcquire<br>  1. ReentrantLock.Sync#nonfairTryAcquire： </p>
<ul>
<li>state 为 0，则继续调用 compareAndSetState 抢锁（尝试把 state 变为 1，成功则接着调用 setExclusiveOwnerThread）</li>
<li>state 为 &gt; 0，且当前线程是独占访问的那个线程（说明锁重入），则 state++（此时 state 代表重入线程数）</li>
<li>否则 TryAcquire 失败</li>
</ul>
</li>
<li><p> TryAcquire 失败则调用 AbstractQueuedSynchronizer#addWaiter：使用 CAS 加入链表队列</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> {</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// jdk 9 使用 VarHandler.set(this, pred)。</span></span><br><span class="line">        <span class="comment">// VarHandler 内部有 CAS 的方法</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) {</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><br>jdk 9 使用 <code>VarHandler.set(this, pred)</code> 代替 <code>node.prev = pred;</code>，其调用 native 实现（相当于直接操纵二进制码），效率比反射高<br>VarHandler 指向一个变量  </p>
<pre><code>     1. AbstractQueuedSynchronizer#acquireQueued：加入队列后不断监听前一个节点，若前节点为头结点（已拿到锁），则试图去抢锁，成功则返回 false（不中断）
</code></pre>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/34494674">深度揭秘 ThreadLocal</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>1668. 最大重复子字符串</title>
    <url>/084a2e22f3ba/</url>
    <content><![CDATA[<p>给你一个字符串&nbsp;sequence&nbsp;，如果字符串 word&nbsp;连续重复&nbsp;k&nbsp;次形成的字符串是&nbsp;sequence&nbsp;的一个子字符串，那么单词&nbsp;word 的 重复值为 k 。单词 word&nbsp;的 最大重复值&nbsp;是单词&nbsp;word&nbsp;在&nbsp;sequence&nbsp;中最大的重复值。如果&nbsp;word&nbsp;不是&nbsp;sequence&nbsp;的子串，那么重复值&nbsp;k&nbsp;为 0 。<br>给你一个字符串 sequence&nbsp;和 word&nbsp;，请你返回 最大重复值&nbsp;k 。</p>
<span id="more"></span>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRepeating</span><span class="params">(String sequence, String word)</span> {</span><br><span class="line">        <span class="type">char</span>[] seqArray = sequence.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] wordArray = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> seqArray.length - wordArray.length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> s + wordArray.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (e &lt;= seqArray.length) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; e; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (seqArray[j] != wordArray[j - s]) <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (j == e) {</span><br><span class="line">                    cnt++;</span><br><span class="line">                    s = e;</span><br><span class="line">                    e += wordArray.length;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; result) result = cnt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f81256185fb2eaa9a76f211b218fe376.png" alt="image.png"></p>
<h2 id="简单枚举-动态规划"><a href="#简单枚举-动态规划" class="headerlink" title="简单枚举 + 动态规划"></a>简单枚举 + 动态规划</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c0150a85f67492b303819cdc095c976c.png" alt="image.png"></p>
<h2 id="KMP-算法-动态规划"><a href="#KMP-算法-动态规划" class="headerlink" title="KMP 算法 + 动态规划"></a>KMP 算法 + 动态规划</h2><p>方法一的数组 valid 本质上就是标记了字符串 word 在字符串 sequence 中所有出现的位置。而我们可以使用更高效的 <a href="https://oi-wiki.org/string/kmp/">KMP 算法</a> 在 O (m+n) O (m+n) 的时间内得到数组 valid。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRepeating</span><span class="params">(String sequence, String word)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sequence.length(), m = word.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] fail = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; word.charAt(j + <span class="number">1</span>) != word.charAt(i)) {</span><br><span class="line">                j = fail[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(j + <span class="number">1</span>) == word.charAt(i)) {</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; word.charAt(j + <span class="number">1</span>) != sequence.charAt(i)) {</span><br><span class="line">                j = fail[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(j + <span class="number">1</span>) == sequence.charAt(i)) {</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span> (j == m - <span class="number">1</span>) {</span><br><span class="line">                    f[i] = (i &gt;= m ? f[i - m] : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                    j = fail[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(f).max().getAsInt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O (m + n) O (m+n)，其中 nn 和 mm 分别是字符串 sequence 和 word 的长度。</li>
<li>空间复杂度：O (m + n) O (m+n)，即为 KMP 算法中的数组 fail 以及数组 f 需要使用的空间。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489813&amp;idx=1&amp;sn=7f3bc18ca390d85b17655f7164d8e660">【字符串哈希】字符串哈希入门</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/77e54569881e1323d57e605359c57fc2.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>790. 多米诺和托米诺平铺</title>
    <url>/8a6c84365f71/</url>
    <content><![CDATA[<p>有两种形状的瓷砖：一种是&nbsp;2 x 1 的多米诺形，另一种是形如&nbsp;“L” 的托米诺形。两种形状都可以旋转。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9ba5351e90e431406c86a1f5aeb30dd5.png" alt="image.png"></p>
<p>给定整数 n ，返回可以平铺&nbsp;2 x n 的面板的方法的数量。返回对&nbsp;109&nbsp;+ 7&nbsp;取模&nbsp;的值。<br>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>
<span id="more"></span>
<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTilings</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d[i][0] =&gt; 第 i 列上面占位</span></span><br><span class="line">        <span class="comment">// d[i][1] =&gt; 第 i 列下面占位</span></span><br><span class="line">        <span class="comment">// d[i][2] =&gt; 第 i 列都占位</span></span><br><span class="line">        <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) {</span><br><span class="line">            d[i][<span class="number">0</span>] = (d[i - <span class="number">1</span>][<span class="number">1</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">            d[i][<span class="number">1</span>] = (d[i - <span class="number">1</span>][<span class="number">0</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">            d[i][<span class="number">2</span>] = (((d[i - <span class="number">1</span>][<span class="number">2</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD + d[i - <span class="number">1</span>][<span class="number">0</span>]) % MOD + d[i - <span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d[n - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>TODO</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>481. 神奇字符串</title>
    <url>/5889a7e516e2/</url>
    <content><![CDATA[<p>神奇字符串 s 仅由 ‘1’ 和 ‘2’ 组成，并需要遵守下面的规则：</p>
<ul>
<li>神奇字符串 s 的神奇之处在于，串联字符串中 ‘1’ 和 ‘2’ 的连续出现次数可以生成该字符串。</li>
</ul>
<p>s 的前几个元素是 s = “1221121221221121122……” 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 “1 22 11 2 1 22 1 22 11 2 11 22 ……” 。每组中 1 或者 2 的出现次数分别是 “1 2 2 1 1 2 1 2 2 1 2 2 ……” 。上面的出现次数正是 s 自身。<br>给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。</p>
<span id="more"></span>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">magicalString</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        result[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) {</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (result[i++] == <span class="number">1</span>) {</span><br><span class="line">                sum++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result[s] == <span class="number">2</span> &amp;&amp; i &lt; n) {</span><br><span class="line">                result[i] = result[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (result[i++] == <span class="number">1</span>) {</span><br><span class="line">                    sum++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            s++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>双指针推导题，没啥可说的，就是题目文字多了点。。。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>792. 匹配子序列的单词数</title>
    <url>/66915abb06c0/</url>
    <content><![CDATA[<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<code>words[i]</code>&nbsp;中是 <code>s</code> 的子序列的单词个数&nbsp;。<br>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符 (可以是 none)，而不改变其余字符的相对顺序。</p>
<ul>
<li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>864. 获取所有钥匙的最短路径</title>
    <url>/1728e5a327c0/</url>
    <content><![CDATA[<p>给定一个二维网格&nbsp;grid&nbsp;，其中：</p>
<ul>
<li><code>'.'</code> 代表一个空房间</li>
<li><code>'#'</code> 代表一堵</li>
<li><code>'@'</code>&nbsp;是起点</li>
<li>小写字母代表钥匙</li>
<li>大写字母代表锁</li>
</ul>
<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 k&nbsp;为 钥匙 / 锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>
<span id="more"></span>
<h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">35</span>, K = <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N][N][<span class="number">1</span> &lt;&lt; K];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]{{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">0</span>,-<span class="number">1</span>}};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] g)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length, m = g[<span class="number">0</span>].length(), cnt = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                Arrays.fill(dist[i][j], INF);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[i].charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'@'</span>) {</span><br><span class="line">                    d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, j, <span class="number">0</span>});</span><br><span class="line">                    dist[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) {</span><br><span class="line">            <span class="type">int</span>[] info = d.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> info[<span class="number">0</span>], y = info[<span class="number">1</span>], cur = info[<span class="number">2</span>], step = dist[x][y][cur];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] di : dirs) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + di[<span class="number">0</span>], ny = y + di[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[nx].charAt(ny);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="string">'A'</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ncur</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) ncur |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ncur == (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (step + <span class="number">1</span> &gt;= dist[nx][ny][ncur]) <span class="keyword">continue</span>;</span><br><span class="line">                dist[nx][ny][ncur] = step + <span class="number">1</span>;</span><br><span class="line">                d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{nx, ny, ncur});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>891. 子序列宽度之和</title>
    <url>/38f6854c01e2/</url>
    <content><![CDATA[<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。<br>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>1e9 + 7</code> <strong>取余</strong> 后的结果。<br><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>
<span id="more"></span>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pow2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2</span> % MOD; <span class="comment">// 预处理 2 的幂次</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += (<span class="type">long</span>) (pow2[i] - pow2[n - <span class="number">1</span> - i]) * nums[i]; <span class="comment">// 在题目的数据范围下，这不会溢出</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (ans % MOD + MOD) % MOD; <span class="comment">// 注意上面有减法，ans 可能为负数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>754. 到达终点数字</title>
    <url>/7fe9682c61b6/</url>
    <content><![CDATA[<p>在一根无限长的数轴上，你站在 0 的位置。终点在 target 的位置。<br>你可以做一些数量的移动 numMoves :</p>
<ul>
<li>每次你可以选择向左或向右移动。</li>
<li>第 i&nbsp;次移动（从 &nbsp;i == 1&nbsp;开始，到&nbsp;i == numMoves ），在选择的方向上走 i&nbsp;步。</li>
</ul>
<p>给定整数&nbsp;target ，返回 到达目标所需的 最小&nbsp;移动次数 (即最小 numMoves)&nbsp;。</p>
<span id="more"></span>
<h2 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachNumber</span><span class="params">(<span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) target = -target;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil((Math.sqrt(<span class="number">1</span> + <span class="number">8</span> * (<span class="type">double</span>) target) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="number">1</span> + k) * k / <span class="number">2</span> - target;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">return</span> ((k + <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span> ? k + <span class="number">1</span> : k + <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cd93f41c4b9e8b2fa85ccfcbbaa922f9.png" alt="image.png"></p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">reachNumber</span><span class="params">(<span class="type">int</span> target)</span> {</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pos;</span><br><span class="line">        pos.push(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pos.empty()){</span><br><span class="line">            <span class="keyword">if</span>(target==pos.front().first)</span><br><span class="line">                <span class="keyword">return</span> pos.front().second;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nowPos=pos.front().first;</span><br><span class="line">                <span class="type">int</span> step=pos.front().second;</span><br><span class="line">                pos.push(make_pair(nowPos+step+<span class="number">1</span>,step+<span class="number">1</span>));</span><br><span class="line">                pos.push(make_pair(nowPos-step-<span class="number">1</span>,step+<span class="number">1</span>));</span><br><span class="line">                pos.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DP（0-1背包）"><a href="#DP（0-1背包）" class="headerlink" title="DP（0-1背包）"></a>DP（0-1 背包）</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/246e489c91161cdfb8b80ab2f2dc4de6.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深入检出 Redis Cluster ①：概述及部署</title>
    <url>/e5fe2b66b411/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><strong><em>采用虚拟槽分片：</em></strong></p>
<ul>
<li>每个节点分配一堆槽</li>
<li>每个节点与其他所有节点共享消息</li>
<li>官方指定全部槽数量为 16384（0-16383）</li>
<li>每个节点有主从复制</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/be3189a2010a7f13a39bbe83c05888c4.png" alt="image.png"><br><strong><em>命令：</em></strong></p>
<ul>
<li><strong>cluster nodes：</strong> 查看自动生成的集群本地配置文件记录</li>
<li><strong> cluster info：</strong> 集群信息</li>
<li><strong> cluster meet ip port：</strong> 两个 cluster 节点之间的消息沟通</li>
<li><strong> cluster addslots slot [slot…]：</strong> 为节点分配槽</li>
<li><strong> cluster slots：</strong> 查看槽的分配信息</li>
<li><strong> cluster replicate ${node-id}：</strong> 设置主从关系</li>
<li><strong> cluster forget ${downNodeId}：</strong> 遗忘节点</li>
<li> ** cluster keyslot ${key}：** 返回 key 对应的槽</li>
</ul>
<span id="more"></span>
<h1 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h1><p><strong><em>配置：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6379.log"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主从复制依赖于 rdb</span></span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前节点是一个 cluster 节点</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">节点超时时间</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群本地配置文件记录，自动生成</span></span><br><span class="line">cluster-config-file nodes-${port}.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部节点正常时集群才能提供服务</span></span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>获取节点信息命令：</em></strong></p>
<ul>
<li><strong>cluster nodes：</strong> 查看自动生成的集群本地配置文件记录</li>
<li><strong> cluster info：</strong> 集群信息</li>
</ul>
<h2 id="1-原生部署"><a href="#1-原生部署" class="headerlink" title="1. 原生部署"></a>1. 原生部署</h2><h3 id="1-1-启动"><a href="#1-1-启动" class="headerlink" title="1.1. 启动"></a>1.1. 启动</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2-meet"><a href="#1-2-meet" class="headerlink" title="1.2. meet"></a>1.2. meet</h3><p><strong><em>cluster meet ip port：</em></strong> 两个 cluster 节点之间的消息沟通</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-3-分配槽"><a href="#1-3-分配槽" class="headerlink" title="1.3. 分配槽"></a>1.3. 分配槽</h3><p><strong><em>cluster addslots slot [slot…]：</em></strong> 为节点分配槽<br><strong><em>cluster slots：</em></strong> 查看槽的分配信息<br><strong><em>addslots.sh：</em></strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">host=$1</span><br><span class="line">port=$2</span><br><span class="line">start=$3</span><br><span class="line">end=$4</span><br><span class="line">for slot in `seq ${start} ${end}`</span><br><span class="line">do</span><br><span class="line">    redis-cli -h ${host} -p ${port} cluster addslots ${slot}</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sh addslots.sh 127.0.0.1 7000 0 5461</span><br><span class="line">sh addslots.sh 127.0.0.1 7001 5462 10922</span><br><span class="line">sh addslots.sh 127.0.0.1 7002 10923 16383</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-4-设置主从"><a href="#1-4-设置主从" class="headerlink" title="1.4. 设置主从"></a>1.4. 设置主从</h3><p><strong><em>cluster replicate node-id：</em></strong> 设置主从关系<br><strong><em>通过 cluster nodes 命令获取 node-id：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/61bab65c2a4da3d275b69bd79b883d3a.png" alt="image.png"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 7003 cluster replicate ${node-id-7000}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-使用-redis-trib-部署（需要-ruby-环境）"><a href="#2-使用-redis-trib-部署（需要-ruby-环境）" class="headerlink" title="2. 使用 redis-trib 部署（需要 ruby 环境）"></a>2. 使用 redis-trib 部署（需要 ruby 环境）</h2><h3 id="2-1-启动"><a href="#2-1-启动" class="headerlink" title="2.1. 启动"></a>2.1. 启动</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-2-创建"><a href="#2-2-创建" class="headerlink" title="2.2. 创建"></a>2.2. 创建</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--replicas 1表示每个节点的备份数为1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7000 7001 7002 为主</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7003 7004 7005 为从</span></span><br><span class="line">./redis1-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis Cluster ③：客户端</title>
    <url>/5e25fb4bf698/</url>
    <content><![CDATA[<h2 id="1-moved-重定向"><a href="#1-moved-重定向" class="headerlink" title="1. moved 重定向"></a>1. moved 重定向</h2><p><strong><em>概述：</em></strong> 客户端存取键值的时候使用的重定向</p>
<ul>
<li>命中则直接返回</li>
<li>不命中则返回目标 ip 及对应的槽给客户端，通过 cluster keyslot ${key} 命令可算出 key 对应的槽</li>
</ul>
<p><strong><em>-c：</em></strong> cluster 模式执行，出现 moved 不命中的情况可直接跳转到对应节点上执行命令。非 cluster 模式时会出现 moved 错误<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/116076ca37beeae6639ab4745ce2ed33.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="2-ask-重定向"><a href="#2-ask-重定向" class="headerlink" title="2. ask 重定向"></a>2. ask 重定向</h2><p><strong><em>概述：</em></strong> 扩容或缩容中槽在迁移时客户端访问源节点发生的重定向</p>
<ol>
<li>客户端向源节点发送键命令后源节点回复 ask 转向</li>
<li>客户端再向目标节点发送 Asking 命令</li>
</ol>
<h2 id="3-smart-客户端"><a href="#3-smart-客户端" class="headerlink" title="3. smart 客户端"></a>3. smart 客户端</h2><p><strong><em>原理：</em></strong><br>假设有 n 个节点，若随机选择一个结点发送命令，那么命中率为 n/1，有性能问题<br>smart 客户端先为所有节点创建连接池，再根据 key 获得相应的 slot 进行直连<br><strong><em>过程：</em></strong></p>
<ol>
<li>从集群中选一个可运行节点，得到 cluster slots 的映射集，为每个节点创建 JedisPool</li>
<li> 执行键命令</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d3f7a10ccd09f32f917f953c4f9070b.png" alt="image.png"><br><strong><em>工厂类：</em></strong></p>
<ul>
<li>无需手动归还连接池</li>
<li>使用单例模式 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">@Conponent</span><br><span class="line">public class JedisClusterFactory {</span><br><span class="line">    private JedisCluster jedisCluster;</span><br><span class="line">    private List&lt;String&gt; hostPortList;</span><br><span class="line">    private int timeout;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(JedisClusterFactory.class);</span><br><span class="line">    </span><br><span class="line">    public void init() {</span><br><span class="line">        // 可以设置相关参数</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        </span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = new HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        for (String hostPort : hostPortList) {</span><br><span class="line">            String[] arr = hostPort.split(":");</span><br><span class="line">            if (arr.length != 2) {</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">            nodeSet.add(new HosrAndPort(arr[0], Integer.parseInt(arr[1])));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        try {</span><br><span class="line">            jedisCluster = new JedisCluster(nodeSet, timeout, jedisPoolConfig);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void destroy() {</span><br><span class="line">        if (jedisCluster != null) {</span><br><span class="line">            try {</span><br><span class="line">                jedisCluster.close();                </span><br><span class="line">            } catch (IOException e) {</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // set and get</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<strong><em>获取所有节点：</em></strong><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">// 获取所有节点的连接池</span><br><span class="line">Map&lt;String, JedisPool&gt; jedisPoolMap = jedisCluster.getClusterNodes();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis Cluster ②：集群伸缩</title>
    <url>/03cdb7782275/</url>
    <content><![CDATA[<p><strong><em>概述：</em></strong> 槽和数据在节点之间移动<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2e2bc7631836cb377850f7c201c02975.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="1-扩容"><a href="#1-扩容" class="headerlink" title="1. 扩容"></a>1. 扩容</h2><h3 id="1-1-添加节点"><a href="#1-1-添加节点" class="headerlink" title="1.1. 添加节点"></a>1.1. 添加节点</h3><p><strong><em>具体实现：</em></strong></p>
<ol>
<li><strong>redis-cli 命令：</strong> meet</li>
<li><strong>redis-trib 命令：</strong> ./redis-trib.rb add-node mhost:mport shost:sport</li>
</ol>
<h3 id="1-2-迁移槽和数据"><a href="#1-2-迁移槽和数据" class="headerlink" title="1.2. 迁移槽和数据"></a>1.2. 迁移槽和数据</h3><p><strong><em>概述：</em></strong> 从源节点迁移数据到目标节点<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0be390675381ca0c337991dd3b314480.png" alt="image.png"></p>
<ol>
<li><strong>目标节点准备导入槽 {slot}：</strong> 目标节点执行 cluster setslot {slot} importing {sourceNodeId}</li>
<li><strong> 源节点准备导出槽 {slot}：</strong> 源节点执行 cluster setslot {slot} migrating {targetNodeId}</li>
<li><strong> 获取源节点 {slot} 槽下的 {count} 个键：</strong> 源节点执行 cluster getkeysinslot {slot} {count}</li>
<li><strong> 批量迁移相关键的数据：</strong> 源节点执行 migrate {targetIp} {targetPort} key 0 {timeout}</li>
<li><strong> 循环迁移数据：</strong> 循环执行 3、4 步骤直到槽下所有的键数据迁移到目标节点</li>
<li><strong>通知 {slot} 槽被目标节点负责：</strong> 向所有节点发送 cluster setslot {slot} node {targetNodeId}</li>
</ol>
<p><strong><em>具体实现：</em></strong></p>
<ul>
<li>redis-trib.rb reshard host:port</li>
</ul>
<h2 id="2-缩容"><a href="#2-缩容" class="headerlink" title="2. 缩容"></a>2. 缩容</h2><p><strong><em>步骤：</em></strong></p>
<ol>
<li>迁移槽： 同扩容</li>
<li>所有节点遗忘下线节点： cluster forget {downNodeId}</li>
<li> 关闭节点</li>
</ol>
<p><strong><em>具体实现：</em></strong></p>
<ul>
<li>迁移槽： redis-trib.rb reshard host:port –from {fromNodeId} –to {toNodeId} –slots {slotNums}</li>
<li> 遗忘下线节点： redis-trib.rb del-node host:port {downNodeId}</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis Cluster ④：故障转移</title>
    <url>/3ccd4fe86b25/</url>
    <content><![CDATA[<h2 id="1-故障发现"><a href="#1-故障发现" class="headerlink" title="1. 故障发现"></a>1. 故障发现</h2><p><strong><em>概述：</em></strong> 通过 ping/pong 消息实现故障发现，不需要 sentinel<br><strong><em>主观下线 流程：</em></strong><br>ping 超时则认为主观下线<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/43c60451a837a93ffcc4f34c4f7710ca.png" alt="image.png"><br><strong><em>客观下线 流程：</em></strong><br>半数以上持有槽的主节点都标记某节点主观下线时<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/53a11b50de8e1a700bb532d0531448fc.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39b92057c1916a19179e6c37c2ca891.png" alt="image.png"></p>
<span id="more"></span>
<h2 id="2-故障转移"><a href="#2-故障转移" class="headerlink" title="2. 故障转移"></a>2. 故障转移</h2><p><strong><em>概述：</em></strong> 发现故障后，故障节点的从节点替代主节点工作<br><strong><em>流程：</em></strong></p>
<ul>
<li><p><strong><em>检查从节点资格：</em></strong> 每个从节点检查与其故障的主节点的断线时间，若超过 》cluster-node-timeout * cluster-slave-validity-factor 则取消资格</p>
<blockquote>
<p>cluster-node-timeout 默认为 15s，cluster-slave-validity-factor 默认为 10</p>
</blockquote>
</li>
<li><p><strong><em>偏移量优先：</em></strong> 偏移量更小的从节点延迟选举时间越小，越能更快开始选举，获得的票数也越多</p>
</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d3624377185a40982f8dbfd65d524299.png" alt="image.png"></p>
<ul>
<li><strong><em>开始选举：</em></strong> 每个主节点对从节点投票</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a0b75d0c32e6daf58b0059940a5f15c2.png" alt="image.png"></p>
<ul>
<li><strong><em>替换主节点：</em></strong> 选举成功的从节点变为主节点</li>
<li><strong><em>替换槽：</em></strong> 执行 clusterDelSlot 撤销故障主节点的槽，并执行 clusterAddSlot 把相应的槽分配给选出的从节点</li>
<li><strong><em>通知集群：</em></strong> 向集群广播自己的 pong 消息，表明已替换故障主节点</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>764. 最大加号标志</title>
    <url>/6dc201714435/</url>
    <content><![CDATA[<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [xi, yi]</code> 表示&nbsp;<code>grid[xi][yi] == 0</code><br>返回 &nbsp;<code>grid</code> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong><em>轴对齐</em></strong> 加号标志的阶数 。如果未找到加号标志，则返回 <code>0</code> 。</p>
<p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<code>1</code>&nbsp;组成的 <strong><em>“轴对称” 加号标志</em></strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及 4 个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p>
<span id="more"></span>
<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] mines)</span> {</span><br><span class="line">        <span class="type">boolean</span>[][] map = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mines.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> mines[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span>  <span class="operator">=</span> mines[i][<span class="number">1</span>];</span><br><span class="line">            map[x][y] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n % <span class="number">2</span> == <span class="number">0</span> ? n - <span class="number">1</span>: n;</span><br><span class="line">        <span class="keyword">for</span> (; m &gt; <span class="number">0</span>; m -= <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// i =&gt; 上下偏移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">                <span class="comment">// j =&gt; 左右偏移</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n - m; j++) {</span><br><span class="line">                    <span class="comment">// 横向</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> m / <span class="number">2</span> + i;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j;</span><br><span class="line">                    <span class="keyword">for</span> (; y &lt; j + m; y++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 横向有 0</span></span><br><span class="line">                    <span class="keyword">if</span> (y != j + m) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 纵向</span></span><br><span class="line">                    x = i;</span><br><span class="line">                    y = m / <span class="number">2</span> + j;</span><br><span class="line">                    <span class="keyword">for</span> (; x &lt; i + m; x++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 可行，返回</span></span><br><span class="line">                    <span class="keyword">if</span> (x == i + m) {</span><br><span class="line">                        <span class="keyword">return</span> m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>深入检出 Redis Sentinel ①：概述</title>
    <url>/949a0607b70f/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul>
<li>sentinel 是特殊的 redis（不存储数据，支持的命令有限）</li>
<li>多节点实现</li>
<li>默认端口： 26379</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f29a6eefff469e8d170d5cf543f6b38.png" alt="image.png"></p>
<span id="more"></span>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p><strong><em>启动：</em></strong> redis-sentinel redis-sentinel-26379.conf<br><strong><em>查看 sentinel 信息：</em></strong> info sentinel</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir "/opt/soft/redis/data"</span><br><span class="line">logfile "26379.log"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor master名称 ip port n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2个sentinel节点认为 master 有问题则进行故障转移</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">超过 30s 做主观下线判断（单个 sentinel 做下线判断）</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并发复制新的 master 的 slave 数目</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">故障转移时间</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis 主从复制</title>
    <url>/e5d94578b16c/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><strong>单机、单节点、单实例问题</strong></p>
<ul>
<li>单点故障</li>
<li>容量有限</li>
<li>压力</li>
</ul>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2ca3031938d6a22279811aba11b68492.png" alt="image.png"><br>X 轴问题<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a5ef3ff143bff5663034d49986fc1a04.png" alt="image.png"></p>
<ul>
<li>主备数据一致性<ul>
<li>强一致性：降低可用性</li>
<li>最终一致性：使用可靠的速度快的消息队列集群</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong><em>info replication：</em></strong> 分片信息</p>
<h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><p>replicaof： 5.0 以后<br>**<em>slaveof：</em>**5.0 以前</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"># 成为 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> 的从节点</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-取消主从复制"><a href="#2-取消主从复制" class="headerlink" title="2. 取消主从复制"></a>2. 取消主从复制</h2><p><strong><em>slaveof no one：</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-配置方式"><a href="#3-配置方式" class="headerlink" title="3. 配置方式"></a>3. 配置方式</h2><h3 id="3-1-主节点配置"><a href="#3-1-主节点配置" class="headerlink" title="3.1. 主节点配置"></a>3.1. 主节点配置</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">port <span class="number">6379</span></span><br><span class="line">daemonize yes</span><br><span class="line"># pid 文件</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis-<span class="number">6379.</span>pid</span><br><span class="line">logfile <span class="string">"6379.log"</span></span><br><span class="line"># 主从复制依赖于 rdb</span><br><span class="line">dbfilename dump-<span class="number">6379.</span>rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-从节点配置"><a href="#3-2-从节点配置" class="headerlink" title="3.2. 从节点配置"></a>3.2. 从节点配置</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br><span class="line">daemonize yes</span><br><span class="line"># pid 文件</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis-<span class="number">6380.</span>pid</span><br><span class="line">logfile <span class="string">"6380.log"</span></span><br><span class="line"># 主从复制依赖于 rdb</span><br><span class="line">dbfilename dump-<span class="number">6380.</span>rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slaveof ip port</span><br><span class="line"># 从节点只读</span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></tbody></table></figure>
<h1 id="三、主从链"><a href="#三、主从链" class="headerlink" title="三、主从链"></a>三、主从链</h1><p>避免复制风暴<br>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。<br>为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/678b820fef3f7b91d8dc9bcd47e1532d.png" alt="image.png"></p>
<h1 id="四、复制"><a href="#四、复制" class="headerlink" title="四、复制"></a>四、复制</h1><h2 id="1-全量复制"><a href="#1-全量复制" class="headerlink" title="1. 全量复制"></a>1. 全量复制</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c325ce85db6b042d934e7c7e1be5db64.png" alt="image.png"><br><strong><em>全量同步过程：</em></strong></p>
<ol>
<li><strong>获取 runId 和 offset</strong><ol>
<li><em>[1] slave 请求同步：</em> slave 发送 psync runId offset 到 master 请求全量同步。由于不知道 master 的 runId 所以第一次请求发送 psync ? -1</li>
<li><em>[2] master 返回信息：</em> 返回 master 的 runId 和 offset</li>
<li><em>[3] slave 保存信息</em></li>
</ol>
</li>
<li><strong>获取 RDB 文件 和 写命令</strong><ol>
<li>_[4] master 持久化：_maset 异步执行 RDB 持久化（bgsave），同时把这之后执行的写命令加入缓冲区 repl_back_buffer</li>
<li><em>[5] 发送 RDB 文件</em></li>
<li><em> [6] 发送写命令</em></li>
</ol>
</li>
<li><strong>丢弃所有数据，载入 RDB 文件并执行写命令</strong><ol>
<li><em> [7] 丢弃旧数据</em></li>
<li><em> [8] 载入 RDB 文件和写命令</em></li>
</ol>
</li>
</ol>
<h2 id="2-部分复制"><a href="#2-部分复制" class="headerlink" title="2. 部分复制"></a>2. 部分复制</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5dd4051e81f6dd38445c1fd0b858070c.png" alt="image.png"><br>发送 pysnc runId offset 到 master 获取当前偏移量之后的数据</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis Sentinel ②：故障转移</title>
    <url>/c7ad9ade5370/</url>
    <content><![CDATA[<p>可实现 多个主从复制 的故障转移<br><strong><em>主观下线：</em></strong> 一个 sentinel 节点主观地认为某个 redis 节点已下线，即这个主观认知可能是错误的（因网络等因素）<br><strong><em>客观下线：</em></strong> 超过 quorum 个 sentinel 节点认为某个 master 节点已下线，达成共识。通过 sentinel is-master-down-by-addr 询问其他 sentinel 节点对该 master 节点的看法</p>
<blockquote>
<p>sentinel monitor ${masterName} ${ip} ${port} ${quorum} </p>
</blockquote>
<p><strong><em>命令：</em></strong></p>
<ul>
<li>sentinel is-master-down-by-addr：<ul>
<li>客观下线时 sentinel 节点询问其他 sentinel 节点对该 master 节点的看法</li>
<li>选举 sentinel 节点领导</li>
</ul>
</li>
<li> sentinel failover ${masterName}： 手动故障转移</li>
</ul>
<span id="more"></span>
<h2 id="1-定时任务监控"><a href="#1-定时任务监控" class="headerlink" title="1. 定时任务监控"></a>1. 定时任务监控</h2><ol>
<li>每 10 秒每个 sentinel 对 master 和 slave 执行 info<ol>
<li> 发现 slave 节点</li>
<li>确定主从关系</li>
</ol>
</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0535492dae6355ec852d9bd505360a56.png" alt="image.png"></p>
<ol>
<li>每 2 秒每个 sentinel 通过 master 节点的 channel 交换信息（发布 / 订阅）<ol>
<li>通过订阅 <strong>sentinel</strong>:hello 频道实现交互</li>
<li>交互对节点的认知和自身信息</li>
</ol>
</li>
</ol>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d83a8f1f518851e73cd95926a04b73fe.png" alt="image.png"></p>
<ol>
<li>每 1 秒每个 sentinel 对其他 sentinel 和 redis 执行 ping</li>
</ol>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><ol>
<li><strong>发现问题：</strong> 多个 sentinel 结点发现 master 出现问题（主观下线 + 客观下线）</li>
<li><strong>sentinel 选举领导（raft 算法）：</strong> 选举出一个 sentinel 作为领导<ol>
<li><em>拉票：</em> 每个做出了主观下线的 sentinel 节点（A）会向其他 sentinel 节点（B）发送 sentinel is-master-down-by-addr 命令，以获得 B 的投票。若 B 尚未投票则投票给 A</li>
<li><em> 成为领导者：</em> 如果某个拉票的 sentinel 节点获得的票数超过 sentinel 集合的半数且超过 quorum，则成为领导者。若有选出了多个领导者，则重新进行选举</li>
</ol>
</li>
<li><strong> redis 选举新 master：</strong> 从 slave 中选出一个新的 master，并让其余的 slave 成为新 master 的 slave<ol>
<li><em> 优先级：</em> 首先选择 slave-priority（节点优先级）最高的 slave 节点</li>
<li><em>复制完整性：</em> 其次选择复制偏移量最大的（复制最完整的） slave 节点</li>
<li><em>启动最早：</em> 再其次选择 runId 最小的（启动最早的） slave 节点</li>
</ol>
</li>
<li><strong>通知客户端：</strong> 通知客户端主从变化</li>
<li><strong>监听故障 master：</strong> 监听等待故障的 master 恢复，恢复后使其成为新 master 的 slave</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
  <entry>
    <title>深入检出 Redis Sentinel ③：客户端</title>
    <url>/15e20a853a5b/</url>
    <content><![CDATA[<h2 id="1-客户端实现原理"><a href="#1-客户端实现原理" class="headerlink" title="1. 客户端实现原理"></a>1. 客户端实现原理</h2><ol>
<li><strong>获取 Sentinel 节点：</strong> 遍历所有 Sentinel 节点，获取一个可用的 Sentinel 节点</li>
<li><strong>获取 master 节点：</strong> 执行 sentinel get-master-addr-by-name ${masterName} 命令获取 master 节点</li>
<li><strong>验证 master 节点：</strong> 执行 role 或 role replication 命令获取节点信息进行验证其是否故障</li>
<li><strong>故障转移通知：</strong> 当 redis 主从变化时通知客户端<ol>
<li><em> +switch-master：</em> 切换主节点（从节点晋升主节点）</li>
<li><em>+convert-to-slave：</em> 切换从节点（主节点降为从节点）</li>
<li><em>+sdown：</em> 主观下线</li>
</ol>
</li>
</ol>
<span id="more"></span>
<h2 id="2-Jedis"><a href="#2-Jedis" class="headerlink" title="2. Jedis"></a>2. Jedis</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">JedisSentinelPool</span> <span class="variable">sentinelPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(masterName, sentinelSet, poolConfig, timeout);</span><br><span class="line">Jedis = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">redisSentinelPool</span>.getResource();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) {</span><br><span class="line">        jedis.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>集群</category>
      </categories>
  </entry>
</search>
