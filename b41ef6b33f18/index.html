<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta name="google-site-verification" content="5K7puGkNbKLWhZTmZZm6haOpSbJ-oOvUQFYJeMFBJSk">
  <meta name="baidu-site-verification" content="codeva-3O8Y6jTFCL">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ccomma.cn","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 进程进程本质上是正在执行的一个程序，它有程序、输入、输出以及状态。 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。 当一个进程有特定事件要求在指定的若干亳秒内发生，那么必须采取特殊措施以保证它们一定在这段时间中发生。然而，通常大多数进程并不受 CPU 多道程序设计或其他进程相对速度的影响。 守护进程（daemon）：后台执行的进程 地">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统从入门到入土②：进程与线程">
<meta property="og:url" content="https://ccomma.cn/b41ef6b33f18/">
<meta property="og:site_name" content="CComma&#39;s Blog">
<meta property="og:description" content="1. 进程进程本质上是正在执行的一个程序，它有程序、输入、输出以及状态。 单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。 当一个进程有特定事件要求在指定的若干亳秒内发生，那么必须采取特殊措施以保证它们一定在这段时间中发生。然而，通常大多数进程并不受 CPU 多道程序设计或其他进程相对速度的影响。 守护进程（daemon）：后台执行的进程 地">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/828b44f4de1b2b927606a14533ac78a5.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34de6f6d5359a8417458735c0caf39d6.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6bbe3b9f1384ff80400a9cdd30eec6d1.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e84dfc08363c2351445625f328384792.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34097c7499df1cc76fa684893527f7ee.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ac9744832c89093fd00d340a3dc048a5.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8db0ef2450f716996389814f9e4d7665.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/86dd057f2abb5745be8515ff5045dab3.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3fccdb0a67e6fab47c8c5fca1add5d01.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f39086303733b0ad3d17fb855e17217a.png">
<meta property="og:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/545cb74e88b486b863fb5b54e3cf3334.png">
<meta property="article:published_time" content="2021-09-13T02:23:33.000Z">
<meta property="article:modified_time" content="2024-04-02T03:31:44.758Z">
<meta property="article:author" content="CComma">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/828b44f4de1b2b927606a14533ac78a5.png">


<link rel="canonical" href="https://ccomma.cn/b41ef6b33f18/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://ccomma.cn/b41ef6b33f18/","path":"b41ef6b33f18/","title":"操作系统从入门到入土②：进程与线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统从入门到入土②：进程与线程 | CComma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GS592DM662"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GS592DM662","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?152282c2c823c1e5ab34c577ba338801"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="CComma's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/ccomma.png" alt="CComma's Blog">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CComma's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Connect the world</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">20</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">118</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1. 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%BB%88%E6%AD%A2"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. 状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%9E%84%E9%80%A0-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 构造 web 服务器的三种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1. 多线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2. 单线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3. 有限状态机实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8C%85%E7%8E%AF%E5%A2%83"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 实现线程包环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E5%9C%A8%E7%94%A8%E6%88%B7%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1. 在用户态实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E5%9C%A8%E5%86%85%E6%A0%B8%E6%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2. 在内核态实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3. 混合实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. 调度程序激活机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%BC%B9%E5%87%BA%E5%BC%8F%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. 弹出式线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.</span> <span class="nav-text">3. 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E4%BA%92%E6%96%A5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. 互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1. 屏蔽中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E9%94%81%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2. 锁变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E4%B8%A5%E6%A0%BC%E8%BD%AE%E6%8D%A2%E6%B3%95"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3. 严格轮换法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-Peterson-%E8%A7%A3%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4. Peterson 解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-TSL-%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5. TSL 指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. 生产者 - 消费者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. 信号量与互斥量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1. 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2. 互斥量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E7%AE%A1%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. 管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">3.5.</span> <span class="nav-text">3.5. 消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1. 消息传递系统的设计要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E7%94%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2. 用消息传递解决生产者 - 消费者问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%B1%8F%E9%9A%9C"><span class="nav-number">3.6.</span> <span class="nav-text">3.6. 屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E8%AF%BB-%E5%A4%8D%E5%88%B6-%E6%9B%B4%E6%96%B0%EF%BC%88Read-Copy-Update%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">3.7. 读 - 复制 - 更新（Read-Copy-Update）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%B0%83%E5%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">4. 调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">4.2.</span> <span class="nav-text">4.2. 批处理系统中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1. 先来先服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2. 最短作业优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3. 最短剩余时间优先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.</span> <span class="nav-text">4.3. 交互式系统中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1. 轮转调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2. 优先级调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3. 多级队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4. 最短进程优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-%E4%BF%9D%E8%AF%81%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5. 保证调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-6-%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.6.</span> <span class="nav-text">4.3.6. 彩票调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-7-%E5%85%AC%E5%B9%B3%E5%88%86%E4%BA%AB%E8%B0%83%E5%BA%A6"><span class="nav-number">4.3.7.</span> <span class="nav-text">4.3.7. 公平分享调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">4.4.</span> <span class="nav-text">4.4. 实时系统中的调度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-IPC-%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">5. IPC 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.</span> <span class="nav-text">5.1. 哲学家就餐问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.</span> <span class="nav-text">5.2. 读者 - 写者问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%9D%A1%E7%9C%A0%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88"><span class="nav-number">5.3.</span> <span class="nav-text">5.3. 睡眠的理发师</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">5.4.</span> <span class="nav-text">5.4. 练习题</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CComma"
      src="/images/ccomma.png">
  <p class="site-author-name" itemprop="name">CComma</p>
  <div class="site-description" itemprop="description">下一个目标：改变世界！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ccomma" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ccomma" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ccomma_cat" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ccomma_cat" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ccomma.cn/b41ef6b33f18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ccomma.png">
      <meta itemprop="name" content="CComma">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CComma's Blog">
      <meta itemprop="description" content="下一个目标：改变世界！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统从入门到入土②：进程与线程 | CComma's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统从入门到入土②：进程与线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-13 10:23:33" itemprop="dateCreated datePublished" datetime="2021-09-13T10:23:33+08:00">2021-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/b41ef6b33f18/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="b41ef6b33f18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><p>进程本质上是正在执行的一个程序，它有程序、输入、输出以及状态。</p>
<p>单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>
<p>当一个进程有特定事件要求在指定的若干亳秒内发生，那么必须采取特殊措施以保证它们一定在这段时间中发生。然而，通常大多数进程并不受 CPU 多道程序设计或其他进程相对速度的影响。</p>
<p><strong>守护进程（daemon）：</strong>后台执行的进程</p>
<p><strong>地址空间（address space）：</strong><br>这是从某个最小值的存储位置（通常是 0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。</p>
<p><strong>子进程：</strong><br>若一个进程能够创建一个或多个进程（称为 <strong>子进程</strong>），而且这些进程又可以创建子进程，则形成得到进程树。合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信称为 <strong>进程间通信</strong></p>
<h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1. 创建"></a>1.1. 创建</h2><p><strong>4 种创建进程的主要事件：</strong></p>
<ul>
<li>系统初始化创建：启动系统时创建</li>
<li>运行的程序执行创建进程的系统调用：fork</li>
<li> 用户请求创建一个新进程：手动运行软件</li>
<li>一个批处理作业的初始化</li>
</ul>
<p><strong>fork：</strong></p>
<ol>
<li>在调用了 fork 后，这两个进程（父进程和子进程)）拥有相同的内存映像、同样的环境字符串和同样的打开文件。</li>
<li>子进程接着执行 execve 或一个类似的系统调用，以修改其内存映像并运行一个新的程序。</li>
<li>之所以要安排两步建立进程，是为了在 fork 之后 execve 之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</li>
</ol>
<p><strong>父进程与子进程的地址空间：</strong><br>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p>
<p>在 UNIX 中，不可写的内存区是共享的。或者，子进程通过 <strong>写时复制（copy-on-write）</strong>共享父进程的所有内存。若要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。</p>
<p>可写的内存是不可以共享的。但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等。</p>
<h2 id="1-2-终止"><a href="#1-2-终止" class="headerlink" title="1.2. 终止"></a>1.2. 终止</h2><p>通常由下列条件引起：</p>
<ol>
<li>正常退出（自愿的）</li>
<li>出错退出（自愿的）：通常是程序中的错误导致</li>
<li>严重错误（非自愿）：例如编译不存在的文件</li>
<li>被其他进程杀死（非自愿）：某个进程执行一个系统调（kill）用杀死另一个进程</li>
</ol>
<h2 id="1-3-层次结构"><a href="#1-3-层次结构" class="headerlink" title="1.3. 层次结构"></a>1.3. 层次结构</h2><p>在 UNIX 中，进程和它的所有子进程以及后裔共同组成一个进程组。<br>当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。<br>每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。</p>
<blockquote>
<p>UNIX 在启动时如何初始化自己。</p>
<ul>
<li>一个特殊进程 init 出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。</li>
<li>接着，为每个终端创建一个新进程，这些进程等待用户登录。</li>
<li>如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程。</li>
<li>这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</li>
</ul>
</blockquote>
<p>Windows 中没有进程层次的概念，所有的进程都是地位相同的。<br>但是在创建进程的时候，父进程会得到一个 ** 句柄 ** 来控制子进程。<br>父进程可以把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p>
<h2 id="1-4-状态"><a href="#1-4-状态" class="headerlink" title="1.4. 状态"></a>1.4. 状态</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/828b44f4de1b2b927606a14533ac78a5.png" alt="image.png"></p>
<ol>
<li>运行态：正在运行，占用 CPU</li>
<li> 就绪态：因其他进程在运行而暂时停止（未分配到 CPU 时间片）</li>
<li>阻塞态：进程阻塞至某一事件发生（如等待键盘输入、进程等待管道传输数据等）</li>
</ol>
<h2 id="1-5-实现"><a href="#1-5-实现" class="headerlink" title="1.5. 实现"></a>1.5. 实现</h2><p><strong>进程表：</strong><br>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即 <strong>进程表（process table）</strong>。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34de6f6d5359a8417458735c0caf39d6.png" alt="image.png"><br>每个进程占用一个进程表项，其包含了程序计数器、堆栈指针、内存分配状况、锁打开文件的状态、账号和调度信息。</p>
<p>进程由运行态装换到其他状态时必须保存的信息也会保存到进程表中，以保证该进程随后能再次启动。</p>
<p>单一进程的系统不需要进程表，因为单一进程从不挂起。</p>
<p><strong>中断切换程序：</strong><br>与每一 I/O 类关联的是一个叫 ** 中断向量（interrupt vector）** 的位置（靠近内存底部的固定区城）。它包含中断服务程序的入口地址。</p>
<p>当一个磁盘中断发生时，某一用户进程正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，随后跳转到中断向量所指示的地址。<br>这些是硬件完成的所有操作，然后中断服务例程就接管一切剩余的工作。</p>
<p><strong>中断发生后底层工作步骤：</strong></p>
<ol>
<li><p>硬件压入堆栈程序计数器等</p>
</li>
<li><p>硬件从中断向量装入新的程序计数器</p>
</li>
<li><p>汇编语言过程保存寄存器值，设置新的堆栈（无法用 C 实现）</p>
</li>
<li><p>C 中断服务例程运行（典型地读和缓冲输入）</p>
<blockquote>
<p>I/O 设备启动后，管理进程对其信号量执行 down 操作，使其阻塞<br>该步骤在设备的信号量上执行 up 操作，使相关进程设置为就绪状态</p>
</blockquote>
</li>
<li><p>调度程序决定下一个将运行的进程</p>
</li>
<li><p>C 过程返回至汇编代码</p>
</li>
<li><p>汇编语言过程开始运行新的当前进程</p>
</li>
</ol>
<h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><p><strong>必要性：</strong></p>
<ul>
<li>运行某些任务随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</li>
<li>线程比进程更轻量级，线程比进程能更快地被创建，也更容易撤销。在有大量线程需要动态和快速修改时，具有这一特性是很有用的。</li>
<li>性能方面，若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强。但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</li>
</ul>
<p><strong>共享资源：</strong><br>多线程概念要求并行实体要共享同一个地址空间和所有可用数据。<br>对于某些应用而言，这种能力是必需的。而这正是多进程模型（它们具有不同的地址空间）所无法具备的。</p>
<h2 id="2-1-构造-web-服务器的三种方法"><a href="#2-1-构造-web-服务器的三种方法" class="headerlink" title="2.1. 构造 web 服务器的三种方法"></a>2.1. 构造 web 服务器的三种方法</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6bbe3b9f1384ff80400a9cdd30eec6d1.png" alt="image.png"></p>
<h3 id="2-1-1-多线程实现"><a href="#2-1-1-多线程实现" class="headerlink" title="2.1.1. 多线程实现"></a>2.1.1. 多线程实现</h3><p>多线程异步</p>
<ul>
<li>分派线程（dispatcher）：接收请求，分派请求给一个被阻塞工作线程（work thread），通常是在线程某个专门字中写入一个消息指针，接着把它从阻塞状态转为就绪状态；</li>
<li>工作线程：被唤醒后检查是否在缓存中，命中则返回页面。未命中则阻塞调用 read 操作从磁盘获取，直到操作完成；</li>
<li>在此工作线程阻塞的同时，分派线程依然在工作（分派任务）。</li>
</ul>
<h3 id="2-1-2-单线程实现"><a href="#2-1-2-单线程实现" class="headerlink" title="2.1.2. 单线程实现"></a>2.1.2. 单线程实现</h3><ul>
<li>获取请求，查询缓存；</li>
<li>未命中则阻塞的查询磁盘；</li>
<li>此时服务器会空转，不能处理任何其他的请求。</li>
</ul>
<h3 id="2-1-3-有限状态机实现"><a href="#2-1-3-有限状态机实现" class="headerlink" title="2.1.3. 有限状态机实现"></a>2.1.3. 有限状态机实现</h3><p>使用 <strong>有限状态机（finite-state machine）</strong>保存状态，模拟线程及堆栈，并使用非阻塞 I/O。</p>
<ul>
<li>获取请求，查询缓存；</li>
<li>未命中则使用非阻塞的 read 系统调用查询磁盘，并在表格中记录当前请求的状态；</li>
<li>然后去处理下一个事件。<ul>
<li>可能是新的请求，则处理新请求；</li>
<li>可能是磁盘对先前操作的应答（信号或中断的形式），则从表格中取出对应的信息，并处理该应答。</li>
</ul>
</li>
</ul>
<h2 id="2-2-实现线程包环境"><a href="#2-2-实现线程包环境" class="headerlink" title="2.2. 实现线程包环境"></a>2.2. 实现线程包环境</h2><h3 id="2-2-1-在用户态实现"><a href="#2-2-1-在用户态实现" class="headerlink" title="2.2.1. 在用户态实现"></a>2.2.1. 在用户态实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e84dfc08363c2351445625f328384792.png" alt="image.png"><br><strong>结构：</strong><br>用户态模拟多线程，内核仍然是单线程。<br>运行时系统是一个管理线程过程的集合，线程在该系统的上层运行。<br>每个进程都偶有一个线程表，其和进程表类似。</p>
<p><strong>线程切换：</strong><br>调用一个运行时系统的过程进行线程切换，在线程表中保存该线程的寄存器，并把新线程的保存至重新装入及其的寄存器中。<br>只要堆栈指针和程序计数器被切换，新线程就能运行。<br>但始终只能运行该进程内的线程，直到 CPU 调度切换其他进程为止。</p>
<p><strong>优点：</strong></p>
<ul>
<li>在用户态进行线程切换至少比陷入内核要快一个数量级。</li>
<li>用户态线程允许每个进程有自己定制的调度算法。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>线程调度问题：</li>
</ul>
<p>如果一个线程开始运行，除非该线程自动放弃 CPU，否则该进程中的其他线程就不能运行。<br>在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度（轮流）的方式调度线程。除非某个线程能够按照自己的意志进入运行时系统，否则调度程序就没有任何机会。<br>一个可能的解决方案是让运行时系统请求每秒次的时钟信号（中断），但是这样对程序也是生硬和无序的。不可能总是高频率地发生周期性的时钟中断，即使可能，总的开销也是可观的。而且，线程可能也需要时钟中断，这就会扰乱运行时系统使用的时钟。</p>
<ul>
<li>阻塞系统调用问题：</li>
</ul>
<p>用户态线程不能进行阻塞系统调用（阻塞等待键盘输入等），因为会停止所有的线程。可以使用 select 系统调用（包装器）通知 read 是否会阻塞。</p>
<ul>
<li>不阻塞时才进行 read 调用</li>
<li>如果 read 调用会阻塞，就让出运行其他线程</li>
</ul>
<p>需要重写部分系统调用库，效率不高也不优雅。</p>
<ul>
<li>缺页中断问题：</li>
</ul>
<p>把计算机设置成并不是所有的程序都一次性放在内存中这样的一种工作方式。如果某个程序调用或者跳转到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令（和该指令的 “邻居们”），这就称为页面故障。在对所需的指令进行定位和读入时，相关的进程就被阻塞。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p>
<h3 id="2-2-2-在内核态实现"><a href="#2-2-2-在内核态实现" class="headerlink" title="2.2.2. 在内核态实现"></a>2.2.2. 在内核态实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34097c7499df1cc76fa684893527f7ee.png" alt="image.png"><br><strong>结构：</strong><br>在内核中存放线程表记录线程的寄存器、状态和其他信息。</p>
<p><strong>创建和销毁：</strong><br>线程的创建和销毁都得进行系统调用来完成，代价较大。<br>某些系统在回收线程时，只把它标记为不可运行。等到必须创建新线程时再重启这个线程，从而节省一些开销。</p>
<p><strong>线程切换：</strong><br>阻塞都在内核中发生（阻塞系统调用），代价较大。<br>当一个线程阻塞时，内核可以运行同一进程中的另一个线程或运行别的进程中的线程。</p>
<p><strong>问题：</strong></p>
<ul>
<li>进程创建新的进程，新进程的线程数与原进程相同还是只有一个。<ul>
<li>如果新建进程后就要调用 exec 启动一个新程序，最好只复制一个线程，避免不必要的开销。</li>
<li>如果新建进程后，该进程继续执行则最好复制所有的进程。</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-混合实现"><a href="#2-2-3-混合实现" class="headerlink" title="2.2.3. 混合实现"></a>2.2.3. 混合实现</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ac9744832c89093fd00d340a3dc048a5.png" alt="image.png"><br>一种方法是使用内核级线程，然后将用户级线程与其进行多路复用。<br>编程人员可以自定义哪些内核线程和哪些用户线程进行多路复用，灵活度较高。<br>每个内核级线程有一个可以轮流使用的用户级线程集合。</p>
<h2 id="2-3-调度程序激活机制"><a href="#2-3-调度程序激活机制" class="headerlink" title="2.3.调度程序激活机制"></a>2.3. 调度程序激活机制</h2><p>调度程序激活的目标是模拟内核线程的功能，并且为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。避免了在用户空间和内核空间之间的不必要转换。</p>
<ul>
<li>如果用户线程从事某种系统调用时是安全的，那就不应该进行专门的非阻塞调用或者进行提前检查。</li>
<li>如果线程阻塞在某个系统调用或页面故障上，只要在同一个进程中有任何就绪的线程，就应该有可能运行其他的线程。</li>
</ul>
<p><strong>虚拟处理器：</strong><br>当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让用户态中的运行时系统将线程分配到处理器上。</p>
<p><strong>分配与回收：</strong><br>被分配给一个进程的虚拟处理器的初始数量是一个，但是该进程可以申请更多的处理器并且在不用时退回。内核也可以取回已经分配出去的虚拟处理器，以便把它们分给需要更多处理器的进程。</p>
<p><strong>上行调用：</strong><br>当内核了解到一个线程被阻塞之后，内核通过在一个已知的起始地址启动该进程的运行时系统从而发出通知，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。<br>这是对 UNIX 中信号的一种粗略模拟。这个机制称为 ** 上行调用（upcall）**。</p>
<p><strong>线程调度：</strong><br>然后运行时系统就重新调度其线程。</p>
<ol>
<li>把当前线程标记为阻塞并从就绪表中取出另一个线程，设置其寄存器，然后启动它。</li>
<li>当内核知道原来的线程又可运行时，内核会再次上行调用运行时系统，通知它这一事件。</li>
<li>此时该运行时系统按照自己的判断，可能立即重启动被阻塞的线程，也可能把它放入就绪表中稍后运行。</li>
</ol>
<p><strong>中断处理：</strong><br>在某个用户线程运行的同时发生一个硬件中断时，被中断的 CPU 切换进内核态。</p>
<ul>
<li>如果被中断的进程对引起该中断的事件不感兴趣。比如，是另一个进程的 I/O 完成了。</li>
</ul>
<p>那么在中断处理程序结束之后，就把被中断的线程恢复到中断之前的状态。</p>
<ul>
<li>不过，如果该进程对中断感兴趣。比如，是该进程中的某个线程所需要的页面到达了。<ol>
<li>被中断的线程就不再启动，并且被挂起。</li>
<li>运行时系统则启动对应的虚拟 CPU，此时被中断线程的状态保存在堆栈中。</li>
<li>随后，运行时系统决定在该 CPU 上调度哪个线程：被中断的线程、新就绪的线程还是某个第三种选择。</li>
</ol>
</li>
</ul>
<p>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。通常，n 层提供 n + 1 层可调用的特定服务，但是 n 层不能调用 n + 1 层中的过程。上行调用并不遵守这个基本原理。</p>
<h2 id="2-4-弹出式线程"><a href="#2-4-弹出式线程" class="headerlink" title="2.4. 弹出式线程"></a>2.4. 弹出式线程</h2><p>线程如何处理到来的消息？<br>传统的方法是将进程或线程阻塞在一个 receive 系统调用上，等待消息到来。<br>当消息到达时，该系统调用接收消息，并打开消息检查其内容，然后进行处理。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8db0ef2450f716996389814f9e4d7665.png" alt="image.png"><br>另一种方法为 <strong>弹出式线程</strong>，一个消息的到达导致系统创建一个处理该消息的线程。</p>
<p><strong>优势：</strong><br>弹出式线程没有必须存储的寄存器、堆栈等。所以能快速创建这类线程，消息到达与处理开始之间的时间非常短。</p>
<p><strong>内核中运行：</strong></p>
<ul>
<li>在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和 I/O 设备，这些也许在中断处理时有用。</li>
<li>但是，出错的内核线程会比出错的用户线程造成更大的损害。例如，如果某个线程运行时间太长，又没有办法抢占它，就可能造成进来的信息丢失。</li>
</ul>
<h1 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h1><p><strong>问题：</strong><br>线程也存在以下问题</p>
<ul>
<li>信息传递问题：一个进程如何把信息传递给另一个进程</li>
<li>资源竞争问题：如何确保多个进程在关键活动中不会出现交叉</li>
<li>执行顺序问题：比如，进程 A 产生数据而进程 B 打印数据，那么 B 在打印之前必须等待，直到 A 已经产生一些数据。</li>
</ul>
<h2 id="3-1-互斥"><a href="#3-1-互斥" class="headerlink" title="3.1. 互斥"></a>3.1. 互斥</h2><p>我们把对共享内存进行访问的程序片段称作 <strong>临界区域（critical region）</strong>或 <strong>临界区 ( critical section）</strong>。如果能使两个进程不能同时处于临界区中，就能避免竞争。</p>
<p>几种互斥方案用于避免多个进程运行在临界区中。</p>
<h3 id="3-1-1-屏蔽中断"><a href="#3-1-1-屏蔽中断" class="headerlink" title="3.1.1. 屏蔽中断"></a>3.1.1. 屏蔽中断</h3><p>屏蔽中断后，时钟中断也被屏蔽。所以 CPU 将不会切换到其他进程。</p>
<p>但是把屏蔽中断的权利交给用户进程是不合理的。<br>而且在多处理器系统中，其他的 CPU 仍然在运行，并可以访问共享内存。</p>
<h3 id="3-1-2-锁变量"><a href="#3-1-2-锁变量" class="headerlink" title="3.1.2. 锁变量"></a>3.1.2. 锁变量</h3><p>共享的互斥变量作为锁，1 代表占有，0 代表未被占有。只有值为 0 时进程才能进入临界区，并将锁改为 1。</p>
<p>但是读锁和改锁这是两个操作，不是原子操作。依然会有竞争问题</p>
<h3 id="3-1-3-严格轮换法"><a href="#3-1-3-严格轮换法" class="headerlink" title="3.1.3. 严格轮换法"></a>3.1.3. 严格轮换法</h3><p>以下进程 0 和进程 1 使用自旋锁轮换执行</p>
<p>进程 0 执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>);  <span class="comment">/* 不等于 0 就一直循环 */</span></span><br><span class="line">    critical_region();</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>进程 1 执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>);  <span class="comment">/* 等于 1 就一直循环 */</span></span><br><span class="line">    critical_region();</span><br><span class="line">    turn <span class="number">0</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>连续测试一个变量直到某个值出现为止，称为 <strong>忙等待（busy waiting）</strong><br>用于忙等待的锁，称为 <strong>自旋锁（spin lock）</strong><br>由于这种方式浪费 CPU 时间，只有在等待时间非常短的情况下，才能使用此方法。</p>
<h3 id="3-1-4-Peterson-解法"><a href="#3-1-4-Peterson-解法" class="headerlink" title="3.1.4. Peterson 解法"></a>3.1.4. Peterson 解法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N     2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="comment">/* 所有值初始化为 0（FALSE） */</span></span><br><span class="line"><span class="type">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">    <span class="comment">/* 另一个进程 */</span></span><br><span class="line">    other = <span class="number">1</span> - process;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 表示进入临界区 */</span></span><br><span class="line">    interested[process] = TRUE;</span><br><span class="line">    <span class="comment">/* 设置标志 */</span></span><br><span class="line">    turn = process;</span><br><span class="line">    <span class="comment">/* 空语句 */</span></span><br><span class="line">    <span class="keyword">while</span> (interested[other] == TRUE &amp;&amp; turn == process);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程：谁离开 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">    interested[process] = FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>enter_ region：代表进入临界区<br>leave_region：代表离开临界区</p>
<p><code>interested[process] == TRUE</code> 表明 process 进程想进入临界区</p>
<ul>
<li>若当前进程想进入临界区（即 <code>interested[process] == TRUE</code>）而另一个进程不想（即 <code>interested[other] == FALSE</code>）时，while 肯定为 false，当前进程直接进入临界区。</li>
<li>当两个进程都想进入临界区（即 interested [0] 和 interested [1] 都为 TRUE）时，此时取决于 turn，turn 会指向后进入的进程。所以先进入的进程能进入临界区。</li>
</ul>
<h3 id="3-1-5-TSL-指令"><a href="#3-1-5-TSL-指令" class="headerlink" title="3.1.5. TSL 指令"></a>3.1.5. TSL 指令</h3><p><strong>测试并加锁（test and set lock）：</strong>硬件支持的一种方案，特别是多处理器的计算机都有这条指令：TSL RX, LOCK。</p>
<p><strong>原理：</strong><br>它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值，这两个操作保证是不可分割的。执行 TSL 指令的 CPU 将 <strong>锁住内存总线</strong>，以禁止其他 CPU 在本指令结束之前访问内存。</p>
<ul>
<li>锁住存储总线不同于屏蔽中断。中断只对当前处理器有影响，对别的处理器没影响，所以屏蔽中断不能阻止其他处理器对内存的访问。</li>
<li>让处理器 2 远离内存直到处理器 1 完成的唯一方法就是锁住总线，这需要硬件层面的支持（一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能用）</li>
</ul>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。<br>当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为 0。</p>
<p><strong>代码：</strong></p>
<ol>
<li><code>TSL REGISTER,LOCK</code>：将 lock 原来的值复制到寄存器中并将 lock 设为 1</li>
<li><code>CMP REGISTER,#0</code>：将寄存器中的值与 0 比较</li>
<li><code>JNE enter_region</code>：如果不是 0，说明以前已被加锁，则循环重新测试</li>
<li>若其他进程离开临界区（lock 变为 0），则可加锁。</li>
<li>释放锁只需把 lock 设为 0 即可。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    TSL REGISTER,LOCK    | 复制锁到寄存器并将锁设为 1</span><br><span class="line">    CMP REGISTER,#0      | 判断锁是否为 0</span><br><span class="line">    JNE enter_region     | 若不是 0，说明锁已被设置，所以循环</span><br><span class="line">    RET                  | 返回调用者，进入临界区</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">    MOVE LOCK,#0         | 在锁中存入 0</span><br><span class="line">    RET                  | 返回调用者</span><br></pre></td></tr></tbody></table></figure>
XCHG 指令可以代替 TSL，它原子性地交换了两个位置的内容，达到一样的效果。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVE REGISTER,#1         | 在寄存器中存一个 1</span><br><span class="line">XCHG REGISTER,LOCK       | 交换寄存器与锁变量的内容</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>优先级反转问题：</strong><br>Peterson 解法和 TSL/XCHG 本质上都有忙等待的缺点<br>考虑一台计算机有两个进程，H 优先级较高，L 优先级较低。调度规则规定，只要 H 处于就绪态它就可以运行。<br>在某一时刻，L 处于临界区中，此时 H 变到就绪态，准备运行。现在 H 开始忙等待，但由于当 H 就绪时 L 不会被调度，也就无法离开临界区，所以 H 将永远忙等待下去。这种情况有时被称作 ** 优先级反转问题（priority inversion problem）**。</p>
<p><strong>多个进程如何共享内存变量？</strong></p>
<ol>
<li>信号量等某些共享数据结构可以存放在内核中，并且只能通过系统调用来访问。</li>
<li>让进程共享部分地址空间。缓冲区和其他数据结构可以共享。如果没有可共享的途径，则可以使用共享文件。</li>
</ol>
<h2 id="3-2-生产者-消费者问题"><a href="#3-2-生产者-消费者问题" class="headerlink" title="3.2. 生产者-消费者问题"></a>3.2. 生产者 - 消费者问题</h2><p>也称作 <strong>有界缓冲区（bounded-buffer）</strong>问题。<br>两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。</p>
<ul>
<li>当缓冲区已满时，生产者就睡眠以避免继续生产数据项，待消费者从缓冲区中取出一个或多个数据项时再唤醒它。</li>
<li>当缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                                  <span class="comment">/* 缓冲区槽数据 */</span></span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;                                 <span class="comment">/* 缓冲区数据项数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();                 <span class="comment">/* 产生下一个新数据项 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == N) sleep();               <span class="comment">/* 如果缓冲区满了，就进入休眠 */</span></span><br><span class="line">        insert_item(item);                     <span class="comment">/* 将新数据项放入缓冲区 */</span></span><br><span class="line">        count = count + <span class="number">1</span>;                     <span class="comment">/* 将缓冲区的数据项计数器+1 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) wakeup(consumer);      <span class="comment">/* 判断缓冲区是否为空 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) sleep();               <span class="comment">/* 如果缓冲区为空，则进入休眠 */</span></span><br><span class="line">        item = remove_item();                  <span class="comment">/* 从缓冲区中取出一个数据项 */</span></span><br><span class="line">        count = count - <span class="number">1</span>;                     <span class="comment">/* 将缓冲区的数据项计数器-1 */</span></span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>) wakeup(producer);  <span class="comment">/* 判断缓冲区是否已满 */</span></span><br><span class="line">        consume_item(item);                    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会出现竞争条件：</p>
<ol>
<li>缓冲区（队列）为空时，消费者读取 count 的值为 0。</li>
<li>若此时消费者暂停，生产者运行，并向缓冲区中加入一个数据项，这时调用 wakeup 来唤醒消费者。但是，消费者并未睡眠，所以 wakeup 信号丢失。</li>
<li>消费者再次运行时，用之前读取的 count 判断，于是进入睡眠。</li>
</ol>
<h2 id="3-3-信号量与互斥量"><a href="#3-3-信号量与互斥量" class="headerlink" title="3.3. 信号量与互斥量"></a>3.3. 信号量与互斥量</h2><h3 id="3-3-1-信号量"><a href="#3-3-1-信号量" class="headerlink" title="3.3.1. 信号量"></a>3.3.1. 信号量</h3><p><strong>信号量（semaphore）</strong>，由 Dijkstra 在 1965 年提出的一种方法。本质上是一个计数器，用来记录对某个资源的数量（资源池）。</p>
<p>Dijkstra 建议设立两种操作：down 和 up。可以把信号量看成是一个有若干信号的池子。</p>
<ul>
<li><strong>down（P，Proberen 尝试）：</strong>调用 down，进程尝试去拿到一个信号（即尝试使信号量减 1：取出值，判断是否 &gt; 0，再操作）。<ul>
<li>拿到后才能进入临界区；</li>
<li>拿不到（去拿时信号量已为 0）则进入睡眠（阻塞），等待有信号被释放时再进行 down 操作；</li>
</ul>
</li>
<li><strong>up（V，Verhogen 增加）：</strong>进程离开临界区时，调用 up，进程将释放信号（信号量加 1）。<ul>
<li>如果有其他进程因拿不到信号而正在睡眠（即之前 down 的时候发现信号量为 0），则由系统唤醒其中一个正在睡眠的进程，继续进行 down 操作尝试去拿信号。所以最后表现是信号量还是 0，但有一个正在睡眠的进程被唤醒，拿到了当前进程的信号。</li>
<li>当然，如果没有其他进程因拿不到信号而进入睡眠，那么当前进程释放信号会直接使信号量加 1。</li>
</ul>
</li>
</ul>
<p><strong>保证检查数值、修改变量值和睡眠操作都是原子操作。</strong></p>
<ul>
<li>单核 CPU 操作系统在执行以上操作时暂时屏蔽中断</li>
<li>由于中断只对当前处理器有影响，对别的处理器没影响，屏蔽中断不能阻止其他处理器对内存的访问。所以多 CPU 系统中使用 TSX 或 XCHG 指令来区人保同一时刻只有一个 CPU 对信号量进行操作</li>
</ul>
<p><strong>使用信号量解决生产者 - 消费者问题：</strong><br>信号量的作用：</p>
<ul>
<li>互斥：由 mutex 实现互斥，保证同一时刻只有一个进程访问内存变量</li>
<li>同步：full 和 empty 保证某件事件的顺序发生或不发生。如下保证当缓冲区满时生产者暂停；当缓冲区空时消费者暂停。<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                     <span class="comment">/* 缓冲区中的槽数目 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;            <span class="comment">/* 信号量是一种特殊的整型数据 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;              <span class="comment">/* 控制对临界区的访问 */</span></span><br><span class="line">semaphore empty = N;              <span class="comment">/* 计数缓冲区的空槽数目 */</span></span><br><span class="line">semaphore full = <span class="number">0</span>;               <span class="comment">/* 计数缓冲区的满槽数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();    <span class="comment">/* 产生放在缓冲区中的一些数据 */</span></span><br><span class="line">        down(&amp;empty);             <span class="comment">/* 将空槽数目减 1 */</span></span><br><span class="line">        down(&amp;mutex);             <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        insert_item(item);        <span class="comment">/* 将新数据项放到缓冲区中 */</span></span><br><span class="line">        up(&amp;mutex);               <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        up(&amp;full);                <span class="comment">/* 将满槽的数目加 1 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        down(&amp;full);              <span class="comment">/* 将满槽数目减 1 */</span></span><br><span class="line">        down(&amp;mutex);             <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        item = remove_item();     <span class="comment">/* 从缓冲区中取出数据项 */</span></span><br><span class="line">        up(&amp;mutex);               <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        up(&amp;empty);               <span class="comment">/* 将空槽数目减 1 */</span></span><br><span class="line">        comsume_item(item);       <span class="comment">/* 处理数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-3-2-互斥量"><a href="#3-3-2-互斥量" class="headerlink" title="3.3.2. 互斥量"></a>3.3.2. 互斥量</h3><p>信号量的简化版本，用一个整形量表示：0 表示解锁；其他值表示加锁。<br>互斥量仅仅适用于管理共享资源或一小段代码，因此很适用于处理线程。</p>
<p>以下是线程互斥：使用 thread_yield 避免忙等待</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">    TSL REGISTER,MUTEX     | 将互斥信号量复制到寄存器，并且将互斥信号量置为 1</span><br><span class="line">    CMP REGISTER,#0        | 判断互斥信号量是否为 0</span><br><span class="line">    JZE ok                 | 如果互斥信号量为 0，表示未加锁，返回</span><br><span class="line">    CALL thread_yield      | 已加锁，让出线程</span><br><span class="line">    JMP mutex_lock         | 稍后再试</span><br><span class="line">ok: RET                    |返回调用者；进入临界区</span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">    MOVE MUTEX,#0          | 将 mutex 置为 0，即释放锁</span><br><span class="line">    RET                    | 返回调用者</span><br></pre></td></tr></tbody></table></figure>

<p><strong>1. 快速用户区互斥量 futex</strong><br>自旋锁适用于等待时间短的情况，如果等待时间长，会浪费 CPU 周期。<br>互斥锁适用于竞争量大的情况，它会阻塞进程，直到锁被释放才会让内核接触阻塞。如果一开始只有很小的竞争，那么不停地切换内核会有很大的花销，而且预测竞争锁的数量并不容易。</p>
<p>futex 结合了自旋锁及互斥锁的优点。futex 是 Linux 的一个特性，它实现了基本的锁（很像互斥锁），且尽量避免陷入内核从而可观地改善了性能。<br>一个 futex 包含两个部分：一个内核服务和一个用户库。</p>
<ul>
<li>内核服务提供一个等待队列，允许多个进程在一个锁上等待。除非内核对它们解除阻塞否则这些进程将不会运行。将一个进程放到等待队列需要系统调用（开销大），应尽量避免出现这种情况。</li>
<li>在没有竞争时，futex 完全在用户空间工作。这些进程共享通用的锁变量 —— 一个对齐的 32 位整数锁。</li>
</ul>
<p>假设锁初始值为 1（释放状态）。线程通过执行原子操作 “减少并检验” 来夺取锁。这个线程检查结果，看锁是否被释放。</p>
<ul>
<li>如果未处于加锁状态，该线程成功夺取锁。</li>
<li>如果锁被另一个线程持有，futex 库不会自旋，而是使用一个系统调用把这个线程放在内核的等待队列上。因为已经该线程被阻塞了，所以无所谓开销。</li>
<li>当一个线程使用完锁，会通过原子操作 “增加并检验” 来释放锁，并检查是否仍有进程阻塞在内核等待队列上。如果有，它会通知内核可以对等待队列里的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与其中。</li>
</ul>
<p><strong>2. pthread 中的互斥量</strong></p>
<table>
<thead>
<tr>
<th><strong>线程调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> pthread_mutex_init</td>
<td> 创建一个互斥量</td>
</tr>
<tr>
<td> pthread_mutex_destory</td>
<td> 销毁一个互斥量</td>
</tr>
<tr>
<td> pthread_mutex_lock</td>
<td> 获取一个锁，否则阻塞</td>
</tr>
<tr>
<td> pthread_mutex_trylock</td>
<td> 获取一个锁，否则失败</td>
</tr>
<tr>
<td> pthread_mutex_unlock</td>
<td> 释放一个锁</td>
</tr>
</tbody></table>
<p>Pthread 提供许多可以用来同步线程的函数。其基本机制是使用一个可以被加锁和解锁的互斥量来保护每个临界区。<br>一个线程如果想要进入临界区，它首先尝试锁住相关的互斥量。</p>
<ul>
<li>如果互斥量没有加锁，那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他线程进入。</li>
<li>如果互斥量已经被加锁，则调用线程被阻塞，直到该互斥量被解锁。</li>
<li>如果多个线程在等待同一个互斥量，当锁释放时，这些等待的线程中只有一个被允许运行并将互斥量重新锁定。这些互斥锁不是强制性的，而是由程序员来保证线程正确地使用它们。</li>
</ul>
<p><strong>3. pthread 中的条件变量</strong><br>pthread 提供了另一种同步机制：<strong>条件变量</strong>。</p>
<table>
<thead>
<tr>
<th><strong>线程调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td> pthread_cond_init</td>
<td> 创建一个条件变量</td>
</tr>
<tr>
<td> pthread_cond_destory</td>
<td> 销毁一个条件变量</td>
</tr>
<tr>
<td> pthread_cond_wait</td>
<td> 阻塞以等待一个信号</td>
</tr>
<tr>
<td> pthread_cond_signal</td>
<td> 向另一个线程发信号来唤醒它</td>
</tr>
<tr>
<td> pthread_cond_broadcast</td>
<td> 向多个线程发信号来让它们全部唤醒</td>
</tr>
</tbody></table>
<p>互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。<br>例如生产者 - 消费者问题中生产者使用互斥量保证操作的原子性，不被其他线程干扰。但是如果在缓冲区满了这样的条件下想要将生产者阻塞就得需要条件变量了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000000000                                 <span class="comment">/* 需要生产的数量 */</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> condc, condp;</span><br><span class="line"><span class="type">int</span> buffer = <span class="number">0</span>;                                        <span class="comment">/* 生产者消费者使用的缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;the_mutex);                <span class="comment">/* 互斥使用缓冲区 */</span></span><br><span class="line">        <span class="keyword">while</span> (buffer != <span class="number">0</span>) {</span><br><span class="line">            pthread_cond_wait(&amp;condp, &amp;the_mutex);</span><br><span class="line">        }</span><br><span class="line">        buffer = i;                                    <span class="comment">/* 将数据放入缓冲区 */</span></span><br><span class="line">        pthread_cond_signal(&amp;condc);                   <span class="comment">/* 唤醒消费者 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;the_mutex);              <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;the_mutex);                 <span class="comment">/* 互斥使用缓冲区 */</span></span><br><span class="line">        <span class="keyword">while</span> (buffer == <span class="number">0</span>) {</span><br><span class="line">            pthread_cond_wait(&amp;condc, &amp;the_mutex);</span><br><span class="line">        }</span><br><span class="line">        buffer = <span class="number">0</span>;                                     <span class="comment">/* 从缓冲区中取出数据 */</span></span><br><span class="line">        pthread_cond_signal(&amp;condp);                    <span class="comment">/* 唤醒生产者 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;the_mutex);               <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">pthread_t</span> pro,con;</span><br><span class="line">    pthread_mutex_init(&amp;the_mutex, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_init(condc, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_init(condp, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;con, <span class="number">0</span>, consumer, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;pro, <span class="number">0</span>, producer, <span class="number">0</span>);</span><br><span class="line">    pthread_join(pro, <span class="number">0</span>);</span><br><span class="line">    pthread_join(con, <span class="number">0</span>);</span><br><span class="line">    pthread_cond_destory(&amp;condc);</span><br><span class="line">    pthread_cond_destory(&amp;condp);</span><br><span class="line">    pthread_mutex_destory(&amp;the_mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-4-管程"><a href="#3-4-管程" class="headerlink" title="3.4. 管程"></a>3.4. 管程</h2><p>一个管程（monitor）是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。<br>进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。<br>管程是一个编程语言的概念，由编程语言提供支持。例如 java 的 synchronized。</p>
<p><strong>特性：</strong><br>任一时刻管程中只能有一个活跃进程，这使得管程能有效地完成互斥。<br>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。</p>
<ul>
<li>如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。</li>
<li>如果没有活跃进程在使用管程，则该调用进程可以进入。</li>
</ul>
<p><strong>条件变量：</strong></p>
<ul>
<li>wait：当前进程在某个条件变量上调用 wait 使自身阻塞，并将另一个等待在管程外的进程调入管程</li>
<li> signal：当前进程在某个条件变量上调用 signal 唤醒在其上等待的进程。</li>
</ul>
<p>这时管程中会有两个进程：当前进程和被唤醒的进程，所以在 signal 之后得做处理使得管程只运行一个进程（多种方案）。</p>
<ul>
<li>可以挂起当前进程，直接运行唤醒的进程（Hoare 建议）。</li>
<li>可以使当前进程立即退出管程，从而运行唤醒的进程（Brinch Hansen 建议）。</li>
<li>可以继续运行当前线程，直到退出管程后再裕兴唤醒的进程。</li>
</ul>
<p><strong>与信号量实现的区别：</strong><br>用信号量也能实现相同的效果，对 <code>value=0</code> 的信号量进行 P 操作（相当于 wait）使得调用进程阻塞，对其进行 V 操作（相当于 signal）使其唤醒。但与信号量不同的是条件变量不能累加：</p>
<ul>
<li>对一个没有进程在其阻塞的信号量使用 V 操作会使信号量加 1，这样如果有进程下次调用 P 操作将不会阻塞。</li>
<li>但对没有进行过 wait 操作的条件变量使用 signal 操作不会有任何作用。signal 必须在 wait 之后才会起作用。</li>
</ul>
<h2 id="3-5-消息传递"><a href="#3-5-消息传递" class="headerlink" title="3.5. 消息传递"></a>3.5. 消息传递</h2><p>管程与信号量可以解决单个计算机内的竞争问题，但在一个分布式系统里这些原语都会失效。<br><strong>消息传递（message passing）</strong>可以解决这个问题。提供两个系统调用过程：</p>
<ul>
<li>send (destination, &amp;message)：向一个给定的目标发送</li>
<li> receive (source, &amp;message)：从一个给定的源或任意源接收一条消息</li>
</ul>
<h3 id="3-5-1-消息传递系统的设计要点"><a href="#3-5-1-消息传递系统的设计要点" class="headerlink" title="3.5.1. 消息传递系统的设计要点"></a>3.5.1. 消息传递系统的设计要点</h3><p><strong>消息丢失问题：</strong><br>为了防止消息丢失，接收方一旦接收到信息，马上回送一条特殊的 <strong>确认（acknowledgement）</strong>消息。如果发送方在一段时间间隔内未收到确认，则重发消息。<br>确认消息也有可能会丢失，这时发送者将重发消息，所以接收者如何保证消息幂等性很重要，可通过版本号解决。</p>
<p><strong>进程命名问题：</strong><br>在 send 和 receive 调用中所制定的进程必须是没有二义性的。</p>
<p><strong>身份认证（authentication）问题：</strong>客户端怎么判断与之通信的是不是一个冒充者？</p>
<p>……</p>
<h3 id="3-5-2-用消息传递解决生产者-消费者问题"><a href="#3-5-2-用消息传递解决生产者-消费者问题" class="headerlink" title="3.5.2. 用消息传递解决生产者-消费者问题"></a>3.5.2. 用消息传递解决生产者 - 消费者问题</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100                         <span class="comment">/* 缓冲区中的槽数目 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    message m;                        <span class="comment">/* 消息缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        item = produce_item();        <span class="comment">/* 产生放入缓冲区的一些数据 */</span></span><br><span class="line">        receive(consumer, &amp;m);        <span class="comment">/* 等待消费者发送空缓冲区 */</span></span><br><span class="line">        build_message(&amp;m, item);      <span class="comment">/* 建立一个待发送的消息 */</span></span><br><span class="line">        send(consumer, &amp;m);           <span class="comment">/* 发送数据项给消费者 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> item, i;</span><br><span class="line">    message m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        send(producer, &amp;m);            <span class="comment">/* 发送 N 个空缓冲区 */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        receive(producer, &amp;m);         <span class="comment">/* 接收包含数据项的消息 */</span></span><br><span class="line">        item = extract_item(&amp;m);       <span class="comment">/* 将数据项从消息中提取出来 */</span></span><br><span class="line">        send(producer, &amp;m);            <span class="comment">/* 将空缓冲区发送回生产者 */</span></span><br><span class="line">        consume_item(item);            <span class="comment">/* 处理数据项 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>信箱：</strong><br>如何对消息进行编址？可以为每个进程分配一个唯一的地址，让消息按进程的地址编址。<br>也可以引入一种新的数据结构，称作 ** 信箱（mailbox）**：一个用来对一定数量的消息进行缓冲的地方。使用信箱时，在 send 和 receive 调用中的地址参数就是信箱的地址，而不是进程的地址。当一个进程试图向一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走，从而为新消息腾出空间。</p>
<p>信箱起到缓冲机制的作用，能够容纳那些已被发送但尚未被目标进程接收的消息。</p>
<p><strong>会合：</strong><br>使用信箱的另一种极端方法是彻底取消缓冲。采用这种方法时，send 和 receive 会进行一对一传输。</p>
<ul>
<li>如果下线执行 send ，那么它直到 receive 接收到消息之前都会被阻塞。</li>
<li>同理，先执行 receive，在 send 发送消息前接收者会被阻塞。</li>
</ul>
<p>这种方案常被称为 ** 会合（rendezvous）**。与带有缓冲的消息方案相比，该方案实现起来更容易，但却降低了灵活性。</p>
<h2 id="3-6-屏障"><a href="#3-6-屏障" class="headerlink" title="3.6. 屏障"></a>3.6. 屏障</h2><p>在有些应用中划分了若干阶段，只有所有的进程都就绪才能进入下一个阶段。<br><strong>屏障（barrier）</strong>可用于一组进程同步，可在每个阶段的结尾安置屏障来实现。<br>当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p>
<p>例：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/86dd057f2abb5745be8515ff5045dab3.png" alt="image.png"><br> A、B、D 进程完成计算，执行 barrier 原语被挂起进入屏障，只有当 C 进程（最后一个进程）到达屏障屏障时所有的进程才一起被释放。</p>
<h2 id="3-7-读-复制-更新（Read-Copy-Update）"><a href="#3-7-读-复制-更新（Read-Copy-Update）" class="headerlink" title="3.7. 读-复制-更新（Read-Copy-Update）"></a>3.7. 读 - 复制 - 更新（Read-Copy-Update）</h2><p>RCU 可以看做读写锁的高性能版本。</p>
<ul>
<li>读操作不需要获得任何锁就可以访问，不使用原子操作。</li>
<li>写操作在访问前需要先复制一份副本，然后对副本进行修改，最后使用一个回调机制，在适当的时机把指向原来数据的指针重新指向新的被修改的数据。</li>
</ul>
<h1 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h1><p>调度程序需考虑 CPU 的利用率，因为进程切换的代价是比较高的。</p>
<ol>
<li>首先用户态必须切换到内核态；</li>
<li>然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新装载。内存映像（例如，页表内的内存访问位）也必须保存；</li>
<li>接着，通过运行调度算法选定一个新进程；</li>
<li>之后，应该将新进程的内存映像重新装入 MMU；</li>
<li>最后新进程开始运行。</li>
</ol>
<p>进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）。所以如果每秒钟切换进程的次数太多，会耗费大量 CPU 时间。</p>
<h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h2><p><strong>调度时机：</strong></p>
<ol>
<li>在创建一个新进程之后，可以任意决定先运行父进程还是先运行子进程。</li>
<li>在一个进程退出时必须做出调度决策。必须从就绪进程集中选择另外某个进程，如果没有就绪的进程，通常会运行一个系统提供的空闲进程。</li>
<li>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</li>
<li>在一个 I/O 中断发生时，必须做出调度决策。调度程序决定是否让新就绪的进程运行，还是让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</li>
</ol>
<p><strong>调度算法分类：</strong><br>如果硬件时钟提供 50Hz、60Hz 或其他频率的周期性中断，可以在每个时钟中断或者在每 k 个时钟中断时做出调度决策。根据如何处理时钟中断，可以把调度算法分为两类。</p>
<ul>
<li><strong>非抢占式：</strong>调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在 I/O 上或等待另一个进程），或者直到该进程自动释放 CPU。即使该进程运行了若千个小时，它也不会被强迫挂起。</li>
</ul>
<p>这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。</p>
<ul>
<li><strong>抢占式：</strong>调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时仍在运行，它就被挂起，然后调度程序挑选另一个进程运行。</li>
</ul>
<p>进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是唯一的选择了。</p>
<h2 id="4-2-批处理系统中的调度"><a href="#4-2-批处理系统中的调度" class="headerlink" title="4.2. 批处理系统中的调度"></a>4.2. 批处理系统中的调度</h2><h3 id="4-2-1-先来先服务"><a href="#4-2-1-先来先服务" class="headerlink" title="4.2.1. 先来先服务"></a>4.2.1. 先来先服务</h3><p>非抢占式。进程按照它们请求 CPU 的顺序使用 CPU。类似队列的先进先出。缺点是大任务容易阻塞。</p>
<h3 id="4-2-2-最短作业优先"><a href="#4-2-2-最短作业优先" class="headerlink" title="4.2.2. 最短作业优先"></a>4.2.2. 最短作业优先</h3><p>非抢占式。按照运行时间从小到大处理。只有在所有的作业都可同时运行的情况下才是最优化的。如果有运行时间较短的任务还未到达而只能运行其他较大的任务，这种情况下平均时间会较大。</p>
<h3 id="4-2-3-最短剩余时间优先"><a href="#4-2-3-最短剩余时间优先" class="headerlink" title="4.2.3. 最短剩余时间优先"></a>4.2.3. 最短剩余时间优先</h3><p>最短作业优先的抢占式版本。调度程序总是选择剩余运行时间最短的那个进程运行。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。</p>
<h2 id="4-3-交互式系统中的调度"><a href="#4-3-交互式系统中的调度" class="headerlink" title="4.3. 交互式系统中的调度"></a>4.3. 交互式系统中的调度</h2><h3 id="4-3-1-轮转调度"><a href="#4-3-1-轮转调度" class="headerlink" title="4.3.1. 轮转调度"></a>4.3.1. 轮转调度</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3fccdb0a67e6fab47c8c5fca1add5d01.png" alt="image.png"><br>每个进程被分配一个时间片，允许该进程在该时间段中运行。如果在时间片结束或是该进程阻塞 / 结束，则将 CPU 并分配给另一个进程。当一个进程用完它的时间片后，就被移到队列的末尾。</p>
<p>从一个进程切换到另一个进程是需要一定时间进行管理事务处理的，如保存和装入寄存器值及内存映像、更新各种表格和列表、清除和重新调入内存高速缓存等。<br>所以如果时间片的时间与进程切换的时间比值过小，会造成进程频繁切换；如果比值过大，则后面的进程可能无法在短时间内使用 CPU。时间片设为 20~50ms 通常是一个比较合理的折中。</p>
<h3 id="4-3-2-优先级调度"><a href="#4-3-2-优先级调度" class="headerlink" title="4.3.2. 优先级调度"></a>4.3.2. 优先级调度</h3><p>为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前<br>进程的优先级。这之后如果该进程的优先级低于次高优先级的进程，则进行进程切换。<br>另一种方法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。</p>
<p>为达到某种目的，优先级也可以由系统动态确定。例如，有些进程为 I/O 密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配给它 CPU，以便启动下一个 I/O 请求，这样就可以在另一个进程计算的通知执行 I/O 操作。</p>
<p>可以将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。</p>
<h3 id="4-3-3-多级队列"><a href="#4-3-3-多级队列" class="headerlink" title="4.3.3. 多级队列"></a>4.3.3. 多级队列</h3><p>属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行 2 个时间片，再次一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后被移到下一类。</p>
<p>考虑有一个进程需要连续计算 100 个时间片。它最初被分配 1 个时间片，然后被换出。下次它将获得 2 个时间片，接下来分别是 4、8、16、32  和 64。当然最后一次它只使用 64 个时间片中的 37 个便可以结束工作。</p>
<p>该进程需要 7 次交换（包括最初的装入），而如果采用纯粹的轮转算法则需要 100 次交换。而且，随着进程优先级的不断降低，它的运行频度逐渐放慢，从而为短的交互进程让出 CPU。</p>
<h3 id="4-3-4-最短进程优先"><a href="#4-3-4-最短进程优先" class="headerlink" title="4.3.4. 最短进程优先"></a>4.3.4. 最短进程优先</h3><p>与批处理系统中的最短作业优先相同。可以根据进程过去的行为估计运行时间的长短，<br>对于最新一次的运行时间 T 和上一次预估运行时间 P，可以对他们进行加权来得到最新的预估时间。如 aT+(1-a) P，当 a=1/2 时，当前预估时间为 T/2+P/2。</p>
<h3 id="4-3-5-保证调度"><a href="#4-3-5-保证调度" class="headerlink" title="4.3.5. 保证调度"></a>4.3.5. 保证调度</h3><p>向用户做出明确的性能保证并去实现它。例如 n 个用户，每个用户获得 1/n 的 CPU 时间。<br>系统必须跟踪各个进程自创建以来已使用了多少 CPU 时间，然后计算它们应获得的 CPU 时间。</p>
<h3 id="4-3-6-彩票调度"><a href="#4-3-6-彩票调度" class="headerlink" title="4.3.6. 彩票调度"></a>4.3.6. 彩票调度</h3><p>为进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就<br>随机抽出一张彩票，拥有该彩票的进程获得该资源。</p>
<p>可以给更重要的进程额外的彩票，以便增加它们获胜的机会。如果总共有 100 张彩票，而有一个进程持有其中的 20 张，那么在每一次抽奖中该进程就有 20% 的取胜机会。<br>短期时间内会有不公平的问题，但从长期来看，该进程会得到 20% 的 CPU。</p>
<p><strong>优点：</strong><br>彩票调度实现简单而且可以迅速调整。加入一个新进程出现并得到一些彩票，那么在下一次的抽奖中，该进程会有同它持有的彩票数量成比例的机会拿到奖励。</p>
<p><strong>缺点：</strong><br>彩票调度并没有在 CPU 调度程序里广泛使用。一个原因是不能很好的适合 I/O；另一个原因是票数分配问题没有确定的解决方式，比如你新打开了一个浏览器进程，那该给他分配多少票？票数少了，响应跟不上，票数多了，又会浪费 CPU 时间。</p>
<h3 id="4-3-7-公平分享调度"><a href="#4-3-7-公平分享调度" class="headerlink" title="4.3.7. 公平分享调度"></a>4.3.7. 公平分享调度</h3><p>以上算法关注的是进程本身而不是所有者，假设用户 1 启动 9 个进程而用户 2 启动 1 个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90% 的 CPU 时间，而用户 2 只得到 10% 的 CPU 时间。</p>
<p>公平愤怒向调度使每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。两个用户都得到获得 50% CPU 时间的保证。</p>
<h2 id="4-4-实时系统中的调度"><a href="#4-4-实时系统中的调度" class="headerlink" title="4.4. 实时系统中的调度"></a>4.4. 实时系统中的调度</h2><p>实时系统通常可以分为 ** 硬实时（hard real time）<strong>和</strong> 软实时（soft real time）**，硬实时是必须满足绝对的截止时间，软实时是虽然不希望偶尔错失截止时间，但是可以容忍。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为 <strong>周期性（以规则的时间间隔发生）</strong>事件或 ** 非周期性（发生时间不可预知）** 事件。一个系统可能要响应多个周期性事件流。根据每个事件需要处理时间的长短，系统甚至有可能无法处理完所有的事件。</p>
<p>实时系统的调度算法可以是静态或动态的。前者在系统开始运行之前作出调度决策，后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等全部信息时，静态调度才能工作，而动态调度算法不需要这些限制。</p>
<h1 id="5-IPC-问题"><a href="#5-IPC-问题" class="headerlink" title="5. IPC 问题"></a>5. IPC 问题</h1><p>IPC（Inter-Process Communication）问题：进程间通信问题</p>
<h2 id="5-1-哲学家就餐问题"><a href="#5-1-哲学家就餐问题" class="headerlink" title="5.1. 哲学家就餐问题"></a>5.1. 哲学家就餐问题</h2><p>互斥访问竞争模型。</p>
<p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f39086303733b0ad3d17fb855e17217a.png" alt="image.png"><br>五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉。由于通心粉很滑，所以需要两把叉子才能夹住，相邻两个盘子之间放有一把叉子。</p>
<p>他们的生活方式是交替地进行思考和进餐，当一个哲学家觉得饿了时，他就试图分两次去取其左边和右边的叉子，每次拿一把，但不分次序。</p>
<p>如果成功地得到了两把叉子，就开始吃饭，吃完后放下叉子继续思考。如何实现程序且决不会出现死锁？</p>
<p><strong>先拿左叉再尝试拿右叉：</strong><br>如果先拿左叉，再去查看右叉是否可用，这样会出现饥饿。比如当所有人同时拿起左叉，他们都会发现右叉不能用，于是都放下左叉，过了一会儿又同时拿起左叉，一直循环下去。主要原因是拿不到叉子不意味着叉子正被人用于吃饭。</p>
<p>可以在拿不到右叉时随机等待一段时间，而不是等待相同的时间，但是有随机性，可靠性并不是百分百。</p>
<p><strong>哲学家状态控制：</strong></p>
<ol>
<li>更改状态：A 想吃饭，更改状态为饥饿。</li>
<li>条件阻塞：A 发现旁边有人正在吃饭则 A 进入阻塞，否则直接就餐。</li>
<li>条件唤醒：被阻塞的 A 旁边有人吃完时，A 就观察左右两边是不是都没人在吃饭，是的话可以唤醒就餐。</li>
</ol>
<p>该算法加入状态，不会出现死锁，因为一个哲学家只有在两个邻座都不在进餐时，才允许转换到进餐状态。<br>但是会出现某个哲学家处于饥饿状态，当左右两边的哲学家交替吃饭，则当前的哲学家始终吃不上饭。<br>该算法能够实现对于任意多位哲学家的情况都能获得最大的并行度，因此也具有重要的意义。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N        5            <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT     (i+N-1)%N    <span class="comment">/* i 的左邻居编号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT    (i+1)%N      <span class="comment">/* i 的右邻居编号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0            <span class="comment">/* 哲学家在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1            <span class="comment">/* 哲学家试图拿起叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2            <span class="comment">/* 哲学家进餐 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;        <span class="comment">/* 信号量是一种特殊的整型数据 */</span></span><br><span class="line"><span class="type">int</span> state[N];                 <span class="comment">/* 数组用来跟踪记录每位哲学家的状态 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;          <span class="comment">/* 临界区的互斥 */</span></span><br><span class="line">semaphore s[N];               <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);              <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state[i] = HUNGRY;         <span class="comment">/* 记录哲学家 i 处于饥饿的状态 */</span></span><br><span class="line">    test(i);                   <span class="comment">/* 尝试获取 2 把叉子 */</span></span><br><span class="line">    up(&amp;mutex);                <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    down(&amp;s[i]);               <span class="comment">/* 如果得不到需要的叉子则阻塞 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);               <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state[i] = THINKING;        <span class="comment">/* 哲学家已经就餐完毕 */</span></span><br><span class="line">    test(LEFT);                 <span class="comment">/* 检查左边的邻居现在可以吃吗 */</span></span><br><span class="line">    test(RIGHT);                <span class="comment">/* 检查右边的邻居现在可以吃吗 */</span></span><br><span class="line">    up(&amp;mutex);                 <span class="comment">/* 离开临界区 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i:哲学家编号，从 0 到 N-1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (state[i] == HUNGRY </span><br><span class="line">        &amp;&amp; state[LEFT] != EATING </span><br><span class="line">        &amp;&amp; state[RIGHT] != EATING) {</span><br><span class="line">        </span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>只允许 4 人同时就餐：</strong><br>至多只允许四个哲学家同时进餐，因为少了一个人，所以即使这 4 人同时拿叉子也会保证至少有一个哲学家能够进餐。就解决了同时拿叉互等的问题。<br>以下将 count 作为信号量，只允许 4 个哲学家同时进入餐厅就餐。申请进入餐厅的哲学家进入等待队列，根据 FIFO 的原则，总会进入到餐厅就餐，因此不会出现饿死和死锁的现象。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">chopstick</span>[5]=</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 每个叉子都是信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">count</span>=</span><span class="number">4</span>;                       <span class="comment">// 4 个位置，信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        think();                                <span class="comment">// 思考</span></span><br><span class="line">        P(count);                               <span class="comment">// 人数控制</span></span><br><span class="line">        P(chopstick[i]);                        <span class="comment">// 拿起左叉</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);                  <span class="comment">// 拿起右叉</span></span><br><span class="line">        eat();                                  <span class="comment">// 吃饭</span></span><br><span class="line">        V(chopstick[i]);                        <span class="comment">// 放下左叉</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);                  <span class="comment">// 放下右叉</span></span><br><span class="line">        V(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>左右叉子绑定：</strong><br>仅当哲学家的左右两只叉子都可用时，才允许他拿起叉子进餐。</p>
<ol>
<li>利用 AND 型信号量机制实现</li>
</ol>
<p>由于等待队列的存在，使得对资源的请求满足 FIFO 的要求，因此不会出现饥饿的情形。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        Swait(chopstick[(i + <span class="number">1</span>)] % <span class="number">5</span>, chopstick[i]);</span><br><span class="line">        eat();</span><br><span class="line">        Ssignal(chopstick[(i + <span class="number">1</span>)] % <span class="number">5</span>, chopstick[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>利用信号量的保护机制实现</li>
</ol>
<p>通过信号量 mutex 对 eat () 之前的取左侧和右侧叉子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        signal(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>奇偶顺序拿叉：</strong><br>规定奇数号的哲学家先拿起他左边的叉子，然后再去拿他右边的叉子；偶数号的哲学家则相反。<br>1、2 号哲学家竞争 1 号叉子，3、4 号哲学家竞争 3 号叉子。即五个哲学家都竞争奇数号叉子，获得后，再去竞争偶数号叉子，最后总会有一个哲学家能获得两只叉子而进餐。<br>申请不到的哲学家进入阻塞等待队列，根 FIFO 原则，则先申请的哲学家会较先可以吃饭，因此不会出现饿死的哲学家。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]= {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        think();</span><br><span class="line">        <span class="comment">// 偶数哲学家，先右后左。</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            wait(chopstick[i]) ;</span><br><span class="line">            eat();</span><br><span class="line">            signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            signal(chopstick[i]) ;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 奇数哲学家，先左后右。</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            wait(chopstick[i]) ;</span><br><span class="line">            wait(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">            eat();</span><br><span class="line">            signal(chopstick[i]) ;</span><br><span class="line">            signal(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]) ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-2-读者-写者问题"><a href="#5-2-读者-写者问题" class="headerlink" title="5.2. 读者-写者问题"></a>5.2. 读者 - 写者问题</h2><p>数据库访问模型。<br>读写互斥。多个进程可以同时读库；但如果一个进程正在写库，那么其他所有进程都不能访问数据库。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;       <span class="comment">/* 控制对 rc 的访问 */</span></span><br><span class="line">semaphore db = <span class="number">1</span>;          <span class="comment">/* 控制对 db 的访问 */</span></span><br><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;                <span class="comment">/* 正在读或者即将读的进程数目 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        down(&amp;mutex);      <span class="comment">/* 获得对 rc 的互斥访问 rc */</span></span><br><span class="line">        rc = rc + <span class="number">1</span>;       <span class="comment">/* 多了一个读者 */</span></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">1</span>) {     <span class="comment">/* 如果是第一个读者 */</span></span><br><span class="line">            down(&amp;db);</span><br><span class="line">        }</span><br><span class="line">        up(&amp;mutex);        <span class="comment">/* 释放对 rc 的互斥访问 */</span></span><br><span class="line">        </span><br><span class="line">        read_data_base();  <span class="comment">/* 访问数据 */</span></span><br><span class="line">        </span><br><span class="line">        down(&amp;mutex);      <span class="comment">/* 获得对 rc 的互斥访问权 */</span></span><br><span class="line">        rc = rc - <span class="number">1</span>;       <span class="comment">/* 少了一个读者 */</span></span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) {     <span class="comment">/* 如果是最后一个读者 */</span></span><br><span class="line">            up(&amp;db);</span><br><span class="line">        }</span><br><span class="line">        up(&amp;mutex);        <span class="comment">/* 释放对 rc 的访问 */</span></span><br><span class="line">        </span><br><span class="line">        use_data_read();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">while</span> (TRUE) {</span><br><span class="line">        think_up_data();</span><br><span class="line">        </span><br><span class="line">        down(&amp;db);         <span class="comment">/* 互斥访问数据库 */</span></span><br><span class="line">        write_data_base();</span><br><span class="line">        up(&amp;db);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只要有一个稳定的读者流存在，写者将永远没有机会访问数据库。为避免这种情形，可以采用写者优先的方式：读者访问时若发现写者正在等待则在写者之后挂起（排队），缺点是并发度和效率较低。</p>
<h2 id="5-3-睡眠的理发师"><a href="#5-3-睡眠的理发师" class="headerlink" title="5.3. 睡眠的理发师"></a>5.3. 睡眠的理发师</h2><ol>
<li>5 把供顾客等候的椅子</li>
<li>一个理发师同时只能给一个顾客理发</li>
<li>没有顾客，理发师进入睡眠状态。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHAIRS 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore customers=<span class="number">0</span>;</span><br><span class="line">semaphore barbers=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;  <span class="comment">//protect 'waiting'</span></span><br><span class="line"><span class="type">int</span> waiting=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">barber</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        down(&amp;customers);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        waiting=waiting<span class="number">-1</span>;</span><br><span class="line">        up(&amp;barbers);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        cut_hair();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting&lt;CHAIRS)</span><br><span class="line">    {</span><br><span class="line">        waiting=waiting+<span class="number">1</span>;</span><br><span class="line">        up(&amp;customers);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        down(&amp;barbers);</span><br><span class="line">        get_haircut();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>另一版：</strong><br>一个理发店有一个入口和一个出口。理发店内有一个可站 5 位顾客的站席区、4 个单人沙发、3 个理发师及其专用理发工具、一个收银台。新来的顾客坐在沙发上等待；没有空沙发时，可在站席区等待；站席区满时，只能在入口外等待。理发师可从事理发、收银和休息三种活动。理发店的活动满足下列条件：<br>1）休息的理发师是坐地自己专用的理发椅上，不会占用顾客的沙发；<br>2）处理休息状态的理发师可为在沙发上等待时间最长的顾客理发；<br>3）理发时间长短由理发师决定；<br>4）在站席区等待时间最长的顾客可坐到空闲的理发上；<br>5）任何时刻最多只能有一个理发师在收银。<br>试用信号量机制或管程机制实现理发师进程和顾客进程。</p>
<p>原理：<br>(1) customer 进程：<br>首先检查站席区是否已满（stand_capacity）, 若满选择离开，否则进入站席区，即进入理发店。在站席区等待沙发的空位（信号量 sofa），如果沙发已满，则进入阻塞等待队列，直到出现空位，在站席区中等待时间最长的顾客离开站席区（stand_capacity）。坐到沙发上，等待理发椅 (barber_chair)，如果理发椅已满，则进入阻塞等待队列，直到出现空位，在沙发上等待时间最长的顾客离开沙发（释放信号量 sofa）。坐到理发椅上，释放准备好的信号（customer_ready），获得该理发师的编号（0~1 的数字）。等待理发师理发结束（finished [barber_number]）。在离开理发椅之前付款（payment），等待收据 (receipt)，离开理发椅（leave_barberchair）。最后离开理发店。<br>这里需要注意几点：<br>a) 首先是几个需要进行互斥处理的地方，主要包括：进入站席区、进入沙发、进入理发椅和付款几个地方。<br>b) 通过 barber_chair 保证一个理发椅上最多只有一名顾客。但这也不够，因为单凭 baber_chair 无法保证一名顾客离开理发椅之前，另一位顾客不会坐到该理发椅上，因此增加信号量 leave_barberchair，让顾客离开理发椅后，释放该信号，而理发师接收到该信号后才释放 barber_chair 等待下一位顾客。<br>c) 在理发的过程中，需要保证是自己理发完毕，才能够进行下面的付款、离开理发椅的活动。这个机制是通过 customer 进程获得给他理发的理发师编号来实现的，这样，当该编号的理发师释放对应的 finished [i] 信号的时候，该顾客才理发完毕。<br>d) 理发师是通过 mutex 信号量保证他们每个人同时只进行一项操作（理发或者收款）。<br>e) 为了保证该顾客理发完毕后马上可以付款离开，就应该保证给该顾客理发的理发师在理发完毕后马上到收银台进入收款操作而不是给下一位顾客服务。在伪码中由以下机制实现：即顾客在释放离开理发椅的信号前，发出付款的信号。这样该理发师得不到顾客的离开理发椅的信号，不能进入下一个循环为下一名顾客服务，而只能进入收款台的收款操作。直到顾客接到收据后，才释放离开理发椅的信号，离开理发椅，让理发师释放该理发椅的信号，让下一位等待的顾客坐到理发椅上。<br>(2) barber 进程<br>首先将该理发师的编号压入队列，供顾客提取。等待顾客坐到理发椅坐好 (信号量 customer_ready)，开始理发，理发结束后释放结束信号（finished [i]）。等待顾客离开理发椅（leave_barberchair）（期间去收银台进行收款活动），释放理发椅空闲信号 (barber_chair)，等待下一位顾客坐上来。<br>(3) cash（收银台）进程<br>等待顾客付款 (payment), 执行收款操作，收款操作结束，给付收据（receipt）。</p>
<p>信号量总表：<br>stand_capacity 顾客等待进入理发店 顾客离开站席区<br>sofa 顾客等待坐到沙发 顾客离开沙发<br>barber_chair 顾客等待空理发椅，理发师释放空理发椅<br>customer_ready 理发师等待，直到一个顾客坐到理发椅；顾客坐到理发椅上，给理发师发出信号<br>mutex 等待理发师空闲，执行理发或收款操作；理发师执行理发或收款结束，进入空闲状态<br>mutex1 执行入队或出队等待入队或出队结束，释放信号<br>finished [i] 顾客等待对应编号理发师理发结束；理发师理发结束，释放信号<br>leave_barberchair 理发师等待顾客离开理发椅；顾客付款完毕得到收据，离开理发椅释放信号<br>payment 收银员等待顾客付款顾客付款，发出信号<br>receipt 顾客等待收银员收、开具收据；收银员收款结束、开具收据，释放信号</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">semaphore stand_capacity=<span class="number">5</span>;</span><br><span class="line">semaphore sofa=<span class="number">4</span>;</span><br><span class="line">semaphore barber_chair=<span class="number">3</span>;</span><br><span class="line">semaphore customer_ready=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">3</span>;</span><br><span class="line">semaphore mutex1=<span class="number">1</span>;</span><br><span class="line">semaphore finished[<span class="number">3</span>]= {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">semaphore leave_barberchair=<span class="number">0</span>;</span><br><span class="line">semaphore payment=<span class="number">0</span>;</span><br><span class="line">semaphore receipt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> barber_number;</span><br><span class="line">    wait(stand_capacity); <span class="comment">//等待进入理发店</span></span><br><span class="line">    enter_room(); <span class="comment">//进入理发店</span></span><br><span class="line">    wait(sofa); <span class="comment">//等待沙发</span></span><br><span class="line">    leave_stand_section(); <span class="comment">//离开站席区</span></span><br><span class="line">    signal(stand_capacity);</span><br><span class="line">    sit_on_sofa(); <span class="comment">//坐在沙发上</span></span><br><span class="line">    wait(barber_chair); <span class="comment">//等待理发椅</span></span><br><span class="line">    get_up_sofa(); <span class="comment">//离开沙发</span></span><br><span class="line">    signal(sofa);</span><br><span class="line">    wait(mutex1);</span><br><span class="line">    sit_on_barberchair(); <span class="comment">//坐到理发椅上</span></span><br><span class="line">    signal(customer_ready);</span><br><span class="line">    barber_number=dequeue(); <span class="comment">//得到理发师编号</span></span><br><span class="line">    signal(mutex1);</span><br><span class="line">    wait(finished[barber_number]); <span class="comment">//等待理发结束</span></span><br><span class="line">    pay(); <span class="comment">//付款</span></span><br><span class="line">    signal(payment); <span class="comment">//付款</span></span><br><span class="line">    wait(receipt); <span class="comment">//等待收据</span></span><br><span class="line">    get_up_barberchair(); <span class="comment">//离开理发椅</span></span><br><span class="line">    signal(leave_barberchair); <span class="comment">//发出离开理发椅信号</span></span><br><span class="line">    exit_shop(); <span class="comment">//了离开理发店</span></span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">barber</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        wait(mutex1);</span><br><span class="line">        enqueue(i); <span class="comment">//将该理发师的编号加入队列</span></span><br><span class="line">        signal(mutex1);</span><br><span class="line">        wait(customer_ready); <span class="comment">//等待顾客准备好</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        cut_hair(); <span class="comment">//理发</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(finished[i]); <span class="comment">//理发结束</span></span><br><span class="line">        wait(leave_barberchair); <span class="comment">//等待顾客离开理发椅信号</span></span><br><span class="line">        signal(barber_chair); <span class="comment">//释放barber_chair 信号</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">cash</span><span class="params">()</span> <span class="comment">//收银</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        wait(payment); <span class="comment">//等待顾客付款</span></span><br><span class="line">        wait(mutex); <span class="comment">//原子操作</span></span><br><span class="line">        get_pay(); <span class="comment">//接受付款</span></span><br><span class="line">        give_receipt(); <span class="comment">//给顾客收据</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(receipt); <span class="comment">//收银完毕，释放信号</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：<br>在分析该问题过程中，出现若干问题，是参阅相关资料后才认识到这些问题的隐蔽性和严重性的，主要包括：<br>（1）在顾客进程，如果是在释放 leave_barberchair 信号之后进行付款动作的话，很容易造成没有收银员为其收款的情形， 原因是： 为该顾客理发的理发师收到 leave_barberchair 信号后，释放 barber_chair 信号，另外一名顾客坐到理发椅上，该理发师有可能为这另外一名顾客理发，而没有为刚理完发的顾客收款。为解决这个问题，就是采取在释放 leave_barberchair 信号之前，完成付款操作。这样该理发师无法进入下一轮循环为另外顾客服务，只能到收银台收款。<br>（2）本算法是通过给理发师编号的方式，当顾客坐到某理发椅上也同时获得理发师的编号，如此，当该理发师理发结束，释放信号，顾客只有接收到为其理发的理发师的理发结束信号才会进行付款等操作。这样实现，是为避免这样的错误，即：如果仅用一个 finished 信号量的话，很容易出现别的理发师理发完毕释放了 finished 信号，把正在理发的这位顾客赶去付款，而已经理完发的顾客却被阻塞在理发椅上的情形。当然也可以为顾客进行编号，让理发师获取他理发的顾客的编号，但这样就会限制顾客的数量，因为 finished [] 数组不能是无限的。而为理发师编号，则只需要三个元素即可。</p>
<h2 id="5-4-练习题"><a href="#5-4-练习题" class="headerlink" title="5.4. 练习题"></a>5.4. 练习题</h2><p>1、某小型超级市场，可容纳 50 人同时购物。入口处有篮子，每个购物者可拿一只篮子入内购物。出口处结帐，并归还篮子（出、入口禁止多人同时通过）。试用信号量和 P、 V 操作写出购物者的同步算法。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex1=<span class="number">1</span>,mutex2=<span class="number">1</span>,empty=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">customer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex1);</span><br><span class="line">    take a basket;</span><br><span class="line">    V(mutex1);</span><br><span class="line">    shopping;</span><br><span class="line">    P(mutex2);</span><br><span class="line">    put back a basket;</span><br><span class="line">    V(mutex2);</span><br><span class="line">    leaving;</span><br><span class="line">    V(empty);</span><br><span class="line">}</span><br><span class="line">conend;</span><br></pre></td></tr></tbody></table></figure>

<p>2、桌上有个只能盛得下一个水果的空盘子。爸爸可向盘中放苹果或桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定：当盘子空时，一次只能放入一个水果供吃者取用。试用信号量和 P、 V 操作实现爸爸、儿子和女儿这三个循环进程之间的同步。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore empty=<span class="number">1</span>,orange=<span class="number">0</span>,apple=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> fruit;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">father</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(empty);</span><br><span class="line">        fruit=put_fruit();</span><br><span class="line">        <span class="keyword">if</span>(fruit==ORE) V(orange);</span><br><span class="line">        <span class="keyword">else</span> V(apple);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">son</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(orange);</span><br><span class="line">        eat orange;</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">daughter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(apple);</span><br><span class="line">        eat apple;</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>3、设 A、 B 两点之间是一段东西向的单行车道，现在要设计一个 AB 路段自动管理系统，管理规则如下：当 AB 间有车辆在行驶时同方向的车可以同时驶入 AB 段，但另一方向的车必须在 AB 段外等待；当 AB 段之间无车辆行驶时，到达 AB 段的任一方向的车都可进入 AB 段，但不能从两个方向同时驶入，即只能有一个方向的车驶入；当某方向在 AB 段行驶的车辆驶出了 AB 段且暂无车辆进入 AB 段时，应让另一方向等待的车辆进入 AB 段行驶。试用信号量和 P、V 操作管理 AB 路段车辆的行驶。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>,mAtoB=<span class="number">1</span>,mBtoA=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> car_numAtoB=<span class="number">0</span>,car_numBtoA=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">carFromAtoB</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(mAtoB);</span><br><span class="line">    <span class="keyword">if</span>(car_numAtoB==<span class="number">0</span>)</span><br><span class="line">        P(mutex);</span><br><span class="line">    ++car_numAtoB;</span><br><span class="line">    V(mAtoB);</span><br><span class="line">    Car runs from A to B;</span><br><span class="line">    P(mAtoB);</span><br><span class="line">    --car_numAtoB;</span><br><span class="line">    <span class="keyword">if</span>(car_numAtoB==<span class="number">0</span>)</span><br><span class="line">        V(mutex);</span><br><span class="line">    V(mAtoB);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">carFromBtoA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(mBtoA);</span><br><span class="line">    <span class="keyword">if</span>(car_numBtoA==<span class="number">0</span>)</span><br><span class="line">        P(mutex);</span><br><span class="line">    ++car_numBtoA;</span><br><span class="line">    V(mBtoA);</span><br><span class="line">    Car runs from B to A;</span><br><span class="line">    P(mBtoA);</span><br><span class="line">    --car_numBtoA;</span><br><span class="line">    <span class="keyword">if</span>(car_numBtoA==<span class="number">0</span>)</span><br><span class="line">        V(mutex);    </span><br><span class="line">    V(mBtoA);</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>4、有两个用户进程 A 和 B，在运行过程中都要使用系统中的一台打印机输出计算结果。为保证这两个进程能正确地打印出各自的结果，请用信号量和 P、 V 操作写出各自的有关申请、使用打印机的代码。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);</span><br><span class="line">        print();</span><br><span class="line">        V(mutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>5、有一个阅览室，共有 100 个座位，读者进入时必须先在一张登记表上登记，该表为每一座位列一表目，包括座号和读者姓名等，读者离开时要消掉登记的信息，试用 PV 操作描述读者进程之间的同步关系。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>;</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>,seats=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_in</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    P(seats);</span><br><span class="line">    P(mutex);</span><br><span class="line">    登记;</span><br><span class="line">    V(mutex);</span><br><span class="line">    read();</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_out</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    V(seats);</span><br><span class="line">    P(mutex);</span><br><span class="line">    消去登记;</span><br><span class="line">    V(mutex);</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>6、设有一台计算机，有两条 I/O 通道，分别挂一台输入机和一台打印机。若要把输入机上的数据逐一地输入到缓冲区 B1 中，然后处理，并把结果搬到缓冲区 B2 中，最后在打印机上输出。用 P-V 操作写出这些进程的同步算法。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/545cb74e88b486b863fb5b54e3cf3334.png" alt="20160406120541066.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">empty1</span>, <span class="title">full1</span>, <span class="title">empty2</span>, <span class="title">full2</span>=</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line">data B1, B2;</span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">IP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        Get a new  data from input unit into x;</span><br><span class="line">        P(empty1);</span><br><span class="line">        B1=x;</span><br><span class="line">        V(full1);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">PP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(full2);</span><br><span class="line">        x=B2;</span><br><span class="line">        V(empty2);</span><br><span class="line">        print x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">CP</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    data x,y;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(full1);</span><br><span class="line">        x=B1;</span><br><span class="line">        V(empty1);</span><br><span class="line">        Compute on x and put the result into y;</span><br><span class="line">        P(empty2);</span><br><span class="line">        B2=y;</span><br><span class="line">        V(full2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">coend;</span><br></pre></td></tr></tbody></table></figure>

<p>7、假定有三个进程 R、W1、W2 共享一个缓冲区 B，B 中每次只能存放一个整数。进程 R 每次启动输入设备读一个整数且把它存放在缓冲区 B 中，若存放到缓冲区 B 中的是奇数，则由进程 W1 将其取出打印，否则由进程 W2 将其取出打印。要求用 PV 操作管理这 3 个并发进程，使它们能够正确同步工作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">empty</span>, <span class="title">fullo</span>, <span class="title">fulle</span>=</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> B;</span><br><span class="line"><span class="type">void</span> process <span class="title function_">R</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        input data into x;</span><br><span class="line">        P(empty);</span><br><span class="line">        B=x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)  V(fullo);</span><br><span class="line">        <span class="keyword">else</span>  V(fulle);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> process <span class="title function_">W1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(fullo);</span><br><span class="line">        y=B;</span><br><span class="line">        V(empty);</span><br><span class="line">        print y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> process <span class="title function_">W2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        P(fulle);</span><br><span class="line">        z=B;</span><br><span class="line">        V(empty);</span><br><span class="line">        print z;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/ccomma_cat">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/da53cb8a00c9/" rel="prev" title="操作系统从入门到入土①：概述">
                  <i class="fa fa-angle-left"></i> 操作系统从入门到入土①：概述
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/e9eb9f4d0df9/" rel="next" title="操作系统从入门到入土③：内存管理">
                  操作系统从入门到入土③：内存管理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CComma</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ccomma" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://ccomma.cn/b41ef6b33f18/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ccomma","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
