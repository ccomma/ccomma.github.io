<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CComma&#39;s Blog</title>
  
  <subtitle>Connect the world</subtitle>
  <link href="https://ccomma.cn/atom.xml" rel="self"/>
  
  <link href="https://ccomma.cn/"/>
  <updated>2024-03-15T07:39:34.050Z</updated>
  <id>https://ccomma.cn/</id>
  
  <author>
    <name>CComma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES 写入原理及调优</title>
    <link href="https://ccomma.cn/4216ce6ea7d2/"/>
    <id>https://ccomma.cn/4216ce6ea7d2/</id>
    <published>2024-03-12T02:37:13.000Z</published>
    <updated>2024-03-15T07:39:34.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？</p><p><strong>1. 解决写入问题</strong><br>心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。</p><p><strong>2. 学习架构设计思想</strong><br>这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。</p><p><strong>3. 应对面试</strong><br>虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题</p><p>常见的面试问题：</p><ul><li>你了解 ES 的写入原理吗</li><li>你了解文档的写入 / 删除过程吗</li><li>如何保证 ES 数据写入一致性</li><li>文档写入超时原因</li><li> ES 写入实时性如何去保证</li><li>数据量大时如何保证数据写入性能</li><li>如何提高数据检索能力</li></ul><span id="more"></span><h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h2><p>ES 中的数据写入均发生在主分片上。由于 ES 是分布式系统，实际接收到写入请求的节点可能是任意一台节点，这就需要将请求通过 routing 路由到具体主分片所在的节点，将数据写入该节点的主分片中，然后主分片再同步数据到其他节点的副分片中。<br>路由公式：<code>shard_num = hash(_routing) % num_primary_shards</code><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b20c17eb26dfc1a90e9433ae005a39e.jpeg"><br>具体流程：</p><ol><li>客户端发起写入请求至 node 4</li><li>node 4 通过文档 id 在路由表中的映射信息确定当前数据的位置为分片 0，分片 0 的主分片位于 node 5，并将数据转发至 node 5。</li><li>数据在 node 5 写入，写入成功之后将数据的同步请求转发至其副本所在的 node 4 和 node 6 上面，等待所有副本数据写入成功之后 node 5 将结果报告 node 4，并由 node 4 将结果返回给客户端，报告数据写入成功。</li></ol><h2 id="写一致性策略"><a href="#写一致性策略" class="headerlink" title="写一致性策略"></a>写一致性策略</h2><p>ES 5.x 之后，一致性策略由 <code>wait_for_active_shards</code> 参数控制：状态为 active 的主副分片数量达到设定阈值时才视为写入成功，才会返回数据给客户端。默认为 1，即只需要主分片写入成功，可设置为 <code>all</code> 或任何正整数，最大值为索引中的分片总数 (&nbsp;<code>number_of_replicas + 1</code> )。</p><p>如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间 30 秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。</p><p>执行索引操作时，分配给执行索引操作的主分片可能不可用。造成这种情况的原因可能是主分片当前正在从网关恢复或正在进行重定位。默认情况下，索引操作将在主分片上等待最多 1 分钟，然后才会失败并返回错误。</p><h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p>我们已经知道了宏观上的写入流程：先找到主节点，写入主节点后再同步到副节点。<br><strong>那 ES 是怎么把数据写入主节点和副节点中的呢？</strong></p><p>大家可能会有疑问，难道不是直接写入到磁盘吗？<strong>我们可以思考下，每次请求都直接写入到磁盘这种方式在高并发的场景下会消耗大量的 IO 资源，每次都要寻址然后写入磁盘。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba7282dc7f49c616767143d774646a3b.jpeg" alt="未命名文件.jpg"></p><p>对此我们可以用缓存来解决，即把数据写入系统缓存后，定期批量写入磁盘，同时缓存也提供检索服务。<br>而 Lucene 中索引是细分为多个 segment 的，segment 是索引中存储索引数据的内部存储元素，并且是不可变的。较小的 segment 会定期合并到较大的 segment 中，以控制索引大小。问题又来了：<strong>如果每次请求都创建一个新的 segment，那么会导致频繁的合并操作（merge）。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ec5aedd4c9bc6e805872b3f5944957a8.jpeg" alt="未命名文件.jpg"></p><p>所以 ES 在请求进入缓存之前先让请求进缓冲区（memory buffer），每秒或每 100 个缓存才会执行刷新操作（Refresh）把缓冲区中的数据创建 segment 写入系统缓存中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/10b375c43ff4ab15fe0c8ed7fa469f8e.jpeg" alt="未命名文件 (1).jpg"></p><p>至此这套批量持久化结构已经比较完善，但还有一个问题：<strong>缓存虽然提高了性能，但毕竟未持久化到磁盘，一旦系统出现故障数据就会丢失。</strong>ES 采用事务日志（translog）的方式解决此问题，当请求进来时会同时写入缓冲区和事务日志中，当服务重启后就会从事务日志中恢复数据到缓存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dcb5acedec3e2a0f97e678cd403a0eea.jpeg" alt="未命名文件 (1).jpg"></p><p>整体结构：</p><ul><li>Memory Buffer（缓冲区）：数据批量操作，高性能写入</li><li> Translog（事务日志）：保证数据写入安全性，防止丢失</li><li> OS Cache（内存）：保证数据高性能检索</li><li> OS Disk（磁盘）：保证数据持久化</li></ul><p>具体流程：</p><ol><li>客户端写入 Memory Buffer 缓冲区，并追加写入 Translog 事务日志（删除、写入…）以保证数据安全性。</li><li>Memory Buffer 达到阈值（100 条 / 1s）后执行 Refresh 操作生成 Segment 索引文件到系统缓存中。<ol><li>然后系统缓存会把该 Segment 标记为可被检索，因此数据有 1s 不可读的延迟。</li><li>Refresh 操作不能过于频繁，因此针对实时性不高的数据，可以配置 refresh 的间隔时间为 30s 一次。</li></ol></li><li>每个 Segment 都会消耗文件句柄、内存、CPU 运行周期，所以每隔一段时间会执行 Merge 操作，合并 Segment。<ol><li>Merge 操作发生在 JVM 中，频率过高会占用堆内存空间，所以 Refresh 的频率不能太高，否则会使 Merge 频率增高。</li><li>不合并 Segment 的影响：<ol><li>每个 Segment 占据的内存不会随着 GC 释放的。导致系统内存不足，进一步导致超时问题。</li><li>查询时会遍历每个 Segment，过多的 Segment 会导致查询速度下降。</li></ol></li></ol></li><li>执行 Flush 操作缓存写入 OS Disk（磁盘）并提交一次，并清空 Translog。<ol><li>系统缓存每隔 30 分钟、Translog 每隔 5 秒刷一次到磁盘中，所以默认情况下，可能会有 5s 数据丢失。</li><li>系统缓存和 Translog 写满时也会刷磁盘。</li></ol></li><li>断电等异常操作导致数据丢失时，服务重启后会读取 Translog 中的数据到 Memory Buffer 中，以完成回滚操作。</li></ol><p>相关参数：</p><ul><li>index.translog.durability：同步还是异步<ul><li> request：（默认）主副分片在每个请求后执行 fsync 和 commit，才会向客户端报告索引、删除、更新或批量请求的成功。如果发生崩溃，那么所有只要是已经确认的写操作都已经被提交到磁盘。</li><li>async：在后台每 index.translog.sync_interval 时间进行一次 fsync 和 commit。意味着如果发生崩溃，那么所有在上一次自动提交以后的已确认的写操作将会丢失。</li></ul></li><li>index.translog.sync_interval：translog 多久被同步到磁盘并提交一次。默认 5 秒。这个值不能小于 100ms。</li><li>index.translog.flush_threshold_size：translog 执行 flush 操作的空间最大阈值，默认 512 MB。</li></ul><h2 id="写入性能调优"><a href="#写入性能调优" class="headerlink" title="写入性能调优"></a>写入性能调优</h2><p>生产经常面临的写入可以分为两种情况：</p><ul><li>高并发：高频的创建 / 更新索引文档，一般发生在 C 端场景下</li><li>高吞吐：定期重建索引或批量更新文档数据，一般为 B 端场景</li></ul><p><strong>1. 提升写入吞吐量和并发</strong><br>ES 数据写入具有一定的延时性，这是为了减少频繁的索引文件产生。默认情况下 ES 每秒生成一个 segment 文件，当达到一定阈值的时候会执行 merge，merge 过程发生在 JVM 中，频繁的生成 segmen 文件可能会导致频繁的触发 FGC，导致 OOM。<br>为了避免避免这种情况，通常采取的手段是降低 segment 文件的生成频率，手段有两个，一个是增加时间阈值，另一个是增大 buffer 的空间阈值。</p><ol><li>增加 flush 时间间隔。Flush 是 IO 操作，很消耗性能，不能太频繁</li><li>增加 refresh_interval 的参数值<ol><li>目的是减少 segment 文件的创建，减少 segment 的 merge 次数。</li><li>merge 是发生在 JVM 中的，有可能导致 full GC，增加 refresh 会降低搜索的实时性。</li></ol></li><li>增加 buffer 大小<ol><li>减小 refresh 的时间间隔，因为导致 segment 文件创建的原因不仅有时间阈值，还有 buffer 空间大小，写满了也会创建。</li><li>默认最小值 48MB &lt; 默认值 JVM 空间的 10% &lt; 默认最大无限制</li></ol></li><li>关闭副本（提高单次吞吐）<ol><li>需要单次写入大量数据的时候，可以关闭副本（减少数据同步），暂停搜索服务，或选择在检索请求量谷值区间时间段来完成。因为副本的存在会导致主从之间频繁的进行数据同步，大大增加服务器的资源占用。</li><li>可通过则设置 index.number_of_replicas 为 0 以加快索引速度。没有副本意味着丢失单个节点可能会导致数据丢失，因此数据保存在其他地方很重要，以便在出现问题时可以重试初始加载。初始加载完成后，可以设置 index.number_of_replicas 改回其原始值。</li></ol></li><li>max_result_window 参数</li></ol><p>分页返回的最大数值，默认值为 10000。通过设定一个合理的阈值，避免初学者分页查询时由于单页数据过大而导致 OOM。</p><p><strong>2. 提高写入实时性（不推荐）</strong><br>在搜索引擎的业务场景下，用户一般并不需要那么高的写入实时性。有时这个延时的过程需要处理很多事情，比如信息需要后台审核。<br>可以提高 Memory Buffer 的 refresh 操作频率，但是过高的 refresh 会导致频繁 merge segment，会消耗更多堆内存、CPU 的资源</p><h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><p>1. 避免单次召回大量数据<br>搜索引擎最擅长的事情是从海量数据中查询少量相关文档，而非单次检索大量文档。非常不建议动辄查询上万数据。如果有这样的需求，建议使用滚动查询<br>2. 避免单个文档过大<br>硬性限制：<br>鉴于默认 http.max_content_length 设置为 100MB，Elasticsearch 将拒绝索引任何大于该值的文档。可以增加该特定设置，但 Lucene 仍然有大约 2GB 的限制。<br> <br>大型文档对网络、内存使用和磁盘造成了更大的压力，即使对于不请求的搜索请求也是如此。<br>3. 使用 filter 代替 query<br>query 是要对查询的每个结果计算相关性得分的，而 filter 不会。另外 filter 有相应的缓存机制，可以提高查询效率。<br>4. 避免深度分页<br>5. 使用 Keyword 类型<br>并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为查询优化数字字段，例如 integeror long。如果不需要范围查找，对于 term 查询而言，keyword 比 integer 性能更好。</p><p>参考：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index-modules-translog.html">Translog | Elasticsearch Guide [7.17] | Elastic</a></li><li><a href="https://blog.csdn.net/a645293829/article/details/132223065">【HBZ 分享】ES 索引分片的写入原理 及 流程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 解决写入问题&lt;/strong&gt;&lt;br&gt;心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 学习架构设计思想&lt;/strong&gt;&lt;br&gt;这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 应对面试&lt;/strong&gt;&lt;br&gt;虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题&lt;/p&gt;
&lt;p&gt;常见的面试问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你了解 ES 的写入原理吗&lt;/li&gt;
&lt;li&gt;你了解文档的写入 / 删除过程吗&lt;/li&gt;
&lt;li&gt;如何保证 ES 数据写入一致性&lt;/li&gt;
&lt;li&gt;文档写入超时原因&lt;/li&gt;
&lt;li&gt; ES 写入实时性如何去保证&lt;/li&gt;
&lt;li&gt;数据量大时如何保证数据写入性能&lt;/li&gt;
&lt;li&gt;如何提高数据检索能力&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从 0 到 1 快速搭建博客</title>
    <link href="https://ccomma.cn/58a80fbce4aa/"/>
    <id>https://ccomma.cn/58a80fbce4aa/</id>
    <published>2024-02-13T07:05:42.000Z</published>
    <updated>2024-03-12T12:09:52.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么搭建博客"><a href="#为什么搭建博客" class="headerlink" title="为什么搭建博客"></a>为什么搭建博客</h1><ul><li>知识积累</li><li>分享</li><li>影响力</li></ul><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="静态页面生成"><a href="#静态页面生成" class="headerlink" title="静态页面生成"></a>静态页面生成</h2><p>我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。</p><p>像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress</p><p>为什么选择 hexo？主题较现代化、方便快捷<br><a href="https://github.com/hexojs/hexo">hexo github</a></p><span id="more"></span><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>_config.yml 里配置你的项目地址</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ccomma/ccomma.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></tbody></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多主题，这里推荐 Next 主题，因为 Next 的社区非常活跃，这就导致 Next 主题有非常多的配置和插件</p><p>Next 主题配置<br><a href="https://theme-next.js.org/docs/theme-settings/">Theme Settings</a></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>博客可以部署在阿里云等云服务器上，但是特地买一台服务器专门用来部署博客还是有点太浪费了。</p><p>以下几种方式可以免费部署静态 web 应用</p><ul><li>github pages<ul><li> 服务器地理位置：美国</li><li>推荐：push 即部署，简单快捷 </li><li>缺点：网络连接严重不稳定</li></ul></li><li> cloudflare pages<ul><li> 服务器地理位置：美国自家节点</li><li>推荐原因：速度稳定，在全球各地均有 CDN，支持从 Github/Gitlab 等平台自动部署 </li><li>缺点：部署速度较慢，但不算太影响</li></ul></li><li> Vercel<ul><li> 服务器地理位置：美国 AWS</li><li> 推荐原因：部署速度快，支持自动部署</li><li>缺点：被墙过一次，速度有可能出现不稳定</li></ul></li></ul><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>hexo 能让我们更专心写博客，但即使是如此，我们还是要先使用 <code>hexo new "xxx"</code> 命令来新建文档。而我们平时的笔记可能是写在 notion、语雀、飞书上。</p><p>写作同步工具 <a href="https://github.com/LetTTGACO/elog">elog</a> 能让我们的在 notion、语雀、飞书上的笔记自动部署到 github 上</p><p>elog 会在本地创建缓存，每次同步只会增量更新，包括图片上传也是。</p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>github pages 自带域名：xxxx.github.io，够用，但是有点 low</p><ul><li><a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520112.products-recent.ddomain.5c0234c0saWuKP#/overview">阿里云域名</a>：基本都是国内的，30+/ 年 </li><li><a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412">cloudflare</a>：国外域名，9.77～45 美元</li></ul><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1. 阿里云付费 SSL<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79690ec1537f107639504c426c7654f.png" alt="image.png"></p><p>2. 阿里个人测试证书，有效期 3 个月<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7abb7f515c8c087585cf82b749f58856.png" alt="image.png"></p><p> 3.<a href="https://letsencrypt.org/">Let’s Encrypt</a>：提供免费 TLS 证书的非营利证书颁发机构，就个人博客而言足以</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>阿里云 DNS：DNS 解析与域名服务捆绑，声誉一般</p><p>cloudflare：</p><ul><li>支持 CDN（国内减速）</li><li>自带 DDos 防御服务</li><li>支持解析 A、AAAA、CNAME、MX、LOC、SRV、SPF、TXT、NS、CAA、PTR、CERT、DNSKEY、DS、NAPTR、SMIMEA、SSHFP、TLSA、URI</li><li> 支持 DNSSEC</li><li> 免费版支持一部分其他地方收费的配套服务，例如 Worker，Page，访客规则</li></ul><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>搜索引擎优化，让你的网站更好的被搜索引擎收录</p><p>google：<a href="https://search.google.com/search-console">https://search.google.com/search-console</a><br>bing：<a href="https://www.bing.com/webmasters">https://www.bing.com/webmasters</a><br>百度：<a href="https://ziyuan.baidu.com/site">https://ziyuan.baidu.com/site</a></p><p>以 google 为例：<br>登录到 Google Search Console，选择您要验证的网站。输入网址<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/060a5e066eda3911a4d4b938a91b23b3.png" alt="image.png"><br>将验证码复制到 DNS 记录中<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb3c64f775d04dc6ff8dabc1d6990035.png" alt="image.png"></p><h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>对网站流量访问进行分析</p><p>1.<a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412/web-analytics/sites">cloudflare</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39742d06912a9f134af70c3df193507.png" alt="image.png"></p><p>2.<a href="https://search.google.com/search-console?resource_id=sc-domain:ccomma.cn">google</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d5ef6ca57eb04a42125cc57f9f95af0.png" alt="image.png"></p><p>3. <a href="https://tongji.baidu.com/main/overview/10000609568/overview/index?siteId=20141034">百度统计</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bfbbe9f8eda65e69abc5b9b1074671cd.png" alt="image.png"></p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>百度云 CDN：百度云加速分为免费版和付费版，免费版不支持 SSL 证书，海外网站也支持加速。</p><p>cloudflare CDN：<br>免费提供，对于国外的服务器还行，国内服务器反而减速。支持 SSL，无须备案</p><p>七牛云 CDN：<br>每个月可使用 10G 的免费存储量和 10G 的 CDN 流量与 100 万次的 Get 请求数，七牛云在海外也有众多加速节点，七牛云 TCP 压缩优化使网页中大图和样式等实现秒加载。但请注意使用七牛 CDN，须保证账户中有最低金额 10 元。国内必须备案，支持 SSL。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bilibili.com/video/BV1Sp4y157br/?vd_source=8f8a2ec64a5f07bb8bf30a6ef4819025">将 Hexo 博客部署到 CloudFlare Pages 使用全球加速</a></li><li><a href="https://cloud.tencent.com/developer/article/1987796?areaSource=102001.7&amp;traceId=zTjHWNtLK7p3TbHHsvayg">5 个免费的静态 Web 应用部署平台</a></li><li><a href="https://hqyman.cn/post/4255.html">国内外免费域名 DNS 解析推荐</a></li><li><a href="https://www.zhihu.com/question/342631132">如何使用 Notion 制作个人网站？</a></li><li><a href="https://www.cnblogs.com/wangyuehan/p/12743624.html">Notion 做个人博客的两种实现方式</a></li><li><a href="https://blog.ithuo.net/post/2023-11-07%2FNotion%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97">Notion 博客折腾指南</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2">使用 hexo+github 搭建免费个人博客</a></li><li><a href="https://juejin.cn/post/7304540675668181003">语雀写作，Kubernetes 部署 ——Elog+Hexo 博客持续集成</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么搭建博客&quot;&gt;&lt;a href=&quot;#为什么搭建博客&quot; class=&quot;headerlink&quot; title=&quot;为什么搭建博客&quot;&gt;&lt;/a&gt;为什么搭建博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;知识积累&lt;/li&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;影响力&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建站&quot;&gt;&lt;a href=&quot;#建站&quot; class=&quot;headerlink&quot; title=&quot;建站&quot;&gt;&lt;/a&gt;建站&lt;/h1&gt;&lt;h2 id=&quot;静态页面生成&quot;&gt;&lt;a href=&quot;#静态页面生成&quot; class=&quot;headerlink&quot; title=&quot;静态页面生成&quot;&gt;&lt;/a&gt;静态页面生成&lt;/h2&gt;&lt;p&gt;我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。&lt;/p&gt;
&lt;p&gt;像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress&lt;/p&gt;
&lt;p&gt;为什么选择 hexo？主题较现代化、方便快捷&lt;br&gt;&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;hexo github&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://ccomma.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="https://ccomma.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>并行流导致接口慢调用问题</title>
    <link href="https://ccomma.cn/cb2072810346/"/>
    <id>https://ccomma.cn/cb2072810346/</id>
    <published>2023-08-14T00:55:38.000Z</published>
    <updated>2024-02-23T05:26:09.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。</p><span id="more"></span><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8ff9b37602e5bee3be548af291c7348e.png" alt="image.png"><br>根据 ARMS 分析该接口的调用量在 18:31-18:41 出现断崖式增长，每分钟请求数从 5.1k 增加到 14.7k，10 分钟增长了 9.6k。（后续调查表明在该时间段内大部分接口调用量都出现了断崖式增长）<br>异常时刻的 qps 大致为 236.1，几乎是一周前的 2 倍。</p><p><strong>响应时间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3dd26f56b4afe1a4bfcb5a79450452d1.png" alt="image.png"><br>每分钟响应时间平均为 3747 ms，整个异常过程中该接口最长的响应时间达到 8s 多。</p><p><strong>dubbo 线程池：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d7b54ac7097680e22af442ccbd6b276.png" alt="image.png"><br>所有接口的每分钟 dubbo 请求调用量在 18:35-18:45 内从 14.2k 增长至 35.6k<br>也是在这段时间内 dubbo 线程池被打满，在 18:40 左右基本被打满<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/decb4154e9d3362f4dd2e3b7dbd1892f.png" alt="image.png"></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>初步判断流量突增的原因是客户端开放灰度，使得预定业务中的一个轮询调用的接口调用次数上升。<br>该接口调用桌位状态服务的一个较为通用的查询接口，里面使用 parallelStream 来进行 RPC 调用获取账单。<br>parallelStream 使用与 CPU 核数一致的线程数来处理任务，当请求量增大时线程池中的线程全部被打满，导致后续的任务一直在排队等待延迟处理，最终 dubbo 线程池也被占满。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>从问题的核心代码到外部调用，可优化的点如下：</p><ol><li>取消并行流</li><li>加大批量获取数，让调用量减小</li><li>经查看代码发现出现问题的使用并行流查账单是为了设置桌位状态的 payStatus，但是上层并不关心这个字段，所以可以让上层调用更轻量级的接口</li><li>降低客户端轮询次数，轮询调用需谨慎，轮询策略需要好好设计</li></ol><h2 id="2023-08-13（代码修改后）"><a href="#2023-08-13（代码修改后）" class="headerlink" title="2023.08.13（代码修改后）"></a>2023.08.13（代码修改后）</h2><p>141 部署了优化后的代码，取消了并行流，分页大小增加到 10<br>142 没有改动，以此作为对照。</p><p>总体应用每分钟调用量峰值也有 14.7k，但是 13 号这天的曲线明显更加平滑，没有出现 dubbo 线程池被打满的情况，慢调用的数量和时长都在正常范围内。</p><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b6f1ef4f96f597a9b716feb0c2990204.png" alt="image.png"></p><p><strong>响应时间：</strong><br>141 比 142 更缓和</p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4cbe6c1f08b59f911f0a0aa91140deae.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4573954d3923199d395b8c80d3cb6909.png" alt="image.png"></p><p><strong>dubbo 线程数：</strong></p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/50b9cd579f52f5b56e2e28be3205d865.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1f735878b6e9667f825e70e452c8492.png" alt="image.png"></p><p>08.13 修改优化后至今，142 会依然出现一定量的慢调用，141 没有出现过<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/532b6fca9a1b64382d8ac364a4851385.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次问题应该是由于短时间内的调用量突增，加上使用并发流处理 RPC 调用引起的。<br>根据 13 号的对照来看，流量平滑增加的情况不会出现特别严重的线程池等待现象，但依然有慢调用，存在隐患。</p><p>取消并行流，增加分页大小的方案是可行的，以后并行流需要谨慎使用。后续也和客户端讨论了上层接口的调整方案。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
    <category term="并行流" scheme="https://ccomma.cn/tags/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>如何快速定位问题</title>
    <link href="https://ccomma.cn/6c827d88b19c/"/>
    <id>https://ccomma.cn/6c827d88b19c/</id>
    <published>2023-08-10T14:23:27.000Z</published>
    <updated>2024-02-23T03:15:00.055Z</updated>
    
    <content type="html"><![CDATA[<p>这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。</p><p>整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再去更新打印状态。</p><p>排查了很久发现是客户端接收不到消息，客户端同学也表示不知所措，问了消息通道那边的同学后发现安卓客户端在这之前就断开连接了，重新连接后立马就接收到了消息。一度怀疑是消息通道的问题，后来才发现客户端一直运行在后台，且自动刷新是关闭的。</p><p>因整个排查浪费了太多时间故在此做个复盘<br>整个链路很长，任何环节都有可能出现问题。</p><ol><li>先尽可能排除用户误操作产生的影响</li><li>有些地方不好排查（如消息通道），排查必须得有侧重点</li><li>需要有一个负责人协调多位项目相关人，依次推进进度，提高效率</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。&lt;/p&gt;
&lt;p&gt;整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再</summary>
      
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="思考" scheme="https://ccomma.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>类型转换异常 sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</title>
    <link href="https://ccomma.cn/fb2b1fd4b701/"/>
    <id>https://ccomma.cn/fb2b1fd4b701/</id>
    <published>2023-06-21T06:13:28.000Z</published>
    <updated>2024-02-23T05:24:31.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">    Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第四行 <code>Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[0]</code> 报 <code>java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</code> 错误</p><p>这个代码是子类想要拿到泛型参数时出现的类型转换异常</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上述问题中的类结构简化如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request2</span> <span class="keyword">extends</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request3</span> <span class="keyword">extends</span> <span class="title class_">Request2</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request</span>&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request2</span>&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;R&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&lt;Request3&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>1/ <code>(new C).requestHandle()</code><br>因为 C 继承 B<request3>，所以 <code>parameterizedType.getActualTypeArguments()[0]</code> 拿到的其实就是 <code>Request3.class</code> </request3></p><p>2/ <code>(new B).requestHandle()</code><br>这种情况 <code>parameterizedType.getActualTypeArguments()[0]</code> 返回的是 <code>TypeVariable</code>，不是 Class<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/266de73a45592b057e2f6005b846e830.png" alt="image.png"><br>很好理解，因为 B 类的定义是 B<r extends="" request2="">，这里很容易因为泛型的类型擦除误认为 <code>parameterizedType.getActualTypeArguments()[0]</code> 会返回 <code>Request2.class</code></r></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>仔细观察 <code>TypeVariable</code> 接口定义</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeVariable</span>&lt;D <span class="keyword">extends</span> <span class="title class_">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title class_">Type</span>, AnnotatedElement {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上边界</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 Request2.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取泛型声明的类型，即这个类型变量的声明来源</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 B.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    D <span class="title function_">getGenericDeclaration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该类型变量名称</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 R</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带注解的上边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以调用 <code>getBounds()</code> 来获取泛型的上边界</p><p>最终调整如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> Class) {</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> TypeVariable) {</span><br><span class="line">            <span class="type">TypeVariable</span> <span class="variable">v</span> <span class="operator">=</span> (TypeVariable) actualTypeArgument;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) v.getBounds()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; getClass().getGenericSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; ParameterizedType) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ParameterizedType&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;parameterizedType&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; (ParameterizedType) type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四行 &lt;code&gt;Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[0]&lt;/code&gt; 报 &lt;code&gt;java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class&lt;/code&gt; 错误&lt;/p&gt;
&lt;p&gt;这个代码是子类想要拿到泛型参数时出现的类型转换异常&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>对 1e9 + 7 取模</title>
    <link href="https://ccomma.cn/6a28fa6963c0/"/>
    <id>https://ccomma.cn/6a28fa6963c0/</id>
    <published>2022-11-19T13:45:19.000Z</published>
    <updated>2024-02-23T05:31:05.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么取模"><a href="#为什么取模" class="headerlink" title="为什么取模"></a>为什么取模</h2><p>OJ 上很多题目因为难度原因需要非常大的测试数据量（数据量大了自然会对算法的时间复杂度要求更高），而大数据量往往会导致溢出，虽然可以用 BigInt 等方式做题，但这就失去了这道题的原本意义。</p><p>这种情况题目会要求计算结果对 1e9 + 7 取模，因为对取模不会影响算法的正确性，既避免了高精度运算，又能保证极少的冲突情况。<br>这里可以先回顾下模除运算的等价性</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p</span><br><span class="line">(a - b) % p = (a % p - b % p ) % p</span><br><span class="line">(a * b) % p = (a % p * b % p) % p</span><br><span class="line">a ^ b % p = ((a % p)^b) % p</span><br></pre></td></tr></tbody></table></figure><p>由上述各个公式可知只要每次运算后觉得结果过大都可以对其进行取模，只要避免数据溢出，那么最终结果都是一样的。例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> MOD + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + <span class="number">1</span> + a * a;</span><br><span class="line">sum %= MOD;</span><br></pre></td></tr></tbody></table></figure><p>只要 sum 不溢出，那么其结果和对每次运算结果都 <code>%MOD</code> 一遍是一样的。</p><p>所以 <strong>取模成了简化大数据的一种约定</strong>，服务端给定算法取模后的测试数据，我们写算法时也进行取模，那么依然能验证算法的正确性。</p><span id="more"></span><h2 id="为什么是-1e9-7"><a href="#为什么是-1e9-7" class="headerlink" title="为什么是 1e9 + 7"></a>为什么是 1e9 + 7</h2><p>参考：<br><a href="https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E9%99%A4#%E7%AD%89%E4%BB%B7%E6%80%A7">wiki 模除 #等价性</a><br><a href="https://blog.csdn.net/qq_46689648/article/details/122795304">为什么对 1e9+7 取模</a><br><a href="https://blog.csdn.net/cpb____/article/details/107959450?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">C++ 中 1e9（初始化、无穷大）解析</a><br><a href="https://blog.csdn.net/qq_43827595/article/details/104267327?utm_term=1e9%207java%E5%8F%96%E6%A8%A1&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-104267327&amp;spm=3001.4430">【C++ 取模 mod 易错点】由于答案可能会很大，请你将结果对 1e9+7 取模后再返回</a><br><a href="https://www.zhihu.com/question/49374703">为什么很多程序竞赛题目都要求答案对 1e9+7 取模？</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么取模&quot;&gt;&lt;a href=&quot;#为什么取模&quot; class=&quot;headerlink&quot; title=&quot;为什么取模&quot;&gt;&lt;/a&gt;为什么取模&lt;/h2&gt;&lt;p&gt;OJ 上很多题目因为难度原因需要非常大的测试数据量（数据量大了自然会对算法的时间复杂度要求更高），而大数据量往往会导致溢出，虽然可以用 BigInt 等方式做题，但这就失去了这道题的原本意义。&lt;/p&gt;
&lt;p&gt;这种情况题目会要求计算结果对 1e9 + 7 取模，因为对取模不会影响算法的正确性，既避免了高精度运算，又能保证极少的冲突情况。&lt;br&gt;这里可以先回顾下模除运算的等价性&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(a + b) % p = (a % p + b % p) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(a - b) % p = (a % p - b % p ) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(a * b) % p = (a % p * b % p) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a ^ b % p = ((a % p)^b) % p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由上述各个公式可知只要每次运算后觉得结果过大都可以对其进行取模，只要避免数据溢出，那么最终结果都是一样的。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;MOD&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;1e9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; MOD + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; a + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + a * a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sum %= MOD;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只要 sum 不溢出，那么其结果和对每次运算结果都 &lt;code&gt;%MOD&lt;/code&gt; 一遍是一样的。&lt;/p&gt;
&lt;p&gt;所以 &lt;strong&gt;取模成了简化大数据的一种约定&lt;/strong&gt;，服务端给定算法取模后的测试数据，我们写算法时也进行取模，那么依然能验证算法的正确性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>891. 子序列宽度之和</title>
    <link href="https://ccomma.cn/38f6854c01e2/"/>
    <id>https://ccomma.cn/38f6854c01e2/</id>
    <published>2022-11-19T12:54:17.000Z</published>
    <updated>2024-02-23T05:24:31.381Z</updated>
    
    <content type="html"><![CDATA[<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。<br>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>1e9 + 7</code> <strong>取余</strong> 后的结果。<br><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p><span id="more"></span><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pow2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2</span> % MOD; <span class="comment">// 预处理 2 的幂次</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += (<span class="type">long</span>) (pow2[i] - pow2[n - <span class="number">1</span> - i]) * nums[i]; <span class="comment">// 在题目的数据范围下，这不会溢出</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (ans % MOD + MOD) % MOD; <span class="comment">// 注意上面有减法，ans 可能为负数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个序列的 &lt;strong&gt;宽度&lt;/strong&gt; 定义为该序列中最大元素和最小元素的差值。&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;code&gt;nums&lt;/code&gt; 的所有非空 &lt;strong&gt;子序列&lt;/strong&gt; 的 &lt;strong&gt;宽度之和&lt;/strong&gt; 。由于答案可能非常大，请返回对 &lt;code&gt;1e9 + 7&lt;/code&gt; &lt;strong&gt;取余&lt;/strong&gt; 后的结果。&lt;br&gt;&lt;strong&gt;子序列&lt;/strong&gt; 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 就是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的一个子序列。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>792. 匹配子序列的单词数</title>
    <link href="https://ccomma.cn/66915abb06c0/"/>
    <id>https://ccomma.cn/66915abb06c0/</id>
    <published>2022-11-17T15:10:37.000Z</published>
    <updated>2024-02-23T03:15:00.047Z</updated>
    
    <content type="html"><![CDATA[<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<code>words[i]</code>&nbsp;中是 <code>s</code> 的子序列的单词个数&nbsp;。<br>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符 (可以是 none)，而不改变其余字符的相对顺序。</p><ul><li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt;&amp;nbsp;和字符串数组&amp;nbsp;&lt;code&gt;words&lt;/code&gt;, 返回&amp;nbsp;&amp;nbsp;&lt;code&gt;words[i]&lt;/code&gt;&amp;nbsp;中是 &lt;code&gt;s&lt;/code&gt; 的子序列的单词个数&amp;nbsp;。&lt;br&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂</title>
    <link href="https://ccomma.cn/e8fc79331955/"/>
    <id>https://ccomma.cn/e8fc79331955/</id>
    <published>2022-11-13T10:27:20.000Z</published>
    <updated>2024-02-23T05:24:31.379Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">790. 多米诺和托米诺平铺</a><br>做题时看到官方除了 DP，还给出了这样一种解法，有点好奇便研究了一下</p><p>矩阵快速幂由 **_ 矩阵运算 _** 和 **_快速幂 _** 两部分组成</p><span id="more"></span><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/domino-and-tromino-tiling/&quot;&gt;790. 多米诺和托米诺平铺&lt;/a&gt;&lt;br&gt;做题时看到官方除了 DP，还给出了这样一种解法，有点好奇便研究了一下&lt;/p&gt;
&lt;p&gt;矩阵快速幂由 **_ 矩阵运算 _** 和 **_快速幂 _** 两部分组成&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="矩阵快速幂" scheme="https://ccomma.cn/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>764. 最大加号标志</title>
    <link href="https://ccomma.cn/6dc201714435/"/>
    <id>https://ccomma.cn/6dc201714435/</id>
    <published>2022-11-13T10:18:38.000Z</published>
    <updated>2024-02-23T05:24:31.386Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [xi, yi]</code> 表示&nbsp;<code>grid[xi][yi] == 0</code><br>返回 &nbsp;<code>grid</code> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong><em>轴对齐</em></strong> 加号标志的阶数 。如果未找到加号标志，则返回 <code>0</code> 。</p><p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<code>1</code>&nbsp;组成的 <strong><em>“轴对称” 加号标志</em></strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及 4 个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p><span id="more"></span><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] mines)</span> {</span><br><span class="line">        <span class="type">boolean</span>[][] map = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mines.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> mines[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span>  <span class="operator">=</span> mines[i][<span class="number">1</span>];</span><br><span class="line">            map[x][y] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n % <span class="number">2</span> == <span class="number">0</span> ? n - <span class="number">1</span>: n;</span><br><span class="line">        <span class="keyword">for</span> (; m &gt; <span class="number">0</span>; m -= <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// i =&gt; 上下偏移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">                <span class="comment">// j =&gt; 左右偏移</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n - m; j++) {</span><br><span class="line">                    <span class="comment">// 横向</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> m / <span class="number">2</span> + i;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j;</span><br><span class="line">                    <span class="keyword">for</span> (; y &lt; j + m; y++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 横向有 0</span></span><br><span class="line">                    <span class="keyword">if</span> (y != j + m) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 纵向</span></span><br><span class="line">                    x = i;</span><br><span class="line">                    y = m / <span class="number">2</span> + j;</span><br><span class="line">                    <span class="keyword">for</span> (; x &lt; i + m; x++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 可行，返回</span></span><br><span class="line">                    <span class="keyword">if</span> (x == i + m) {</span><br><span class="line">                        <span class="keyword">return</span> m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵&amp;nbsp;&lt;code&gt;grid&lt;/code&gt;&amp;nbsp;中，除了在数组&amp;nbsp;&lt;code&gt;mines&lt;/code&gt;&amp;nbsp;中给出的元素为&amp;nbsp;&lt;code&gt;0&lt;/code&gt;，其他每个元素都为&amp;nbsp;&lt;code&gt;1&lt;/code&gt;。&lt;code&gt;mines[i] = [xi, yi]&lt;/code&gt; 表示&amp;nbsp;&lt;code&gt;grid[xi][yi] == 0&lt;/code&gt;&lt;br&gt;返回 &amp;nbsp;&lt;code&gt;grid&lt;/code&gt; 中包含&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;的最大的 &lt;strong&gt;&lt;em&gt;轴对齐&lt;/em&gt;&lt;/strong&gt; 加号标志的阶数 。如果未找到加号标志，则返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;阶由&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;组成的 &lt;strong&gt;&lt;em&gt;“轴对称” 加号标志&lt;/em&gt;&lt;/strong&gt; 具有中心网格&amp;nbsp;&lt;code&gt;grid[r][c] == 1&lt;/code&gt;&amp;nbsp;，以及 4 个从中心向上、向下、向左、向右延伸，长度为&amp;nbsp;&lt;code&gt;k-1&lt;/code&gt;，由&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 &lt;code&gt;0&lt;/code&gt; 也可能为 &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>864. 获取所有钥匙的最短路径</title>
    <link href="https://ccomma.cn/1728e5a327c0/"/>
    <id>https://ccomma.cn/1728e5a327c0/</id>
    <published>2022-11-13T10:16:16.000Z</published>
    <updated>2024-02-23T05:24:31.385Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格&nbsp;grid&nbsp;，其中：</p><ul><li><code>'.'</code> 代表一个空房间</li><li><code>'#'</code> 代表一堵</li><li><code>'@'</code>&nbsp;是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 k&nbsp;为 钥匙 / 锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p><span id="more"></span><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">35</span>, K = <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N][N][<span class="number">1</span> &lt;&lt; K];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]{{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">0</span>,-<span class="number">1</span>}};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] g)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length, m = g[<span class="number">0</span>].length(), cnt = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                Arrays.fill(dist[i][j], INF);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[i].charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'@'</span>) {</span><br><span class="line">                    d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, j, <span class="number">0</span>});</span><br><span class="line">                    dist[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) {</span><br><span class="line">            <span class="type">int</span>[] info = d.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> info[<span class="number">0</span>], y = info[<span class="number">1</span>], cur = info[<span class="number">2</span>], step = dist[x][y][cur];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] di : dirs) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + di[<span class="number">0</span>], ny = y + di[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[nx].charAt(ny);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="string">'A'</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ncur</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) ncur |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ncur == (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (step + <span class="number">1</span> &gt;= dist[nx][ny][ncur]) <span class="keyword">continue</span>;</span><br><span class="line">                dist[nx][ny][ncur] = step + <span class="number">1</span>;</span><br><span class="line">                d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{nx, ny, ncur});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个二维网格&amp;nbsp;grid&amp;nbsp;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;.&#39;&lt;/code&gt; 代表一个空房间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;#&#39;&lt;/code&gt; 代表一堵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;@&#39;&lt;/code&gt;&amp;nbsp;是起点&lt;/li&gt;
&lt;li&gt;小写字母代表钥匙&lt;/li&gt;
&lt;li&gt;大写字母代表锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。&lt;br&gt;假设 k&amp;nbsp;为 钥匙 / 锁 的个数，且满足&amp;nbsp;&lt;code&gt;1 &amp;lt;= k&amp;nbsp;&amp;lt;= 6&lt;/code&gt;，字母表中的前 &lt;code&gt;k&lt;/code&gt;&amp;nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。&lt;br&gt;返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&amp;nbsp;&lt;code&gt;-1&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>790. 多米诺和托米诺平铺</title>
    <link href="https://ccomma.cn/8a6c84365f71/"/>
    <id>https://ccomma.cn/8a6c84365f71/</id>
    <published>2022-11-13T10:12:38.000Z</published>
    <updated>2024-02-23T05:24:31.385Z</updated>
    
    <content type="html"><![CDATA[<p>有两种形状的瓷砖：一种是&nbsp;2 x 1 的多米诺形，另一种是形如&nbsp;“L” 的托米诺形。两种形状都可以旋转。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9ba5351e90e431406c86a1f5aeb30dd5.png" alt="image.png"></p><p>给定整数 n ，返回可以平铺&nbsp;2 x n 的面板的方法的数量。返回对&nbsp;109&nbsp;+ 7&nbsp;取模&nbsp;的值。<br>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p><span id="more"></span><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTilings</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d[i][0] =&gt; 第 i 列上面占位</span></span><br><span class="line">        <span class="comment">// d[i][1] =&gt; 第 i 列下面占位</span></span><br><span class="line">        <span class="comment">// d[i][2] =&gt; 第 i 列都占位</span></span><br><span class="line">        <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) {</span><br><span class="line">            d[i][<span class="number">0</span>] = (d[i - <span class="number">1</span>][<span class="number">1</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">            d[i][<span class="number">1</span>] = (d[i - <span class="number">1</span>][<span class="number">0</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">            d[i][<span class="number">2</span>] = (((d[i - <span class="number">1</span>][<span class="number">2</span>] + d[i - <span class="number">2</span>][<span class="number">2</span>]) % MOD + d[i - <span class="number">1</span>][<span class="number">0</span>]) % MOD + d[i - <span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d[n - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两种形状的瓷砖：一种是&amp;nbsp;2 x 1 的多米诺形，另一种是形如&amp;nbsp;“L” 的托米诺形。两种形状都可以旋转。&lt;br&gt;&lt;img data-src=&quot;https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9ba5351e90e431406c86a1f5aeb30dd5.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;给定整数 n ，返回可以平铺&amp;nbsp;2 x n 的面板的方法的数量。返回对&amp;nbsp;109&amp;nbsp;+ 7&amp;nbsp;取模&amp;nbsp;的值。&lt;br&gt;平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1620. 网络信号最好的坐标</title>
    <link href="https://ccomma.cn/9dc3e8a4d1b1/"/>
    <id>https://ccomma.cn/9dc3e8a4d1b1/</id>
    <published>2022-11-06T15:14:16.000Z</published>
    <updated>2024-02-23T03:15:00.052Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个数组 towers&nbsp;和一个整数 radius 。<br>数组&nbsp; towers&nbsp; 中包含一些网络信号塔，其中&nbsp;towers [i] = [xi, yi, qi]&nbsp;表示第&nbsp;i&nbsp;个网络信号塔的坐标是&nbsp;(xi, yi)&nbsp;且信号强度参数为&nbsp;qi&nbsp;。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;整数&nbsp;坐标。两个坐标之间的距离用 欧几里得距离&nbsp;计算。<br>整数&nbsp;radius&nbsp;表示一个塔 能到达&nbsp;的 最远距离&nbsp;。如果一个坐标跟塔的距离在 radius&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius&nbsp;以外的距离该塔是 不能到达的&nbsp;。<br>如果第 i&nbsp;个塔能到达 (x, y)&nbsp;，那么该塔在此处的信号为&nbsp;⌊qi / (1 + d)⌋&nbsp;，其中&nbsp;d&nbsp;是塔跟此坐标的距离。一个坐标的 信号强度 是所有 能到达&nbsp;该坐标的塔的信号强度之和。<br>请你返回数组 [cx, cy] ，表示 信号强度 最大的 整数 坐标点&nbsp;(cx, cy) 。如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。<br>注意：</p><ul><li>坐标&nbsp;(x1, y1)&nbsp;字典序比另一个坐标&nbsp;(x2, y2) 小，需满足以下条件之一：<ul><li>要么&nbsp;x1 &lt; x2&nbsp;，</li><li>要么&nbsp;x1 == x2 且&nbsp;y1 &lt; y2&nbsp;。</li></ul></li><li>⌊val⌋&nbsp;表示小于等于&nbsp;val&nbsp;的最大整数（向下取整函数）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给你一个数组 towers&amp;nbsp;和一个整数 radius 。&lt;br&gt;数组&amp;nbsp; towers&amp;nbsp; 中包含一些网络信号塔，其中&amp;nbsp;towers [i] = [xi, yi, qi]&amp;nbsp;表示第&amp;nbsp;i&amp;nbsp;个网络信号塔的坐标是&amp;n</summary>
      
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1668. 最大重复子字符串</title>
    <link href="https://ccomma.cn/084a2e22f3ba/"/>
    <id>https://ccomma.cn/084a2e22f3ba/</id>
    <published>2022-11-06T14:59:11.000Z</published>
    <updated>2024-02-23T05:24:31.384Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串&nbsp;sequence&nbsp;，如果字符串 word&nbsp;连续重复&nbsp;k&nbsp;次形成的字符串是&nbsp;sequence&nbsp;的一个子字符串，那么单词&nbsp;word 的 重复值为 k 。单词 word&nbsp;的 最大重复值&nbsp;是单词&nbsp;word&nbsp;在&nbsp;sequence&nbsp;中最大的重复值。如果&nbsp;word&nbsp;不是&nbsp;sequence&nbsp;的子串，那么重复值&nbsp;k&nbsp;为 0 。<br>给你一个字符串 sequence&nbsp;和 word&nbsp;，请你返回 最大重复值&nbsp;k 。</p><span id="more"></span><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRepeating</span><span class="params">(String sequence, String word)</span> {</span><br><span class="line">        <span class="type">char</span>[] seqArray = sequence.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] wordArray = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> seqArray.length - wordArray.length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> s + wordArray.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (e &lt;= seqArray.length) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; e; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (seqArray[j] != wordArray[j - s]) <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (j == e) {</span><br><span class="line">                    cnt++;</span><br><span class="line">                    s = e;</span><br><span class="line">                    e += wordArray.length;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; result) result = cnt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f81256185fb2eaa9a76f211b218fe376.png" alt="image.png"></p><h2 id="简单枚举-动态规划"><a href="#简单枚举-动态规划" class="headerlink" title="简单枚举 + 动态规划"></a>简单枚举 + 动态规划</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c0150a85f67492b303819cdc095c976c.png" alt="image.png"></p><h2 id="KMP-算法-动态规划"><a href="#KMP-算法-动态规划" class="headerlink" title="KMP 算法 + 动态规划"></a>KMP 算法 + 动态规划</h2><p>方法一的数组 valid 本质上就是标记了字符串 word 在字符串 sequence 中所有出现的位置。而我们可以使用更高效的 <a href="https://oi-wiki.org/string/kmp/">KMP 算法</a> 在 O (m+n) O (m+n) 的时间内得到数组 valid。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRepeating</span><span class="params">(String sequence, String word)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sequence.length(), m = word.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] fail = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; word.charAt(j + <span class="number">1</span>) != word.charAt(i)) {</span><br><span class="line">                j = fail[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(j + <span class="number">1</span>) == word.charAt(i)) {</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; word.charAt(j + <span class="number">1</span>) != sequence.charAt(i)) {</span><br><span class="line">                j = fail[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(j + <span class="number">1</span>) == sequence.charAt(i)) {</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span> (j == m - <span class="number">1</span>) {</span><br><span class="line">                    f[i] = (i &gt;= m ? f[i - m] : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                    j = fail[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(f).max().getAsInt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O (m + n) O (m+n)，其中 nn 和 mm 分别是字符串 sequence 和 word 的长度。</li><li>空间复杂度：O (m + n) O (m+n)，即为 KMP 算法中的数组 fail 以及数组 f 需要使用的空间。</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489813&amp;idx=1&amp;sn=7f3bc18ca390d85b17655f7164d8e660">【字符串哈希】字符串哈希入门</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/77e54569881e1323d57e605359c57fc2.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个字符串&amp;nbsp;sequence&amp;nbsp;，如果字符串 word&amp;nbsp;连续重复&amp;nbsp;k&amp;nbsp;次形成的字符串是&amp;nbsp;sequence&amp;nbsp;的一个子字符串，那么单词&amp;nbsp;word 的 重复值为 k 。单词 word&amp;nbsp;的 最大重复值&amp;nbsp;是单词&amp;nbsp;word&amp;nbsp;在&amp;nbsp;sequence&amp;nbsp;中最大的重复值。如果&amp;nbsp;word&amp;nbsp;不是&amp;nbsp;sequence&amp;nbsp;的子串，那么重复值&amp;nbsp;k&amp;nbsp;为 0 。&lt;br&gt;给你一个字符串 sequence&amp;nbsp;和 word&amp;nbsp;，请你返回 最大重复值&amp;nbsp;k 。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>754. 到达终点数字</title>
    <link href="https://ccomma.cn/7fe9682c61b6/"/>
    <id>https://ccomma.cn/7fe9682c61b6/</id>
    <published>2022-11-06T14:48:28.000Z</published>
    <updated>2024-02-23T05:24:31.386Z</updated>
    
    <content type="html"><![CDATA[<p>在一根无限长的数轴上，你站在 0 的位置。终点在 target 的位置。<br>你可以做一些数量的移动 numMoves :</p><ul><li>每次你可以选择向左或向右移动。</li><li>第 i&nbsp;次移动（从 &nbsp;i == 1&nbsp;开始，到&nbsp;i == numMoves ），在选择的方向上走 i&nbsp;步。</li></ul><p>给定整数&nbsp;target ，返回 到达目标所需的 最小&nbsp;移动次数 (即最小 numMoves)&nbsp;。</p><span id="more"></span><h2 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachNumber</span><span class="params">(<span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) target = -target;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil((Math.sqrt(<span class="number">1</span> + <span class="number">8</span> * (<span class="type">double</span>) target) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="number">1</span> + k) * k / <span class="number">2</span> - target;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">return</span> ((k + <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span> ? k + <span class="number">1</span> : k + <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cd93f41c4b9e8b2fa85ccfcbbaa922f9.png" alt="image.png"></p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">reachNumber</span><span class="params">(<span class="type">int</span> target)</span> {</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pos;</span><br><span class="line">        pos.push(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pos.empty()){</span><br><span class="line">            <span class="keyword">if</span>(target==pos.front().first)</span><br><span class="line">                <span class="keyword">return</span> pos.front().second;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="type">int</span> nowPos=pos.front().first;</span><br><span class="line">                <span class="type">int</span> step=pos.front().second;</span><br><span class="line">                pos.push(make_pair(nowPos+step+<span class="number">1</span>,step+<span class="number">1</span>));</span><br><span class="line">                pos.push(make_pair(nowPos-step-<span class="number">1</span>,step+<span class="number">1</span>));</span><br><span class="line">                pos.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="DP（0-1背包）"><a href="#DP（0-1背包）" class="headerlink" title="DP（0-1背包）"></a>DP（0-1 背包）</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/246e489c91161cdfb8b80ab2f2dc4de6.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一根无限长的数轴上，你站在 0 的位置。终点在 target 的位置。&lt;br&gt;你可以做一些数量的移动 numMoves :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次你可以选择向左或向右移动。&lt;/li&gt;
&lt;li&gt;第 i&amp;nbsp;次移动（从 &amp;nbsp;i == 1&amp;nbsp;开始，到&amp;nbsp;i == numMoves ），在选择的方向上走 i&amp;nbsp;步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定整数&amp;nbsp;target ，返回 到达目标所需的 最小&amp;nbsp;移动次数 (即最小 numMoves)&amp;nbsp;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1106. 解析布尔表达式</title>
    <link href="https://ccomma.cn/ef40641adb89/"/>
    <id>https://ccomma.cn/ef40641adb89/</id>
    <published>2022-11-06T12:41:13.000Z</published>
    <updated>2024-02-23T05:24:31.383Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个以字符串形式表述的&nbsp;布尔表达式（boolean） expression，返回该式的运算结果。<br>有效的表达式需遵循以下约定：</p><ul><li>“t”，运算结果为 True</li><li>“f”，运算结果为 False</li><li>“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）</li><li>“&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）</li><li>“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）</li></ul><span id="more"></span><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>截取子表达式字符串，每个字符串递归，效率较低</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"t"</span>.equals(expression)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"f"</span>.equals(expression)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取标志位</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> expression.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 分解内部表达式 </span></span><br><span class="line">        <span class="comment">// e.g.|(&amp;(t,f,t),!(t)) =&gt; [&amp;(t,f,t), !(t)]</span></span><br><span class="line">        List&lt;String&gt; innerExps = getInnerExpression(expression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'!'</span>) <span class="keyword">return</span> !parseBoolExpr(innerExps.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &amp;</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'&amp;'</span>) {</span><br><span class="line">            <span class="keyword">for</span> (String innerExp : innerExps) {</span><br><span class="line">                <span class="keyword">if</span> (!parseBoolExpr(innerExp)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// |</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="string">'|'</span>) {</span><br><span class="line">            <span class="keyword">for</span> (String innerExp : innerExps) {</span><br><span class="line">                <span class="keyword">if</span> (parseBoolExpr(innerExp)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getInnerExpression</span><span class="params">(String exp)</span> {</span><br><span class="line">        <span class="comment">// exp &lt;=&gt; !(innerExpStr)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">innerExpStr</span> <span class="operator">=</span> exp.substring(<span class="number">2</span>, exp.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">char</span>[] innerExpCharArray = innerExpStr.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bracketsNumDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; innerExpCharArray.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (innerExpCharArray[i] == <span class="string">'('</span>) {</span><br><span class="line">                bracketsNumDiff++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (innerExpCharArray[i] == <span class="string">')'</span>) {</span><br><span class="line">                bracketsNumDiff--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逗号时判断</span></span><br><span class="line">            <span class="keyword">if</span> (bracketsNumDiff == <span class="number">0</span> &amp;&amp; innerExpCharArray[i] == <span class="string">','</span>) {</span><br><span class="line">                result.add(innerExpStr.substring(preIndex, i));</span><br><span class="line">                <span class="comment">// preIndex 设为逗号后的点，i 跳过 preIndex</span></span><br><span class="line">                preIndex = i++ + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        result.add(innerExpStr.substring(preIndex));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后的递归，使用全局索引</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> {</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'t'</span>) {</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'f'</span>) {</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'!'</span>) {</span><br><span class="line">                index += <span class="number">2</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> parseBoolExpr(expression);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> !t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'&amp;'</span>) {</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    index++;</span><br><span class="line">                    t &amp;= parseBoolExpr(expression);</span><br><span class="line">                } <span class="keyword">while</span> (expression.charAt(index) == <span class="string">','</span>);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (expression.charAt(index) == <span class="string">'|'</span>) {</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    index++;</span><br><span class="line">                    t |= parseBoolExpr(expression);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (expression.charAt(index) == <span class="string">','</span>);</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个以字符串形式表述的&amp;nbsp;布尔表达式（boolean） expression，返回该式的运算结果。&lt;br&gt;有效的表达式需遵循以下约定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“t”，运算结果为 True&lt;/li&gt;
&lt;li&gt;“f”，运算结果为 False&lt;/li&gt;
&lt;li&gt;“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）&lt;/li&gt;
&lt;li&gt;“&amp;amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）&lt;/li&gt;
&lt;li&gt;“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>481. 神奇字符串</title>
    <link href="https://ccomma.cn/5889a7e516e2/"/>
    <id>https://ccomma.cn/5889a7e516e2/</id>
    <published>2022-10-31T14:09:44.000Z</published>
    <updated>2024-02-23T05:24:31.387Z</updated>
    
    <content type="html"><![CDATA[<p>神奇字符串 s 仅由 ‘1’ 和 ‘2’ 组成，并需要遵守下面的规则：</p><ul><li>神奇字符串 s 的神奇之处在于，串联字符串中 ‘1’ 和 ‘2’ 的连续出现次数可以生成该字符串。</li></ul><p>s 的前几个元素是 s = “1221121221221121122……” 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 “1 22 11 2 1 22 1 22 11 2 11 22 ……” 。每组中 1 或者 2 的出现次数分别是 “1 2 2 1 1 2 1 2 2 1 2 2 ……” 。上面的出现次数正是 s 自身。<br>给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。</p><span id="more"></span><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">magicalString</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        result[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) {</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (result[i++] == <span class="number">1</span>) {</span><br><span class="line">                sum++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result[s] == <span class="number">2</span> &amp;&amp; i &lt; n) {</span><br><span class="line">                result[i] = result[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (result[i++] == <span class="number">1</span>) {</span><br><span class="line">                    sum++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            s++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双指针推导题，没啥可说的，就是题目文字多了点。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;神奇字符串 s 仅由 ‘1’ 和 ‘2’ 组成，并需要遵守下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;神奇字符串 s 的神奇之处在于，串联字符串中 ‘1’ 和 ‘2’ 的连续出现次数可以生成该字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;s 的前几个元素是 s = “1221121221221121122……” 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 “1 22 11 2 1 22 1 22 11 2 11 22 ……” 。每组中 1 或者 2 的出现次数分别是 “1 2 2 1 1 2 1 2 2 1 2 2 ……” 。上面的出现次数正是 s 自身。&lt;br&gt;给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>包依赖导致的 ClassNotFoundException</title>
    <link href="https://ccomma.cn/2659d1283ba8/"/>
    <id>https://ccomma.cn/2659d1283ba8/</id>
    <published>2022-08-25T11:36:59.000Z</published>
    <updated>2024-02-23T03:15:00.055Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-08-<span class="number">25</span> <span class="number">17</span>:<span class="number">47</span>:<span class="number">31.203</span> ERROR o.s.boot.SpringApplication.reportFailure:<span class="number">860</span> Application run failed</span><br><span class="line">java.lang.TypeNotPresentException: Type com.dfire.soa.consumer.vo.DinningTableVo not present</span><br><span class="line">        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:<span class="number">117</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:<span class="number">125</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:<span class="number">49</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:<span class="number">68</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:<span class="number">138</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:<span class="number">49</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.repository.MethodRepository.getReturnType(MethodRepository.java:<span class="number">68</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.reflect.Method.getGenericReturnType(Method.java:<span class="number">255</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.common.utils.ReflectUtils.getReturnTypes(ReflectUtils.java:<span class="number">1196</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.MethodDescriptor.&lt;init&gt;(MethodDescriptor.java:<span class="number">48</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceDescriptor.initMethods(ServiceDescriptor.java:<span class="number">54</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceDescriptor.&lt;init&gt;(ServiceDescriptor.java:<span class="number">45</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceRepository.lambda$registerService$<span class="number">0</span>(ServiceRepository.java:<span class="number">64</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:<span class="number">1688</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.rpc.model.ServiceRepository.registerService(ServiceRepository.java:<span class="number">63</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:<span class="number">321</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:<span class="number">314</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:<span class="number">238</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.exportService(DubboBootstrap.java:<span class="number">1099</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.lambda$exportServices$<span class="number">14</span>(DubboBootstrap.java:<span class="number">1086</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at java.util.HashMap$Values.forEach(HashMap.java:<span class="number">981</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.exportServices(DubboBootstrap.java:<span class="number">1070</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.bootstrap.DubboBootstrap.start(DubboBootstrap.java:<span class="number">886</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onContextRefreshedEvent(DubboBootstrapApplicationListener.java:<span class="number">70</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.onApplicationContextEvent(DubboBootstrapApplicationListener.java:<span class="number">63</span>) ~[dubbo-<span class="number">2.7</span><span class="number">.15</span>.jar:<span class="number">2.7</span><span class="number">.15</span>]</span><br><span class="line">        at com.alibaba.spring.context.OnceApplicationContextEventListener.onApplicationEvent(OnceApplicationContextEventListener.java:<span class="number">52</span>) ~[spring-context-support-<span class="number">1.0</span><span class="number">.11</span>.jar:na]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:<span class="number">176</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:<span class="number">169</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:<span class="number">143</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:<span class="number">421</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:<span class="number">378</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:<span class="number">938</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">586</span>) ~[spring-context-<span class="number">5.3</span><span class="number">.13</span>.jar:<span class="number">5.3</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="number">144</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">771</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">763</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="number">438</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">339</span>) ~[spring-boot-<span class="number">2.4</span><span class="number">.13</span>.jar:<span class="number">2.4</span><span class="number">.13</span>]</span><br><span class="line">        at com.dfire.soa.SpringbootApplication.main(SpringbootApplication.java:<span class="number">21</span>) [cash-platform-soa.jar:na]</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.dfire.soa.consumer.vo.DinningTableVo</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">382</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">418</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">352</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">351</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.Class.forName0(Native Method) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at java.lang.Class.forName(Class.java:<span class="number">348</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:<span class="number">114</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">        ... <span class="number">38</span> common frames omitted</span><br></pre></td></tr></tbody></table></figure><p>dubbo:2.7.15，spring-boot:2.4.13</p><p>今天遇到一个问题，本地启动项目没有问题，发布到测试环境提示 ClassNotFoundException。<br>报的错都是一些新加的 jar 包下的类，都是 SNAPSHOT 包。看起来像是找不到类导致 Spring 无法创建 bean，但是明明包里是有这个类的。<br>经过一天的修改发布观察，发现是 maven 依赖的问题，只要引用了多个相同的依赖包就会遇到这样的问题。比如 consumer 包，该项目直接引用了 consumer 包，还引用了一个包，那个包也引用了 consumer 包，导致 consumer 包出现了两次，如图。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f77aac19c0f35efc3359d8f1ac0894a0.png" alt="image.png"></p><p>按理来说只是包重复引用应该不会出现这样的问题，更何况版本都是一样的。所以目前原因暂不明，可能和快照包有关，也可能和 dubbo 等一系列包升级有关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
