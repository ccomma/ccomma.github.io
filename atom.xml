<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CComma&#39;s Blog</title>
  
  <subtitle>Connect the world</subtitle>
  <link href="https://ccomma.cn/atom.xml" rel="self"/>
  
  <link href="https://ccomma.cn/"/>
  <updated>2024-04-01T08:13:04.822Z</updated>
  <id>https://ccomma.cn/</id>
  
  <author>
    <name>CComma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES 写入原理及调优</title>
    <link href="https://ccomma.cn/4216ce6ea7d2/"/>
    <id>https://ccomma.cn/4216ce6ea7d2/</id>
    <published>2024-03-12T02:37:13.000Z</published>
    <updated>2024-04-01T08:13:04.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？</p><p><strong>1. 解决写入问题</strong><br>心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。</p><p><strong>2. 学习架构设计思想</strong><br>这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。</p><p><strong>3. 应对面试</strong><br>虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题</p><p>常见的面试问题：</p><ul><li>你了解 ES 的写入原理吗</li><li>你了解文档的写入 / 删除过程吗</li><li>如何保证 ES 数据写入一致性</li><li>文档写入超时原因</li><li> ES 写入实时性如何去保证</li><li>数据量大时如何保证数据写入性能</li><li>如何提高数据检索能力</li></ul><span id="more"></span><h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h2><p>ES 中的数据写入均发生在主分片上。由于 ES 是分布式系统，实际接收到写入请求的节点可能是任意一台节点，这就需要将请求通过 routing 路由到具体主分片所在的节点，将数据写入该节点的主分片中，然后主分片再同步数据到其他节点的副分片中。<br>路由公式：<code>shard_num = hash(_routing) % num_primary_shards</code><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b20c17eb26dfc1a90e9433ae005a39e.jpeg"><br>具体流程：</p><ol><li>客户端发起写入请求至 node 4</li><li>node 4 通过文档 id 在路由表中的映射信息确定当前数据的位置为分片 0，分片 0 的主分片位于 node 5，并将数据转发至 node 5。</li><li>数据在 node 5 写入，写入成功之后将数据的同步请求转发至其副本所在的 node 4 和 node 6 上面，等待所有副本数据写入成功之后 node 5 将结果报告 node 4，并由 node 4 将结果返回给客户端，报告数据写入成功。</li></ol><h2 id="写一致性策略"><a href="#写一致性策略" class="headerlink" title="写一致性策略"></a>写一致性策略</h2><p>ES 5.x 之后，一致性策略由 <code>wait_for_active_shards</code> 参数控制：状态为 active 的主副分片数量达到设定阈值时才视为写入成功，才会返回数据给客户端。默认为 1，即只需要主分片写入成功，可设置为 <code>all</code> 或任何正整数，最大值为索引中的分片总数 (&nbsp;<code>number_of_replicas + 1</code> )。</p><p>如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间 30 秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。</p><p>执行索引操作时，分配给执行索引操作的主分片可能不可用。造成这种情况的原因可能是主分片当前正在从网关恢复或正在进行重定位。默认情况下，索引操作将在主分片上等待最多 1 分钟，然后才会失败并返回错误。</p><h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p>我们已经知道了宏观上的写入流程：先找到主节点，写入主节点后再同步到副节点。<br><strong>那 ES 是怎么把数据写入主节点和副节点中的呢？</strong></p><p>大家可能会有疑问，难道不是直接写入到磁盘吗？<strong>我们可以思考下，每次请求都直接写入到磁盘这种方式在高并发的场景下会消耗大量的 IO 资源，每次都要寻址然后写入磁盘。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba7282dc7f49c616767143d774646a3b.jpeg" alt="未命名文件.jpg"></p><p>对此我们可以用缓存来解决，即把数据写入系统缓存后，定期批量写入磁盘，同时缓存也提供检索服务。<br>而 Lucene 中索引是细分为多个 segment 的，segment 是索引中存储索引数据的内部存储元素，并且是不可变的。较小的 segment 会定期合并到较大的 segment 中，以控制索引大小。问题又来了：<strong>如果每次请求都创建一个新的 segment，那么会导致频繁的合并操作（merge）。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ec5aedd4c9bc6e805872b3f5944957a8.jpeg" alt="未命名文件.jpg"></p><p>所以 ES 在请求进入缓存之前先让请求进缓冲区（memory buffer），每秒或每 100 个缓存才会执行刷新操作（Refresh）把缓冲区中的数据创建 segment 写入系统缓存中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/10b375c43ff4ab15fe0c8ed7fa469f8e.jpeg" alt="未命名文件 (1).jpg"></p><p>至此这套批量持久化结构已经比较完善，但还有一个问题：<strong>缓存虽然提高了性能，但毕竟未持久化到磁盘，一旦系统出现故障数据就会丢失。</strong>ES 采用事务日志（translog）的方式解决此问题，当请求进来时会同时写入缓冲区和事务日志中，当服务重启后就会从事务日志中恢复数据到缓存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dcb5acedec3e2a0f97e678cd403a0eea.jpeg" alt="未命名文件 (1).jpg"></p><p>整体结构：</p><ul><li>Memory Buffer（缓冲区）：数据批量操作，高性能写入</li><li> Translog（事务日志）：保证数据写入安全性，防止丢失</li><li> OS Cache（内存）：保证数据高性能检索</li><li> OS Disk（磁盘）：保证数据持久化</li></ul><p>具体流程：</p><ol><li>客户端写入 Memory Buffer 缓冲区，并追加写入 Translog 事务日志（删除、写入…）以保证数据安全性。</li><li>Memory Buffer 达到阈值（100 条 / 1s）后执行 Refresh 操作生成 Segment 索引文件到系统缓存中。<ol><li>然后系统缓存会把该 Segment 标记为可被检索，因此数据有 1s 不可读的延迟。</li><li>Refresh 操作不能过于频繁，因此针对实时性不高的数据，可以配置 refresh 的间隔时间为 30s 一次。</li></ol></li><li>每个 Segment 都会消耗文件句柄、内存、CPU 运行周期，所以每隔一段时间会执行 Merge 操作，合并 Segment。<ol><li>Merge 操作发生在 JVM 中，频率过高会占用堆内存空间，所以 Refresh 的频率不能太高，否则会使 Merge 频率增高。</li><li>不合并 Segment 的影响：<ol><li>每个 Segment 占据的内存不会随着 GC 释放的。导致系统内存不足，进一步导致超时问题。</li><li>查询时会遍历每个 Segment，过多的 Segment 会导致查询速度下降。</li></ol></li></ol></li><li>执行 Flush 操作缓存写入 OS Disk（磁盘）并提交一次，并清空 Translog。<ol><li>系统缓存每隔 30 分钟、Translog 每隔 5 秒刷一次到磁盘中，所以默认情况下，可能会有 5s 数据丢失。</li><li>系统缓存和 Translog 写满时也会刷磁盘。</li></ol></li><li>断电等异常操作导致数据丢失时，服务重启后会读取 Translog 中的数据到缓存中，以完成回滚操作。</li></ol><p>相关参数：</p><ul><li>index.translog.durability：同步还是异步<ul><li> request：（默认）主副分片在每个请求后执行 fsync 和 commit，才会向客户端报告索引、删除、更新或批量请求的成功。如果发生崩溃，那么所有只要是已经确认的写操作都已经被提交到磁盘。</li><li>async：在后台每 index.translog.sync_interval 时间进行一次 fsync 和 commit。意味着如果发生崩溃，那么所有在上一次自动提交以后的已确认的写操作将会丢失。</li></ul></li><li>index.translog.sync_interval：translog 多久被同步到磁盘并提交一次。默认 5 秒。这个值不能小于 100ms。</li><li>index.translog.flush_threshold_size：translog 执行 flush 操作的空间最大阈值，默认 512 MB。</li></ul><h2 id="写入性能调优"><a href="#写入性能调优" class="headerlink" title="写入性能调优"></a>写入性能调优</h2><p>生产经常面临的写入可以分为两种情况：</p><ul><li>高并发：高频的创建 / 更新索引文档，一般发生在 C 端场景下</li><li>高吞吐：定期重建索引或批量更新文档数据，一般为 B 端场景</li></ul><p><strong>1. 提升写入吞吐量和并发</strong><br>ES 数据写入具有一定的延时性，这是为了减少频繁的索引文件产生。默认情况下 ES 每秒生成一个 segment 文件，当达到一定阈值的时候会执行 merge，merge 过程发生在 JVM 中，频繁的生成 segmen 文件可能会导致频繁的触发 FGC，导致 OOM。<br>为了避免避免这种情况，通常采取的手段是降低 segment 文件的生成频率，手段有两个，一个是增加时间阈值，另一个是增大 buffer 的空间阈值。</p><ol><li>增加 flush 时间间隔。Flush 是 IO 操作，很消耗性能，不能太频繁</li><li>增加 refresh_interval 的参数值<ol><li>目的是减少 segment 文件的创建，减少 segment 的 merge 次数。</li><li>merge 是发生在 JVM 中的，有可能导致 full GC，增加 refresh 会降低搜索的实时性。</li></ol></li><li>增加 buffer 大小<ol><li>减小 refresh 的时间间隔，因为导致 segment 文件创建的原因不仅有时间阈值，还有 buffer 空间大小，写满了也会创建。</li><li>默认最小值 48MB &lt; 默认值 JVM 空间的 10% &lt; 默认最大无限制</li></ol></li><li>关闭副本（提高单次吞吐）<ol><li>需要单次写入大量数据的时候，可以关闭副本（减少数据同步），暂停搜索服务，或选择在检索请求量谷值区间时间段来完成。因为副本的存在会导致主从之间频繁的进行数据同步，大大增加服务器的资源占用。</li><li>可通过则设置 index.number_of_replicas 为 0 以加快索引速度。没有副本意味着丢失单个节点可能会导致数据丢失，因此数据保存在其他地方很重要，以便在出现问题时可以重试初始加载。初始加载完成后，可以设置 index.number_of_replicas 改回其原始值。</li></ol></li><li>max_result_window 参数</li></ol><p>分页返回的最大数值，默认值为 10000。通过设定一个合理的阈值，避免初学者分页查询时由于单页数据过大而导致 OOM。</p><p><strong>2. 提高写入实时性（不推荐）</strong><br>在搜索引擎的业务场景下，用户一般并不需要那么高的写入实时性。有时这个延时的过程需要处理很多事情，比如信息需要后台审核。<br>可以提高 Memory Buffer 的 refresh 操作频率，但是过高的 refresh 会导致频繁 merge segment，会消耗更多堆内存、CPU 的资源。</p><h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><p>1. 避免单次召回大量数据<br>搜索引擎最擅长的事情是从海量数据中查询少量相关文档，而非单次检索大量文档。非常不建议动辄查询上万数据。如果有这样的需求，建议使用滚动查询。<br> <br>2. 避免单个文档过大<br>硬性限制：<br>鉴于默认 http.max_content_length 设置为 100MB，Elasticsearch 将拒绝索引任何大于该值的文档。可以增加该特定设置，但 Lucene 仍然有大约 2GB 的限制。<br> <br>大型文档对网络、内存使用和磁盘造成了更大的压力，即使对于不请求的搜索请求也是如此。<br> <br>3. 使用 filter 代替 query<br>query 是要对查询的每个结果计算相关性得分的，而 filter 不会。另外 filter 有相应的缓存机制，可以提高查询效率。<br> <br>4. 避免深度分页<br> <br>5. 使用 Keyword 类型<br>并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为查询优化数字字段，例如 integeror long。如果不需要范围查找，对于 term 查询而言，keyword 比 integer 性能更好。</p><p>参考：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index-modules-translog.html">Translog | Elasticsearch Guide [7.17] | Elastic</a></li><li><a href="https://blog.csdn.net/a645293829/article/details/132223065">【HBZ 分享】ES 索引分片的写入原理 及 流程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 解决写入问题&lt;/strong&gt;&lt;br&gt;心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 学习架构设计思想&lt;/strong&gt;&lt;br&gt;这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 应对面试&lt;/strong&gt;&lt;br&gt;虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题&lt;/p&gt;
&lt;p&gt;常见的面试问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你了解 ES 的写入原理吗&lt;/li&gt;
&lt;li&gt;你了解文档的写入 / 删除过程吗&lt;/li&gt;
&lt;li&gt;如何保证 ES 数据写入一致性&lt;/li&gt;
&lt;li&gt;文档写入超时原因&lt;/li&gt;
&lt;li&gt; ES 写入实时性如何去保证&lt;/li&gt;
&lt;li&gt;数据量大时如何保证数据写入性能&lt;/li&gt;
&lt;li&gt;如何提高数据检索能力&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ES 写入原理" scheme="https://ccomma.cn/categories/ES-%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="ES" scheme="https://ccomma.cn/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 快速搭建博客</title>
    <link href="https://ccomma.cn/58a80fbce4aa/"/>
    <id>https://ccomma.cn/58a80fbce4aa/</id>
    <published>2024-02-13T07:05:42.000Z</published>
    <updated>2024-03-12T12:09:52.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么搭建博客"><a href="#为什么搭建博客" class="headerlink" title="为什么搭建博客"></a>为什么搭建博客</h1><ul><li>知识积累</li><li>分享</li><li>影响力</li></ul><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="静态页面生成"><a href="#静态页面生成" class="headerlink" title="静态页面生成"></a>静态页面生成</h2><p>我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。</p><p>像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress</p><p>为什么选择 hexo？主题较现代化、方便快捷<br><a href="https://github.com/hexojs/hexo">hexo github</a></p><span id="more"></span><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>_config.yml 里配置你的项目地址</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ccomma/ccomma.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></tbody></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多主题，这里推荐 Next 主题，因为 Next 的社区非常活跃，这就导致 Next 主题有非常多的配置和插件</p><p>Next 主题配置<br><a href="https://theme-next.js.org/docs/theme-settings/">Theme Settings</a></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>博客可以部署在阿里云等云服务器上，但是特地买一台服务器专门用来部署博客还是有点太浪费了。</p><p>以下几种方式可以免费部署静态 web 应用</p><ul><li>github pages<ul><li> 服务器地理位置：美国</li><li>推荐：push 即部署，简单快捷 </li><li>缺点：网络连接严重不稳定</li></ul></li><li> cloudflare pages<ul><li> 服务器地理位置：美国自家节点</li><li>推荐原因：速度稳定，在全球各地均有 CDN，支持从 Github/Gitlab 等平台自动部署 </li><li>缺点：部署速度较慢，但不算太影响</li></ul></li><li> Vercel<ul><li> 服务器地理位置：美国 AWS</li><li> 推荐原因：部署速度快，支持自动部署</li><li>缺点：被墙过一次，速度有可能出现不稳定</li></ul></li></ul><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>hexo 能让我们更专心写博客，但即使是如此，我们还是要先使用 <code>hexo new "xxx"</code> 命令来新建文档。而我们平时的笔记可能是写在 notion、语雀、飞书上。</p><p>写作同步工具 <a href="https://github.com/LetTTGACO/elog">elog</a> 能让我们的在 notion、语雀、飞书上的笔记自动部署到 github 上</p><p>elog 会在本地创建缓存，每次同步只会增量更新，包括图片上传也是。</p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>github pages 自带域名：xxxx.github.io，够用，但是有点 low</p><ul><li><a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520112.products-recent.ddomain.5c0234c0saWuKP#/overview">阿里云域名</a>：基本都是国内的，30+/ 年 </li><li><a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412">cloudflare</a>：国外域名，9.77～45 美元</li></ul><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1. 阿里云付费 SSL<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79690ec1537f107639504c426c7654f.png" alt="image.png"></p><p>2. 阿里个人测试证书，有效期 3 个月<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7abb7f515c8c087585cf82b749f58856.png" alt="image.png"></p><p> 3.<a href="https://letsencrypt.org/">Let’s Encrypt</a>：提供免费 TLS 证书的非营利证书颁发机构，就个人博客而言足以</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>阿里云 DNS：DNS 解析与域名服务捆绑，声誉一般</p><p>cloudflare：</p><ul><li>支持 CDN（国内减速）</li><li>自带 DDos 防御服务</li><li>支持解析 A、AAAA、CNAME、MX、LOC、SRV、SPF、TXT、NS、CAA、PTR、CERT、DNSKEY、DS、NAPTR、SMIMEA、SSHFP、TLSA、URI</li><li> 支持 DNSSEC</li><li> 免费版支持一部分其他地方收费的配套服务，例如 Worker，Page，访客规则</li></ul><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>搜索引擎优化，让你的网站更好的被搜索引擎收录</p><p>google：<a href="https://search.google.com/search-console">https://search.google.com/search-console</a><br>bing：<a href="https://www.bing.com/webmasters">https://www.bing.com/webmasters</a><br>百度：<a href="https://ziyuan.baidu.com/site">https://ziyuan.baidu.com/site</a></p><p>以 google 为例：<br>登录到 Google Search Console，选择您要验证的网站。输入网址<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/060a5e066eda3911a4d4b938a91b23b3.png" alt="image.png"><br>将验证码复制到 DNS 记录中<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb3c64f775d04dc6ff8dabc1d6990035.png" alt="image.png"></p><h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>对网站流量访问进行分析</p><p>1.<a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412/web-analytics/sites">cloudflare</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39742d06912a9f134af70c3df193507.png" alt="image.png"></p><p>2.<a href="https://search.google.com/search-console?resource_id=sc-domain:ccomma.cn">google</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d5ef6ca57eb04a42125cc57f9f95af0.png" alt="image.png"></p><p>3. <a href="https://tongji.baidu.com/main/overview/10000609568/overview/index?siteId=20141034">百度统计</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bfbbe9f8eda65e69abc5b9b1074671cd.png" alt="image.png"></p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>百度云 CDN：百度云加速分为免费版和付费版，免费版不支持 SSL 证书，海外网站也支持加速。</p><p>cloudflare CDN：<br>免费提供，对于国外的服务器还行，国内服务器反而减速。支持 SSL，无须备案</p><p>七牛云 CDN：<br>每个月可使用 10G 的免费存储量和 10G 的 CDN 流量与 100 万次的 Get 请求数，七牛云在海外也有众多加速节点，七牛云 TCP 压缩优化使网页中大图和样式等实现秒加载。但请注意使用七牛 CDN，须保证账户中有最低金额 10 元。国内必须备案，支持 SSL。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bilibili.com/video/BV1Sp4y157br/?vd_source=8f8a2ec64a5f07bb8bf30a6ef4819025">将 Hexo 博客部署到 CloudFlare Pages 使用全球加速</a></li><li><a href="https://cloud.tencent.com/developer/article/1987796?areaSource=102001.7&amp;traceId=zTjHWNtLK7p3TbHHsvayg">5 个免费的静态 Web 应用部署平台</a></li><li><a href="https://hqyman.cn/post/4255.html">国内外免费域名 DNS 解析推荐</a></li><li><a href="https://www.zhihu.com/question/342631132">如何使用 Notion 制作个人网站？</a></li><li><a href="https://www.cnblogs.com/wangyuehan/p/12743624.html">Notion 做个人博客的两种实现方式</a></li><li><a href="https://blog.ithuo.net/post/2023-11-07%2FNotion%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97">Notion 博客折腾指南</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2">使用 hexo+github 搭建免费个人博客</a></li><li><a href="https://juejin.cn/post/7304540675668181003">语雀写作，Kubernetes 部署 ——Elog+Hexo 博客持续集成</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么搭建博客&quot;&gt;&lt;a href=&quot;#为什么搭建博客&quot; class=&quot;headerlink&quot; title=&quot;为什么搭建博客&quot;&gt;&lt;/a&gt;为什么搭建博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;知识积累&lt;/li&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;影响力&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建站&quot;&gt;&lt;a href=&quot;#建站&quot; class=&quot;headerlink&quot; title=&quot;建站&quot;&gt;&lt;/a&gt;建站&lt;/h1&gt;&lt;h2 id=&quot;静态页面生成&quot;&gt;&lt;a href=&quot;#静态页面生成&quot; class=&quot;headerlink&quot; title=&quot;静态页面生成&quot;&gt;&lt;/a&gt;静态页面生成&lt;/h2&gt;&lt;p&gt;我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。&lt;/p&gt;
&lt;p&gt;像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress&lt;/p&gt;
&lt;p&gt;为什么选择 hexo？主题较现代化、方便快捷&lt;br&gt;&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;hexo github&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://ccomma.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="https://ccomma.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>并行流导致接口慢调用问题</title>
    <link href="https://ccomma.cn/cb2072810346/"/>
    <id>https://ccomma.cn/cb2072810346/</id>
    <published>2023-08-14T00:55:38.000Z</published>
    <updated>2024-02-23T05:26:09.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。</p><span id="more"></span><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8ff9b37602e5bee3be548af291c7348e.png" alt="image.png"><br>根据 ARMS 分析该接口的调用量在 18:31-18:41 出现断崖式增长，每分钟请求数从 5.1k 增加到 14.7k，10 分钟增长了 9.6k。（后续调查表明在该时间段内大部分接口调用量都出现了断崖式增长）<br>异常时刻的 qps 大致为 236.1，几乎是一周前的 2 倍。</p><p><strong>响应时间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3dd26f56b4afe1a4bfcb5a79450452d1.png" alt="image.png"><br>每分钟响应时间平均为 3747 ms，整个异常过程中该接口最长的响应时间达到 8s 多。</p><p><strong>dubbo 线程池：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d7b54ac7097680e22af442ccbd6b276.png" alt="image.png"><br>所有接口的每分钟 dubbo 请求调用量在 18:35-18:45 内从 14.2k 增长至 35.6k<br>也是在这段时间内 dubbo 线程池被打满，在 18:40 左右基本被打满<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/decb4154e9d3362f4dd2e3b7dbd1892f.png" alt="image.png"></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>初步判断流量突增的原因是客户端开放灰度，使得预定业务中的一个轮询调用的接口调用次数上升。<br>该接口调用桌位状态服务的一个较为通用的查询接口，里面使用 parallelStream 来进行 RPC 调用获取账单。<br>parallelStream 使用与 CPU 核数一致的线程数来处理任务，当请求量增大时线程池中的线程全部被打满，导致后续的任务一直在排队等待延迟处理，最终 dubbo 线程池也被占满。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>从问题的核心代码到外部调用，可优化的点如下：</p><ol><li>取消并行流</li><li>加大批量获取数，让调用量减小</li><li>经查看代码发现出现问题的使用并行流查账单是为了设置桌位状态的 payStatus，但是上层并不关心这个字段，所以可以让上层调用更轻量级的接口</li><li>降低客户端轮询次数，轮询调用需谨慎，轮询策略需要好好设计</li></ol><h2 id="2023-08-13（代码修改后）"><a href="#2023-08-13（代码修改后）" class="headerlink" title="2023.08.13（代码修改后）"></a>2023.08.13（代码修改后）</h2><p>141 部署了优化后的代码，取消了并行流，分页大小增加到 10<br>142 没有改动，以此作为对照。</p><p>总体应用每分钟调用量峰值也有 14.7k，但是 13 号这天的曲线明显更加平滑，没有出现 dubbo 线程池被打满的情况，慢调用的数量和时长都在正常范围内。</p><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b6f1ef4f96f597a9b716feb0c2990204.png" alt="image.png"></p><p><strong>响应时间：</strong><br>141 比 142 更缓和</p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4cbe6c1f08b59f911f0a0aa91140deae.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4573954d3923199d395b8c80d3cb6909.png" alt="image.png"></p><p><strong>dubbo 线程数：</strong></p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/50b9cd579f52f5b56e2e28be3205d865.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1f735878b6e9667f825e70e452c8492.png" alt="image.png"></p><p>08.13 修改优化后至今，142 会依然出现一定量的慢调用，141 没有出现过<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/532b6fca9a1b64382d8ac364a4851385.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次问题应该是由于短时间内的调用量突增，加上使用并发流处理 RPC 调用引起的。<br>根据 13 号的对照来看，流量平滑增加的情况不会出现特别严重的线程池等待现象，但依然有慢调用，存在隐患。</p><p>取消并行流，增加分页大小的方案是可行的，以后并行流需要谨慎使用。后续也和客户端讨论了上层接口的调整方案。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
    <category term="并行流" scheme="https://ccomma.cn/tags/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>如何快速定位问题</title>
    <link href="https://ccomma.cn/6c827d88b19c/"/>
    <id>https://ccomma.cn/6c827d88b19c/</id>
    <published>2023-08-10T14:23:27.000Z</published>
    <updated>2024-02-23T03:15:00.055Z</updated>
    
    <content type="html"><![CDATA[<p>这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。</p><p>整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再去更新打印状态。</p><p>排查了很久发现是客户端接收不到消息，客户端同学也表示不知所措，问了消息通道那边的同学后发现安卓客户端在这之前就断开连接了，重新连接后立马就接收到了消息。一度怀疑是消息通道的问题，后来才发现客户端一直运行在后台，且自动刷新是关闭的。</p><p>因整个排查浪费了太多时间故在此做个复盘<br>整个链路很长，任何环节都有可能出现问题。</p><ol><li>先尽可能排除用户误操作产生的影响</li><li>有些地方不好排查（如消息通道），排查必须得有侧重点</li><li>需要有一个负责人协调多位项目相关人，依次推进进度，提高效率</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。&lt;/p&gt;
&lt;p&gt;整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再</summary>
      
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="思考" scheme="https://ccomma.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>可重入锁实现</title>
    <link href="https://ccomma.cn/71c0fe543a49/"/>
    <id>https://ccomma.cn/71c0fe543a49/</id>
    <published>2023-08-03T03:43:48.000Z</published>
    <updated>2024-04-01T08:13:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantCacheLockManager：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReentrantCacheLockManager implements ICacheLockManager {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ICacheService cacheService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(String key, int expireSecond) {</span><br><span class="line">        return tryLock(Collections.singletonList(key), expireSecond);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(List&lt;String&gt; keyList, int expireSecond) {</span><br><span class="line">        Assert.isTrue(CollectionUtils.isNotEmpty(keyList), "获取锁失败：key 不能为空");</span><br><span class="line"></span><br><span class="line">        // 1.从未获取过锁的 key 先去获取锁</span><br><span class="line">        List&lt;String&gt; unCacheKeyList = keyList.stream()</span><br><span class="line">                .filter(k -&gt; !LockKeyCountHolder.exist(k))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量获取锁</span><br><span class="line">        if (CollectionUtils.isNotEmpty(unCacheKeyList)) {</span><br><span class="line">            Map&lt;String, String&gt; lockMap = unCacheKeyList.stream().collect(Collectors.toMap(Function.identity(), k -&gt; "1", (a, b) -&gt; b));</span><br><span class="line">            long msetnx = cacheService.msetnx(lockMap, expireSecond);</span><br><span class="line">            // 未取到锁</span><br><span class="line">            if (Objects.equals(msetnx, 0L)) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 2.重入计数 +1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            LockKeyCountHolder.increment(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(String key) {</span><br><span class="line">        unlock(Collections.singletonList(key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(List&lt;String&gt; keyList) {</span><br><span class="line">        List&lt;String&gt; releaseKeyList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        // 重入 -1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            if (LockKeyCountHolder.decrement(key) == 0) {</span><br><span class="line">                releaseKeyList.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 释放锁</span><br><span class="line">        cacheService.del(releaseKeyList.toArray(new String[0]));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>LockKeyCountHolder：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 已锁的 key 重入计数</span><br><span class="line"> *</span><br><span class="line"> * @author mianxian</span><br><span class="line"> * 2023/8/2 14:56</span><br><span class="line"> */</span><br><span class="line">public class LockKeyCountHolder {</span><br><span class="line"></span><br><span class="line">    private LockKeyCountHolder() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * lockKey -&gt; 重入次数</span><br><span class="line">     */</span><br><span class="line">    private static final ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; THREAD_LOCAL = ThreadLocal.withInitial(Maps::newConcurrentMap);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 +1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int increment(String key) {</span><br><span class="line">        int count = get(key);</span><br><span class="line">        THREAD_LOCAL.get().put(key, ++count);</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取计数</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int get(String key) {</span><br><span class="line">        Map&lt;String, Integer&gt; keyMap = THREAD_LOCAL.get();</span><br><span class="line">        return keyMap.getOrDefault(key, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数是否 &gt; 0</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 是否 &gt; 0</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static boolean exist(String key) {</span><br><span class="line">        return get(key) &gt; 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 -1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int decrement(String key) {</span><br><span class="line">        if (!exist(key)) {</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int count = get(key) - 1;</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            THREAD_LOCAL.get().remove(key);</span><br><span class="line">        } else {</span><br><span class="line">            THREAD_LOCAL.get().put(key, count);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ReentrantCacheLockManager：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="https://ccomma.cn/2181815722f9/"/>
    <id>https://ccomma.cn/2181815722f9/</id>
    <published>2023-06-26T09:21:45.000Z</published>
    <updated>2024-04-01T08:13:04.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/14ce66fea5c132fb2889b56af226f5c9.png" alt="image.png"></p><h2 id="2-ACID"><a href="#2-ACID" class="headerlink" title="2. ACID"></a>2. ACID</h2><h3 id="2-1-原子性（Atomicity）"><a href="#2-1-原子性（Atomicity）" class="headerlink" title="2.1. 原子性（Atomicity）"></a>2.1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p><h3 id="2-2-一致性（Consistency）"><a href="#2-2-一致性（Consistency）" class="headerlink" title="2.2. 一致性（Consistency）"></a>2.2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</p><h3 id="2-3-隔离性（Isolation）"><a href="#2-3-隔离性（Isolation）" class="headerlink" title="2.3. 隔离性（Isolation）"></a>2.3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的</p><h3 id="2-4-持久性（Durability）"><a href="#2-4-持久性（Durability）" class="headerlink" title="2.4. 持久性（Durability）"></a>2.4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失<br>使用重做日志来保证持久性<br><strong><em>理解：</em></strong> 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</li><li>事务满足持久化是为了能应对数据库崩溃的情况</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/340df236be6073235c93ec32f85bccb2.png" alt="image.png"></p><h2 id="3-AUTOCOMMIT"><a href="#3-AUTOCOMMIT" class="headerlink" title="3. AUTOCOMMIT"></a>3. AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。<br>如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p><strong><em>概述：</em></strong> 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题<br>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1. 丢失修改"></a>1. 丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5699ecb598913f47c5e996bd30467a1b.png" alt="image.png"></p><h2 id="2-读脏数据"><a href="#2-读脏数据" class="headerlink" title="2. 读脏数据"></a>2. 读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1e7a318bb33ae42872be8b6f981afe99.png" alt="image.png"></p><h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/600643f3fa1c4175a70b2e7e419dd444.png" alt="image.png"></p><h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4. 幻读"></a>4. 幻读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cc2dd0b4a10f306d6eb1d39200abc61c.png" alt="image.png"></p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="1-封锁粒度"><a href="#1-封锁粒度" class="headerlink" title="1. 封锁粒度"></a>1. 封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁<br>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h2 id="2-封锁类型"><a href="#2-封锁类型" class="headerlink" title="2. 封锁类型"></a>2. 封锁类型</h2><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1. 读写锁"></a>2.1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/26454bd0fd3a5fe1a6f848d7237335fc.png" alt="image.png"></p><h3 id="2-2-意向锁"><a href="#2-2-意向锁" class="headerlink" title="2.2. 意向锁"></a>2.2. 意向锁</h3><p><strong><em>概念：</em></strong> 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁。它们表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。<br><strong><em>现象：</em></strong> 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br><strong>规定：</strong></p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li></ul><p><strong><em>原理：</em></strong> 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。<br>各种锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3eed892c3a7ec589352d30f9b14fa561.png" alt="image.png"></p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁</li><li> S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁</li></ul><h2 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3. 封锁协议"></a>3. 封锁协议</h2><h3 id="3-1-三级封锁协议"><a href="#3-1-三级封锁协议" class="headerlink" title="3.1. 三级封锁协议"></a>3.1. 三级封锁协议</h3><p><strong><em>一级封锁协议：</em></strong><br>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁<br>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f31b55014ddb0a0a435cf553af74da2b.png" alt="image.png"><br><strong><em>二级封锁协议：</em></strong><br>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。<br>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c88864935fbcdf40bda35f48ca62f25e.png" alt="image.png"><br><strong><em>三级封锁协议：</em></strong><br>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。<br>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b258ef58d2448d4e983995c3adb129c.png" alt="image.png"></p><h3 id="3-2-两段锁协议"><a href="#3-2-两段锁协议" class="headerlink" title="3.2. 两段锁协议"></a>3.2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。<br>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。<br>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><blockquote><p>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)</p></blockquote><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><blockquote><p>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)</p></blockquote><h2 id="4-MySQL-隐式与显示锁定"><a href="#4-MySQL-隐式与显示锁定" class="headerlink" title="4. MySQL 隐式与显示锁定"></a>4. MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><p><a href="https://www.cnblogs.com/shoshana-kong/p/10516404.html">Mysql 默认的事务隔离级别为什么是可重复读</a><br><strong>1. 未提交读（READ UNCOMMITTED）</strong><br>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>2. 提交读（READ COMMITTED）</strong><br>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>3. 可重复读（REPEATABLE READ）</strong><br>保证在同一个事务中多次读取同样数据的结果是一样的。<br>对 update 语句进行行加锁</p><p><strong>4. 可串行化（SERIALIZABLE）</strong><br>强制事务串行执行。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/92baf28f1dd4b475882244d42de388b5.png" alt="image.png"></p><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p><a href="https://www.jianshu.com/p/db334404d909">浅析 Mysql 的隔离级别及 MVCC</a><br>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="1-版本号"><a href="#1-版本号" class="headerlink" title="1. 版本号"></a>1. 版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><h2 id="2-隐藏的列"><a href="#2-隐藏的列" class="headerlink" title="2. 隐藏的列"></a>2. 隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了</li></ul><h2 id="3-Undo-日志"><a href="#3-Undo-日志" class="headerlink" title="3. Undo 日志"></a>3. Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6d8b260999c124ace1b2e329bc62ec5d.png" alt="image.png"></p><h2 id="4-实现过程"><a href="#4-实现过程" class="headerlink" title="4. 实现过程"></a>4. 实现过程</h2><p>以下实现过程针对可重复读隔离级别。<br>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h3 id="4-1-SELECT"><a href="#4-1-SELECT" class="headerlink" title="4.1. SELECT"></a>4.1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。<br>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="4-2-INSERT"><a href="#4-2-INSERT" class="headerlink" title="4.2. INSERT"></a>4.2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="4-3-DELETE"><a href="#4-3-DELETE" class="headerlink" title="4.3. DELETE"></a>4.3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-4-UPDATE"><a href="#4-4-UPDATE" class="headerlink" title="4.4. UPDATE"></a>4.4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="5-快照读与当前读"><a href="#5-快照读与当前读" class="headerlink" title="5. 快照读与当前读"></a>5. 快照读与当前读</h2><h3 id="5-1-快照读"><a href="#5-1-快照读" class="headerlink" title="5.1. 快照读"></a>5.1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-当前读"><a href="#5-2-当前读" class="headerlink" title="5.2. 当前读"></a>5.2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。<br>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p><strong><em>记录索引：</em></strong> 锁定一个记录上的索引，而不是记录本身。<br>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p><strong><em>记录索引间隙：</em></strong> 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-Next-Key-Locks"><a href="#3-Next-Key-Locks" class="headerlink" title="3. Next-Key Locks"></a>3. Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, positive infinity)</span><br></pre></td></tr></tbody></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h2><p>属性不可分。</p><h2 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h2><p>每个非主属性完全函数依赖于键码。<br>可以通过分解来满足。</p><h2 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h2><p>非主属性不传递函数依赖于键码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 常用函数</title>
    <link href="https://ccomma.cn/cd5f30760ffd/"/>
    <id>https://ccomma.cn/cd5f30760ffd/</id>
    <published>2023-06-26T09:08:26.000Z</published>
    <updated>2024-04-01T08:13:04.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="concat-str1-str2-…"><a href="#concat-str1-str2-…" class="headerlink" title="concat(str1, str2,…)"></a>concat(str1, str2,…)</h2><h2 id="date-sub-curdate-interval-7-day"><a href="#date-sub-curdate-interval-7-day" class="headerlink" title="date_sub(curdate(), interval 7 day)"></a>date_sub(curdate(), interval 7 day)</h2><h2 id="substring-str-start-len"><a href="#substring-str-start-len" class="headerlink" title="substring(str, start, len)"></a>substring(str, start, len)</h2><h3 id="3-1-从字符串的第-4-个字符位置开始取，直到结束"><a href="#3-1-从字符串的第-4-个字符位置开始取，直到结束" class="headerlink" title="3.1. 从字符串的第 4 个字符位置开始取，直到结束"></a>3.1. 从字符串的第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f989799d1594d6c6347f726aa6db249.png" alt="image.png"></p><h3 id="3-2-从字符串的倒数第-4-个字符位置开始取，直到结束"><a href="#3-2-从字符串的倒数第-4-个字符位置开始取，直到结束" class="headerlink" title="3.2 从字符串的倒数第 4 个字符位置开始取，直到结束"></a>3.2 从字符串的倒数第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0636d54c94efe5f728e072b11e5d04dc.png" alt="image.png"></p><h3 id="3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符"><a href="#3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符"></a>3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4aca25208e5313e87f299a38e4d2c0c4.png" alt="image.png"></p><h3 id="3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符"><a href="#3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符"></a>3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b3176ddb272f1050b3f9616ff715d5d.png" alt="image.png"></p><h2 id="substring-index-str-‘-’-2"><a href="#substring-index-str-‘-’-2" class="headerlink" title="substring_index(str, ‘>’, 2)"></a>substring_index(str, ‘&gt;’, 2)</h2><h3 id="4-1-截取第二个-‘-’-之前的所有字符"><a href="#4-1-截取第二个-‘-’-之前的所有字符" class="headerlink" title="4.1. 截取第二个 ‘.’ 之前的所有字符"></a>4.1. 截取第二个 ‘.’ 之前的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a2f362bf0cf1858e59d7096f97caf712.png" alt="image.png"></p><h3 id="4-2-截取倒数第二个-‘-’-之后的所有字符"><a href="#4-2-截取倒数第二个-‘-’-之后的所有字符" class="headerlink" title="4.2. 截取倒数第二个 ‘.’ 之后的所有字符"></a>4.2. 截取倒数第二个 ‘.’ 之后的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7bd62c1fcce43cc5037a59c28a74533f.png" alt="image.png"></p><h2 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP_CONCAT"></a>GROUP_CONCAT</h2><p>测试数据表<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f5cec81e840d7468bdc4c338f528d9c8.png" alt="image.png"><br> <br>以 product_id; 分组，把 name 字段的值打印在一行，逗号分隔 (默认) <br> SELECT id,GROUP_CONCAT(name) FROM test_brand GROUP BY product_id;<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3b8b8c51da8a0c3eb4b4fe0e2a61c970.png" alt="image.png"></p><ul><li>group_concat () 有长度限制 1024， 需要修改配置 group_concat_max_len，如果超过大小会被截断</li><li>排序 GROUP_CONCAT (name ORDER BY id DESC) </li><li>当你用 group_concat 的时候请注意，连接起来的字段如果是 int 型，一定要转换成 char 再拼起来，否则在你执行后 (ExecuteScalar 或者其它任何执行 SQL 返回结果的方法) 返回的将不是一个逗号隔开的串，而是 byte []</li></ul><h2 id="COUNT-等聚合函数"><a href="#COUNT-等聚合函数" class="headerlink" title="COUNT 等聚合函数"></a>COUNT 等聚合函数</h2><p>count 不会统计 null：</p><ul><li>count(t.aae140 = ‘390’ or null)</li><li>count(case when region_stat.city_num &gt; 0 and prov_stat.city_num &gt; city_stat.city_num then 1 end)</li></ul><h2 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNIX_TIMESTAMP(NOW(3)) * 1000</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;concat-str1-str2-…&quot;&gt;&lt;a href=&quot;#concat-str1-str2-…&quot; class=&quot;headerlink&quot; title=&quot;concat(str1, str2,…)&quot;&gt;&lt;/a&gt;concat(str1, str2,…)&lt;/h2&gt;&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://ccomma.cn/0c6c9beb5c26/"/>
    <id>https://ccomma.cn/0c6c9beb5c26/</id>
    <published>2023-06-26T09:01:33.000Z</published>
    <updated>2024-04-01T08:13:04.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/myseries/p/10728533.html">MySQL 中的几种日志了解</a></p><h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="1-B-Tree-原理"><a href="#1-B-Tree-原理" class="headerlink" title="1. B+ Tree 原理"></a>1. B+ Tree 原理</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1. 数据结构"></a>1.1. 数据结构</h3><p><strong><em>B Tree：</em></strong> B Tree 指的是 Balance Tree，也就是 <strong>平衡树</strong>。平衡树是一颗查找树，并且 <strong>所有叶子节点位于同一层</strong><br><strong><em>B+ Tree：</em></strong> B+ Tree 是基于 B Tree 和叶子节点 <strong>顺序访问指针 <strong>进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br></strong><em>非递减：</em></strong> 在 B+ Tree 中，一个节点中的 key 从左到右 <strong>非递减排列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2d1103b4d71fad09128907f8eca6190.png" alt="image.png"></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2. 操作"></a>1.2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data<br>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性</p><h3 id="1-3-与红黑树的比较"><a href="#1-3-与红黑树的比较" class="headerlink" title="1.3. 与红黑树的比较"></a>1.3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><ol><li>更少的查找次数<ol><li>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O (h)=O (logdN)，其中 d 为每个节点的出度。</li><li>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</li></ol></li><li>利用磁盘预读特性<ol><li>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</li><li>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li></ol></li></ol><h2 id="2-MySQL-索引"><a href="#2-MySQL-索引" class="headerlink" title="2. MySQL 索引"></a>2. MySQL 索引</h2><h3 id="2-1-B-Tree-索引"><a href="#2-1-B-Tree-索引" class="headerlink" title="2.1. B+ Tree 索引"></a>2.1. B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型<br><strong><em>速度快：</em></strong> 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多<br><strong><em>排序、分组：</em></strong> 除了用于查找，还可以用于排序和分组<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引<br><strong><em>主索引（聚簇索引）：</em></strong><br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/30543773300e9ea98415981a1d06e6cf.png" alt="image.png"><br><strong><em>辅助索引（非聚簇索引）：</em></strong><br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/314a86a9ddf86481c7ccb3a16791ef29.png" alt="image.png"></p><h3 id="2-2-哈希索引"><a href="#2-2-哈希索引" class="headerlink" title="2.2. 哈希索引"></a>2.2. 哈希索引</h3><p>哈希索引能以 O (1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3. 全文索引"></a>2.3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="2-4-空间数据索引"><a href="#2-4-空间数据索引" class="headerlink" title="2.4. 空间数据索引"></a>2.4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1. 独立的列"></a>3.1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> sakila.actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2. 多列索引"></a>3.2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好<br>例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id </span><br><span class="line"><span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-索引列的顺序"><a href="#3-3-索引列的顺序" class="headerlink" title="3.3. 索引列的顺序"></a>3.3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。<br><strong><em>索引的选择性：</em></strong> 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。<br>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line"></span><br><span class="line">   staff_id_selectivity: <span class="number">0.0001</span></span><br><span class="line">customer_id_selectivity: <span class="number">0.0373</span></span><br><span class="line">               <span class="built_in">COUNT</span>(<span class="operator">*</span>): <span class="number">16049</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-前缀索引"><a href="#3-4-前缀索引" class="headerlink" title="3.4. 前缀索引"></a>3.4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5. 覆盖索引"></a>3.5. 覆盖索引</h3><p>索引包含 <strong>所有需要查询的字段的值</strong>。<br><strong><em>优点：</em></strong></p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="4-索引的优点"><a href="#4-索引的优点" class="headerlink" title="4. 索引的优点"></a>4. 索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="5-索引的使用条件"><a href="#5-索引的使用条件" class="headerlink" title="5. 索引的使用条件"></a>5. 索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="1-使用-Explain-进行分析"><a href="#1-使用-Explain-进行分析" class="headerlink" title="1. 使用 Explain 进行分析"></a>1. 使用 Explain 进行分析</h2><p>Explain 用来 <strong>分析 SELECT 查询语句</strong>，开发人员可以通过分析 Explain 结果来优化查询语句<br><strong><em>重要字段：</em></strong></p><ul><li><strong>select_type：</strong> 查询类型，有简单查询、联合查询、子查询等</li><li><strong> key：</strong> 使用的索引</li><li><strong> rows：</strong> 扫描的行数</li></ul><h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><h3 id="2-1-减少请求的数据量"><a href="#2-1-减少请求的数据量" class="headerlink" title="2.1. 减少请求的数据量"></a>2.1. 减少请求的数据量</h3><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="2-2-减少服务器端扫描的行数"><a href="#2-2-减少服务器端扫描的行数" class="headerlink" title="2.2. 减少服务器端扫描的行数"></a>2.2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="3-重构查询方式"><a href="#3-重构查询方式" class="headerlink" title="3. 重构查询方式"></a>3. 重构查询方式</h2><h3 id="3-1-切分大查询"><a href="#3-1-切分大查询" class="headerlink" title="3.1. 切分大查询"></a>3.1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do {</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")</span><br><span class="line">} while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-分解大连接查询"><a href="#3-2-分解大连接查询" class="headerlink" title="3.2. 分解大连接查询"></a>3.2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联<br><strong><em>好处：</em></strong></p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN () 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><p><strong><em>概述：</em></strong> MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br><strong><em>隔离级别：</em></strong><br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<br>在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻读。<br><strong><em>索引：</em></strong> 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。<br><strong><em>内部优化：</em></strong> 包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。<br><strong><em>热备份：</em></strong> 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h2><p><strong><em>概述：</em></strong> 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br><strong><em>特性：</em></strong> 提供了压缩表、空间数据索引等。<br><strong><em>事务：</em></strong> 不支持事务。<br><strong><em>读写锁：</em></strong> 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。<br><strong><em>索引：</em></strong> 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ul><li><strong>事务：</strong> InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li><li><strong>并发：</strong> MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li><li><strong>外键：</strong> InnoDB 支持外键</li><li><strong>备份：</strong> InnoDB 支持在线热备份</li><li><strong>崩溃恢复：</strong> MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li><strong>其它特性：</strong> MyISAM 支持压缩表和空间数据索引</li></ul><h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT (11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL (18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。<br>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h2 id="4-时间和日期"><a href="#4-时间和日期" class="headerlink" title="4. 时间和日期"></a>4. 时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3 id="4-1-DATETIME"><a href="#4-1-DATETIME" class="headerlink" title="4.1. DATETIME"></a>4.1. DATETIME</h3><p><strong><em>概述：</em></strong> 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。<br><strong><em>时区：</em></strong> 与时区无关。<br>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如 “2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3 id="4-2-TIMESTAMP"><a href="#4-2-TIMESTAMP" class="headerlink" title="4.2. TIMESTAMP"></a>4.2. TIMESTAMP</h3><p><strong><em>概述：</em></strong> 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。<br><strong><em>时区：</em></strong> 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。<br>MySQL 提供了 FROM_UNIXTIME () 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP () 函数把日期转换为 UNIX 时间戳。<br><strong><em>优点：</em></strong> 比 DATETIME 空间效率更高。</p><h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><p><a href="https://blog.csdn.net/bluishglc/column/info/sharding">数据库分库分表 (sharding)</a></p><h2 id="1-水平切分"><a href="#1-水平切分" class="headerlink" title="1. 水平切分"></a>1. 水平切分</h2><p><strong><em>概述：</em></strong> 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。<br>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c737fd088f55ee87e034c39ac838861.png" alt="image.png"></p><h2 id="2-垂直切分"><a href="#2-垂直切分" class="headerlink" title="2. 垂直切分"></a>2. 垂直切分</h2><p><strong><em>概述：</em></strong> 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。<br>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9cb0ca9f7892a9d4fca291f0674da13c.png" alt="image.png"></p><h2 id="3-Sharding-策略"><a href="#3-Sharding-策略" class="headerlink" title="3. Sharding 策略"></a>3. Sharding 策略</h2><p><strong><em>策略：</em></strong></p><ul><li><strong>哈希取模：</strong> hash(key) % N</li><li><strong> 范围：</strong> 可以是 ID 范围也可以是时间范围</li><li><strong>映射表：</strong> 使用单独的一个数据库来存储映射关系</li></ul><p><strong><em>问题：</em></strong></p><ol><li><strong>事务问题：</strong> 使用分布式事务来解决，比如 XA 接口。</li><li><strong>连接：</strong> 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li><li><strong>ID 唯一性：</strong><ol><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ol></li></ol><h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><p><a href="https://www.cnblogs.com/idoljames/p/11694039.html">Mysql 主从复制原理及同步延迟问题</a><br><a href="https://blog.51cto.com/6300167/2344750">mysql 主从复制延迟问题</a><br><a href="https://www.jianshu.com/p/37f54c32c93c">mysql 读写分离和解决主从同步延时问题</a></p><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><p>主要涉及三个线程： binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程：</strong> 负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程：</strong> 负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li><li><strong>SQL 线程：</strong> 负责读取重放日志并重放其中的 SQL 语句。</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5ebee84b776054508db67f7a9ca22bc1.png" alt="image.png"></p><h2 id="2-读写分离"><a href="#2-读写分离" class="headerlink" title="2. 读写分离"></a>2. 读写分离</h2><p><strong>概述：</strong> 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br><strong>优点：</strong></p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p><strong>实现：</strong> 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a18825649461134799421b2a56728e4d.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/myseries/p/10728533.html&quot;&gt;MySQL 中的几种日志了解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、索引&quot;&gt;&lt;a href=&quot;#一、索引&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DATETIME 与 TIMESTAMP 的一些区别与问题</title>
    <link href="https://ccomma.cn/ce89239438f9/"/>
    <id>https://ccomma.cn/ce89239438f9/</id>
    <published>2023-06-26T09:00:48.000Z</published>
    <updated>2024-04-01T08:13:04.831Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个问题，明明数据有更新，update_time 字段却还停留在创建数据的时候。<br>按常理来说这个字段应该是自动更新的才对。<br>查了一下表结构，<code>update_time</code> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP<br>发现 update_time 字段的类型是 datetime<br>由此牵扯出两个问题，（1）timestamp 与 datetime 的区别；（2）CURRENT_TIMESTAMP 为什么能用于 datetime 类型</p><ul><li>timestamp 与 datetime 的区别<br>a）DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空（not null）, 默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且 update 语句中没有指定该列的更新值，则默认更新为当前时间。<br>这个区别就解释了为什么平时我们都不用可以管这个字段就能自动更新了，因为多数时候用的是 timestamp；而此处用的是 datetime，不会有自动更新当前时间的机制，所以需要在上层手动更新该字段 b）DATETIME 使用 8 字节的存储空间，TIMESTAMP 的存储空间为 4 字节。因此，TIMESTAMP 比 DATETIME 的空间利用率更高。这个区别解释了为啥 timestamp 类型用的多 c）两者的存储方式不一样 ，对于 TIMESTAMP，它把客户端插入的时间从当前时区转化为 UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于 DATETIME，不做任何改变，基本上是原样输入和输出。d）两者所能存储的时间范围不一样 timestamp 所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’；datetime 所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</li><li>CURRENT_TIMESTAMP 为什么能用于 datetime 类型<br>在 mysql 5.6 之前的版本，CURRENT_TIMESTAMP 只能用于 timestamp 类型，<br>5.6 版本之后，CURRENT_TIMESTAMP 也能用于 datetime 类型了<br>select version () 查了一下数据库发现确实版本是 5.6.29</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天遇到一个问题，明明数据有更新，update_time 字段却还停留在创建数据的时候。&lt;br&gt;按常理来说这个字段应该是自动更新的才对。&lt;br&gt;查了一下表结构，&lt;code&gt;update_time&lt;/code&gt; datetime NOT NULL DEFAULT CURREN</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows 安装 MySQL</title>
    <link href="https://ccomma.cn/2d2e70c8da23/"/>
    <id>https://ccomma.cn/2d2e70c8da23/</id>
    <published>2023-06-26T09:00:03.000Z</published>
    <updated>2024-04-01T08:13:04.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_37350706/article/details/81707862">MySQL 8.0.18 安装教程 (windows 64 位)</a></p><p><a href="https://www.cnblogs.com/xiaoran991/p/12343911.html">MySQL 5.7x 安装教程</a></p><p><strong>系列目录</strong><br>一、安装 MySql<br>二、安装并破解 Navicat<br>三、没有 my.in 配置文件怎么办<br>四、设置 MySql 的大小写敏感<br>五、重置 MySql 登陆密码</p><hr><p>&nbsp;<br>之前说过，Windows 操作系统中，我们安装 Mysql 有两个选择：一是下载 MSI 点击运行，利用 windows 系统安装程序的方法按部就班的来安装；二是下载 ZIP，解压出来就能立即使用。<br>在使用 ZIP 安装时，安装好之后默认是没有 my.ini 配置文件的：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c9424ffe1cccb3d4cf13cdf5fba1b12.png"><br> 当我们想修改数据库的配置信息如 wait_timeout、interactive_timeout、max_connections 或大小写敏感时，却找不到 my.ini 配置文件。<br>虽然这时，还可以通过命令行来修改配置信息，但重启 mysql 后修改会失效，配置会回归默认值，所以这种方式治标不治本。<br>这里提供了另一种方法，解决的基本思路是：先删除 Mysql 服务，然后自己新建一个 my.ini 文件，最后使用命令行重新初始化 mysql 服务，同时指定新建的 my.ini 作为服务默认的配置文件。<br>以下是详细步骤：</p><h2 id="1-删除-MySql-服务"><a href="#1-删除-MySql-服务" class="headerlink" title="1. 删除 MySql 服务"></a>1. 删除 MySql 服务</h2><p>打开 cmd（记得” 使用管理员身份 “打开），如果没有配置环境变量，请 cd（切换目录）到 mysql 程序下的 bin 文件夹下（详细步骤参见第一章～）：<br>运行命令：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/214e32b66097f62f2e6fcdc2a4d456c8.png"><br>“MySql” 为服务名称，你的 MysSql 服务不一定是这个名称，可以打开电脑的服务窗口查看。<br>删除完成之后，最好去电脑的服务窗口看下，如果找不到 MySql 服务，说明已经已经删除成功。<br>如果还能看到 MySql 服务，可以手动右击选择” 停止 “，服务停止之后就会自动消失了。</p><h2 id="2-新建-my-ini-配置文件"><a href="#2-新建-my-ini-配置文件" class="headerlink" title="2. 新建 my.ini 配置文件"></a>2. 新建 my.ini 配置文件</h2><p>在 mysql 程序的根目录下，新建一个 my.ini 空白文件，用记事本打开，将以下内容复制进去，保存：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8f900a89c6347c561fdf2122f13be562.gif"><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/961ddebeb323a10fe0623af514929fc1.gif"><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d2f7717359a727f8dee0391547dff4d1.gif"># For advice on how to change settings please see # <a href="http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html's">http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html's</a> a template which will be copied to thedefaultif you #  upgrade to a newer version of MySQL. [client] defaultset utf8mb4 [mysql] defaultset utf8mb4 [mysqld] characterset FALSE characterset utf8mb4 collation utf8mb4_bin init_connect’SET NAMES utf8mb4’ # Remove leading # and setfor the most important data # cache in70forelse10. innodb_buffer_pool_size  128M # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # These are commonly setsetas required. basedir  D:\MySQL datadir  D:\MySQL\data port 3306 # server_id  ….. # Remove leading # to setfor reporting servers. # The server defaults are faster for transactions and fast SELECTs. # Adjust sizes as needed, experiment to find the optimal values. join_buffer_size  128M sort_buffer_size  16M read_rnd_buffer_size  16M  sql_mode<img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d2f7717359a727f8dee0391547dff4d1.gif">View Code<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d170ccbff7604b164f568b4f77f0cf3f.png"><br>其中 basedir 和 datadir 根据实际 MySql 安装的位置进行修改。</p><h2 id="3-重新生成-data-文件"><a href="#3-重新生成-data-文件" class="headerlink" title="3. 重新生成 data 文件"></a>3. 重新生成 data 文件</h2><p>删除之前生成的 data 文件，如果有重要的数据表，请先备份好。<br>回到 cmd，重新生成 data 文件。运行：<br>该命令需要执行大概一分钟左右，完成后会在 MySql 程序文件夹下重新生成名称为 data 的文件夹：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2871ea1de0e1ea258bd39f113bf6302c.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0c19aa129347bbc21afc48f5f809a79d.png"><br>&nbsp;</p><h2 id="4-重新安装-mysql-服务，同时绑定-my-ini-配置文件"><a href="#4-重新安装-mysql-服务，同时绑定-my-ini-配置文件" class="headerlink" title="4. 重新安装 mysql 服务，同时绑定 my.ini 配置文件"></a>4. 重新安装 mysql 服务，同时绑定 my.ini 配置文件</h2><p>安装 MySql 服务，同时设置绑定 my.ini 配置文件。命令：<br>“MySql80” –defaults-file=”d:/mysql/my.ini”<br>“MySql80” 是服务名称，80 表示 8.0 版本，当然，也可以自己取别的名字。<br>”..\my.ini“是新建的配置文件的位置，也可以写成绝对路径”D:\MySql\my.ini“。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7c0eff842ce4139a3230795344806810.png"><br>如果提示安装成功，这时打开电脑的” 服务 “窗口，可以找到新添加的 MySql80 服务：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b881a1e15afbadb0e900a9de4673de43.png"><br>&nbsp;</p><h2 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a>5. 启动服务</h2><p>这里有两种启动服务的方式：1）服务窗口启动；2）cmd 启动</p><h3 id="5-1-服务窗口启动"><a href="#5-1-服务窗口启动" class="headerlink" title="5.1 服务窗口启动"></a>5.1 服务窗口启动</h3><p>直接右击服务项，选择启动：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/95f42ae7e44b283aaf44eb616a0d73e6.png"><br>&nbsp;</p><h3 id="5-2-cmd-命令启动"><a href="#5-2-cmd-命令启动" class="headerlink" title="5.2 cmd 命令启动"></a>5.2 cmd 命令启动</h3><p>命令：<br>等待 20 秒左右，如果启动成功，是这样的：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b3f9d6c79a8350cfad64599feee15ee.png"><br>&nbsp;<br>如果不成功：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/70e18e9cba139ecd5b99730a9e11fc3e.png"><br>&nbsp;<br>这时可能是 my.ini 配置文件中的某些配置有问题。你可以修改 ini 文件内容，然后从头按步骤再试一遍。</p><h2 id="6-重新设置密码"><a href="#6-重新设置密码" class="headerlink" title="6. 重新设置密码"></a>6. 重新设置密码</h2><p>删除了 data 文件和服务之后，之前的密码就失效了，所以需要重新设置密码。</p><h3 id="6-1-登陆-mysql"><a href="#6-1-登陆-mysql" class="headerlink" title="6.1 登陆 mysql"></a>6.1 登陆 mysql</h3><p>命令：<br>这时密码为空，不需要填写，直接回车：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b45fb44fead6edf175a976a634f44d9f.png"><br>如果这里没有登陆成功，请移步下一章” 重置 MySql 密码 “~</p><h3 id="6-2-修改-root-用户密码"><a href="#6-2-修改-root-用户密码" class="headerlink" title="6.2 修改 root 用户密码"></a>6.2 修改 root 用户密码</h3><p>（敲黑板）这里有个需要注意的地方，在 8.0 之后的版本，修改 root 用户密码的命令是：<br>‘root’’localhost’’你的密码’<br>&nbsp;之前的版本是：<br>set” 你的密码”where”root”<br>&nbsp;我这里安装的是 8.0.11，所以是第一个：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/05f4b146bb74f83635ad8951abf4cc07.png"></p><h3 id="6-3-退出-MySQL"><a href="#6-3-退出-MySQL" class="headerlink" title="6.3 退出 MySQL"></a>6.3 退出 MySQL</h3><p>命令：</p><h3 id="6-4-使用修改后的密码重新登陆"><a href="#6-4-使用修改后的密码重新登陆" class="headerlink" title="6.4 使用修改后的密码重新登陆"></a>6.4 使用修改后的密码重新登陆</h3><p>这里的命令和之前是一样的，就不写了，密码记得要填刚才设置的：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/af7c90061a5c0b9eae88372318325818.png"><br>&nbsp;<br>&nbsp;<br>现在已经成功绑定了 my.ini 配置文件了，如果需要自定义配置，可以打开文件进行相应的配置设置，修改后重启服务即可。<br>如果修改后，重启服务报错，如下图：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e7bb3e3063f151fb192e70f6a4f20470.png"><br>&nbsp;<br>有一种可能：你修改的配置与服务初始化时的配置有冲突，这时只能从头开始，在初始化的时候绑定 my.ini 文件 。<br>下一章要讲的的 “设置 MySql 大小写敏感” 就是～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_37350706/article/details/81707862&quot;&gt;MySQL 8.0.18 安装教程 (windows 64 位)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnb</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 安装 MySQL</title>
    <link href="https://ccomma.cn/9d889f53bf61/"/>
    <id>https://ccomma.cn/9d889f53bf61/</id>
    <published>2023-06-26T08:59:22.000Z</published>
    <updated>2024-04-01T08:13:04.832Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 下载解压</strong><br><strong>1.1 下载</strong><br>wget mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz<br><strong>1.2 解压到 /usr/local/ 下，并更名</strong><br>tar -zxvf /home/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz -C /usr/local<br>mv /usr/local/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz /usr/local/mysql<br><strong>1.3 创建 data 文件夹存放数据</strong><br>mkdir /usr/local/mysql/data<br><strong>2. 用户组</strong><br><strong>2.1 创建 用户 和 组</strong><br>groupadd mysql<br>useradd -r -g mysql mysql<br><strong>2.2 更改文件所属</strong><br>-R 表示递归<br>chown -R mysql:mysql /usr/local/mysql/<br>chown -R mysql:mysql /usr/local/mysql/data/<br>chown -R mysql /usr/local/mysql/<br>chown -R mysql /usr/local/mysql/data/<br><strong>2.3 更改权限</strong><br>755：rwxr-xr-x<br>chmod -R 755 /usr/local/mysql/<br><strong>3. 安装 libaio 依赖包</strong><br>yum install libaio<br><strong>4. 初始化</strong><br>cd /usr/local/mysql/bin<br>./mysqld –user=mysql –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –initialize<br>[Note] A temporary password is generated for root@localhost: o*s#gqh)F4Ck<br>得到随机的 初始密码<br><strong>5. 启动 mysql 服务</strong><br>sh /usr/local/mysql/support-files/mysql.server start<br><strong>6. 修改 my.cnf 文件</strong><br>cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld<br>chmod 755 /etc/init.d/mysqld<br>vim /etc/my.cnf<br>[client]<br>no-beep<br>socket =/usr/local/mysql/mysql.sock<br># pipe<br># socket=0.0<br>port=3306<br>[mysql]<br>default-character-set=utf8<br>[mysqld]<br>basedir=/usr/local/mysql<br>datadir=/usr/local/mysql/data<br>port=3306<br>pid-file=/usr/local/mysql/mysqld.pid<br>#skip-grant-tables<br>skip-name-resolve<br>socket = /usr/local/mysql/mysql.sock<br>character-set-server=utf8<br>default-storage-engine=INNODB<br>explicit_defaults_for_timestamp = true<br># Server Id.<br>server-id=1<br>max_connections=2000<br>query_cache_size=0<br>table_open_cache=2000<br>tmp_table_size=246M<br>thread_cache_size=300<br>#限定用于每个数据库线程的栈大小。默认设置足以满足大多数应用<br>thread_stack = 192k<br>key_buffer_size=512M<br>read_buffer_size=4M<br>read_rnd_buffer_size=32M<br>innodb_data_home_dir = /usr/local/mysql/data<br>innodb_flush_log_at_trx_commit=0<br>innodb_log_buffer_size=16M<br>innodb_buffer_pool_size=256M<br>innodb_log_file_size=128M<br>innodb_thread_concurrency=128<br>innodb_autoextend_increment=1000<br>innodb_buffer_pool_instances=8<br>innodb_concurrency_tickets=5000<br>innodb_old_blocks_time=1000<br>innodb_open_files=300<br>innodb_stats_on_metadata=0<br>innodb_file_per_table=1<br>innodb_checksum_algorithm=0<br>back_log=80<br>flush_time=0<br>join_buffer_size=128M<br>max_allowed_packet=1024M<br>max_connect_errors=2000<br>open_files_limit=4161<br>query_cache_type=0<br>sort_buffer_size=32M<br>table_definition_cache=1400<br>binlog_row_event_max_size=8K<br>sync_master_info=10000<br>sync_relay_log=10000<br>sync_relay_log_info=10000<br>#批量插入数据缓存大小，可以有效提高插入效率，默认为 8M<br>bulk_insert_buffer_size = 64M<br>interactive_timeout = 120<br>wait_timeout = 120<br>log-bin-trust-function-creators=1<br>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES<br>#<br># include all files from the config directory<br>#<br>!includedir /etc/my.cnf.d<br><strong>7. 登录</strong><br>/usr/local/mysql/bin/mysql -u root –p</p><p>密码为之前的临时密码<br><strong>8. 修改密码 及 共享</strong><br>set password=password (‘密码’);<br>grant all privileges on 库名。表名 to ‘用户名‘@’IP 地址’ identified by ‘密码’ with grant option;<br>flush privileges;<br>库名：要远程访问的数据库名称，所有的数据库使用 “<em>” <br>表名：要远程访问的数据库下的表的名称，所有的表使用 “</em>” <br>用户名：要赋给远程访问权限的用户名称 <br>IP 地址：可以远程访问的电脑的 IP 地址，所有的地址使用 “%” <br>密码：要赋给远程访问权限的用户对应使用的密码<br><strong><em>例子：</em></strong><br># 所有的地址都可以使用 root 用户，密码为 lxh 远程访问所有的数据库<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘lxh’ WITH GRANT OPTION; <br># IP 为 172.16.52.225 的电脑可以使用 lxh 用户，密码为 lxh 远程访问数据库 testdb 的所有表<br>GRANT ALL PRIVILEGES ON testdb.* TO ‘lxh‘@’172.16.52.225’ IDENTIFIED BY ‘lxh’ WITH GRANT OPTION; <br><strong>9. 添加 环境变量</strong><br><strong>9.1 直接在命令行中设置 PATH</strong><br>PATH=$PATH:/usr/local/mysql/bin<br>使用这种方法，只对当前会话有效，也就是说每当登出或注销系统以后，PATH 设置就会失效。<br><strong>9.2 在 profile 中设置 PATH</strong><br>vim /etc/profile<br>export PATH=$PATH:/usr/local/apache/bin<br><strong>9.3 在当前用户的 profile 中设置 PATH</strong><br>vim ~/.bash_profile<br>PATH=$PATH:$HOME/bin:/usr/local/apache/bin<br>source ~/.bash_profile<br>这种方法只对当前用户起作用的，其他用户该修改无效。<br><strong>10. 阿里云设置安全组</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3b66d3af9ad75ff18c49b57b367845a6.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/acf9c36242e743914d261e0a63a9a15e.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1. 下载解压&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1.1 下载&lt;/strong&gt;&lt;br&gt;wget mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz&lt;br&gt;&lt;strong&gt;1.2 解压到 /usr/local/ 下，并</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://ccomma.cn/bcd61782344f/"/>
    <id>https://ccomma.cn/bcd61782344f/</id>
    <published>2023-06-26T03:16:17.000Z</published>
    <updated>2024-04-01T08:13:04.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h1><h1 id="Spring-和-SpringBoot"><a href="#Spring-和-SpringBoot" class="headerlink" title="Spring 和 SpringBoot"></a>Spring 和 SpringBoot</h1><p>Spring 缺点：重配置<br>Spring Boot 优点</p><ul><li>起步依赖：将多个 maven 包的坐标整合到一起，并提供一些默认的功能</li><li>自动配置：会自动将一些配置类的 bean 注册进 IoC 容器</li></ul><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul><li>@SpringBootTest：标记该类为 SpringBoot 单元测试类，并加载 applicationContext 上下文环境</li><li> @RunWith (SpringRunner.class)：测试启动器，并加载 SpringBoot 测试注解</li></ul><h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><p>依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol><li>IDEA 开启自动编译</li><li> Ctrl + Shift + Alt + /-&gt; Registry -&gt; compiler.automake.allow.when.app.running √：用于指定 IDEA 在程序运行过程中自动编译</li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="5-1-ConfigurationProperties"><a href="#5-1-ConfigurationProperties" class="headerlink" title="5.1 ConfigurationProperties"></a>5.1 <a href="https://blog.csdn.net/yusimiao/article/details/97622666">ConfigurationProperties</a></h2><p>依赖包</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><pre><code>  -  [@ConfigurationProperties(prefix ](/ConfigurationProperties(prefix ) = "person")：将配置文件中以 person 开头的属性注入到类中  </code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// set and get</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><a href="/Value">@Value </a>  </p><ul><li>无需 set 方法 </li><li>不支持 Map、对象及行内写法 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="meta">@Value("${person.id}")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>@PropertySource：加载配置文件 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource("classpath:text.properties")</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// set and get</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>随机值设置<br>使用 Spring Boot 内嵌的 RandomValuePropertySource 类 </p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">${random.value}</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">${random.int} </span></span><br><span class="line"><span class="attr">my.bignumber</span>=<span class="string">${random.long} </span></span><br><span class="line"><span class="attr">my.uuid</span>=<span class="string">${random.uuid}</span></span><br><span class="line"><span class="comment"># 配置小于 10 的随机整数</span></span><br><span class="line"><span class="attr">my.number.less.than.ten</span>=<span class="string">${random.int(10)}</span></span><br><span class="line"><span class="comment"># 配置范围在 [1024,65536] 之间的随机整数</span></span><br><span class="line"><span class="attr">my.number.in.range</span>=<span class="string">${random.int[1024,65536]}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>参数引用 </p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp </span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">${app.name} is a Spring Boot application</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="SpringBootApplication-源码"><a href="#SpringBootApplication-源码" class="headerlink" title="@SpringBootApplication 源码"></a>@SpringBootApplication 源码</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.TYPE})</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 表明该类为配置类</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> </span><br><span class="line"><span class="comment">// 启用自动配置功能</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> </span><br><span class="line"><span class="comment">// 包扫描</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">excludeFilters = {</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), </span></span><br><span class="line"><span class="meta">        @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})</span></span><br><span class="line"><span class="meta">    })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>@SpringBootConfiguration<br>组合了 @Configuration，配置类 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.TYPE})</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="comment">// 配置 IoC 容器</span></span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration { </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@EnableAutoConfiguration </p><ul><li>@AutoConfigurationPackage：将 AutoConfigurationPackages.Registrar 类导入到 IoC 容器中。拿到启动类所在的包名 </li><li>@Import (AutoConfigurationImportSelector.class) ：将 AutoConfigurationImportSelector 类导入到 IoC 容器中。 <ul><li>AutoConfigurationMetadataLoader#loadMetadata：加载 spring-boot-autoconfigure.jar 依赖包中 <code>spring-autoconfigure-metadata.properties</code> 文件中的属性，其定义了各个自动配置类及其加载条件。最终生成 AutoConfigurationMetadata 对象。 </li><li>AutoConfigurationImportSelector#getAutoConfigurationEntry： <ol><li>AutoConfigurationImportSelector#getAttributes：获得注解的属性 </li><li><strong>AutoConfigurationImportSelector#getCandidateConfigurations：</strong> 获取默认支持的自动配置类名列表<br>Spring Boot 在启动的时候，使用内部工具类 SpringFactoriesLoader 查找 classpath 上所有 jar 包中的 <code>META-INF/spring.factories</code> 文件。找到将 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的键值对，其值为多个工厂类名称。取出生成 <code>自动配置类名列表</code>。 </li><li>AutoConfigurationImportSelector#removeDuplicates：对 <code>自动配置类名列表</code> 去重 </li><li>AutoConfigurationImportSelector#getExclusions：得到需排除的自动配置类，后续操作对列表集合进行排除 </li><li>AutoConfigurationImportSelector#filter：根据配置类的 <a href="/ConditionalXXX">@ConditionalXXX </a> 注解指定的条件对列表集合进行筛选，并对 AutoConfigurationMetadataLoader#loadMetadata 生成的 AutoConfigurationMetadata 对象进行筛选  </li><li>AutoConfigurationImportSelector#fireAutoConfigurationImportEvents：将自动配置导入事件通知监听器。<br>过滤完成后会自动加载类路径下 Jar 包中 <code>META-INF/spring.factories</code> 文件中 AutoConfigurationImportListener 的实现类，并触发 fireAutoConfigurationImportEvents 事件。进行自动配置类的加载创建 </li></ol></li></ul></li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 自动配置包：会把 @SpringbootApplication 注解标注的类所在包名拿到，并且对该包及其子包进行扫描，将组件添加到容器中</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="comment">// 可以帮助springboot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器(ApplicationContext)中</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="自定义-starter"><a href="#自定义-starter" class="headerlink" title="自定义 starter"></a>自定义 starter</h1><ul><li><p>导入依赖 </p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>SimpleBean </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(SimpleBean.class)</span> </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = "simplebean")</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleBean</span> {</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// setter and getter</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>MyAutoConfiguration<br>@ConditionalOnClass：当类路径 classpath 下有指定的类的情况下才进行自动配置 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(SimpleBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> {</span><br><span class="line"><span class="keyword">static</span> { </span><br><span class="line">        System.out.println(<span class="string">"MyAutoConfiguration init...."</span>); </span><br><span class="line">    }</span><br><span class="line"><span class="meta">@Bean</span> <span class="keyword">public</span> SimpleBean <span class="title function_">simpleBean</span><span class="params">()</span>{ </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleBean</span>();</span><br><span class="line">} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>resources 下创建 /META-INF/spring.factories </p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\ com.ccomma.config.MyAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="SpringApplication-run-源码"><a href="#SpringApplication-run-源码" class="headerlink" title="SpringApplication#run 源码"></a>SpringApplication#run 源码</h1><ul><li>静态方法 SpringApplication#run <ul><li>创建 SpringApplication 实例：new SpringApplication (primarySources)，其中 primarySources 为启动类的 Class 对象 <ol><li>存储项目启动类的 Class 对象至属性字段中</li><li>设置应用类型是 SERVLET 应用（Spring 5 之前的传统 MVC 应用）还是 REACTIVE 应用（Spring 5 开始出现的 WebFlux 交互式应用）</li><li>SpringApplication#getSpringFactoriesInstances (ApplicationContextInitializer.class)：在 <code>spring.factories</code> 中获取以 ApplicationContextInitializer 全类名为键的所有值（值为初始化器的全类名），并创建实例返回。即返回了 ApplicationContextInitializer 这一类的所有初始化器实例。然后进行设置</li><li> SpringApplication#getSpringFactoriesInstances (ApplicationListener.class)：同上，获取 ApplicationListener 这一键下的所有监听器并进行设置</li><li>初始化 mainApplicationClass 属性：用于推断并设置项目 main () 方法启动的主程序启动类</li></ol></li><li>调用 SpringApplication 实例的 run 方法 <ol><li>获取并启动监听器：调用 SpringApplication#getRunListeners 方法从 <code>spring.factories</code> 中获取键为 SpringApplicationRunListener.class 的所有值（全类名），放入 SpringApplicationRunListeners 对象中，并调用其 starting 方法启动监听器</li><li>项目运行环境 Environment 的预配置：调用 SpringApplication#prepareEnvironment 方法创建并配置当前 SpringBoot 应用将要使用的 Environment，并遍历调用所有的 SpringApplicationRunListener 的 environmentPrepared () 方法。最后调用 SpringApplication#configureIgnoreBeanInfo 配置环境 <ol><li>SpringApplication#getOrCreateEnvironment：获取或创建环境</li><li> SpringApplication#configureEnvironment：配置环境。配置 PropertySources 和 Active Profiles</li><li>SpringApplicationRunListeners#environmentPrepared：Listeners 环境准备（广播 ApplicationEnvironmentPreparedEvent 事件）</li><li>SpringApplication#bindToSpringApplication：将环境绑定到 SpringApplication 中</li></ol></li><li>创建 Spring 容器：调用 SpringApplication#createApplicationContext 创建一个 AnnotationConfigServletWebServerApplicationContext 容器</li><li>获得异常报告器（SpringBootExceptionReporter 集合）：调用 SpringApplication#getSpringFactoriesInstances 从 <code>spring.factories</code> 中获取键为 BootExceptionReporter.class 的所有类，即所有异常报告器</li><li> Spring 容器前置处理：调用 SpringApplication#prepareContext 方法，在容器刷新之前的准备动作，比如触发监听器的响应事件、加载资源、设置上下文环境等。并将启动类注入容器为后续开启自动化配置奠定基础 <ol><li>SpringApplication#load：将启动类注入容器，为后续开启自动化配置奠定基础</li></ol></li><li>刷新容器：调用 SpringApplication#refreshContext <ol><li>SpringApplication#refresh：初始化 IoC 容器，包括 Bean 资源的定位、解析、注册等</li><li> ConfigurableApplicationContext#registerShutdownHook：注册 JVM 关闭钩子。在 JVM 关机时关闭这个上下文</li></ol></li><li> Spring 容器后置处理：钩子，无实现可拓展</li><li>发出结束执行的事件通知：调用 SpringApplicationRunListeners#started 方法执行所有监听器的 SpringApplicationRunListener#started 方法</li><li> SpringApplication#callRunners：获取并执行 ApplicationRunner 和 CommandLineRunner 的所有实现类。Runner 运行器用于在服务启动时进行一些业务初始化操作，这些操作只在服务启动后执行一次。Spring Boot 提供了 ApplicationRunner 和 CommandLineRunner 两种服务接口</li><li>发布应用上下文就绪事件：调用 SpringApplicationRunListeners#running 方法来持续运行配置好的应用上下文 ApplicationContext</li></ol></li></ul></li></ul><h1 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h1><ul><li>注解方式：未使用缓存管理器则默认使用 Simple 缓存组件进行缓存 <ul><li><p><a href="/EnableCaching">@EnableCaching </a>  </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot04CacheApplication</span> {</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> { </span><br><span class="line">        SpringApplication.run(Springboot04CacheApplication.class, args);</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@Cacheable：缓存数据，用于查询方法</p></li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames = "comment")</span> </span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">findById</span><span class="params">(<span class="type">int</span> comment_id)</span>{ </span><br><span class="line">    Optional&lt;Comment&gt; optional = commentRepository.findCommentById(comment_id); </span><br><span class="line">    <span class="keyword">if</span>(optional.isPresent()){ </span><br><span class="line">        <span class="keyword">return</span> optional.get();</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>  -  @CachePut：更新数据库后更新缓存，用于更新方法   -  @CacheEvict：删除数据库数据后删除缓存，用于删除方法 </code></pre><ul><li><p>API 方式 </p><ul><li>RedisTemplate <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiCommentService</span> {</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> CommentRepository commentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">findCommentById</span><span class="params">(Integer id)</span> {</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">"comment_"</span> + id); </span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) { </span><br><span class="line">            <span class="keyword">return</span> (Comment) o;</span><br><span class="line">} <span class="keyword">else</span> { </span><br><span class="line">            <span class="comment">// 缓存中没有，从数据库中查询</span></span><br><span class="line">            Optional&lt;Comment&gt; byId = commentRepository.findById(id);</span><br><span class="line">            <span class="keyword">if</span> (byId.isPresent()) {</span><br><span class="line">                <span class="type">Comment</span> <span class="variable">comment</span> <span class="operator">=</span> byId.get();</span><br><span class="line">                <span class="comment">// 将查询结果存入到缓存中</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"comment_"</span>+id,comment,<span class="number">1</span>,TimeUnit.DAYS); </span><br><span class="line">                <span class="keyword">return</span> comment;</span><br><span class="line">} <span class="keyword">else</span> { </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">updateComment</span><span class="params">(Comment comment)</span> { </span><br><span class="line">        commentRepository.updateComment(comment.getAuthor(), comment.getaId()); </span><br><span class="line">        <span class="comment">// 更新数据后进行缓存更新</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"comment_"</span>+comment.getId(),comment); </span><br><span class="line">        <span class="keyword">return</span> comment;</span><br><span class="line">} </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteComment</span><span class="params">(<span class="type">int</span> comment_id)</span> {</span><br><span class="line">commentRepository.deleteById(comment_id); </span><br><span class="line">        redisTemplate.delete(<span class="string">"comment_"</span>+comment_id);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>自定义 Redis 缓存序列化机制 </p><ul><li>RedisTemplate#afterPropertiesSet 方法中判断如果默认序列化参数 defaultSerializer 为空，则指定 JdkSerializationRedisSerializer 为默认序列化方式，所以进行缓存的实体类必须实现 Serializable 接口 </li><li>RedisConfig <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> { </span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>(); </span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory); </span><br><span class="line">        <span class="comment">// 使用 Json 格式序列化对象，对缓存数据 key 和 value 进行转换</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); </span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); </span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); </span><br><span class="line">        jacksonSeial.setObjectMapper(om); </span><br><span class="line">        <span class="comment">// 设置 RedisTemplate 模版 API 的序列化方式为 Jsonz</span></span><br><span class="line">        template.setDefaultSerializer(jacksonSeial); <span class="keyword">return</span> template;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;约定优于配置&quot;&gt;&lt;a href=&quot;#约定优于配置&quot; class=&quot;headerlink&quot; title=&quot;约定优于配置&quot;&gt;&lt;/a&gt;约定优于配置&lt;/h1&gt;&lt;h1 id=&quot;Spring-和-SpringBoot&quot;&gt;&lt;a href=&quot;#Spring-和-SpringBoo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>类型转换异常 sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</title>
    <link href="https://ccomma.cn/fb2b1fd4b701/"/>
    <id>https://ccomma.cn/fb2b1fd4b701/</id>
    <published>2023-06-21T06:13:28.000Z</published>
    <updated>2024-02-23T05:24:31.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">    Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第四行 <code>Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[0]</code> 报 <code>java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</code> 错误</p><p>这个代码是子类想要拿到泛型参数时出现的类型转换异常</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上述问题中的类结构简化如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request2</span> <span class="keyword">extends</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request3</span> <span class="keyword">extends</span> <span class="title class_">Request2</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request</span>&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request2</span>&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;R&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&lt;Request3&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>1/ <code>(new C).requestHandle()</code><br>因为 C 继承 B<request3>，所以 <code>parameterizedType.getActualTypeArguments()[0]</code> 拿到的其实就是 <code>Request3.class</code> </request3></p><p>2/ <code>(new B).requestHandle()</code><br>这种情况 <code>parameterizedType.getActualTypeArguments()[0]</code> 返回的是 <code>TypeVariable</code>，不是 Class<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/266de73a45592b057e2f6005b846e830.png" alt="image.png"><br>很好理解，因为 B 类的定义是 B<r extends="" request2="">，这里很容易因为泛型的类型擦除误认为 <code>parameterizedType.getActualTypeArguments()[0]</code> 会返回 <code>Request2.class</code></r></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>仔细观察 <code>TypeVariable</code> 接口定义</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeVariable</span>&lt;D <span class="keyword">extends</span> <span class="title class_">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title class_">Type</span>, AnnotatedElement {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上边界</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 Request2.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取泛型声明的类型，即这个类型变量的声明来源</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 B.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    D <span class="title function_">getGenericDeclaration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该类型变量名称</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 R</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带注解的上边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以调用 <code>getBounds()</code> 来获取泛型的上边界</p><p>最终调整如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> Class) {</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> TypeVariable) {</span><br><span class="line">            <span class="type">TypeVariable</span> <span class="variable">v</span> <span class="operator">=</span> (TypeVariable) actualTypeArgument;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) v.getBounds()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; getClass().getGenericSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; ParameterizedType) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ParameterizedType&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;parameterizedType&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; (ParameterizedType) type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四行 &lt;code&gt;Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[0]&lt;/code&gt; 报 &lt;code&gt;java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class&lt;/code&gt; 错误&lt;/p&gt;
&lt;p&gt;这个代码是子类想要拿到泛型参数时出现的类型转换异常&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令</title>
    <link href="https://ccomma.cn/510e8464868c/"/>
    <id>https://ccomma.cn/510e8464868c/</id>
    <published>2023-03-21T02:42:05.000Z</published>
    <updated>2024-04-01T08:13:04.834Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wilsonpeng3/article/details/70064336/">线上 FullGC 频繁的排查</a><br><a href="https://blog.csdn.net/cml_blog/article/details/81057966">一次线上 JVM 调优实践，FullGC 40 次 / 天到 10 天一次的优化过程</a><br><a href="https://blog.csdn.net/miracle_8/article/details/78347172">如何合理的规划一次 jvm 性能调优</a><br><a href="https://blog.csdn.net/chenleixing/article/details/46706039/">触发 JVM 进行 Full GC 的情况及应对策略</a><br><a href="https://www.cnblogs.com/ceshi2016/p/8447989.html">JVM 调优总结 -Xms -Xmx -Xmn -Xss</a><br><a href="https://www.cnblogs.com/therunningfish/p/5524238.html">JVM 性能调优监控工具 jps、jstack、jmap、jhat、jstat 使用详解</a><br><a href="https://www.yuque.com/attachments/yuque/0/2023/pdf/12939765/1679367740712-f3d38dbc-99b2-47d8-8dce-a05c56231bff.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/pdf/12939765/1679367740712-f3d38dbc-99b2-47d8-8dce-a05c56231bff.pdf%22,%22name%22:%22JVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%20%C2%B7%20%E8%AF%AD%E9%9B%80.pdf%22,%22size%22:1762928,%22ext%22:%22pdf%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u04b8a5d2-5601-43a0-b06d-8e81a41c41f%22,%22taskType%22:%22upload%22,%22type%22:%22application/pdf%22,%22__spacing%22:%22both%22,%22id%22:%22u0564257d%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">JVM 参数配置・语雀.pdf</a></p><h1 id="栈设置"><a href="#栈设置" class="headerlink" title="栈设置"></a>栈设置</h1><ul><li>-Xss: 栈大小</li></ul><h1 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h1><ul><li>-Xms: 初始堆大小</li><li> -Xmx: 最大堆大小</li><li> -Xmn: 新生代大小</li><li> -XX:NewSize=n: 设置年轻代大小</li><li> -XX:NewRatio=n: 设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</li><li>-XX:SurvivorRatio=n: 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。<ul><li>如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5</li></ul></li><li>-XX:PretenureSizeThreshold: 大于此值的对象直接在老年代分配</li><li> -XX:MaxTenuringThreshold: 定义年龄的阈值。在 Eden 中的对象经过 Minor GC 依然存活，将移动到 Survivor 中，年龄增加 1 岁，超过该年龄阈值将进入老年代</li></ul><h1 id="永久代设置"><a href="#永久代设置" class="headerlink" title="永久代设置"></a>永久代设置</h1><ul><li>-XX:PermSize: 初始化永久代大小</li><li> -XX:MaxPermSize=n: 永久代最大容量</li></ul><p><strong>元空间：</strong></p><ul><li><strong>-XX:MetaspaceSize ：</strong> 分配给类元数据空间的初始大小。<ul><li>MetaspaceSize 的值设置的过大会延长垃圾回收时间。</li><li>垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li></ul></li><li><strong>-XX:MaxMetaspaceSize ：</strong>分配给类元数据空间的最大值<ul><li>超过此值就会触发 Full GC 。此值默认没有限制，但应取决于系统内存的大小，JVM 会动态地改变此值。</li></ul></li></ul><h1 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h1><ul><li>-XX:+UseSerialGC: 设置串行收集器</li><li> -XX:+UseParallelGC: 设置并行收集器</li><li> -XX:+UseParalledlOldGC: 设置并行年老代收集器</li><li> -XX:+UseConcMarkSweepGC: 设置并发收集器</li><li> -XX:ParallelCMSThreads: 并发标记扫描垃圾回收器 = 为使用的线程数量</li><li> -XX:+UseG1GC: G1 垃圾回收器</li></ul><p><strong>并行收集器配置：</strong></p><ul><li>-XX:ParallelGCThreads=n: 设置并行收集器收集时使用的 CPU 数和并行收集线程数。默认开启的线程数量与 CPU 数量相同</li><li> -XX:MaxGCPauseMillis=n: 设置并行收集最大暂停时间</li><li> -XX:GCTimeRatio=n: 设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)-XX:+CMSIncrementalMode: 设置为增量模式。适用于单 CPU 情况。</li><li>-XX:ParallelGCThreads=n: 设置并发收集器年轻代收集方式为并行收集时，使用的 CPU 数。并行收集线程数。</li></ul><h1 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h1><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wilsonpeng3/article/details/70064336/&quot;&gt;线上 FullGC 频繁的排查&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/cml_blog/arti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>性能调优监控工具</title>
    <link href="https://ccomma.cn/6f008ba4e6b7/"/>
    <id>https://ccomma.cn/6f008ba4e6b7/</id>
    <published>2023-03-21T02:40:34.000Z</published>
    <updated>2024-04-01T08:13:04.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-jps（Java-Virtual-Machine-Process-Status-Tool）"><a href="#1-jps（Java-Virtual-Machine-Process-Status-Tool）" class="headerlink" title="1. jps（Java Virtual Machine Process Status Tool）"></a><strong>1. jps（Java Virtual Machine Process Status Tool）</strong></h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3725340a4dc81fe9baf2250d63d3487b.png" alt="image.png"><br><strong><em>作用：</em></strong> 用来输出 JVM 中运行的进程状态信息<br><strong><em>指令：</em></strong> jps [options] [hostid]</p><ul><li>-q 不输出类名、Jar 名和传入 main 方法的参数</li><li> -m 输出传入 main 方法的参数</li><li> -l 输出 main 类或 Jar 的全限名</li><li> -v 输出传入 JVM 的参数</li></ul><h1 id="2-jstack"><a href="#2-jstack" class="headerlink" title="2. jstack"></a>2. jstack</h1><p><strong><em>作用：</em></strong> 用来查看某个 Java 进程内的线程堆栈信息<br>指令：<br>jstack [option] pid<br>jstack [option] executable core<br>jstack [option] [server-id@]remote-hostname-or-ip</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-jps（Java-Virtual-Machine-Process-Status-Tool）&quot;&gt;&lt;a href=&quot;#1-jps（Java-Virtual-Machine-Process-Status-Tool）&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://ccomma.cn/90950ed351e4/"/>
    <id>https://ccomma.cn/90950ed351e4/</id>
    <published>2023-03-21T02:23:08.000Z</published>
    <updated>2024-04-01T08:13:04.835Z</updated>
    
    <content type="html"><![CDATA[<p>类是在 ** 运行期间第一次使用 ** 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存</p><h1 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1. 类的生命周期"></a>1. 类的生命周期</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7d761e858b6b41b873e936793f188da9.png" alt="image.png"><br>包括以下 7 个阶段：</p><ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><h1 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h1><p>包含了加载、验证、准备、解析和初始化这 5 个阶段</p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1. 加载"></a>2.1. 加载</h2><p>加载过程完成以下三件事：</p><ol><li><strong>获取二进制字节流：</strong> 通过一个类的全限定名来获取定义此类的 <strong>二进制字节流</strong><ol><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流</li><li>从网络中获取，最典型的应用是 Applet</li></ol></li><li><strong> 存储结构转化：</strong> 将这个字节流所代表的 ** 静态存储结构 ** 转化为方法区的 <strong>运行时存储结构</strong></li><li><strong>生成 Class 对象：</strong> 在内存中生成一个代表这个类的 <strong>Class 对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2. 验证"></a>2.2. 验证</h2><p><strong><em>概述：</em></strong> 确保 Class 文件的字节流中包含的信息 <strong>符合当前虚拟机的要求（如 cafe babe）</strong>，并且不会危害虚拟机自身的安全</p><h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3. 准备"></a>2.3. 准备</h2><p><strong><em>概述：</em></strong> 准备阶段为 ** 静态变量 ** 分配内存并 <strong>设置初始值</strong>，使用的是 ** 方法区 ** 的内存</p><ul><li><p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中</p></li><li><p>初始值一般为 0 值，例如下面的静态变量 value 被初始化为 0 而不是 123</p><blockquote><p> public static int value = 123; </p></blockquote></li><li><p>如果静态变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0</p><blockquote><p> public static final int value = 123;</p></blockquote></li></ul><h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4. 解析"></a>2.4. 解析</h2><p><strong><em>概述：</em></strong><br>将常量池的符号引用替换为 <strong>直接引用 <strong>的过程<br>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定<br></strong><em>符号引用：</em></strong> 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中<br><strong><em>直接引用：</em></strong> 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在</p><h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5. 初始化"></a>2.5. 初始化</h2><p><strong><em>概述：</em></strong><br>初始化阶段即虚拟机执行 <strong>类构造器</strong> () 方法的过程<br>初始化阶段才真正开始执行类中定义的 Java 程序代码<br><strong><em>特点：</em></strong></p><ul><li><p><strong>静态初始化：</strong> 编译器自动收集类中所有 静态变量的赋值动作和静态语句块中的语句，由 class 类构造器对 ** 静态变量 <strong>、</strong>静态代码块 ** 进行 ** 初始化 **。编译器收集的顺序由语句在源文件中出现的顺序决定。</p><ul><li>如果一个类中不包含静态语句块，也没有对静态变量有赋值操作，编译器可以不为该类生成 () 方法。</li><li>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>先父后子：</strong> 与类的构造函数（或者说实例构造器 ()）不同，() 不需要显式的调用父类的构造器。<strong>虚拟机会自动保证在子类的 () 方法运行之前</strong>，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。这也意味着父类中定义的 <strong>静态语句块的执行要优先于子类</strong></p></li><li><p><strong>接口：</strong> 执行接口的 () 方法不需要先执行父接口的 () 方法。<strong>只有当父接口中定义的变量使用时</strong>，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法</p></li><li><p><strong>加锁等待：</strong> 如果多个线程同时初始化一个类，只会有 ** 一个线程执行 ** 这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</p></li></ul><h1 id="3-类初始化时机"><a href="#3-类初始化时机" class="headerlink" title="3. 类初始化时机"></a>3. 类初始化时机</h1><h2 id="3-1-主动引用"><a href="#3-1-主动引用" class="headerlink" title="3.1. 主动引用"></a>3.1. 主动引用</h2><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li>当虚拟机启动时，用户需要指定一个要执行的 <strong>入口类</strong>（包含 main () 方法的那个类），虚拟机会先初始化这个主类</li><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：<ul><li>使用 new 关键字实例化对象的时候</li><li>读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li><li>以及调用一个类的静态方法的时候</li></ul></li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要 ** 先触发其父类 ** 的初始化</li><li>使用 java.lang.reflect 包的方法对类进行 ** 反射调用 ** 的时候，如果类没有进行初始化，则需要先触发其初始化</li><li>当使用 JDK 1.7 的 ** 动态语言 ** 支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ul><h2 id="3-2-被动引用"><a href="#3-2-被动引用" class="headerlink" title="3.2. 被动引用"></a>3.2. 被动引用</h2><p>以上 5 种场景中的行为称为对一个类进行主动引用<br>除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li><p>通过子类 <strong>引用父类的静态字段</strong>，不会导致子类初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 字段在 SuperClass 中定义</span></span><br><span class="line">System.out.println(SubClass.value);</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过 <strong>数组定义来引用类</strong>，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></tbody></table></figure></li><li><p>** 常量 ** 在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="4-类与类加载器"><a href="#4-类与类加载器" class="headerlink" title="4. 类与类加载器"></a>4. 类与类加载器</h1><p>两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间<br>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</p><h2 id="4-1-类加载器分类"><a href="#4-1-类加载器分类" class="headerlink" title="4.1. 类加载器分类"></a>4.1. 类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li>** 启动类加载器（Bootstrap ClassLoader）： ** 这个类加载器用 C++ 实现，是虚拟机自身的一部分</li><li><strong>所有其他类的加载器：</strong> 这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader</li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）：</strong><ul><li>此类加载器负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中</li><li>启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可</li></ul></li><li><strong>扩展类加载器（Extension ClassLoader）：</strong><ul><li>这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器</li></ul></li><li><strong>应用程序类加载器（Application ClassLoader）：</strong><ul><li>这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader () 方法的返回值，因此一般称为系统类加载器</li><li>它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul></li></ul><h2 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2. 双亲委派模型"></a>4.2. 双亲委派模型</h2><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器<br>下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）<br>该模型要求除了顶层的启动类加载器外，其余的类加载器都应 <strong>有自己的父类加载器 <strong>。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/de5f150dd562209218479d94c4105e4e.png" alt="image.png"><br></strong><em>工作过程：</em></strong> 一个类加载器首先将类加载请求传送到父类加载器，<strong>只有当父类加载器无法完成类加载请求时才尝试加载</strong><br>** <em>优点：</em>** 使得 Java 类随着它的类加载器一起具有一种带有 <strong>优先级的层次关系</strong>，从而使得基础类得到 <strong>统一</strong></p><ul><li><strong>共享功能：</strong> 可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</li><li><strong>隔离功能：</strong> 主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException 。</li></ul><p><strong><em>例：</em></strong> java.lang.Object 存放在 rt.jar（使用启动类加载器）中，如果编写另外一个 java.lang.Object 的类（应用程序类加载器）并放到 ClassPath 中。<br>由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。<br><strong><em>实现：</em></strong><br>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：<br>先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-3-自定义类加载器实现"><a href="#4-3-自定义类加载器实现" class="headerlink" title="4.3. 自定义类加载器实现"></a>4.3. 自定义类加载器实现</h2><p>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。<br>它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass () 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass () 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass () 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> {</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>new 关键字创建对象的过程：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0f0b824d58ce871b1e380098f87dadb4.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类是在 ** 运行期间第一次使用 ** 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存&lt;/p&gt;
&lt;h1 id=&quot;1-类的生命周期&quot;&gt;&lt;a href=&quot;#1-类的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1. </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://ccomma.cn/27d53953edf2/"/>
    <id>https://ccomma.cn/27d53953edf2/</id>
    <published>2023-03-20T06:45:36.000Z</published>
    <updated>2024-04-01T08:13:04.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-从编码到执行"><a href="#Java-从编码到执行" class="headerlink" title="Java 从编码到执行"></a>Java 从编码到执行</h1><ul><li>-Xmixed：混合模式<ul><li>使用解释器 + 热点代码编译</li><li>起始阶段采用解释执行</li><li>热点代码检测<ul><li>多次被调用的方法（使用 <em>方法计数器</em> 检测方法执行频率）</li><li>多次被调用的循环（使用 <em>循环计数器</em> 检测循环执行频率）</li><li>进行编译</li></ul></li></ul></li><li> -Xint：解释模式，启动快，执行慢</li><li> -Xcomp：编译模式，启动慢，执行快</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7e3de546edf8e39f3f1c842a023a4488.png"></p><h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p>Class 文件实际上是二进制字节流，JVM 定义了一系列规范，用把 Class 文件 “翻译” 成 Class 类</p><blockquote><p>逻辑上划分的数据类型：u1（1 字节）、u2（2 字节）、u4（4 字节）、u8（8 字节）和 _info（表类型）<br>_info 的来源是 hotspot 源码中的写法</p></blockquote><h2 id="1-查看-16-进制字节码"><a href="#1-查看-16-进制字节码" class="headerlink" title="1. 查看 16 进制字节码"></a>1. 查看 16 进制字节码</h2><p>.java 文件使用 javac 命令进行编译后得到 .class 文件<br>可以使用 BinEd（IDEA 插件）查看 .class 文件的 16 进制字节码</p><p><strong>ByteCode 类：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCode</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>对应 .class 文件的编码：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a674107c0061ef04a64e2a055e14be96.png"></p><h2 id="2-Class-文件构成"><a href="#2-Class-文件构成" class="headerlink" title="2. Class 文件构成"></a>2. Class 文件构成</h2><p>使用 JClassLib（IDEA 插件）查看 ByteCode<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e56706305d2071f14ae691dfa66393f6.png"></p><p><strong>classfile 构成：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9c7016ea0849b42824754e2c05d703be.png" alt="image.png"></p><p>对应关系<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/12c42883b5bc0dbef7942aa7513744d8.png"></p><p>常量：</p><ul><li>常量池 #1 号标记： <ul><li>标记位 07（1 字节），表明了常量类型</li><li>索引 00 0e（2 字节），代表指向常量池 #14 号标记</li></ul></li></ul><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类是在 <strong>运行期间第一次使用</strong> 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ae1579b82e4c9a00ebd22d577c5ed5a7.png"></p><p>loadClass () 中实现了双亲委派机制，委托给父加载器去执行，父加载器没找到则会调用自己的 findClass () 去找</p><ul><li>自定义类加载器：重写 findClass () </li><li>打破双亲委派机制：重写 loadClass ()</li></ul><h1 id="内存加载过程"><a href="#内存加载过程" class="headerlink" title="内存加载过程"></a>内存加载过程</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dbb80dce45a2038379a95a181acf60fd.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8c6e173b742392ca93cbb591d6045819.png"></p><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>内存数据放入高速缓存中时是以缓存行的形式放入的，多数情况把内存中连续的 64 字节的数据作为一个缓存行加入高速缓存，不会只单独放入几个字节的数据</p><p><strong>伪共享问题：</strong> 位于同一缓存行的两个不同数据，被两个不同 CPU 锁定，产生互相影响的伪共享问题</p><p>缓存行对齐</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheLinePadding</span> {</span><br><span class="line">    <span class="comment">// 加上 padding，使 arr[0] 和 arr[1] 在两个不同的缓存行中</span></span><br><span class="line">    <span class="comment">// 使运行速度提升</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start) / <span class="number">100_0000</span> + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存锁：</strong> MESI<br><a href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU 缓存一致性协议</a></p><p><strong>总线锁：</strong> 有些无法被缓存的数据或者跨越多个缓存行的数据还是得使用总线锁</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><blockquote><p>验证 <strong>JVM/jmm/Disorder.java</strong><br><a href="https://www.cnblogs.com/liushaodong/p/4777308.html">现代 cpu 的合并写技术对程序的影响</a></p></blockquote><p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，慢 100 倍），去同时执行另一条指令，前提是两条指令没有依赖关系</p><ul><li>读指令的同时可以执行不影响的其他指令 </li><li>写指令的同时可以进行合并写<br>WCBuffers（Write Combining Buffers），只能存放 4 字节的数据。用于写指令合并缓存。 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WriteCombining</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITEMS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayA = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayB = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayC = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayD = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayE = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayF = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseOne</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseTwo</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>如何保证不重排：</strong></p><ul><li>CPU 内存屏障（硬件方面实现）：Inter X86 <ul><li>sfence：在 sfence 指令前的写操作必须在 sfence 指令后的写操作前完成</li><li> lfence：在 lfence 指令前的读操作必须在 lfence 指令后的读操作前完成</li><li> mfence：在 mfence 指令前的写操作必须在 mfence 指令后的读操作前完成</li></ul></li><li> CPU lock 原子汇编指令（硬件方面实现）：Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个 CPU </li><li>JVM 规范（JSR 133）：依赖于硬件实现 <ul><li><p>LoadLoad 屏障：<br>保证读操作 Load1 先于读操作 Load2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure></li><li><p>StoreStore 屏障：<br>保证写操作 Store1 先于写操作 Store2 执行</p></li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure><ul><li><p>LoadStore 屏障：<br>保证读操作 Load1 先于写操作 Store2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure></li><li><p>StoreLoad 屏障：<br>保证写操作 Store1 先于读操作 Load2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="volatile-实现细节"><a href="#volatile-实现细节" class="headerlink" title="volatile 实现细节"></a>volatile 实现细节</h2><ol><li><p>字节码层面：<code>ACC_VOLATILE</code> 编码 </p></li><li><p>JVM 层面： </p></li><li><p>写操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StoreStore 屏障</span><br><span class="line">volatile 写操作</span><br><span class="line">StoreLoad 屏障</span><br></pre></td></tr></tbody></table></figure></li><li><p>读操作 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadLoad 屏障</span><br><span class="line">volatile 读操作</span><br><span class="line">LoadStore 屏障</span><br></pre></td></tr></tbody></table></figure></li><li><p>OS 和硬件层面：<br><a href="https://blog.csdn.net/qq_26222859/article/details/52235930">volatile 与 lock 前缀指令</a></p></li></ol><h2 id="synchronized-实现细节"><a href="#synchronized-实现细节" class="headerlink" title="synchronized 实现细节"></a>synchronized 实现细节</h2><ol><li><p>字节码层面<br>ACC_SYNCHRONIZED </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 加锁</span><br><span class="line">monitorenter</span><br><span class="line">...</span><br><span class="line">; 释放锁</span><br><span class="line">monitorexit</span><br><span class="line">...</span><br><span class="line">; 异常后释放锁</span><br><span class="line">monitorexit</span><br></pre></td></tr></tbody></table></figure></li><li><p>JVM 层面<br>C C++ 调用了操作系统提供的同步机制 </p></li><li><p>OS 和硬件层面<br>X86 : lock cmpxchg / xxx<br><a href="https://blog.csdn.net/21aspnet/article/details/88571740">Java 使用字节码和汇编语言同步分析 volatile，synchronized 的底层实现</a></p></li></ol><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8e9b9db2bd428ecd3e1e8c1b2b173d4e.png"></p><h1 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h1><p>关于对象面试题：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/73a0bb354657280d028c0005ede1125f.png"></p><h2 id="对象大小（64位机）"><a href="#对象大小（64位机）" class="headerlink" title="对象大小（64位机）"></a>对象大小（64 位机）</h2><h3 id="观察虚拟机配置"><a href="#观察虚拟机配置" class="headerlink" title="观察虚拟机配置"></a>观察虚拟机配置</h3><p>java -XX:+PrintCommandLineFlags -version<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a0d446091f82ab3ceb874f33de885a69.png"></p><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><ol><li>对象头：markword &nbsp;8 字节</li><li> ClassPointer 指针：-XX:+UseCompressedClassPointers 压缩打开为 4 字节，不开启为 8 字节</li><li>实例数据 <ol><li>引用类型：-XX:+UseCompressedOops 为 4 字节 不开启为 8 字节<br>Oops Ordinary Object Pointers</li></ol></li><li>Padding 对齐，8 的倍数</li></ol><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><ol><li>对象头：markword 8 字节</li><li> ClassPointer 指针同上</li><li>数组长度：4 字节</li><li>数组数据</li><li>对齐 8 的倍数</li></ol><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.jvm.agent.ObjectSizeAgent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -XX:+UseCompressedClassPointers：类型指针压缩</span></span><br><span class="line"><span class="comment">// -XX:+UseCompressedOops：对象引用指针压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T03_SizeOfAnObject</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">Object</span>())); <span class="comment">// 16=8+4+4(补齐)</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">int</span>[] {})); <span class="comment">// 16=8+4+4</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">P</span>()));      <span class="comment">// 32</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P</span> {</span><br><span class="line">        <span class="comment">//8 _markword</span></span><br><span class="line">        <span class="comment">//4 _class pointer -XX:+UseCompressedClassPointers</span></span><br><span class="line">        <span class="type">int</span> id;         <span class="comment">//4</span></span><br><span class="line">        String name;    <span class="comment">//4 _oops pointer -XX:+UseCompressedOops</span></span><br><span class="line">        <span class="type">int</span> age;        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> b1;        <span class="comment">//1</span></span><br><span class="line">        <span class="type">byte</span> b2;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        Object o;       <span class="comment">//4</span></span><br><span class="line">        <span class="type">byte</span> b3;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/29bb86a6e6a00811b70fbb320972c200.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1725fefe349ee3b824ed3ac303df63e.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d91d2c4aa4efc43bf1c527817e9379ee.png"></p><h2 id="IdentityHashCode"><a href="#IdentityHashCode" class="headerlink" title="IdentityHashCode"></a>IdentityHashCode</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3191ffe79b85e1818e79653a761dbb7.png"></p><p><a href="https://cloud.tencent.com/developer/article/1480590">死磕 Synchronized 底层实现，面试你还怕什么？</a><br><a href="https://cloud.tencent.com/developer/article/1484167">面试题深入解析：Synchronized 底层实现</a><br><a href="https://cloud.tencent.com/developer/article/1485795">死磕 Synchronized 底层实现 – 重量级锁</a><br><a href="https://cloud.tencent.com/developer/article/1482500">一文让你读懂 Synchronized 底层实现，秒杀面试官</a></p><h2 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h2><p><a href="https://blog.csdn.net/clover_lily/article/details/80095580">访问对象两种方式 – 句柄和直接指针</a></p><ol><li>句柄池</li><li>直接指针</li></ol><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。<br><strong>作用：</strong> 缓存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>// ===== 软引用测试（-Xms:20M -Xmx20M） =====</p><p>SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024<em>1024</em>10]);<br>System.out.println(m.get());</p><p>// 再分配一个数组，heap 将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉<br>byte[] b = new byte[1024<em>1024</em>15];<br>System.out.println(m.get()); // null</p></blockquote><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p><strong>作用：</strong> 一般用在容器里。强引用和弱引用同时指向某个对象，当强引用不再指向该对象时，该对象就该被回收</p><p>例：ThreadLocal 对象 new 后有强引用，而当前线程中的 ThreadLocalMap 对象的键也有 ThreadLocal 对象的弱引用，所以当 ThreadLocal 对象失去强引用时 ThreadLocalMap 中对应的键也会变为 null，防止了内存泄露。虽然 ThreadLocalMap 的键为 null 了，但是其 value 值还存在所以依然会有内存泄露，所以需要执行 ThreadLocal#remove 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>WeakReference<m> m = new WeakReference&lt;&gt;(new M());</m></p><p>System.out.println(m.get());<br>System.gc();<br>System.out.println(m.get()); // null</p><p>ThreadLocal<m> tl = new ThreadLocal&lt;&gt;();<br>tl.set(new M());<br>tl.remove();</m></p></blockquote><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p><em>作用：</em></p><ul><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 </li><li>管理堆外内存（通常给编写 JVM 的人使用）：DirectByteBuffer 对象指向堆外内存。当 DirectByteBuffer 被回收时，可以通过队列检测到，然后清理堆外内存 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联了对象和队列</span></span><br><span class="line"><span class="comment">// 当对象被回收引用会放入队列中</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line"><span class="comment">// 不能通过 get() 拿到里面的值</span></span><br><span class="line">pf.get();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对象被回收后，通过 poll() 方法可以拿出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; poll = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (poll != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"--- 虚引用对象被jvm回收了 ---- "</span> + poll);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="JVM-组成"><a href="#JVM-组成" class="headerlink" title="JVM 组成"></a>JVM 组成</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7f8078dc240be61d59fbabe554422f76.png"></p><p><strong>JVM 的结构基本上由 4 部分组成：</strong></p><ul><li>_类加载器：_在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</li><li>_运行时数据区：_将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块</li><li><strong>执行引擎：</strong>执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</li><li><strong> 本地方法调用：</strong>调用 C 或 C++ 实现的本地方法的代码返回结果</li></ul><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0a3771f5524d1ecef45ba10c2518dfe5.png"></p><h2 id="PC-程序计数器"><a href="#PC-程序计数器" class="headerlink" title="PC 程序计数器"></a>PC 程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）<br>用于存放指令位置<br>虚拟机的运行，类似于这样的循环：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (not end) {</span><br><span class="line"></span><br><span class="line">取 PC 中的位置，找到对应位置的指令；</span><br><span class="line"></span><br><span class="line">执行该指令；</span><br><span class="line"></span><br><span class="line">PC ++;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a href="https://blog.csdn.net/jt781861965/article/details/114957201?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">变量定义在 for 循环外面还是里面</a></li></ul><p>Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息<br>从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p><p><strong>栈结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4ad59ef5e3736678f5da98683650a3db.png"></p><p>Frame：每个方法对应一个栈帧</p><ol><li>Local Variable Table </li><li>Operand Stack<br>对于 long 的处理（store and load），多数虚拟机的实现都是原子的<br>jls 17.7，没必要加 volatile </li><li>Dynamic Linking<br><a href="https://blog.csdn.net/qq_41813060/article/details/88379473">java Dynamic Linking</a><br>jvms 2.6.3 </li><li>return address<br>a () -&gt; b ()，方法 a 调用了方法 b，b 方法的返回值放在什么地方</li></ol><p>例：<code>i = i++;</code> 的栈实现</p><p><strong>常用字节码指令：</strong><br>store、load、pop、mul、sub<br>invoke：</p><ol><li>InvokeStatic：调用静态方法</li><li> InvokeVirtual：普通方法，自带多态</li><li> InvokeInterface：调用接口的方法</li><li> InovkeSpecial：<br>可以直接定位，不需要多态的方法<br>private 方法 ， 构造方法</li><li> InvokeDynamic：<br>lambda 表达式或者反射或者其他动态语言 scala kotlin，或者 CGLib ASM，动态产生的 class，会用到的指令</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>所有对象都在这里分配内存</strong>，是垃圾收集的主要区域<br>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常</p><p>堆是所有 <strong>线程共享</strong> 的<br>默认新生代：老年代 = 1 : 2</p><h3 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h3><p>分为 伊甸园（Edne）和两个 幸存区（Survival），默认比例为 Eden：from：to = 8：1：1，保证了内存的利用率达到 90%</p><p><strong>Eden：</strong></p><ul><li><strong>线程共享：</strong> 由于堆是所有线程共享的，因此在堆上分配内存 <strong>需要加锁</strong> </li><li><strong> TLAB：</strong> 为提升效率，每个新建的线程在 Eden 上分配了一块独立的空间由该线程独享，这块空间称为 <strong>TLAB</strong>（Thread Local Allocation Buffer） </li><li>在 TLAB 上分配内存 <strong>不需要加锁</strong>，因此 JVM 在给线程中的对象分配内存时会尽量在 TLAB 上分配 <ul><li>如果对象过大或 TLAB 用完，则仍然在堆上进行分配。如果 Eden 区内存也用完了，则会进行一次 Minor GC（young GC）</li></ul></li></ul><p><strong>Survival（from &amp; to）：</strong><br><a href="https://www.jianshu.com/p/989d3b06a49d">jvm 误区 – 动态对象年龄判定</a></p><ul><li>在发生 Minor GC 时，Eden 区和 Survival from 区会把一些仍然存活的对象复制进 Survival to 区，并清除内存 <ul><li>将此时在 Survivor to 区存活下来的对象的年龄设置为 1，以后这些对象每在 Survivor 区熬过一次 GC，它们的年龄就加 1，当对象年龄达到某个年龄（默认值为 15）时，就会把它们移到老年代中<br><strong>调整年龄：</strong> -XX:MaxTenuringThreshold<br><strong>默认年龄：</strong> <ul><li>·Parallel Scavenge 15</li><li>CMS 6</li><li>G1 15</li></ul></li><li>s1 -&gt; s2 超过 50%：把年龄最大的放入老年代</li></ul></li><li>在发生一次 Minor GC 后，from 区就会和 to 区互换</li></ul><p><strong>分配担保：</strong><br><a href="https://cloud.tencent.com/developer/article/1082730">JVM 内存分配担保机制</a><br>如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p><h3 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><p>年老代里存放的都是存活时间较久的，大小较大的对象。<br><strong>Full GC：</strong> 当年老代容量满的时候，会触发一次 Major GC（Full GC），回收年老代和年轻代中不再被使用的对象资源</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p><strong>垃圾回收：</strong> 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p><strong>永久代（PermSpace）：</strong><br>JDK &lt; 1.8<br>方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是 Hotspot 虚拟机对其的一种实现。</p><p>永久代的大小受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变</p><ul><li>字符串常量位于 PermSpace</li><li>FGC 不会清理</li><li>大小启动的时候指定，不能变</li></ul><p><strong>元空间（MetaSpace）：</strong><br>JDK &gt;= 1.8</p><ul><li>移除永久代，并把方法区移至元空间（位于本地内存中，而不是虚拟机内存中）</li><li>字符串常量存放到堆内存中</li><li>会触发 FGC 清理</li><li>元空间大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><strong>栈上分配：</strong> 无需手动调整<ul><li>线程私有小对象</li><li>无逃逸</li><li>支持标量替换</li></ul></li><li><strong>线程本地分配 TLAB（Thread Local Allocation Buffer）：</strong> 无需手动调整</li></ol><ul><li>占用 Eden，默认 1%</li><li> 多线程的时候不用竞争 Eden 就可以申请空间，提高效率</li><li>小对象</li></ul><ol start="3"><li><strong>大对象直接进入老年代：</strong></li></ol><ul><li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</li><li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</li><li> XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制</li></ul><ol start="4"><li><strong>对象优先在 Eden 分配：</strong> 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC </li><li><strong>长期存活的对象进入老年代：</strong> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中 </li><li><strong>空间分配担保：</strong></li></ol><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的 </li><li>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败 <ul><li>如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li><li>如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</li></ul></li></ul><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><ul><li><strong>调用 System.gc ()：</strong> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存 </li><li><strong>老年代空间不足：</strong> <ul><li>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</li><li>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li></ul></li><li><strong>空间分配担保失败：</strong> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC </li><li><strong>JDK 1.7 及以前的永久代空间不足：</strong> <ul><li>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</li><li>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</li></ul></li><li><strong>Concurrent Mode Failure：</strong> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li></ul><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p><a href="https://my.oschina.net/wenbo123/blog/1822414">深入学习 JVM-JVM 安全点和安全区域</a><br>垃圾收集主要是针对 <strong>堆</strong> 和 <strong>方法区</strong> 进行<br>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收</p><blockquote><p>简历：熟悉 GC 常用算法，熟悉常见垃圾回收器，具有实际 JVM 调优实战经验</p></blockquote><h2 id="1-定位垃圾"><a href="#1-定位垃圾" class="headerlink" title="1. 定位垃圾"></a>1. 定位垃圾</h2><h3 id="引用计数算法（ReferenceCount）"><a href="#引用计数算法（ReferenceCount）" class="headerlink" title="引用计数算法（ReferenceCount）"></a>引用计数算法（ReferenceCount）</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p><strong>缺点：</strong> 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。<br>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可达性分析算法（RootSearching）"><a href="#可达性分析算法（RootSearching）" class="headerlink" title="可达性分析算法（RootSearching）"></a>可达性分析算法（RootSearching）</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ce3e51425ea1c0e8ec7df5ea77b23b5d.png"></p><p><strong>GC Roots 一般包含以下内容：</strong></p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h2 id="2-常见的垃圾回收算法"><a href="#2-常见的垃圾回收算法" class="headerlink" title="2. 常见的垃圾回收算法"></a>2. 常见的垃圾回收算法</h2><h3 id="2-1-标记清除（mark-sweep）："><a href="#2-1-标记清除（mark-sweep）：" class="headerlink" title="2.1. 标记清除（mark sweep）："></a>2.1. 标记清除（mark sweep）：</h3><p>将存活的对象进行标记，然后清理掉未被标记的对象<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d0c48c5f7e1089ce05031c847478e918.png"></p><p><strong>扫描两次：</strong></p><ol><li>一次扫描先标记存活对象</li><li>再一次扫描清除未被标记对象</li></ol><p><strong>缺点：</strong> 扫描两次，位置不连续，产生碎片<br>存活对象比较多的情况下效率较高</p><h3 id="2-2-拷贝算法（copying）"><a href="#2-2-拷贝算法（copying）" class="headerlink" title="2.2. 拷贝算法（copying）"></a>2.2. 拷贝算法（copying）</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/31f6dcd971788dc021c5aaf4f67f99bc.png"></p><p>缺点：需移动对象，浪费空间<br>优点：扫描一次，没有碎片<br>适用于存活对象比较少的情况</p><h3 id="2-3-标记压缩（mark-compact）"><a href="#2-3-标记压缩（mark-compact）" class="headerlink" title="2.3. 标记压缩（mark compact）"></a>2.3. 标记压缩（mark compact）</h3><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/012b5391c527342861d9f55c59a907f7.png"></p><p>缺点：扫描两次，需移动对象，效率低下<br>优点：没有碎片，方便对象分配，不会产生内存减半</p><h3 id="2-4-分代收集"><a href="#2-4-分代收集" class="headerlink" title="2.4. 分代收集"></a>2.4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p><ul><li><strong>新生代使用：</strong> 复制算法</li><li><strong>老年代使用：</strong> <em>标记 - 清除</em> 或者 <em>标记 - 整理</em> 算法</li></ul><blockquote><p>除 Epsilon ZGC Shenandoah 之外的 GC 都是使用逻辑分代模型<br>G1 是逻辑分代，物理不分代<br>除此之外的不仅逻辑分代，而且物理分代</p></blockquote><h2 id="3-常见的垃圾回收器"><a href="#3-常见的垃圾回收器" class="headerlink" title="3. 常见的垃圾回收器"></a>3. 常见的垃圾回收器</h2><p><strong>Card Table</strong><br>由于做 YGC 时，需要扫描整个 OLD 区，效率非常低，所以 JVM 设计了 CardTable， 如果一个 OLD 区 CardTable 中有对象指向 Y 区，就将它设为 Dirty，下次扫描时，只需要扫描 Dirty Card<br>在结构上，Card Table 用 BitMap 来实现</p><p><strong>垃圾回收器：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/aaa5c8687b39ad7fb3ccca97c2bfaa87.png"></p><p>连线表示垃圾收集器可以配合使用</p><p><strong>垃圾收集器跟内存大小的关系：</strong></p><ol><li>Serial 几十兆</li><li> PS 上百兆 - 几个 G</li><li>CMS - 20G</li><li>G1 - 上百 G</li><li>ZGC - 4T - 16T（JDK13）</li></ol><p><strong>STW：</strong> stop the world。指 GC 中让用户线程全部暂停而产生的停顿。任何一个垃圾回收器都有 STW，减少 STW 能提升用户响应时间，但也会减少吞吐量。</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9fa3d91b3a2dcc7a97df297037107732.png"><br>用于收集年轻代垃圾的收集器，只会使用 <strong>一个 GC 线程</strong> 进行垃圾收集工作。</p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4c4ea9f436123e32405a3d5968b8b25f.png"></p><p>用于收集年轻代垃圾的收集器，使用多个 GC 线程收集垃圾</p><p>关注吞吐量，目标是 <strong>达到一个可控制的吞吐量</strong>，它被称为 “吞吐量优先” 收集器</p><ul><li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</li></ul><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>用于收集年轻代垃圾的收集器。新版本的 Parallel Scavenge，与其相比做了增强以便能与 CMS 配合使用</p><p><a href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p><ul><li>ParNew 响应时间优先（配合 CMS）</li><li>Parallel Scavenge 吞吐量优先</li></ul><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>用于收集老年代垃圾的收集器。Serial 收集器的老年代版本。</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用（效率低下）</li></ul><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>用于收集老年代垃圾的收集器。Parallel Scavenge 收集器的老年代版本。</p><h3 id="ConcurrentMarkSweep"><a href="#ConcurrentMarkSweep" class="headerlink" title="ConcurrentMarkSweep"></a>ConcurrentMarkSweep</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1796989f83d1e64eddebc8f83871fcea.png"></p><p>用于收集老年代垃圾的收集器。垃圾回收和应用程序同时运行，降低 STW 的时间。</p><p><strong>流程：</strong><br>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p><ol><li><strong>初始标记：</strong> 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</li><li><strong>并发标记：</strong> 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿</li><li><strong>重新标记：</strong> 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li><li><strong>并发清除：</strong> 不需要停顿</li></ol><p><strong>CMS 的问题：</strong><br>CMS 问题比较多，所以现在没有一个版本默认是 CMS，只能手工指定<br>CMS 既然是 MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS 的老年代分配对象分配不下的时候，使用 SerialOld 进行老年代回收</p><ul><li><em>吞吐量低：</em> 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高 </li><li><em>无法处理浮动垃圾：</em> </li><li><ul><li><em>浮动垃圾：</em> 指并发清除阶段由于用户线程继续运行而产生的垃圾。这部分垃圾只能到下一次 GC 时才能进行回收 </li><li><em>需预留内存：</em> 由于浮动垃圾的存在，因此需要预留出一部分内存。这意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收 </li><li><em>Concurrent Mode Failure：</em> 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS </li><li>解决方案：<br>降低触发 CMS 的阈值<br>–XX:CMSInitiatingOccupancyFraction 92%：内存打到 92% 时才会触发 CMS。可以降低这个值，让 CMS 保持老年代足够的空间</li></ul></li><li><em>空间碎片：</em> 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为 0 指的是经过多少次 FGC 才进行压缩</li></ul><p>算法：三色标记 + Incremental Update</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>特点：</strong></p><ul><li>并发收集</li><li>压缩空间，不会延长 GC 的暂停时间</li><li>更容易预测 GC 的暂停时间</li><li>适用不需要实现很高吞吐量的场景</li><li>每个内存区域不是固定的，可能这次存放新生代下次就存放老年代了</li><li>新老年代比例： 5%-60%。不用手工指定，G1 以此作为预测停顿时间的基准</li></ul><p>Edne、Survivor、Old、Humongous（超过单个 Region 的 50%）<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/52d4d0716d23c88b12178ad78e59253b.png"></p><p><strong>CSet（Collection Set）：</strong></p><ul><li>一组可被回收的分区的集合 </li><li>在 CSet 中存活的数据会在 GC 过程中被移动到另一个可用分区 </li><li>CSet 中的分区可以来自 Eden 空间、Survivor 空间或老年代 </li><li>CSet 占用不到整个堆空间的 1% 大小</li></ul><p><strong>RSet（Remembered Set）：</strong></p><ul><li>是一块存放在 Region 内部的 Map，记录了其他 Region 中的对象到本 Region 的引用</li><li>使垃圾回收器不用去扫描整个堆来获取引用了当前分区的对象，只需要扫描 RSet 即可</li></ul><p><strong>当对象无法分配时也会产生 FullGC，如何解决：</strong></p><ul><li>扩内存 </li><li>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大） </li><li>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是 45%） <blockquote><p>MixedGC：类似 CMS<br>XX:InitiatingHeapOccupacyPercent</p><ul><li>默认值 45%</li><li> 当分配堆空间超过这个值，启动 MixedGC</li></ul></blockquote></li></ul><p>算法：三色标记 + SATB<br><strong>三色标记：</strong></p><ul><li>黑色：自身和成员变量均已标记完成</li><li>灰色：自身被标记，成员变量未被标记</li><li>白色：未被标记的对象</li></ul><p><strong>漏标：</strong><br>当一个黑色的对象引用了一个白色对象，且这个白色对象只被这个黑色对象引用时会漏标<br>该白色对象已无法被遍历到了</p><p><strong>解决漏标的方案：</strong></p><ul><li>Incremental update：关注引用的增加。黑色的对象引用白色对象时把黑色对象重新标记为灰色，下次重新扫描属性，CMS 使用</li><li> SATB（snapshot at the beginning）：关注引用的删除。当引用消失时把这个引用推到 GC 的堆栈，保证引用的对象还能被 GC 扫描到。</li></ul><p>G1 使用 SATB，Incremental update 把黑色对象变为灰色对象后，后续还得对其成员变量进行扫描，效率不高。<br>SATB 配合 RSet 判断记录的白色对象是否为漏标对象<br><a href="https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html">垃圾优先型垃圾回收器调优</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>ZGC (1ms) PK C++<br>算法：ColoredPointers + LoadBarrier </li><li>Shenandoah<br>算法：ColoredPointers + WriteBarrier </li><li>Epsilon</li></ol><h2 id="4-常见垃圾回收器组合"><a href="#4-常见垃圾回收器组合" class="headerlink" title="4. 常见垃圾回收器组合"></a>4. 常见垃圾回收器组合</h2><ul><li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old：小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器 </p></li><li><p>-XX:+UseParNewGC = ParNew + SerialOld：这个组合已经很少用（在某些版本中已经废弃） </p><blockquote><p><a href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future">Why Remove support for ParNew+SerialOld andDefNew+CMS in the future？</a></p></blockquote></li><li><p>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old </p></li><li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8 默认) 【PS + SerialOld】 </p></li><li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old </p></li><li><p>-XX:+UseG1GC = G1</p></li></ul><p>Linux 中没找到默认 GC 的查看方法，而 windows 中会打印 UseParallelGC</p><ul><li>java +XX:+PrintCommandLineFlags -version</li><li> 通过 GC 的日志来分辨</li></ul><h1 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h1><h2 id="PS-GC-日志详解"><a href="#PS-GC-日志详解" class="headerlink" title="PS GC 日志详解"></a>PS GC 日志详解</h2><p>PS 日志格式：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6e30320b5571257235fcd22548c61a4c.png"></p><p>heap dump 部分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)</span><br><span class="line">                            后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/18373e80319f93e9ddf9a0b988cc032b.png"></p><h2 id="CMS-日志分析"><a href="#CMS-日志分析" class="headerlink" title="CMS 日志分析"></a>CMS 日志分析</h2><p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p><p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</p><blockquote><p>ParNew：年轻代收集器<br>6144-&gt;640：收集前后的对比<br>（6144）：整个年轻代容量<br>6585 -&gt; 2770：整个堆的情况<br>（19840）：整个堆大小</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: 8511K(13696K)] 9866K(19840K), <span class="number">0.0040321</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line"><span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.018</span>/<span class="number">0.018</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line"><span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: <span class="number">1597</span> K (<span class="number">6144</span> K)][Rescan (parallel) , <span class="number">0.0008396</span> secs][weak refs processing, <span class="number">0.0000138</span> secs][<span class="keyword">class</span> <span class="title class_">unloading</span>, <span class="number">0.0005404</span> secs][scrub symbol table, <span class="number">0.0006169</span> secs][scrub string table, <span class="number">0.0004903</span> secs][<span class="number">1</span> CMS-remark: 8511K(13696K)] 10108K(19840K), <span class="number">0.0039567</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line"><span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line"><span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line"><span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line"><span class="comment">//scrub symbol(string) table: </span></span><br><span class="line"><span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line"><span class="comment">//internalized string respectively</span></span><br><span class="line"><span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line"><span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.005</span>/<span class="number">0.005</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"><span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></tbody></table></figure><h2 id="G1-日志详解"><a href="#G1-日志详解" class="headerlink" title="G1 日志详解"></a>G1 日志详解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="title function_">pause</span> <span class="params">(G1 Evacuation Pause)</span> (young) (initial-mark), <span class="number">0.0015790</span> secs]</span><br><span class="line"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span><br><span class="line"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span><br><span class="line">   [Parallel Time: <span class="number">1.5</span> ms, GC Workers: <span class="number">1</span>] <span class="comment">//一个GC线程</span></span><br><span class="line">      [GC Worker <span class="title function_">Start</span> <span class="params">(ms)</span>:  <span class="number">92635.7</span>]</span><br><span class="line">      [Ext Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">1.1</span>]</span><br><span class="line">      [Update <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">         [Processed Buffers:  <span class="number">1</span>]</span><br><span class="line">      [Scan <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Code Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="title function_">Copy</span> <span class="params">(ms)</span>:  <span class="number">0.1</span>]</span><br><span class="line">      [Termination (ms):  <span class="number">0.0</span>]</span><br><span class="line">         [Termination Attempts:  <span class="number">1</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Other</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Total</span> <span class="params">(ms)</span>:  <span class="number">1.2</span>]</span><br><span class="line">      [GC Worker <span class="title function_">End</span> <span class="params">(ms)</span>:  <span class="number">92636.9</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.0</span> ms]</span><br><span class="line">   [Other: <span class="number">0.1</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Proc: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [Free CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)]</span><br><span class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法 evacuation，进行 FGC</span></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18M(20M), <span class="number">0.0719656</span> secs]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)], [Metaspace: <span class="number">38</span></span><br><span class="line">76K-&gt;3876K(1056768K)] [Times: user=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></tbody></table></figure><h1 id="GC-调优"><a href="#GC-调优" class="headerlink" title="GC 调优"></a>GC 调优</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol><li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li><li>响应时间：STW 越短，响应时间越好</li></ol><p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p><p>问题：<br>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p><p>响应时间：网站 GUI API （1.8 G1）</p><p><strong>什么是调优？</strong></p><ol><li>根据需求进行 JVM 规划和预调优</li><li>优化运行 JVM 运行环境（慢，卡顿）</li><li>解决 JVM 运行过程中出现的各种问题（OOM）</li></ol><h2 id="调优规划"><a href="#调优规划" class="headerlink" title="调优规划"></a>调优规划</h2><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓 </p></li><li><p>监控（压力测试，能看到结果） </p></li><li><p>步骤： </p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） <ol><li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li><li>吞吐量 = 用户时间 /(用户时间 + GC 时间) [PS]</li></ol></li><li> 选择回收器组合</li><li>计算内存需求（经验值 1.5G 16G）</li><li>选定 CPU（越高越好）</li><li>设定年代大小、升级年龄</li><li>设定日志参数 <ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li><li> 或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li><li><p>案例 1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？ </p><blockquote><p>这个问题比较业余，因为很多不同的服务器配置都能支撑（1.5G 16G）<br>1 小时 360000 集中时间段， 100 个订单 / 秒，（找一小时内的高峰期，1000 订单 / 秒）<br>经验值，<br>非要计算：一个订单产生需要多少内存？512K * 1000 500M 内存<br>专业一点儿问法：要求响应时间 100ms<br>压测！</p></blockquote></li><li><p>案例 2：12306 遭遇春节大规模抢票应该如何支撑？ </p><blockquote><p>12306 应该是中国并发量最大的秒杀网站：<br>号称并发量 100W 最高<br> CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发（10K 问题） 100 台机器<br>普通电商订单 -&gt; 下单 -&gt; 订单系统（IO）减库存 -&gt; 等待用户付款<br>12306 的一种可能的模型： 下单 -&gt; 减库存 和 订单 (redis kafka) 同时异步进行 -&gt; 等付款<br>减库存最后还会把压力压到一台服务器<br>可以做分布式本地库存 + 单独服务器做库存均衡<br>大流量的处理方法：分而治之</p></blockquote></li><li><p>怎么得到一个事务会消耗多少内存？ </p><blockquote><ol><li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到 </li><li>用压测来确定</li></ol></blockquote></li></ul><h2 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h2><ol><li>有一个 50 万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G<br>的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为 64 位，16G<br>的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了 <ol><li>为什么原网站慢？<br>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间变慢</li><li>为什么会更卡顿？<br>内存越大，FGC 时间越长</li><li>解决方案：PS -&gt; PN + CMS 或者 G1</li></ol></li><li> 系统 CPU 经常 100%，如何调优？(面试高频)<br>CPU 100% 那么一定有线程在占用系统资源， <ol><li>找出哪个进程 cpu 高（top）</li><li>该进程中的哪个线程 cpu 高（top -Hp）</li><li>导出该线程的堆栈（jstack）</li><li>查找哪个方法（栈帧）消耗时间（jstack）</li><li>工作线程占比高 | 垃圾回收线程占比高</li></ol></li><li>系统内存飙高，如何查找问题？（面试高频） <ol><li>导出堆内存（jmap）</li><li>分析（jhat jvisualvm mat jprofiler … ）</li></ol></li><li>如何监控 JVM <ol><li>jstat jvisualvm jprofiler arthas top…</li></ol></li></ol><h2 id="解决-JVM-运行中的问题"><a href="#解决-JVM-运行中的问题" class="headerlink" title="解决 JVM 运行中的问题"></a>解决 JVM 运行中的问题</h2><h3 id="一个案例理解常用工具"><a href="#一个案例理解常用工具" class="headerlink" title="一个案例理解常用工具"></a>一个案例理解常用工具</h3><ol><li><p>测试代码： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T15_FullGC_Problem01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CardInfo</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"张三"</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">50</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;){</span><br><span class="line">            modelFit();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modelFit</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">        taskList.forEach(info -&gt; {</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            executor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">                <span class="comment">//do sth with info</span></span><br><span class="line">                info.m();</span><br><span class="line"></span><br><span class="line">            }, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title function_">getAllCardInfo</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="type">CardInfo</span> <span class="variable">ci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardInfo</span>();</span><br><span class="line">            taskList.add(ci);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01 </p></li><li><p>运维团队首先受到报警信息（CPU Memory） </p></li><li><p>top 命令观察到问题：内存不断增长 CPU 占用率居高不下 </p></li><li><p>top -Hp 观察进程中的线程，哪个线程 CPU 和内存占比高 </p></li><li><p>jps 定位具体 java 进程<br>jstack 定位线程状况，重点关注：WAITING BLOCKED<br>eg.<br>waiting on &lt;0x0000000088ca3310&gt; （a java.lang.Object）<br>假如有一个进程中 100 个线程，很多线程都在 waiting on <xx> ，一定要找到是哪个线程持有这把锁<br>怎么找？搜索 jstack dump 的信息，找<xx> ，看哪个线程持有这把锁 RUNNABLE </xx></xx></p></li><li><p>线程的名称（尤其是线程池）都要写有意义的名称 </p></li><li><p>jinfo pid </p></li><li><p>jstat -gc 动态观察 gc 情况 / 阅读 GC 日志发现频繁 GC /arthas 观察 /jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个 500 个毫秒打印 GC 的情况<br>如果面试官问你是怎么定位 OOM 问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmdline arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察） </p></li><li><p>jmap - histo 4655 | head -20，查找有多少对象产生 </p></li><li><p>jmap -dump:format=b,file=xxx pid ：<br>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<br>1：设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件<br>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响<br>3：在线定位（一般小点儿公司用不到） </p></li><li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01 </p></li><li><p>使用 MAT /jhat/jvisualvm 进行 dump 文件分析<br><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html">java 命令 –jhat 命令使用</a><br>jhat -J-mx512M xxx.dump<br><a href="http://192.168.17.11:7000/">http://192.168.17.11:7000</a><br>拉到最后：找到对应链接<br>可以使用 OQL 查找特定问题对象 </p></li><li><p>找到代码的问题</p></li></ol><h3 id="jconsole-远程连接"><a href="#jconsole-远程连接" class="headerlink" title="jconsole 远程连接"></a>jconsole 远程连接</h3><ol><li><p>程序启动加入参数： </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果遭遇 Local host name unknown：XXX 的错误，修改 /etc/hosts 文件，把 XXX 加入进去 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.17</span><span class="number">.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></tbody></table></figure></li><li><p>关闭 linux 防火墙（实战中应该打开对应端口） </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></tbody></table></figure></li><li><p>windows 上打开 jconsole 远程连接 192.168.17.11:11111</p></li></ol><h3 id="jvisualvm-远程连接"><a href="#jvisualvm-远程连接" class="headerlink" title="jvisualvm 远程连接"></a>jvisualvm 远程连接</h3><p>简单做法：<a href="https://www.cnblogs.com/liugh/p/7620336.html">使用 jvisualvm 的 jstatd 方式远程监控 Java 程序</a></p><h3 id="jprofiler（收费）"><a href="#jprofiler（收费）" class="headerlink" title="jprofiler（收费）"></a>jprofiler（收费）</h3><h3 id="arthas-在线排查工具"><a href="#arthas-在线排查工具" class="headerlink" title="arthas 在线排查工具"></a>arthas 在线排查工具</h3><ul><li>为什么需要在线排查？<br>在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的 threaddump 或者 heapdump 不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li><li>jvm 观察 jvm 信息</li><li> thread &nbsp;定位线程问题</li><li> dashboard 观察系统情况</li><li> heapdump + jhat 分析</li><li> jad 反编译<br>动态代理生成类的问题定位<br>第三方的类（观察代码）<br>版本问题（确定自己最新提交的版本是不是被使用）</li><li>redefine 热替换<br>目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性<br>m() -&gt; mm()</li><li>sc &nbsp;- search class</li><li>watch &nbsp;- watch method</li><li> 没有包含的功能：jmap</li></ul><h3 id="产生原因案例"><a href="#产生原因案例" class="headerlink" title="产生原因案例"></a>产生原因案例</h3><p>OOM 产生的原因多种多样，有些程序未必产生 OOM，不断 FGC（CPU 飙高，但内存回收特别少）（上面案例）</p><ol><li><p>硬件升级系统反而卡顿的问题（见上） </p></li><li><p>线程池不当运用产生 OOM 问题（见上）<br>不断的往 List 里加对象（实在太 LOW） </p></li><li><p>jira 问题<br>实际生产参数案例： </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xms9216m -Xmx9216m </span><br><span class="line">-XX:-OmitStackTraceInFastThrow </span><br><span class="line">-Xloggc:/opt/xxx/logs/xxx-gc-%t.log </span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br><span class="line">-XX:GCLogFileSize=20M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCCause -classpath /opt/xxx/bin/...jar</span><br></pre></td></tr></tbody></table></figure><p><br>实际系统不断重启<br>解决问题 加内存 + 更换垃圾回收器 G1<br>真正问题在哪儿？不知道 </p></li><li><p>tomcat http-header-size 过大问题（Hector） </p></li><li><p>lambda 表达式导致方法区溢出问题（MethodArea / Perm Metaspace）<br>LambdaGC.java &nbsp; &nbsp; -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails <span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">"C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar"</span> com.mashibing.jvm.gc.LambdaGC</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 11341K-&gt;1880K(38400K)] 11341K-&gt;1888K(125952K), <span class="number">0.0022190</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 1880K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;1777K(35328K)] 1888K-&gt;1777K(73728K), [Metaspace: 8164K-&gt;8164K(1056768K)], <span class="number">0.0100681</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(38400K)] 1777K-&gt;1777K(73728K), <span class="number">0.0005698</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Last ditch collection)</span> [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 1777K-&gt;1629K(67584K)] 1777K-&gt;1629K(105984K), [Metaspace: 8164K-&gt;8156K(1056768K)], <span class="number">0.0124299</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:<span class="number">388</span>)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:<span class="number">411</span>)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">at sun.misc.Unsafe.defineClass(Native Method)</span><br><span class="line">at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:<span class="number">63</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">399</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">394</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:<span class="number">393</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:<span class="number">112</span>)</span><br><span class="line">at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:<span class="number">398</span>)</span><br><span class="line">at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:<span class="number">360</span>)</span><br><span class="line">at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:<span class="number">1574</span>)</span><br><span class="line">at java.io.ObjectStreamClass.access$<span class="number">1500</span>(ObjectStreamClass.java:<span class="number">79</span>)</span><br><span class="line">at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">519</span>)</span><br><span class="line">at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:<span class="number">391</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1134</span>)</span><br><span class="line">at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:<span class="number">727</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:<span class="number">719</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:<span class="number">690</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:<span class="number">439</span>)</span><br><span class="line">at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:<span class="number">550</span>)</span><br><span class="line">at sun.management.Agent.startLocalManagementAgent(Agent.java:<span class="number">137</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>直接内存溢出问题（少见）<br>《深入理解 Java 虚拟机》P59，使用 Unsafe 分配直接内存，或者使用 NIO 的问题 </p></li><li><p>栈溢出问题<br>-Xss 设定太小 </p></li><li><p>比较一下这两段程序的异同，分析哪一个是更优的写法： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) {</span><br><span class="line">    o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>重写 finalize 引发频繁 GC<br>小米云，HBase 同步系统，系统通过 nginx 访问超时报警，最后排查，C++ 程序员重写 finalize 引发频繁 GC 问题<br>为什么 C++ 程序员会重写 finalize？（new delete）<br>finalize 耗时比较长（200ms） </p></li><li><p>如果有一个系统，内存一直消耗不超过 10%，但是观察 GC 日志，发现 FGC 总是频繁产生，会是什么引起的？<br>System.gc () (这个比较 Low) </p></li><li><p>Distuptor 有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出 (来自 死物风情) </p></li><li><p>用 jvm 都会溢出，mycat 用崩过，1.6.5 某个临时版本解析 sql 子查询算法有问题，9 个 exists 的联合 sql 就导致生成几百万的对象（来自 死物风情） </p></li><li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池，<br>解决方案：减少堆空间（太 TM low 了），预留更多内存产生 native thread<br>JVM 内存占物理内存比例 50% - 80%</p></li></ol><h1 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JVM 的命令行参数参考</a><br>HotSpot 参数分类</p><ul><li>标准： - 开头，所有的 HotSpot 都支持 </li><li>非标准：-X 开头，特定版本 HotSpot 支持特定命令 </li><li>不稳定：-XX 开头，下个版本可能取消</li></ul><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li><li> -XX:+UseTLAB<br>使用 TLAB，默认打开</li><li> -XX:+PrintTLAB<br>打印 TLAB 的使用情况</li><li> -XX:TLABSize<br>设置 TLAB 大小</li><li> -XX:+DisableExplictGC<br>System.gc () 不管用 ，FGC</li><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintHeapAtGC</li><li>-XX:+PrintGCTimeStamps</li><li>-XX:+PrintGCCauses</li><li>-XX:+PrintGCApplicationConcurrentTime（低）<br>打印应用程序时间</li><li> -XX:+PrintGCApplicationStoppedTime （低）<br>打印暂停时长</li><li> -XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li><li> -verbose:class<br>类加载详细过程</li><li> -XX:+PrintVMOptions</li><li>-XX:+PrintFlagsFinal</li><li>-XX:+PrintFlagsInitial：查看所有 JVM 参数启动的初始值</li><li> -XX:+PrintCommandLineFlags：默认的参数</li><li> -Xloggc:opt/log/gc.log</li><li>-XX:MaxTenuringThreshold<br>升代年龄，最大值 15</li><li> 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数 -XX:CompileThreshold 逃逸分析 标量替换 …<br>这些不建议设置</li></ul><h2 id="Parallel-常用参数"><a href="#Parallel-常用参数" class="headerlink" title="Parallel 常用参数"></a>Parallel 常用参数</h2><ul><li>-XX:SurvivorRatio</li><li>-XX:PreTenureSizeThreshold<br>大对象到底多大</li><li> -XX:MaxTenuringThreshold</li><li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于 CMS，一般设为和 CPU 核数相同</li><li> -XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li></ul><h2 id="CMS-常用参数"><a href="#CMS-常用参数" class="headerlink" title="CMS 常用参数"></a>CMS 常用参数</h2><ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:ParallelCMSThreads<br>CMS 线程数量</li><li> -XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始 CMS 收集，默认是 68%（近似值），如果频繁发生 SerialOld 卡顿，应该调小，（频繁 CMS 回收）</li><li>-XX:+UseCMSCompactAtFullCollection<br>在 FGC 时进行压缩</li><li> -XX:CMSFullGCsBeforeCompaction<br>多少次 FGC 之后进行压缩</li><li> -XX:+CMSClassUnloadingEnabled</li><li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行 Perm 回收</li><li> GCTimeRatio<br>设置 GC 时间占用程序运行时间的百分比</li><li> -XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代</li></ul><h2 id="G1-常用参数"><a href="#G1-常用参数" class="headerlink" title="G1 常用参数"></a>G1 常用参数</h2><ul><li>-XX:+UseG1GC</li><li>-XX:MaxGCPauseMillis<br>建议值，G1 会尝试调整 Young 区的块数来达到这个值</li><li> -XX:GCPauseIntervalMillis<br>？GC 的间隔时间</li><li> -XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着 size 增加，垃圾的存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长<br>ZGC 做了改进（动态区块大小）</li><li>G1NewSizePercent<br>新生代最小比例，默认为 5%</li><li>G1MaxNewSizePercent<br>新生代最大比例，默认为 60%</li><li>GCTimeRatio<br>GC 时间建议比例，G1 会根据这个值调整堆空间</li><li> ConcGCThreads<br>线程数量</li><li> InitiatingHeapOccupancyPercent<br>启动 G1 的堆空间占用比例</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blogs.oracle.com/jonthecollector/our-collectors">Our Collectors</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">Java Platform, Standard Edition Tools Reference</a></li><li><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp">Java HotSpot VM Options</a></li><li>JVM 调优参考文档： <a href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li><li><a href="https://www.cnblogs.com/nxlhero/p/11660854.html">利用 JVM 在线调试工具排查线上问题</a></li><li><a href="https://www.jianshu.com/p/507f7e0cc3a3">Arthas 使用</a>：arthas 常用命令</li><li> Arthas 手册： <ol><li>启动 arthas java -jar arthas-boot.jar</li><li> 绑定 java 进程</li><li> dashboard 命令观察系统整体情况</li><li> help 查看帮助</li><li> help xx 查看具体命令帮助</li></ol></li><li> jmap 命令参考： <a href="https://www.jianshu.com/p/507f7e0cc3a3">https://www.jianshu.com/p/507f7e0cc3a3</a> <ol><li>jmap -heap pid</li><li>jmap -histo pid</li><li>jmap -clstats pid</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-从编码到执行&quot;&gt;&lt;a href=&quot;#Java-从编码到执行&quot; class=&quot;headerlink&quot; title=&quot;Java 从编码到执行&quot;&gt;&lt;/a&gt;Java 从编码到执行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;-Xmixed：混合模式&lt;ul&gt;
&lt;li&gt;使用解释器 +</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 主从复制</title>
    <link href="https://ccomma.cn/291dfc4393a0/"/>
    <id>https://ccomma.cn/291dfc4393a0/</id>
    <published>2022-12-17T11:21:51.000Z</published>
    <updated>2024-04-01T08:13:04.836Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、概述</strong><br><strong>单机、单节点、单实例问题</strong></p><ul><li>单点故障</li><li>容量有限</li><li>压力</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2ca3031938d6a22279811aba11b68492.png" alt="image.png"><br>X 轴问题<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a5ef3ff143bff5663034d49986fc1a04.png" alt="image.png"></p><ul><li>主备数据一致性<ul><li>强一致性：降低可用性</li><li>最终一致性：使用可靠的速度快的消息队列集群</li></ul></li></ul><p><strong>二、实现</strong><br><strong><em>info replication：</em></strong> 分片信息<br><strong>1. 主从复制</strong><br>replicaof： 5.0 以后<br>**<em>slaveof：</em>**5.0 以前</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 成为 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> 的从节点</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></tbody></table></figure><p><strong>2. 取消主从复制</strong><br><strong><em>slaveof no one：</em></strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></tbody></table></figure><p><strong>3. 配置方式</strong><br><strong>3.1. 主节点配置</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6379</span></span><br><span class="line">daemonize yes</span><br><span class="line"># pid 文件</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis-<span class="number">6379.</span>pid</span><br><span class="line">logfile <span class="string">"6379.log"</span></span><br><span class="line"># 主从复制依赖于 rdb</span><br><span class="line">dbfilename dump-<span class="number">6379.</span>rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br></pre></td></tr></tbody></table></figure><p><strong>3.2. 从节点配置</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br><span class="line">daemonize yes</span><br><span class="line"># pid 文件</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis-<span class="number">6380.</span>pid</span><br><span class="line">logfile <span class="string">"6380.log"</span></span><br><span class="line"># 主从复制依赖于 rdb</span><br><span class="line">dbfilename dump-<span class="number">6380.</span>rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slaveof ip port</span><br><span class="line"># 从节点只读</span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></tbody></table></figure><p><strong>三、主从链</strong><br>避免复制风暴<br>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。<br>为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/678b820fef3f7b91d8dc9bcd47e1532d.png" alt="image.png"><br><strong>四、复制</strong><br><strong>1. 全量复制</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c325ce85db6b042d934e7c7e1be5db64.png" alt="image.png"><br><strong><em>全量同步过程：</em></strong></p><ol><li><strong>获取 runId 和 offset</strong><ol><li><em>[1] slave 请求同步：</em> slave 发送 psync runId offset 到 master 请求全量同步。由于不知道 master 的 runId 所以第一次请求发送 psync ? -1</li><li><em>[2] master 返回信息：</em> 返回 master 的 runId 和 offset</li><li><em>[3] slave 保存信息</em></li></ol></li><li><strong>获取 RDB 文件 和 写命令</strong><ol><li>_[4] master 持久化：_maset 异步执行 RDB 持久化（bgsave），同时把这之后执行的写命令加入缓冲区 repl_back_buffer</li><li><em>[5] 发送 RDB 文件</em></li><li><em> [6] 发送写命令</em></li></ol></li><li><strong>丢弃所有数据，载入 RDB 文件并执行写命令</strong><ol><li><em> [7] 丢弃旧数据</em></li><li><em> [8] 载入 RDB 文件和写命令</em></li></ol></li></ol><p><strong>2. 部分复制</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5dd4051e81f6dd38445c1fd0b858070c.png" alt="image.png"><br>发送 pysnc runId offset 到 master 获取当前偏移量之后的数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;单机、单节点、单实例问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点故障&lt;/li&gt;
&lt;li&gt;容量有限&lt;/li&gt;
&lt;li&gt;压力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="https://ccomma.cn/53c460edad67/"/>
    <id>https://ccomma.cn/53c460edad67/</id>
    <published>2022-12-17T11:20:03.000Z</published>
    <updated>2024-04-01T08:13:04.836Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、概述</strong></p><ul><li>sentinel 是特殊的 redis（不存储数据，支持的命令有限）</li><li>多节点实现</li><li>默认端口： 26379</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f29a6eefff469e8d170d5cf543f6b38.png" alt="image.png"><br><strong>二、配置</strong><br><strong><em>启动：</em></strong> redis-sentinel redis-sentinel-26379.conf<br><strong><em>查看 sentinel 信息：</em></strong> info sentinel</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir "/opt/soft/redis/data"</span><br><span class="line">logfile "26379.log"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor master名称 ip port n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2个sentinel节点认为 master 有问题则进行故障转移</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">超过 30s 做主观下线判断（单个 sentinel 做下线判断）</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并发复制新的 master 的 slave 数目</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">故障转移时间</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></tbody></table></figure><p><strong>三、故障转移</strong><br>可实现 <strong>多个主从复制</strong> 的故障转移<br><strong><em>主观下线：</em></strong> 一个 sentinel 节点主观地认为某个 redis 节点已下线，即这个主观认知可能是错误的（因网络等因素）<br><strong><em>客观下线：</em></strong> 超过 quorum 个 sentinel 节点认为某个 master 节点已下线，达成共识。通过 sentinel is-master-down-by-addr 询问其他 sentinel 节点对该 master 节点的看法</p><blockquote><p>sentinel monitor ${masterName} ${ip} ${port} ${quorum} </p></blockquote><p><strong><em>命令：</em></strong></p><ul><li>sentinel is-master-down-by-addr：<ul><li>客观下线时 sentinel 节点询问其他 sentinel 节点对该 master 节点的看法</li><li>选举 sentinel 节点领导</li></ul></li><li> sentinel failover ${masterName}： 手动故障转移</li></ul><p><strong>1. 定时任务监控</strong></p><ol><li>每 10 秒每个 sentinel 对 master 和 slave 执行 info<ol><li> 发现 slave 节点</li><li>确定主从关系</li></ol></li></ol><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0535492dae6355ec852d9bd505360a56.png" alt="image.png"></p><ol><li>每 2 秒每个 sentinel 通过 master 节点的 channel 交换信息（发布 / 订阅）<ol><li>通过订阅 <strong>sentinel</strong>:hello 频道实现交互</li><li>交互对节点的认知和自身信息</li></ol></li></ol><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d83a8f1f518851e73cd95926a04b73fe.png" alt="image.png"></p><ol><li>每 1 秒每个 sentinel 对其他 sentinel 和 redis 执行 ping</li></ol><p><strong>2. 过程</strong></p><ol><li><strong>发现问题：</strong> 多个 sentinel 结点发现 master 出现问题（主观下线 + 客观下线）</li><li><strong>sentinel 选举领导（raft 算法）：</strong> 选举出一个 sentinel 作为领导<ol><li><em>拉票：</em> 每个做出了主观下线的 sentinel 节点（A）会向其他 sentinel 节点（B）发送 sentinel is-master-down-by-addr 命令，以获得 B 的投票。若 B 尚未投票则投票给 A</li><li><em> 成为领导者：</em> 如果某个拉票的 sentinel 节点获得的票数超过 sentinel 集合的半数且超过 quorum，则成为领导者。若有选出了多个领导者，则重新进行选举</li></ol></li><li><strong> redis 选举新 master：</strong> 从 slave 中选出一个新的 master，并让其余的 slave 成为新 master 的 slave<ol><li><em> 优先级：</em> 首先选择 slave-priority（节点优先级）最高的 slave 节点</li><li><em>复制完整性：</em> 其次选择复制偏移量最大的（复制最完整的） slave 节点</li><li><em>启动最早：</em> 再其次选择 runId 最小的（启动最早的） slave 节点</li></ol></li><li><strong>通知客户端：</strong> 通知客户端主从变化</li><li><strong>监听故障 master：</strong> 监听等待故障的 master 恢复，恢复后使其成为新 master 的 slave</li></ol><p><strong>四、客户端</strong><br><strong>1. 客户端实现原理</strong></p><ol><li><strong>获取 Sentinel 节点：</strong> 遍历所有 Sentinel 节点，获取一个可用的 Sentinel 节点</li><li><strong>获取 master 节点：</strong> 执行 sentinel get-master-addr-by-name ${masterName} 命令获取 master 节点</li><li><strong>验证 master 节点：</strong> 执行 role 或 role replication 命令获取节点信息进行验证其是否故障</li><li><strong>故障转移通知：</strong> 当 redis 主从变化时通知客户端<ol><li><em> +switch-master：</em> 切换主节点（从节点晋升主节点）</li><li><em>+convert-to-slave：</em> 切换从节点（主节点降为从节点）</li><li><em>+sdown：</em> 主观下线</li></ol></li></ol><p><strong>2. Jedis</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JedisSentinelPool</span> <span class="variable">sentinelPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(masterName, sentinelSet, poolConfig, timeout);</span><br><span class="line">Jedis = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">redisSentinelPool</span>.getResource();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) {</span><br><span class="line">        jedis.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sentinel 是特殊的 redis（不存储数据，支持的命令有限）&lt;/li&gt;
&lt;li&gt;多节点实现&lt;/li&gt;
&lt;li&gt;默认端口： 26379&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="https://ccomma.cn/c22a917d2319/"/>
    <id>https://ccomma.cn/c22a917d2319/</id>
    <published>2022-12-17T11:14:30.000Z</published>
    <updated>2024-04-01T08:13:04.836Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、概述</strong><br><strong><em>采用虚拟槽分片：</em></strong></p><ul><li>每个节点分配一堆槽</li><li>每个节点与其他所有节点共享消息</li><li>官方指定全部槽数量为 16384（0-16383）</li><li>每个节点有主从复制</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/be3189a2010a7f13a39bbe83c05888c4.png" alt="image.png"><br><strong><em>命令：</em></strong></p><ul><li><strong>cluster nodes：</strong> 查看自动生成的集群本地配置文件记录</li><li><strong> cluster info：</strong> 集群信息</li><li><strong> cluster meet ip port：</strong> 两个 cluster 节点之间的消息沟通</li><li><strong> cluster addslots slot [slot…]：</strong> 为节点分配槽</li><li><strong> cluster slots：</strong> 查看槽的分配信息</li><li><strong> cluster replicate ${node-id}：</strong> 设置主从关系</li><li><strong> cluster forget ${downNodeId}：</strong> 遗忘节点</li><li> ** cluster keyslot ${key}：** 返回 key 对应的槽</li></ul><p><strong>二、部署</strong><br><strong><em>配置：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6379.log"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主从复制依赖于 rdb</span></span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line">dir /opt/soft/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前节点是一个 cluster 节点</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">节点超时时间</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群本地配置文件记录，自动生成</span></span><br><span class="line">cluster-config-file nodes-${port}.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部节点正常时集群才能提供服务</span></span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></tbody></table></figure><p><strong><em>获取节点信息命令：</em></strong></p><ul><li><strong>cluster nodes：</strong> 查看自动生成的集群本地配置文件记录</li><li><strong> cluster info：</strong> 集群信息</li></ul><p><strong>1. 原生部署</strong><br><strong>1.1. 启动</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></tbody></table></figure><p><strong>1.2. meet</strong><br><strong><em>cluster meet ip port：</em></strong> 两个 cluster 节点之间的消息沟通</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></tbody></table></figure><p><strong>1.3. 分配槽</strong><br><strong><em>cluster addslots slot [slot…]：</em></strong> 为节点分配槽<br><strong><em>cluster slots：</em></strong> 查看槽的分配信息<br><strong><em>addslots.sh：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">host=$1</span><br><span class="line">port=$2</span><br><span class="line">start=$3</span><br><span class="line">end=$4</span><br><span class="line">for slot in `seq ${start} ${end}`</span><br><span class="line">do</span><br><span class="line">    redis-cli -h ${host} -p ${port} cluster addslots ${slot}</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh addslots.sh 127.0.0.1 7000 0 5461</span><br><span class="line">sh addslots.sh 127.0.0.1 7001 5462 10922</span><br><span class="line">sh addslots.sh 127.0.0.1 7002 10923 16383</span><br></pre></td></tr></tbody></table></figure><p><strong>1.4. 设置主从</strong><br><strong><em>cluster replicate node-id：</em></strong> 设置主从关系<br><strong><em>通过 cluster nodes 命令获取 node-id：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/61bab65c2a4da3d275b69bd79b883d3a.png" alt="image.png"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 7003 cluster replicate ${node-id-7000}</span><br></pre></td></tr></tbody></table></figure><p><strong>2. 使用 redis-trib 部署（需要 ruby 环境）</strong><br><strong>2.1. 启动</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br></pre></td></tr></tbody></table></figure><p><strong>2.2. 创建</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--replicas 1表示每个节点的备份数为1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7000 7001 7002 为主</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7003 7004 7005 为从</span></span><br><span class="line">./redis1-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></tbody></table></figure><p><strong>三、集群伸缩</strong><br><strong><em>概述：</em></strong> 槽和数据在节点之间移动<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2e2bc7631836cb377850f7c201c02975.png" alt="image.png"><br><strong>1. 扩容</strong><br><strong>1.1. 添加节点</strong><br><strong><em>具体实现：</em></strong></p><ol><li><strong>redis-cli 命令：</strong> meet</li><li><strong>redis-trib 命令：</strong> ./redis-trib.rb add-node mhost:mport shost:sport</li></ol><p><strong>1.2. 迁移槽和数据</strong><br><strong><em>概述：</em></strong> 从源节点迁移数据到目标节点<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0be390675381ca0c337991dd3b314480.png" alt="image.png"></p><ol><li><strong>目标节点准备导入槽 {slot}：</strong> 目标节点执行 cluster setslot {slot} importing {sourceNodeId}</li><li><strong> 源节点准备导出槽 {slot}：</strong> 源节点执行 cluster setslot {slot} migrating {targetNodeId}</li><li><strong> 获取源节点 {slot} 槽下的 {count} 个键：</strong> 源节点执行 cluster getkeysinslot {slot} {count}</li><li><strong> 批量迁移相关键的数据：</strong> 源节点执行 migrate {targetIp} {targetPort} key 0 {timeout}</li><li><strong> 循环迁移数据：</strong> 循环执行 3、4 步骤直到槽下所有的键数据迁移到目标节点</li><li><strong>通知 {slot} 槽被目标节点负责：</strong> 向所有节点发送 cluster setslot {slot} node {targetNodeId}</li></ol><p><strong><em>具体实现：</em></strong></p><ul><li>redis-trib.rb reshard host:port</li></ul><p><strong>2. 缩容</strong><br><strong><em>步骤：</em></strong></p><ol><li>迁移槽： 同扩容</li><li>所有节点遗忘下线节点： cluster forget {downNodeId}</li><li> 关闭节点</li></ol><p><strong><em>具体实现：</em></strong></p><ul><li>迁移槽： redis-trib.rb reshard host:port –from {fromNodeId} –to {toNodeId} –slots {slotNums}</li><li> 遗忘下线节点： redis-trib.rb del-node host:port {downNodeId}</li></ul><p><strong>四、客户端</strong><br><strong>1. moved 重定向</strong><br><strong><em>概述：</em></strong> 客户端存取键值的时候使用的重定向</p><ul><li>命中则直接返回</li><li>不命中则返回目标 ip 及对应的槽给客户端，通过 cluster keyslot ${key} 命令可算出 key 对应的槽</li></ul><p><strong><em>-c：</em></strong> cluster 模式执行，出现 moved 不命中的情况可直接跳转到对应节点上执行命令。非 cluster 模式时会出现 moved 错误<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/116076ca37beeae6639ab4745ce2ed33.png" alt="image.png"><br><strong>2. ask 重定向</strong><br><strong><em>概述：</em></strong> 扩容或缩容中槽在迁移时客户端访问源节点发生的重定向</p><ol><li>客户端向源节点发送键命令后源节点回复 ask 转向</li><li>客户端再向目标节点发送 Asking 命令</li></ol><p><strong>3. smart 客户端</strong><br><strong><em>原理：</em></strong><br>假设有 n 个节点，若随机选择一个结点发送命令，那么命中率为 n/1，有性能问题<br>smart 客户端先为所有节点创建连接池，再根据 key 获得相应的 slot 进行直连<br><strong><em>过程：</em></strong></p><ol><li>从集群中选一个可运行节点，得到 cluster slots 的映射集，为每个节点创建 JedisPool</li><li> 执行键命令</li></ol><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d3f7a10ccd09f32f917f953c4f9070b.png" alt="image.png"><br><strong><em>工厂类：</em></strong></p><ul><li><p>无需手动归还连接池</p></li><li><p>使用单例模式</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Conponent</span><br><span class="line">public class JedisClusterFactory {</span><br><span class="line">    private JedisCluster jedisCluster;</span><br><span class="line">    private List&lt;String&gt; hostPortList;</span><br><span class="line">    private int timeout;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(JedisClusterFactory.class);</span><br><span class="line">    </span><br><span class="line">    public void init() {</span><br><span class="line">        // 可以设置相关参数</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();</span><br><span class="line">        </span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = new HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        for (String hostPort : hostPortList) {</span><br><span class="line">            String[] arr = hostPort.split(":");</span><br><span class="line">            if (arr.length != 2) {</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">            nodeSet.add(new HosrAndPort(arr[0], Integer.parseInt(arr[1])));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        try {</span><br><span class="line">            jedisCluster = new JedisCluster(nodeSet, timeout, jedisPoolConfig);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void destroy() {</span><br><span class="line">        if (jedisCluster != null) {</span><br><span class="line">            try {</span><br><span class="line">                jedisCluster.close();                </span><br><span class="line">            } catch (IOException e) {</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // set and get</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong><em>获取所有节点：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有节点的连接池</span><br><span class="line">Map&lt;String, JedisPool&gt; jedisPoolMap = jedisCluster.getClusterNodes();</span><br></pre></td></tr></tbody></table></figure><p><strong>五、故障转移</strong><br><strong>1. 故障发现</strong><br><strong><em>概述：</em></strong> 通过 ping/pong 消息实现故障发现，不需要 sentinel<br><strong><em>主观下线 流程：</em></strong><br>ping 超时则认为主观下线<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/43c60451a837a93ffcc4f34c4f7710ca.png" alt="image.png"><br><strong><em>客观下线 流程：</em></strong><br>半数以上持有槽的主节点都标记某节点主观下线时<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/53a11b50de8e1a700bb532d0531448fc.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39b92057c1916a19179e6c37c2ca891.png" alt="image.png"><br><strong>2. 故障转移</strong><br><strong><em>概述：</em></strong> 发现故障后，故障节点的从节点替代主节点工作<br><strong><em>流程：</em></strong></p></li><li><p><strong><em>检查从节点资格：</em></strong> 每个从节点检查与其故障的主节点的断线时间，若超过 》cluster-node-timeout * cluster-slave-validity-factor 则取消资格</p><blockquote><p>cluster-node-timeout 默认为 15s，cluster-slave-validity-factor 默认为 10</p></blockquote></li><li><p><strong><em>偏移量优先：</em></strong> 偏移量更小的从节点延迟选举时间越小，越能更快开始选举，获得的票数也越多</p></li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d3624377185a40982f8dbfd65d524299.png" alt="image.png"></p><ul><li><strong><em>开始选举：</em></strong> 每个主节点对从节点投票</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a0b75d0c32e6daf58b0059940a5f15c2.png" alt="image.png"></p><ul><li><strong><em>替换主节点：</em></strong> 选举成功的从节点变为主节点</li><li><strong><em>替换槽：</em></strong> 执行 clusterDelSlot 撤销故障主节点的槽，并执行 clusterAddSlot 把相应的槽分配给选出的从节点</li><li><strong><em>通知集群：</em></strong> 向集群广播自己的 pong 消息，表明已替换故障主节点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;采用虚拟槽分片：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点分配一堆槽&lt;/li&gt;
&lt;li&gt;每个节点与其他所有节点共享消息&lt;/li&gt;
&lt;li&gt;官方指定全部槽数量为 16384（0-1</summary>
      
    
    
    
    
  </entry>
  
</feed>
