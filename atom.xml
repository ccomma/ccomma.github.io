<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CComma&#39;s Blog</title>
  
  <subtitle>Connect the world</subtitle>
  <link href="https://ccomma.cn/atom.xml" rel="self"/>
  
  <link href="https://ccomma.cn/"/>
  <updated>2024-04-02T03:56:26.602Z</updated>
  <id>https://ccomma.cn/</id>
  
  <author>
    <name>CComma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES 写入原理及调优</title>
    <link href="https://ccomma.cn/4216ce6ea7d2/"/>
    <id>https://ccomma.cn/4216ce6ea7d2/</id>
    <published>2024-03-12T02:37:13.000Z</published>
    <updated>2024-04-02T03:56:26.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？</p><p><strong>1. 解决写入问题</strong><br>心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。</p><p><strong>2. 学习架构设计思想</strong><br>这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。</p><p><strong>3. 应对面试</strong><br>虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题</p><p>常见的面试问题：</p><ul><li>你了解 ES 的写入原理吗</li><li>你了解文档的写入 / 删除过程吗</li><li>如何保证 ES 数据写入一致性</li><li>文档写入超时原因</li><li> ES 写入实时性如何去保证</li><li>数据量大时如何保证数据写入性能</li><li>如何提高数据检索能力</li></ul><span id="more"></span><h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h2><p>ES 中的数据写入均发生在主分片上。由于 ES 是分布式系统，实际接收到写入请求的节点可能是任意一台节点，这就需要将请求通过 routing 路由到具体主分片所在的节点，将数据写入该节点的主分片中，然后主分片再同步数据到其他节点的副分片中。<br>路由公式：<code>shard_num = hash(_routing) % num_primary_shards</code><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b20c17eb26dfc1a90e9433ae005a39e.jpeg"><br>具体流程：</p><ol><li>客户端发起写入请求至 node 4</li><li>node 4 通过文档 id 在路由表中的映射信息确定当前数据的位置为分片 0，分片 0 的主分片位于 node 5，并将数据转发至 node 5。</li><li>数据在 node 5 写入，写入成功之后将数据的同步请求转发至其副本所在的 node 4 和 node 6 上面，等待所有副本数据写入成功之后 node 5 将结果报告 node 4，并由 node 4 将结果返回给客户端，报告数据写入成功。</li></ol><h2 id="写一致性策略"><a href="#写一致性策略" class="headerlink" title="写一致性策略"></a>写一致性策略</h2><p>ES 5.x 之后，一致性策略由 <code>wait_for_active_shards</code> 参数控制：状态为 active 的主副分片数量达到设定阈值时才视为写入成功，才会返回数据给客户端。默认为 1，即只需要主分片写入成功，可设置为 <code>all</code> 或任何正整数，最大值为索引中的分片总数 (&nbsp;<code>number_of_replicas + 1</code> )。</p><p>如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间 30 秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。</p><p>执行索引操作时，分配给执行索引操作的主分片可能不可用。造成这种情况的原因可能是主分片当前正在从网关恢复或正在进行重定位。默认情况下，索引操作将在主分片上等待最多 1 分钟，然后才会失败并返回错误。</p><h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p>我们已经知道了宏观上的写入流程：先找到主节点，写入主节点后再同步到副节点。<br><strong>那 ES 是怎么把数据写入主节点和副节点中的呢？</strong></p><p>大家可能会有疑问，难道不是直接写入到磁盘吗？<strong>我们可以思考下，每次请求都直接写入到磁盘这种方式在高并发的场景下会消耗大量的 IO 资源，每次都要寻址然后写入磁盘。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba7282dc7f49c616767143d774646a3b.jpeg" alt="未命名文件.jpg"></p><p>对此我们可以用缓存来解决，即把数据写入系统缓存后，定期批量写入磁盘，同时缓存也提供检索服务。<br>而 Lucene 中索引是细分为多个 segment 的，segment 是索引中存储索引数据的内部存储元素，并且是不可变的。较小的 segment 会定期合并到较大的 segment 中，以控制索引大小。问题又来了：<strong>如果每次请求都创建一个新的 segment，那么会导致频繁的合并操作（merge）。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ec5aedd4c9bc6e805872b3f5944957a8.jpeg" alt="未命名文件.jpg"></p><p>所以 ES 在请求进入缓存之前先让请求进缓冲区（memory buffer），每秒或每 100 个缓存才会执行刷新操作（Refresh）把缓冲区中的数据创建 segment 写入系统缓存中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/10b375c43ff4ab15fe0c8ed7fa469f8e.jpeg" alt="未命名文件 (1).jpg"></p><p>至此这套批量持久化结构已经比较完善，但还有一个问题：<strong>缓存虽然提高了性能，但毕竟未持久化到磁盘，一旦系统出现故障数据就会丢失。</strong>ES 采用事务日志（translog）的方式解决此问题，当请求进来时会同时写入缓冲区和事务日志中，当服务重启后就会从事务日志中恢复数据到缓存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dcb5acedec3e2a0f97e678cd403a0eea.jpeg" alt="未命名文件 (1).jpg"></p><p>整体结构：</p><ul><li>Memory Buffer（缓冲区）：数据批量操作，高性能写入</li><li> Translog（事务日志）：保证数据写入安全性，防止丢失</li><li> OS Cache（内存）：保证数据高性能检索</li><li> OS Disk（磁盘）：保证数据持久化</li></ul><p>具体流程：</p><ol><li>客户端写入 Memory Buffer 缓冲区，并追加写入 Translog 事务日志（删除、写入…）以保证数据安全性。</li><li>Memory Buffer 达到阈值（100 条 / 1s）后执行 Refresh 操作生成 Segment 索引文件到系统缓存中。<ol><li>然后系统缓存会把该 Segment 标记为可被检索，因此数据有 1s 不可读的延迟。</li><li>Refresh 操作不能过于频繁，因此针对实时性不高的数据，可以配置 refresh 的间隔时间为 30s 一次。</li></ol></li><li>每个 Segment 都会消耗文件句柄、内存、CPU 运行周期，所以每隔一段时间会执行 Merge 操作，合并 Segment。<ol><li>Merge 操作发生在 JVM 中，频率过高会占用堆内存空间，所以 Refresh 的频率不能太高，否则会使 Merge 频率增高。</li><li>不合并 Segment 的影响：<ol><li>每个 Segment 占据的内存不会随着 GC 释放的。导致系统内存不足，进一步导致超时问题。</li><li>查询时会遍历每个 Segment，过多的 Segment 会导致查询速度下降。</li></ol></li></ol></li><li>执行 Flush 操作缓存写入 OS Disk（磁盘）并提交一次，并清空 Translog。<ol><li>系统缓存每隔 30 分钟、Translog 每隔 5 秒刷一次到磁盘中，所以默认情况下，可能会有 5s 数据丢失。</li><li>系统缓存和 Translog 写满时也会刷磁盘。</li></ol></li><li>断电等异常操作导致数据丢失时，服务重启后会读取 Translog 中的数据到缓存中，以完成回滚操作。</li></ol><p>相关参数：</p><ul><li>index.translog.durability：同步还是异步<ul><li> request：（默认）主副分片在每个请求后执行 fsync 和 commit，才会向客户端报告索引、删除、更新或批量请求的成功。如果发生崩溃，那么所有只要是已经确认的写操作都已经被提交到磁盘。</li><li>async：在后台每 index.translog.sync_interval 时间进行一次 fsync 和 commit。意味着如果发生崩溃，那么所有在上一次自动提交以后的已确认的写操作将会丢失。</li></ul></li><li>index.translog.sync_interval：translog 多久被同步到磁盘并提交一次。默认 5 秒。这个值不能小于 100ms。</li><li>index.translog.flush_threshold_size：translog 执行 flush 操作的空间最大阈值，默认 512 MB。</li></ul><h2 id="写入性能调优"><a href="#写入性能调优" class="headerlink" title="写入性能调优"></a>写入性能调优</h2><p>生产经常面临的写入可以分为两种情况：</p><ul><li>高并发：高频的创建 / 更新索引文档，一般发生在 C 端场景下</li><li>高吞吐：定期重建索引或批量更新文档数据，一般为 B 端场景</li></ul><p><strong>1. 提升写入吞吐量和并发</strong><br>ES 数据写入具有一定的延时性，这是为了减少频繁的索引文件产生。默认情况下 ES 每秒生成一个 segment 文件，当达到一定阈值的时候会执行 merge，merge 过程发生在 JVM 中，频繁的生成 segmen 文件可能会导致频繁的触发 FGC，导致 OOM。<br>为了避免避免这种情况，通常采取的手段是降低 segment 文件的生成频率，手段有两个，一个是增加时间阈值，另一个是增大 buffer 的空间阈值。</p><ol><li>增加 flush 时间间隔。Flush 是 IO 操作，很消耗性能，不能太频繁</li><li>增加 refresh_interval 的参数值<ol><li>目的是减少 segment 文件的创建，减少 segment 的 merge 次数。</li><li>merge 是发生在 JVM 中的，有可能导致 full GC，增加 refresh 会降低搜索的实时性。</li></ol></li><li>增加 buffer 大小<ol><li>减小 refresh 的时间间隔，因为导致 segment 文件创建的原因不仅有时间阈值，还有 buffer 空间大小，写满了也会创建。</li><li>默认最小值 48MB &lt; 默认值 JVM 空间的 10% &lt; 默认最大无限制</li></ol></li><li>关闭副本（提高单次吞吐）<ol><li>需要单次写入大量数据的时候，可以关闭副本（减少数据同步），暂停搜索服务，或选择在检索请求量谷值区间时间段来完成。因为副本的存在会导致主从之间频繁的进行数据同步，大大增加服务器的资源占用。</li><li>可通过则设置 index.number_of_replicas 为 0 以加快索引速度。没有副本意味着丢失单个节点可能会导致数据丢失，因此数据保存在其他地方很重要，以便在出现问题时可以重试初始加载。初始加载完成后，可以设置 index.number_of_replicas 改回其原始值。</li></ol></li><li>max_result_window 参数</li></ol><p>分页返回的最大数值，默认值为 10000。通过设定一个合理的阈值，避免初学者分页查询时由于单页数据过大而导致 OOM。</p><p><strong>2. 提高写入实时性（不推荐）</strong><br>在搜索引擎的业务场景下，用户一般并不需要那么高的写入实时性。有时这个延时的过程需要处理很多事情，比如信息需要后台审核。<br>可以提高 Memory Buffer 的 refresh 操作频率，但是过高的 refresh 会导致频繁 merge segment，会消耗更多堆内存、CPU 的资源。</p><h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><p>1. 避免单次召回大量数据<br>搜索引擎最擅长的事情是从海量数据中查询少量相关文档，而非单次检索大量文档。非常不建议动辄查询上万数据。如果有这样的需求，建议使用滚动查询。<br> <br>2. 避免单个文档过大<br>硬性限制：<br>鉴于默认 http.max_content_length 设置为 100MB，Elasticsearch 将拒绝索引任何大于该值的文档。可以增加该特定设置，但 Lucene 仍然有大约 2GB 的限制。<br> <br>大型文档对网络、内存使用和磁盘造成了更大的压力，即使对于不请求的搜索请求也是如此。<br> <br>3. 使用 filter 代替 query<br>query 是要对查询的每个结果计算相关性得分的，而 filter 不会。另外 filter 有相应的缓存机制，可以提高查询效率。<br> <br>4. 避免深度分页<br> <br>5. 使用 Keyword 类型<br>并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为查询优化数字字段，例如 integeror long。如果不需要范围查找，对于 term 查询而言，keyword 比 integer 性能更好。</p><p>参考：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index-modules-translog.html">Translog | Elasticsearch Guide [7.17] | Elastic</a></li><li><a href="https://blog.csdn.net/a645293829/article/details/132223065">【HBZ 分享】ES 索引分片的写入原理 及 流程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 解决写入问题&lt;/strong&gt;&lt;br&gt;心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 学习架构设计思想&lt;/strong&gt;&lt;br&gt;这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 应对面试&lt;/strong&gt;&lt;br&gt;虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题&lt;/p&gt;
&lt;p&gt;常见的面试问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你了解 ES 的写入原理吗&lt;/li&gt;
&lt;li&gt;你了解文档的写入 / 删除过程吗&lt;/li&gt;
&lt;li&gt;如何保证 ES 数据写入一致性&lt;/li&gt;
&lt;li&gt;文档写入超时原因&lt;/li&gt;
&lt;li&gt; ES 写入实时性如何去保证&lt;/li&gt;
&lt;li&gt;数据量大时如何保证数据写入性能&lt;/li&gt;
&lt;li&gt;如何提高数据检索能力&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ES" scheme="https://ccomma.cn/categories/ES/"/>
    
    
    <category term="ES" scheme="https://ccomma.cn/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 快速搭建博客</title>
    <link href="https://ccomma.cn/58a80fbce4aa/"/>
    <id>https://ccomma.cn/58a80fbce4aa/</id>
    <published>2024-02-13T07:05:42.000Z</published>
    <updated>2024-04-02T03:56:26.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么搭建博客"><a href="#为什么搭建博客" class="headerlink" title="为什么搭建博客"></a>为什么搭建博客</h1><ul><li>知识积累</li><li>分享</li><li>影响力</li></ul><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="静态页面生成"><a href="#静态页面生成" class="headerlink" title="静态页面生成"></a>静态页面生成</h2><p>我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。</p><p>像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress</p><p>为什么选择 hexo？主题较现代化、方便快捷<br><a href="https://github.com/hexojs/hexo">hexo github</a></p><span id="more"></span><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>_config.yml 里配置你的项目地址</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ccomma/ccomma.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></tbody></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多主题，这里推荐 Next 主题，因为 Next 的社区非常活跃，这就导致 Next 主题有非常多的配置和插件</p><p>Next 主题配置<br><a href="https://theme-next.js.org/docs/theme-settings/">Theme Settings</a></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>博客可以部署在阿里云等云服务器上，但是特地买一台服务器专门用来部署博客还是有点太浪费了。</p><p>以下几种方式可以免费部署静态 web 应用</p><ul><li>github pages<ul><li> 服务器地理位置：美国</li><li>推荐：push 即部署，简单快捷 </li><li>缺点：网络连接严重不稳定</li></ul></li><li> cloudflare pages<ul><li> 服务器地理位置：美国自家节点</li><li>推荐原因：速度稳定，在全球各地均有 CDN，支持从 Github/Gitlab 等平台自动部署 </li><li>缺点：部署速度较慢，但不算太影响</li></ul></li><li> Vercel<ul><li> 服务器地理位置：美国 AWS</li><li> 推荐原因：部署速度快，支持自动部署</li><li>缺点：被墙过一次，速度有可能出现不稳定</li></ul></li></ul><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>hexo 能让我们更专心写博客，但即使是如此，我们还是要先使用 <code>hexo new "xxx"</code> 命令来新建文档。而我们平时的笔记可能是写在 notion、语雀、飞书上。</p><p>写作同步工具 <a href="https://github.com/LetTTGACO/elog">elog</a> 能让我们的在 notion、语雀、飞书上的笔记自动部署到 github 上</p><p>elog 会在本地创建缓存，每次同步只会增量更新，包括图片上传也是。</p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>github pages 自带域名：xxxx.github.io，够用，但是有点 low</p><ul><li><a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520112.products-recent.ddomain.5c0234c0saWuKP#/overview">阿里云域名</a>：基本都是国内的，30+/ 年 </li><li><a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412">cloudflare</a>：国外域名，9.77～45 美元</li></ul><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1. 阿里云付费 SSL<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79690ec1537f107639504c426c7654f.png" alt="image.png"></p><p>2. 阿里个人测试证书，有效期 3 个月<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7abb7f515c8c087585cf82b749f58856.png" alt="image.png"></p><p> 3.<a href="https://letsencrypt.org/">Let’s Encrypt</a>：提供免费 TLS 证书的非营利证书颁发机构，就个人博客而言足以</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>阿里云 DNS：DNS 解析与域名服务捆绑，声誉一般</p><p>cloudflare：</p><ul><li>支持 CDN（国内减速）</li><li>自带 DDos 防御服务</li><li>支持解析 A、AAAA、CNAME、MX、LOC、SRV、SPF、TXT、NS、CAA、PTR、CERT、DNSKEY、DS、NAPTR、SMIMEA、SSHFP、TLSA、URI</li><li> 支持 DNSSEC</li><li> 免费版支持一部分其他地方收费的配套服务，例如 Worker，Page，访客规则</li></ul><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>搜索引擎优化，让你的网站更好的被搜索引擎收录</p><p>google：<a href="https://search.google.com/search-console">https://search.google.com/search-console</a><br>bing：<a href="https://www.bing.com/webmasters">https://www.bing.com/webmasters</a><br>百度：<a href="https://ziyuan.baidu.com/site">https://ziyuan.baidu.com/site</a></p><p>以 google 为例：<br>登录到 Google Search Console，选择您要验证的网站。输入网址<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/060a5e066eda3911a4d4b938a91b23b3.png" alt="image.png"><br>将验证码复制到 DNS 记录中<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb3c64f775d04dc6ff8dabc1d6990035.png" alt="image.png"></p><h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>对网站流量访问进行分析</p><p>1.<a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412/web-analytics/sites">cloudflare</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39742d06912a9f134af70c3df193507.png" alt="image.png"></p><p>2.<a href="https://search.google.com/search-console?resource_id=sc-domain:ccomma.cn">google</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d5ef6ca57eb04a42125cc57f9f95af0.png" alt="image.png"></p><p>3. <a href="https://tongji.baidu.com/main/overview/10000609568/overview/index?siteId=20141034">百度统计</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bfbbe9f8eda65e69abc5b9b1074671cd.png" alt="image.png"></p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>百度云 CDN：百度云加速分为免费版和付费版，免费版不支持 SSL 证书，海外网站也支持加速。</p><p>cloudflare CDN：<br>免费提供，对于国外的服务器还行，国内服务器反而减速。支持 SSL，无须备案</p><p>七牛云 CDN：<br>每个月可使用 10G 的免费存储量和 10G 的 CDN 流量与 100 万次的 Get 请求数，七牛云在海外也有众多加速节点，七牛云 TCP 压缩优化使网页中大图和样式等实现秒加载。但请注意使用七牛 CDN，须保证账户中有最低金额 10 元。国内必须备案，支持 SSL。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bilibili.com/video/BV1Sp4y157br/?vd_source=8f8a2ec64a5f07bb8bf30a6ef4819025">将 Hexo 博客部署到 CloudFlare Pages 使用全球加速</a></li><li><a href="https://cloud.tencent.com/developer/article/1987796?areaSource=102001.7&amp;traceId=zTjHWNtLK7p3TbHHsvayg">5 个免费的静态 Web 应用部署平台</a></li><li><a href="https://hqyman.cn/post/4255.html">国内外免费域名 DNS 解析推荐</a></li><li><a href="https://www.zhihu.com/question/342631132">如何使用 Notion 制作个人网站？</a></li><li><a href="https://www.cnblogs.com/wangyuehan/p/12743624.html">Notion 做个人博客的两种实现方式</a></li><li><a href="https://blog.ithuo.net/post/2023-11-07%2FNotion%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97">Notion 博客折腾指南</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2">使用 hexo+github 搭建免费个人博客</a></li><li><a href="https://juejin.cn/post/7304540675668181003">语雀写作，Kubernetes 部署 ——Elog+Hexo 博客持续集成</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么搭建博客&quot;&gt;&lt;a href=&quot;#为什么搭建博客&quot; class=&quot;headerlink&quot; title=&quot;为什么搭建博客&quot;&gt;&lt;/a&gt;为什么搭建博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;知识积累&lt;/li&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;影响力&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建站&quot;&gt;&lt;a href=&quot;#建站&quot; class=&quot;headerlink&quot; title=&quot;建站&quot;&gt;&lt;/a&gt;建站&lt;/h1&gt;&lt;h2 id=&quot;静态页面生成&quot;&gt;&lt;a href=&quot;#静态页面生成&quot; class=&quot;headerlink&quot; title=&quot;静态页面生成&quot;&gt;&lt;/a&gt;静态页面生成&lt;/h2&gt;&lt;p&gt;我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。&lt;/p&gt;
&lt;p&gt;像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress&lt;/p&gt;
&lt;p&gt;为什么选择 hexo？主题较现代化、方便快捷&lt;br&gt;&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;hexo github&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://ccomma.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="https://ccomma.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>可重入锁实现</title>
    <link href="https://ccomma.cn/f8c8b8272337/"/>
    <id>https://ccomma.cn/f8c8b8272337/</id>
    <published>2023-08-17T06:56:10.000Z</published>
    <updated>2024-04-02T03:56:26.603Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目时遇到需要可重入的缓存锁场景，缓存锁用的是 Redis 分布式锁，于是考虑用 ThreadLocal 来实现本机上的可重入锁</p><span id="more"></span><p>ReentrantCacheLockManager：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReentrantCacheLockManager implements ICacheLockManager {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ICacheService cacheService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(String key, int expireSecond) {</span><br><span class="line">        return tryLock(Collections.singletonList(key), expireSecond);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(List&lt;String&gt; keyList, int expireSecond) {</span><br><span class="line">        Assert.isTrue(CollectionUtils.isNotEmpty(keyList), "获取锁失败：key 不能为空");</span><br><span class="line"></span><br><span class="line">        // 1.从未获取过锁的 key 先去获取锁</span><br><span class="line">        List&lt;String&gt; unCacheKeyList = keyList.stream()</span><br><span class="line">                .filter(k -&gt; !LockKeyCountHolder.exist(k))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量获取锁</span><br><span class="line">        if (CollectionUtils.isNotEmpty(unCacheKeyList)) {</span><br><span class="line">            Map&lt;String, String&gt; lockMap = unCacheKeyList.stream().collect(Collectors.toMap(Function.identity(), k -&gt; "1", (a, b) -&gt; b));</span><br><span class="line">            long msetnx = cacheService.msetnx(lockMap, expireSecond);</span><br><span class="line">            // 未取到锁</span><br><span class="line">            if (Objects.equals(msetnx, 0L)) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 2.重入计数 +1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            LockKeyCountHolder.increment(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(String key) {</span><br><span class="line">        unlock(Collections.singletonList(key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(List&lt;String&gt; keyList) {</span><br><span class="line">        List&lt;String&gt; releaseKeyList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        // 重入 -1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            if (LockKeyCountHolder.decrement(key) == 0) {</span><br><span class="line">                releaseKeyList.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 释放锁</span><br><span class="line">        cacheService.del(releaseKeyList.toArray(new String[0]));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>LockKeyCountHolder：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 已锁的 key 重入计数</span><br><span class="line"> *</span><br><span class="line"> * @author mianxian</span><br><span class="line"> * 2023/8/2 14:56</span><br><span class="line"> */</span><br><span class="line">public class LockKeyCountHolder {</span><br><span class="line"></span><br><span class="line">    private LockKeyCountHolder() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * lockKey -&gt; 重入次数</span><br><span class="line">     */</span><br><span class="line">    private static final ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; THREAD_LOCAL = ThreadLocal.withInitial(Maps::newConcurrentMap);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 +1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int increment(String key) {</span><br><span class="line">        int count = get(key);</span><br><span class="line">        THREAD_LOCAL.get().put(key, ++count);</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取计数</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int get(String key) {</span><br><span class="line">        Map&lt;String, Integer&gt; keyMap = THREAD_LOCAL.get();</span><br><span class="line">        return keyMap.getOrDefault(key, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数是否 &gt; 0</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 是否 &gt; 0</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static boolean exist(String key) {</span><br><span class="line">        return get(key) &gt; 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 -1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int decrement(String key) {</span><br><span class="line">        if (!exist(key)) {</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int count = get(key) - 1;</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            THREAD_LOCAL.get().remove(key);</span><br><span class="line">        } else {</span><br><span class="line">            THREAD_LOCAL.get().put(key, count);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做项目时遇到需要可重入的缓存锁场景，缓存锁用的是 Redis 分布式锁，于是考虑用 ThreadLocal 来实现本机上的可重入锁&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ccomma.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>并行流导致接口慢调用问题</title>
    <link href="https://ccomma.cn/cb2072810346/"/>
    <id>https://ccomma.cn/cb2072810346/</id>
    <published>2023-08-14T00:55:38.000Z</published>
    <updated>2024-04-02T03:56:26.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。</p><span id="more"></span><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8ff9b37602e5bee3be548af291c7348e.png" alt="image.png"><br>根据 ARMS 分析该接口的调用量在 18:31-18:41 出现断崖式增长，每分钟请求数从 5.1k 增加到 14.7k，10 分钟增长了 9.6k。（后续调查表明在该时间段内大部分接口调用量都出现了断崖式增长）<br>异常时刻的 qps 大致为 236.1，几乎是一周前的 2 倍。</p><p><strong>响应时间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3dd26f56b4afe1a4bfcb5a79450452d1.png" alt="image.png"><br>每分钟响应时间平均为 3747 ms，整个异常过程中该接口最长的响应时间达到 8s 多。</p><p><strong>dubbo 线程池：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d7b54ac7097680e22af442ccbd6b276.png" alt="image.png"><br>所有接口的每分钟 dubbo 请求调用量在 18:35-18:45 内从 14.2k 增长至 35.6k<br>也是在这段时间内 dubbo 线程池被打满，在 18:40 左右基本被打满<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/decb4154e9d3362f4dd2e3b7dbd1892f.png" alt="image.png"></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>初步判断流量突增的原因是客户端开放灰度，使得预定业务中的一个轮询调用的接口调用次数上升。<br>该接口调用桌位状态服务的一个较为通用的查询接口，里面使用 parallelStream 来进行 RPC 调用获取账单。<br>parallelStream 使用与 CPU 核数一致的线程数来处理任务，当请求量增大时线程池中的线程全部被打满，导致后续的任务一直在排队等待延迟处理，最终 dubbo 线程池也被占满。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>从问题的核心代码到外部调用，可优化的点如下：</p><ol><li>取消并行流</li><li>加大批量获取数，让调用量减小</li><li>经查看代码发现出现问题的使用并行流查账单是为了设置桌位状态的 payStatus，但是上层并不关心这个字段，所以可以让上层调用更轻量级的接口</li><li>降低客户端轮询次数，轮询调用需谨慎，轮询策略需要好好设计</li></ol><h2 id="2023-08-13（代码修改后）"><a href="#2023-08-13（代码修改后）" class="headerlink" title="2023.08.13（代码修改后）"></a>2023.08.13（代码修改后）</h2><p>141 部署了优化后的代码，取消了并行流，分页大小增加到 10<br>142 没有改动，以此作为对照。</p><p>总体应用每分钟调用量峰值也有 14.7k，但是 13 号这天的曲线明显更加平滑，没有出现 dubbo 线程池被打满的情况，慢调用的数量和时长都在正常范围内。</p><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b6f1ef4f96f597a9b716feb0c2990204.png" alt="image.png"></p><p><strong>响应时间：</strong><br>141 比 142 更缓和</p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4cbe6c1f08b59f911f0a0aa91140deae.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4573954d3923199d395b8c80d3cb6909.png" alt="image.png"></p><p><strong>dubbo 线程数：</strong></p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/50b9cd579f52f5b56e2e28be3205d865.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1f735878b6e9667f825e70e452c8492.png" alt="image.png"></p><p>08.13 修改优化后至今，142 会依然出现一定量的慢调用，141 没有出现过<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/532b6fca9a1b64382d8ac364a4851385.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次问题应该是由于短时间内的调用量突增，加上使用并发流处理 RPC 调用引起的。<br>根据 13 号的对照来看，流量平滑增加的情况不会出现特别严重的线程池等待现象，但依然有慢调用，存在隐患。</p><p>取消并行流，增加分页大小的方案是可行的，以后并行流需要谨慎使用。后续也和客户端讨论了上层接口的调整方案。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
    <category term="并行流" scheme="https://ccomma.cn/tags/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>如何快速定位问题</title>
    <link href="https://ccomma.cn/6c827d88b19c/"/>
    <id>https://ccomma.cn/6c827d88b19c/</id>
    <published>2023-08-10T14:23:27.000Z</published>
    <updated>2024-04-02T03:56:26.607Z</updated>
    
    <content type="html"><![CDATA[<p>这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。</p><p>整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再去更新打印状态。</p><p>排查了很久发现是客户端接收不到消息，客户端同学也表示不知所措，问了消息通道那边的同学后发现安卓客户端在这之前就断开连接了，重新连接后立马就接收到了消息。一度怀疑是消息通道的问题，后来才发现客户端一直运行在后台，且自动刷新是关闭的。</p><p>因整个排查浪费了太多时间故在此做个复盘<br>整个链路很长，任何环节都有可能出现问题。</p><ol><li>先尽可能排除用户误操作产生的影响</li><li>有些地方不好排查（如消息通道），排查必须得有侧重点</li><li>需要有一个负责人协调多位项目相关人，依次推进进度，提高效率</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。&lt;/p&gt;
&lt;p&gt;整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再</summary>
      
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="思考" scheme="https://ccomma.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>类型转换异常 sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</title>
    <link href="https://ccomma.cn/fb2b1fd4b701/"/>
    <id>https://ccomma.cn/fb2b1fd4b701/</id>
    <published>2023-06-21T06:13:28.000Z</published>
    <updated>2024-04-02T03:56:26.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">    Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第四行 <code>Class&lt;R&gt; requestClass = (Class&lt;R&gt;) parameterizedType.getActualTypeArguments()[0]</code> 报 <code>java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</code> 错误</p><p>这个代码是子类想要拿到泛型参数时出现的类型转换异常</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上述问题中的类结构简化如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request2</span> <span class="keyword">extends</span> <span class="title class_">Request</span> {}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request3</span> <span class="keyword">extends</span> <span class="title class_">Request2</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request</span>&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;R <span class="keyword">extends</span> <span class="title class_">Request2</span>&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;R&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&lt;Request3&gt; {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>1/ <code>(new C).requestHandle()</code><br>因为 C 继承 B<request3>，所以 <code>parameterizedType.getActualTypeArguments()[0]</code> 拿到的其实就是 <code>Request3.class</code> </request3></p><p>2/ <code>(new B).requestHandle()</code><br>这种情况 <code>parameterizedType.getActualTypeArguments()[0]</code> 返回的是 <code>TypeVariable</code>，不是 Class<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/266de73a45592b057e2f6005b846e830.png" alt="image.png"><br>很好理解，因为 B 类的定义是 B<r extends="" request2="">，这里很容易因为泛型的类型擦除误认为 <code>parameterizedType.getActualTypeArguments()[0]</code> 会返回 <code>Request2.class</code></r></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>仔细观察 <code>TypeVariable</code> 接口定义</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeVariable</span>&lt;D <span class="keyword">extends</span> <span class="title class_">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title class_">Type</span>, AnnotatedElement {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上边界</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 Request2.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取泛型声明的类型，即这个类型变量的声明来源</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 B.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    D <span class="title function_">getGenericDeclaration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该类型变量名称</span></span><br><span class="line"><span class="comment">     * 例：B&lt;R extends Request2&gt; 返回 R</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带注解的上边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以调用 <code>getBounds()</code> 来获取泛型的上边界</p><p>最终调整如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> requestHandle {</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> Class) {</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (actualTypeArgument <span class="keyword">instanceof</span> TypeVariable) {</span><br><span class="line">            <span class="type">TypeVariable</span> <span class="variable">v</span> <span class="operator">=</span> (TypeVariable) actualTypeArgument;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">requestClass</span> <span class="operator">=</span> (Class) v.getBounds()[<span class="number">0</span>];</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; getClass().getGenericSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (type &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; ParameterizedType) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ParameterizedType&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;parameterizedType&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; (ParameterizedType) type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四行 &lt;code&gt;Class&amp;lt;R&amp;gt; requestClass = (Class&amp;lt;R&amp;gt;) parameterizedType.getActualTypeArguments()[0]&lt;/code&gt; 报 &lt;code&gt;java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class&lt;/code&gt; 错误&lt;/p&gt;
&lt;p&gt;这个代码是子类想要拿到泛型参数时出现的类型转换异常&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://ccomma.cn/27d53953edf2/"/>
    <id>https://ccomma.cn/27d53953edf2/</id>
    <published>2023-03-20T06:45:36.000Z</published>
    <updated>2024-04-02T03:56:26.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-从编码到执行"><a href="#Java-从编码到执行" class="headerlink" title="Java 从编码到执行"></a>Java 从编码到执行</h1><ul><li>-Xmixed：混合模式<ul><li>使用解释器 + 热点代码编译</li><li>起始阶段采用解释执行</li><li>热点代码检测<ul><li>多次被调用的方法（使用 <em>方法计数器</em> 检测方法执行频率）</li><li>多次被调用的循环（使用 <em>循环计数器</em> 检测循环执行频率）</li><li>进行编译</li></ul></li></ul></li><li> -Xint：解释模式，启动快，执行慢</li><li> -Xcomp：编译模式，启动慢，执行快</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7e3de546edf8e39f3f1c842a023a4488.png"></p><h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p>Class 文件实际上是二进制字节流，JVM 定义了一系列规范，用把 Class 文件 “翻译” 成 Class 类</p><blockquote><p>逻辑上划分的数据类型：u1（1 字节）、u2（2 字节）、u4（4 字节）、u8（8 字节）和 _info（表类型）<br>_info 的来源是 hotspot 源码中的写法</p></blockquote><h2 id="1-查看-16-进制字节码"><a href="#1-查看-16-进制字节码" class="headerlink" title="1. 查看 16 进制字节码"></a>1. 查看 16 进制字节码</h2><p>.java 文件使用 javac 命令进行编译后得到 .class 文件<br>可以使用 BinEd（IDEA 插件）查看 .class 文件的 16 进制字节码</p><p><strong>ByteCode 类：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCode</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>对应 .class 文件的编码：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a674107c0061ef04a64e2a055e14be96.png"></p><h2 id="2-Class-文件构成"><a href="#2-Class-文件构成" class="headerlink" title="2. Class 文件构成"></a>2. Class 文件构成</h2><p>使用 JClassLib（IDEA 插件）查看 ByteCode<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e56706305d2071f14ae691dfa66393f6.png"></p><p><strong>classfile 构成：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9c7016ea0849b42824754e2c05d703be.png" alt="image.png"></p><p>对应关系<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/12c42883b5bc0dbef7942aa7513744d8.png"></p><p>常量：</p><ul><li>常量池 #1 号标记： <ul><li>标记位 07（1 字节），表明了常量类型</li><li>索引 00 0e（2 字节），代表指向常量池 #14 号标记</li></ul></li></ul><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类是在 <strong>运行期间第一次使用</strong> 时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ae1579b82e4c9a00ebd22d577c5ed5a7.png"></p><p>loadClass () 中实现了双亲委派机制，委托给父加载器去执行，父加载器没找到则会调用自己的 findClass () 去找</p><ul><li>自定义类加载器：重写 findClass () </li><li>打破双亲委派机制：重写 loadClass ()</li></ul><h1 id="内存加载过程"><a href="#内存加载过程" class="headerlink" title="内存加载过程"></a>内存加载过程</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dbb80dce45a2038379a95a181acf60fd.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8c6e173b742392ca93cbb591d6045819.png"></p><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>内存数据放入高速缓存中时是以缓存行的形式放入的，多数情况把内存中连续的 64 字节的数据作为一个缓存行加入高速缓存，不会只单独放入几个字节的数据</p><p><strong>伪共享问题：</strong> 位于同一缓存行的两个不同数据，被两个不同 CPU 锁定，产生互相影响的伪共享问题</p><p>缓存行对齐</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheLinePadding</span> {</span><br><span class="line">    <span class="comment">// 加上 padding，使 arr[0] 和 arr[1] 在两个不同的缓存行中</span></span><br><span class="line">    <span class="comment">// 使运行速度提升</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Padding</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) {</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start) / <span class="number">100_0000</span> + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>缓存锁：</strong> MESI<br><a href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU 缓存一致性协议</a></p><p><strong>总线锁：</strong> 有些无法被缓存的数据或者跨越多个缓存行的数据还是得使用总线锁</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><blockquote><p>验证 <strong>JVM/jmm/Disorder.java</strong><br><a href="https://www.cnblogs.com/liushaodong/p/4777308.html">现代 cpu 的合并写技术对程序的影响</a></p></blockquote><p>CPU 为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，慢 100 倍），去同时执行另一条指令，前提是两条指令没有依赖关系</p><ul><li>读指令的同时可以执行不影响的其他指令 </li><li>写指令的同时可以进行合并写<br>WCBuffers（Write Combining Buffers），只能存放 4 字节的数据。用于写指令合并缓存。 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WriteCombining</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITEMS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayA = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayB = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayC = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayD = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayE = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] arrayF = <span class="keyword">new</span> <span class="title class_">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) {</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseOne</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">runCaseTwo</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> i &amp; MASK;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>如何保证不重排：</strong></p><ul><li>CPU 内存屏障（硬件方面实现）：Inter X86 <ul><li>sfence：在 sfence 指令前的写操作必须在 sfence 指令后的写操作前完成</li><li> lfence：在 lfence 指令前的读操作必须在 lfence 指令后的读操作前完成</li><li> mfence：在 mfence 指令前的写操作必须在 mfence 指令后的读操作前完成</li></ul></li><li> CPU lock 原子汇编指令（硬件方面实现）：Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个 CPU </li><li>JVM 规范（JSR 133）：依赖于硬件实现 <ul><li><p>LoadLoad 屏障：<br>保证读操作 Load1 先于读操作 Load2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure></li><li><p>StoreStore 屏障：<br>保证写操作 Store1 先于写操作 Store2 执行</p></li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure><ul><li><p>LoadStore 屏障：<br>保证读操作 Load1 先于写操作 Store2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1 操作</span><br><span class="line">LoadStore 屏障</span><br><span class="line">Store2 操作</span><br></pre></td></tr></tbody></table></figure></li><li><p>StoreLoad 屏障：<br>保证写操作 Store1 先于读操作 Load2 执行 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1 操作</span><br><span class="line">StoreLoad 屏障</span><br><span class="line">Load2 操作</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="volatile-实现细节"><a href="#volatile-实现细节" class="headerlink" title="volatile 实现细节"></a>volatile 实现细节</h2><ol><li><p>字节码层面：<code>ACC_VOLATILE</code> 编码 </p></li><li><p>JVM 层面： </p></li><li><p>写操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StoreStore 屏障</span><br><span class="line">volatile 写操作</span><br><span class="line">StoreLoad 屏障</span><br></pre></td></tr></tbody></table></figure></li><li><p>读操作 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadLoad 屏障</span><br><span class="line">volatile 读操作</span><br><span class="line">LoadStore 屏障</span><br></pre></td></tr></tbody></table></figure></li><li><p>OS 和硬件层面：<br><a href="https://blog.csdn.net/qq_26222859/article/details/52235930">volatile 与 lock 前缀指令</a></p></li></ol><h2 id="synchronized-实现细节"><a href="#synchronized-实现细节" class="headerlink" title="synchronized 实现细节"></a>synchronized 实现细节</h2><ol><li><p>字节码层面<br>ACC_SYNCHRONIZED </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 加锁</span><br><span class="line">monitorenter</span><br><span class="line">...</span><br><span class="line">; 释放锁</span><br><span class="line">monitorexit</span><br><span class="line">...</span><br><span class="line">; 异常后释放锁</span><br><span class="line">monitorexit</span><br></pre></td></tr></tbody></table></figure></li><li><p>JVM 层面<br>C C++ 调用了操作系统提供的同步机制 </p></li><li><p>OS 和硬件层面<br>X86 : lock cmpxchg / xxx<br><a href="https://blog.csdn.net/21aspnet/article/details/88571740">Java 使用字节码和汇编语言同步分析 volatile，synchronized 的底层实现</a></p></li></ol><h2 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8e9b9db2bd428ecd3e1e8c1b2b173d4e.png"></p><h1 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h1><p>关于对象面试题：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/73a0bb354657280d028c0005ede1125f.png"></p><h2 id="对象大小（64位机）"><a href="#对象大小（64位机）" class="headerlink" title="对象大小（64位机）"></a>对象大小（64 位机）</h2><h3 id="观察虚拟机配置"><a href="#观察虚拟机配置" class="headerlink" title="观察虚拟机配置"></a>观察虚拟机配置</h3><p>java -XX:+PrintCommandLineFlags -version<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a0d446091f82ab3ceb874f33de885a69.png"></p><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><ol><li>对象头：markword &nbsp;8 字节</li><li> ClassPointer 指针：-XX:+UseCompressedClassPointers 压缩打开为 4 字节，不开启为 8 字节</li><li>实例数据 <ol><li>引用类型：-XX:+UseCompressedOops 为 4 字节 不开启为 8 字节<br>Oops Ordinary Object Pointers</li></ol></li><li>Padding 对齐，8 的倍数</li></ol><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><ol><li>对象头：markword 8 字节</li><li> ClassPointer 指针同上</li><li>数组长度：4 字节</li><li>数组数据</li><li>对齐 8 的倍数</li></ol><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.jvm.agent.ObjectSizeAgent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -XX:+UseCompressedClassPointers：类型指针压缩</span></span><br><span class="line"><span class="comment">// -XX:+UseCompressedOops：对象引用指针压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T03_SizeOfAnObject</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">Object</span>())); <span class="comment">// 16=8+4+4(补齐)</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">int</span>[] {})); <span class="comment">// 16=8+4+4</span></span><br><span class="line">        System.out.println(ObjectSizeAgent.sizeOf(<span class="keyword">new</span> <span class="title class_">P</span>()));      <span class="comment">// 32</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P</span> {</span><br><span class="line">        <span class="comment">//8 _markword</span></span><br><span class="line">        <span class="comment">//4 _class pointer -XX:+UseCompressedClassPointers</span></span><br><span class="line">        <span class="type">int</span> id;         <span class="comment">//4</span></span><br><span class="line">        String name;    <span class="comment">//4 _oops pointer -XX:+UseCompressedOops</span></span><br><span class="line">        <span class="type">int</span> age;        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> b1;        <span class="comment">//1</span></span><br><span class="line">        <span class="type">byte</span> b2;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        Object o;       <span class="comment">//4</span></span><br><span class="line">        <span class="type">byte</span> b3;        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/29bb86a6e6a00811b70fbb320972c200.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1725fefe349ee3b824ed3ac303df63e.png"></p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d91d2c4aa4efc43bf1c527817e9379ee.png"></p><h2 id="IdentityHashCode"><a href="#IdentityHashCode" class="headerlink" title="IdentityHashCode"></a>IdentityHashCode</h2><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3191ffe79b85e1818e79653a761dbb7.png"></p><p><a href="https://cloud.tencent.com/developer/article/1480590">死磕 Synchronized 底层实现，面试你还怕什么？</a><br><a href="https://cloud.tencent.com/developer/article/1484167">面试题深入解析：Synchronized 底层实现</a><br><a href="https://cloud.tencent.com/developer/article/1485795">死磕 Synchronized 底层实现 – 重量级锁</a><br><a href="https://cloud.tencent.com/developer/article/1482500">一文让你读懂 Synchronized 底层实现，秒杀面试官</a></p><h2 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h2><p><a href="https://blog.csdn.net/clover_lily/article/details/80095580">访问对象两种方式 – 句柄和直接指针</a></p><ol><li>句柄池</li><li>直接指针</li></ol><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。<br><strong>作用：</strong> 缓存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>// ===== 软引用测试（-Xms:20M -Xmx20M） =====</p><p>SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024<em>1024</em>10]);<br>System.out.println(m.get());</p><p>// 再分配一个数组，heap 将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉<br>byte[] b = new byte[1024<em>1024</em>15];<br>System.out.println(m.get()); // null</p></blockquote><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p><strong>作用：</strong> 一般用在容器里。强引用和弱引用同时指向某个对象，当强引用不再指向该对象时，该对象就该被回收</p><p>例：ThreadLocal 对象 new 后有强引用，而当前线程中的 ThreadLocalMap 对象的键也有 ThreadLocal 对象的弱引用，所以当 ThreadLocal 对象失去强引用时 ThreadLocalMap 中对应的键也会变为 null，防止了内存泄露。虽然 ThreadLocalMap 的键为 null 了，但是其 value 值还存在所以依然会有内存泄露，所以需要执行 ThreadLocal#remove 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>WeakReference<m> m = new WeakReference&lt;&gt;(new M());</m></p><p>System.out.println(m.get());<br>System.gc();<br>System.out.println(m.get()); // null</p><p>ThreadLocal<m> tl = new ThreadLocal&lt;&gt;();<br>tl.set(new M());<br>tl.remove();</m></p></blockquote><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p><em>作用：</em></p><ul><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 </li><li>管理堆外内存（通常给编写 JVM 的人使用）：DirectByteBuffer 对象指向堆外内存。当 DirectByteBuffer 被回收时，可以通过队列检测到，然后清理堆外内存 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联了对象和队列</span></span><br><span class="line"><span class="comment">// 当对象被回收引用会放入队列中</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line"><span class="comment">// 不能通过 get() 拿到里面的值</span></span><br><span class="line">pf.get();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对象被回收后，通过 poll() 方法可以拿出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; poll = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (poll != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"--- 虚引用对象被jvm回收了 ---- "</span> + poll);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="JVM-组成"><a href="#JVM-组成" class="headerlink" title="JVM 组成"></a>JVM 组成</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7f8078dc240be61d59fbabe554422f76.png"></p><p><strong>JVM 的结构基本上由 4 部分组成：</strong></p><ul><li>_类加载器：_在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</li><li>_运行时数据区：_将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块</li><li><strong>执行引擎：</strong>执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</li><li><strong> 本地方法调用：</strong>调用 C 或 C++ 实现的本地方法的代码返回结果</li></ul><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0a3771f5524d1ecef45ba10c2518dfe5.png"></p><h2 id="PC-程序计数器"><a href="#PC-程序计数器" class="headerlink" title="PC 程序计数器"></a>PC 程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）<br>用于存放指令位置<br>虚拟机的运行，类似于这样的循环：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (not end) {</span><br><span class="line"></span><br><span class="line">取 PC 中的位置，找到对应位置的指令；</span><br><span class="line"></span><br><span class="line">执行该指令；</span><br><span class="line"></span><br><span class="line">PC ++;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a href="https://blog.csdn.net/jt781861965/article/details/114957201?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">变量定义在 for 循环外面还是里面</a></li></ul><p>Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息<br>从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</p><p><strong>栈结构：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4ad59ef5e3736678f5da98683650a3db.png"></p><p>Frame：每个方法对应一个栈帧</p><ol><li>Local Variable Table </li><li>Operand Stack<br>对于 long 的处理（store and load），多数虚拟机的实现都是原子的<br>jls 17.7，没必要加 volatile </li><li>Dynamic Linking<br><a href="https://blog.csdn.net/qq_41813060/article/details/88379473">java Dynamic Linking</a><br>jvms 2.6.3 </li><li>return address<br>a () -&gt; b ()，方法 a 调用了方法 b，b 方法的返回值放在什么地方</li></ol><p>例：<code>i = i++;</code> 的栈实现</p><p><strong>常用字节码指令：</strong><br>store、load、pop、mul、sub<br>invoke：</p><ol><li>InvokeStatic：调用静态方法</li><li> InvokeVirtual：普通方法，自带多态</li><li> InvokeInterface：调用接口的方法</li><li> InovkeSpecial：<br>可以直接定位，不需要多态的方法<br>private 方法 ， 构造方法</li><li> InvokeDynamic：<br>lambda 表达式或者反射或者其他动态语言 scala kotlin，或者 CGLib ASM，动态产生的 class，会用到的指令</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>所有对象都在这里分配内存</strong>，是垃圾收集的主要区域<br>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常</p><p>堆是所有 <strong>线程共享</strong> 的<br>默认新生代：老年代 = 1 : 2</p><h3 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h3><p>分为 伊甸园（Edne）和两个 幸存区（Survival），默认比例为 Eden：from：to = 8：1：1，保证了内存的利用率达到 90%</p><p><strong>Eden：</strong></p><ul><li><strong>线程共享：</strong> 由于堆是所有线程共享的，因此在堆上分配内存 <strong>需要加锁</strong> </li><li><strong> TLAB：</strong> 为提升效率，每个新建的线程在 Eden 上分配了一块独立的空间由该线程独享，这块空间称为 <strong>TLAB</strong>（Thread Local Allocation Buffer） </li><li>在 TLAB 上分配内存 <strong>不需要加锁</strong>，因此 JVM 在给线程中的对象分配内存时会尽量在 TLAB 上分配 <ul><li>如果对象过大或 TLAB 用完，则仍然在堆上进行分配。如果 Eden 区内存也用完了，则会进行一次 Minor GC（young GC）</li></ul></li></ul><p><strong>Survival（from &amp; to）：</strong><br><a href="https://www.jianshu.com/p/989d3b06a49d">jvm 误区 – 动态对象年龄判定</a></p><ul><li>在发生 Minor GC 时，Eden 区和 Survival from 区会把一些仍然存活的对象复制进 Survival to 区，并清除内存 <ul><li>将此时在 Survivor to 区存活下来的对象的年龄设置为 1，以后这些对象每在 Survivor 区熬过一次 GC，它们的年龄就加 1，当对象年龄达到某个年龄（默认值为 15）时，就会把它们移到老年代中<br><strong>调整年龄：</strong> -XX:MaxTenuringThreshold<br><strong>默认年龄：</strong> <ul><li>·Parallel Scavenge 15</li><li>CMS 6</li><li>G1 15</li></ul></li><li>s1 -&gt; s2 超过 50%：把年龄最大的放入老年代</li></ul></li><li>在发生一次 Minor GC 后，from 区就会和 to 区互换</li></ul><p><strong>分配担保：</strong><br><a href="https://cloud.tencent.com/developer/article/1082730">JVM 内存分配担保机制</a><br>如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p><h3 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><p>年老代里存放的都是存活时间较久的，大小较大的对象。<br><strong>Full GC：</strong> 当年老代容量满的时候，会触发一次 Major GC（Full GC），回收年老代和年轻代中不再被使用的对象资源</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p><strong>垃圾回收：</strong> 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p><strong>永久代（PermSpace）：</strong><br>JDK &lt; 1.8<br>方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是 Hotspot 虚拟机对其的一种实现。</p><p>永久代的大小受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变</p><ul><li>字符串常量位于 PermSpace</li><li>FGC 不会清理</li><li>大小启动的时候指定，不能变</li></ul><p><strong>元空间（MetaSpace）：</strong><br>JDK &gt;= 1.8</p><ul><li>移除永久代，并把方法区移至元空间（位于本地内存中，而不是虚拟机内存中）</li><li>字符串常量存放到堆内存中</li><li>会触发 FGC 清理</li><li>元空间大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><strong>栈上分配：</strong> 无需手动调整<ul><li>线程私有小对象</li><li>无逃逸</li><li>支持标量替换</li></ul></li><li><strong>线程本地分配 TLAB（Thread Local Allocation Buffer）：</strong> 无需手动调整</li></ol><ul><li>占用 Eden，默认 1%</li><li> 多线程的时候不用竞争 Eden 就可以申请空间，提高效率</li><li>小对象</li></ul><ol start="3"><li><strong>大对象直接进入老年代：</strong></li></ol><ul><li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</li><li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</li><li> XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制</li></ul><ol start="4"><li><strong>对象优先在 Eden 分配：</strong> 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC </li><li><strong>长期存活的对象进入老年代：</strong> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中 </li><li><strong>空间分配担保：</strong></li></ol><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的 </li><li>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败 <ul><li>如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li><li>如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</li></ul></li></ul><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><ul><li><strong>调用 System.gc ()：</strong> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存 </li><li><strong>老年代空间不足：</strong> <ul><li>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</li><li>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li></ul></li><li><strong>空间分配担保失败：</strong> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC </li><li><strong>JDK 1.7 及以前的永久代空间不足：</strong> <ul><li>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</li><li>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</li></ul></li><li><strong>Concurrent Mode Failure：</strong> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li></ul><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p><a href="https://my.oschina.net/wenbo123/blog/1822414">深入学习 JVM-JVM 安全点和安全区域</a><br>垃圾收集主要是针对 <strong>堆</strong> 和 <strong>方法区</strong> 进行<br>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收</p><blockquote><p>简历：熟悉 GC 常用算法，熟悉常见垃圾回收器，具有实际 JVM 调优实战经验</p></blockquote><h2 id="1-定位垃圾"><a href="#1-定位垃圾" class="headerlink" title="1. 定位垃圾"></a>1. 定位垃圾</h2><h3 id="引用计数算法（ReferenceCount）"><a href="#引用计数算法（ReferenceCount）" class="headerlink" title="引用计数算法（ReferenceCount）"></a>引用计数算法（ReferenceCount）</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p><strong>缺点：</strong> 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。<br>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可达性分析算法（RootSearching）"><a href="#可达性分析算法（RootSearching）" class="headerlink" title="可达性分析算法（RootSearching）"></a>可达性分析算法（RootSearching）</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ce3e51425ea1c0e8ec7df5ea77b23b5d.png"></p><p><strong>GC Roots 一般包含以下内容：</strong></p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h2 id="2-常见的垃圾回收算法"><a href="#2-常见的垃圾回收算法" class="headerlink" title="2. 常见的垃圾回收算法"></a>2. 常见的垃圾回收算法</h2><h3 id="2-1-标记清除（mark-sweep）："><a href="#2-1-标记清除（mark-sweep）：" class="headerlink" title="2.1. 标记清除（mark sweep）："></a>2.1. 标记清除（mark sweep）：</h3><p>将存活的对象进行标记，然后清理掉未被标记的对象<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d0c48c5f7e1089ce05031c847478e918.png"></p><p><strong>扫描两次：</strong></p><ol><li>一次扫描先标记存活对象</li><li>再一次扫描清除未被标记对象</li></ol><p><strong>缺点：</strong> 扫描两次，位置不连续，产生碎片<br>存活对象比较多的情况下效率较高</p><h3 id="2-2-拷贝算法（copying）"><a href="#2-2-拷贝算法（copying）" class="headerlink" title="2.2. 拷贝算法（copying）"></a>2.2. 拷贝算法（copying）</h3><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/31f6dcd971788dc021c5aaf4f67f99bc.png"></p><p>缺点：需移动对象，浪费空间<br>优点：扫描一次，没有碎片<br>适用于存活对象比较少的情况</p><h3 id="2-3-标记压缩（mark-compact）"><a href="#2-3-标记压缩（mark-compact）" class="headerlink" title="2.3. 标记压缩（mark compact）"></a>2.3. 标记压缩（mark compact）</h3><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/012b5391c527342861d9f55c59a907f7.png"></p><p>缺点：扫描两次，需移动对象，效率低下<br>优点：没有碎片，方便对象分配，不会产生内存减半</p><h3 id="2-4-分代收集"><a href="#2-4-分代收集" class="headerlink" title="2.4. 分代收集"></a>2.4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p><ul><li><strong>新生代使用：</strong> 复制算法</li><li><strong>老年代使用：</strong> <em>标记 - 清除</em> 或者 <em>标记 - 整理</em> 算法</li></ul><blockquote><p>除 Epsilon ZGC Shenandoah 之外的 GC 都是使用逻辑分代模型<br>G1 是逻辑分代，物理不分代<br>除此之外的不仅逻辑分代，而且物理分代</p></blockquote><h2 id="3-常见的垃圾回收器"><a href="#3-常见的垃圾回收器" class="headerlink" title="3. 常见的垃圾回收器"></a>3. 常见的垃圾回收器</h2><p><strong>Card Table</strong><br>由于做 YGC 时，需要扫描整个 OLD 区，效率非常低，所以 JVM 设计了 CardTable， 如果一个 OLD 区 CardTable 中有对象指向 Y 区，就将它设为 Dirty，下次扫描时，只需要扫描 Dirty Card<br>在结构上，Card Table 用 BitMap 来实现</p><p><strong>垃圾回收器：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/aaa5c8687b39ad7fb3ccca97c2bfaa87.png"></p><p>连线表示垃圾收集器可以配合使用</p><p><strong>垃圾收集器跟内存大小的关系：</strong></p><ol><li>Serial 几十兆</li><li> PS 上百兆 - 几个 G</li><li>CMS - 20G</li><li>G1 - 上百 G</li><li>ZGC - 4T - 16T（JDK13）</li></ol><p><strong>STW：</strong> stop the world。指 GC 中让用户线程全部暂停而产生的停顿。任何一个垃圾回收器都有 STW，减少 STW 能提升用户响应时间，但也会减少吞吐量。</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9fa3d91b3a2dcc7a97df297037107732.png"><br>用于收集年轻代垃圾的收集器，只会使用 <strong>一个 GC 线程</strong> 进行垃圾收集工作。</p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4c4ea9f436123e32405a3d5968b8b25f.png"></p><p>用于收集年轻代垃圾的收集器，使用多个 GC 线程收集垃圾</p><p>关注吞吐量，目标是 <strong>达到一个可控制的吞吐量</strong>，它被称为 “吞吐量优先” 收集器</p><ul><li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降</li></ul><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>用于收集年轻代垃圾的收集器。新版本的 Parallel Scavenge，与其相比做了增强以便能与 CMS 配合使用</p><p><a href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p><ul><li>ParNew 响应时间优先（配合 CMS）</li><li>Parallel Scavenge 吞吐量优先</li></ul><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>用于收集老年代垃圾的收集器。Serial 收集器的老年代版本。</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用（效率低下）</li></ul><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>用于收集老年代垃圾的收集器。Parallel Scavenge 收集器的老年代版本。</p><h3 id="ConcurrentMarkSweep"><a href="#ConcurrentMarkSweep" class="headerlink" title="ConcurrentMarkSweep"></a>ConcurrentMarkSweep</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1796989f83d1e64eddebc8f83871fcea.png"></p><p>用于收集老年代垃圾的收集器。垃圾回收和应用程序同时运行，降低 STW 的时间。</p><p><strong>流程：</strong><br>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p><ol><li><strong>初始标记：</strong> 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</li><li><strong>并发标记：</strong> 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿</li><li><strong>重新标记：</strong> 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li><li><strong>并发清除：</strong> 不需要停顿</li></ol><p><strong>CMS 的问题：</strong><br>CMS 问题比较多，所以现在没有一个版本默认是 CMS，只能手工指定<br>CMS 既然是 MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS 的老年代分配对象分配不下的时候，使用 SerialOld 进行老年代回收</p><ul><li><em>吞吐量低：</em> 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高 </li><li><em>无法处理浮动垃圾：</em> </li><li><ul><li><em>浮动垃圾：</em> 指并发清除阶段由于用户线程继续运行而产生的垃圾。这部分垃圾只能到下一次 GC 时才能进行回收 </li><li><em>需预留内存：</em> 由于浮动垃圾的存在，因此需要预留出一部分内存。这意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收 </li><li><em>Concurrent Mode Failure：</em> 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS </li><li>解决方案：<br>降低触发 CMS 的阈值<br>–XX:CMSInitiatingOccupancyFraction 92%：内存打到 92% 时才会触发 CMS。可以降低这个值，让 CMS 保持老年代足够的空间</li></ul></li><li><em>空间碎片：</em> 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为 0 指的是经过多少次 FGC 才进行压缩</li></ul><p>算法：三色标记 + Incremental Update</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>特点：</strong></p><ul><li>并发收集</li><li>压缩空间，不会延长 GC 的暂停时间</li><li>更容易预测 GC 的暂停时间</li><li>适用不需要实现很高吞吐量的场景</li><li>每个内存区域不是固定的，可能这次存放新生代下次就存放老年代了</li><li>新老年代比例： 5%-60%。不用手工指定，G1 以此作为预测停顿时间的基准</li></ul><p>Edne、Survivor、Old、Humongous（超过单个 Region 的 50%）<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/52d4d0716d23c88b12178ad78e59253b.png"></p><p><strong>CSet（Collection Set）：</strong></p><ul><li>一组可被回收的分区的集合 </li><li>在 CSet 中存活的数据会在 GC 过程中被移动到另一个可用分区 </li><li>CSet 中的分区可以来自 Eden 空间、Survivor 空间或老年代 </li><li>CSet 占用不到整个堆空间的 1% 大小</li></ul><p><strong>RSet（Remembered Set）：</strong></p><ul><li>是一块存放在 Region 内部的 Map，记录了其他 Region 中的对象到本 Region 的引用</li><li>使垃圾回收器不用去扫描整个堆来获取引用了当前分区的对象，只需要扫描 RSet 即可</li></ul><p><strong>当对象无法分配时也会产生 FullGC，如何解决：</strong></p><ul><li>扩内存 </li><li>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大） </li><li>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是 45%） <blockquote><p>MixedGC：类似 CMS<br>XX:InitiatingHeapOccupacyPercent</p><ul><li>默认值 45%</li><li> 当分配堆空间超过这个值，启动 MixedGC</li></ul></blockquote></li></ul><p>算法：三色标记 + SATB<br><strong>三色标记：</strong></p><ul><li>黑色：自身和成员变量均已标记完成</li><li>灰色：自身被标记，成员变量未被标记</li><li>白色：未被标记的对象</li></ul><p><strong>漏标：</strong><br>当一个黑色的对象引用了一个白色对象，且这个白色对象只被这个黑色对象引用时会漏标<br>该白色对象已无法被遍历到了</p><p><strong>解决漏标的方案：</strong></p><ul><li>Incremental update：关注引用的增加。黑色的对象引用白色对象时把黑色对象重新标记为灰色，下次重新扫描属性，CMS 使用</li><li> SATB（snapshot at the beginning）：关注引用的删除。当引用消失时把这个引用推到 GC 的堆栈，保证引用的对象还能被 GC 扫描到。</li></ul><p>G1 使用 SATB，Incremental update 把黑色对象变为灰色对象后，后续还得对其成员变量进行扫描，效率不高。<br>SATB 配合 RSet 判断记录的白色对象是否为漏标对象<br><a href="https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html">垃圾优先型垃圾回收器调优</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>ZGC (1ms) PK C++<br>算法：ColoredPointers + LoadBarrier </li><li>Shenandoah<br>算法：ColoredPointers + WriteBarrier </li><li>Epsilon</li></ol><h2 id="4-常见垃圾回收器组合"><a href="#4-常见垃圾回收器组合" class="headerlink" title="4. 常见垃圾回收器组合"></a>4. 常见垃圾回收器组合</h2><ul><li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old：小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器 </p></li><li><p>-XX:+UseParNewGC = ParNew + SerialOld：这个组合已经很少用（在某些版本中已经废弃） </p><blockquote><p><a href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future">Why Remove support for ParNew+SerialOld andDefNew+CMS in the future？</a></p></blockquote></li><li><p>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old </p></li><li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8 默认) 【PS + SerialOld】 </p></li><li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old </p></li><li><p>-XX:+UseG1GC = G1</p></li></ul><p>Linux 中没找到默认 GC 的查看方法，而 windows 中会打印 UseParallelGC</p><ul><li>java +XX:+PrintCommandLineFlags -version</li><li> 通过 GC 的日志来分辨</li></ul><h1 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h1><h2 id="PS-GC-日志详解"><a href="#PS-GC-日志详解" class="headerlink" title="PS GC 日志详解"></a>PS GC 日志详解</h2><p>PS 日志格式：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6e30320b5571257235fcd22548c61a4c.png"></p><p>heap dump 部分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)</span><br><span class="line">                            后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/18373e80319f93e9ddf9a0b988cc032b.png"></p><h2 id="CMS-日志分析"><a href="#CMS-日志分析" class="headerlink" title="CMS 日志分析"></a>CMS 日志分析</h2><p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p><p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</p><blockquote><p>ParNew：年轻代收集器<br>6144-&gt;640：收集前后的对比<br>（6144）：整个年轻代容量<br>6585 -&gt; 2770：整个堆的情况<br>（19840）：整个堆大小</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: 8511K(13696K)] 9866K(19840K), <span class="number">0.0040321</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line"><span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.018</span>/<span class="number">0.018</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line"><span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: <span class="number">1597</span> K (<span class="number">6144</span> K)][Rescan (parallel) , <span class="number">0.0008396</span> secs][weak refs processing, <span class="number">0.0000138</span> secs][<span class="keyword">class</span> <span class="title class_">unloading</span>, <span class="number">0.0005404</span> secs][scrub symbol table, <span class="number">0.0006169</span> secs][scrub string table, <span class="number">0.0004903</span> secs][<span class="number">1</span> CMS-remark: 8511K(13696K)] 10108K(19840K), <span class="number">0.0039567</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line"><span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line"><span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line"><span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line"><span class="comment">//scrub symbol(string) table: </span></span><br><span class="line"><span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line"><span class="comment">//internalized string respectively</span></span><br><span class="line"><span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line"><span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.005</span>/<span class="number">0.005</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"><span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></tbody></table></figure><h2 id="G1-日志详解"><a href="#G1-日志详解" class="headerlink" title="G1 日志详解"></a>G1 日志详解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="title function_">pause</span> <span class="params">(G1 Evacuation Pause)</span> (young) (initial-mark), <span class="number">0.0015790</span> secs]</span><br><span class="line"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span><br><span class="line"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span><br><span class="line">   [Parallel Time: <span class="number">1.5</span> ms, GC Workers: <span class="number">1</span>] <span class="comment">//一个GC线程</span></span><br><span class="line">      [GC Worker <span class="title function_">Start</span> <span class="params">(ms)</span>:  <span class="number">92635.7</span>]</span><br><span class="line">      [Ext Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">1.1</span>]</span><br><span class="line">      [Update <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">         [Processed Buffers:  <span class="number">1</span>]</span><br><span class="line">      [Scan <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Code Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="title function_">Copy</span> <span class="params">(ms)</span>:  <span class="number">0.1</span>]</span><br><span class="line">      [Termination (ms):  <span class="number">0.0</span>]</span><br><span class="line">         [Termination Attempts:  <span class="number">1</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Other</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Total</span> <span class="params">(ms)</span>:  <span class="number">1.2</span>]</span><br><span class="line">      [GC Worker <span class="title function_">End</span> <span class="params">(ms)</span>:  <span class="number">92636.9</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.0</span> ms]</span><br><span class="line">   [Other: <span class="number">0.1</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Proc: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [Free CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)]</span><br><span class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法 evacuation，进行 FGC</span></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18M(20M), <span class="number">0.0719656</span> secs]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)], [Metaspace: <span class="number">38</span></span><br><span class="line">76K-&gt;3876K(1056768K)] [Times: user=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></tbody></table></figure><h1 id="GC-调优"><a href="#GC-调优" class="headerlink" title="GC 调优"></a>GC 调优</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol><li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li><li>响应时间：STW 越短，响应时间越好</li></ol><p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p><p>问题：<br>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p><p>响应时间：网站 GUI API （1.8 G1）</p><p><strong>什么是调优？</strong></p><ol><li>根据需求进行 JVM 规划和预调优</li><li>优化运行 JVM 运行环境（慢，卡顿）</li><li>解决 JVM 运行过程中出现的各种问题（OOM）</li></ol><h2 id="调优规划"><a href="#调优规划" class="headerlink" title="调优规划"></a>调优规划</h2><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓 </p></li><li><p>监控（压力测试，能看到结果） </p></li><li><p>步骤： </p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） <ol><li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li><li>吞吐量 = 用户时间 /(用户时间 + GC 时间) [PS]</li></ol></li><li> 选择回收器组合</li><li>计算内存需求（经验值 1.5G 16G）</li><li>选定 CPU（越高越好）</li><li>设定年代大小、升级年龄</li><li>设定日志参数 <ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li><li> 或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li><li><p>案例 1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？ </p><blockquote><p>这个问题比较业余，因为很多不同的服务器配置都能支撑（1.5G 16G）<br>1 小时 360000 集中时间段， 100 个订单 / 秒，（找一小时内的高峰期，1000 订单 / 秒）<br>经验值，<br>非要计算：一个订单产生需要多少内存？512K * 1000 500M 内存<br>专业一点儿问法：要求响应时间 100ms<br>压测！</p></blockquote></li><li><p>案例 2：12306 遭遇春节大规模抢票应该如何支撑？ </p><blockquote><p>12306 应该是中国并发量最大的秒杀网站：<br>号称并发量 100W 最高<br> CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发（10K 问题） 100 台机器<br>普通电商订单 -&gt; 下单 -&gt; 订单系统（IO）减库存 -&gt; 等待用户付款<br>12306 的一种可能的模型： 下单 -&gt; 减库存 和 订单 (redis kafka) 同时异步进行 -&gt; 等付款<br>减库存最后还会把压力压到一台服务器<br>可以做分布式本地库存 + 单独服务器做库存均衡<br>大流量的处理方法：分而治之</p></blockquote></li><li><p>怎么得到一个事务会消耗多少内存？ </p><blockquote><ol><li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到 </li><li>用压测来确定</li></ol></blockquote></li></ul><h2 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h2><ol><li>有一个 50 万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G<br>的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为 64 位，16G<br>的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了 <ol><li>为什么原网站慢？<br>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间变慢</li><li>为什么会更卡顿？<br>内存越大，FGC 时间越长</li><li>解决方案：PS -&gt; PN + CMS 或者 G1</li></ol></li><li> 系统 CPU 经常 100%，如何调优？(面试高频)<br>CPU 100% 那么一定有线程在占用系统资源， <ol><li>找出哪个进程 cpu 高（top）</li><li>该进程中的哪个线程 cpu 高（top -Hp）</li><li>导出该线程的堆栈（jstack）</li><li>查找哪个方法（栈帧）消耗时间（jstack）</li><li>工作线程占比高 | 垃圾回收线程占比高</li></ol></li><li>系统内存飙高，如何查找问题？（面试高频） <ol><li>导出堆内存（jmap）</li><li>分析（jhat jvisualvm mat jprofiler … ）</li></ol></li><li>如何监控 JVM <ol><li>jstat jvisualvm jprofiler arthas top…</li></ol></li></ol><h2 id="解决-JVM-运行中的问题"><a href="#解决-JVM-运行中的问题" class="headerlink" title="解决 JVM 运行中的问题"></a>解决 JVM 运行中的问题</h2><h3 id="一个案例理解常用工具"><a href="#一个案例理解常用工具" class="headerlink" title="一个案例理解常用工具"></a>一个案例理解常用工具</h3><ol><li><p>测试代码： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T15_FullGC_Problem01</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CardInfo</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"张三"</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">50</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;){</span><br><span class="line">            modelFit();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modelFit</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">        taskList.forEach(info -&gt; {</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            executor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">                <span class="comment">//do sth with info</span></span><br><span class="line">                info.m();</span><br><span class="line"></span><br><span class="line">            }, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title function_">getAllCardInfo</span><span class="params">()</span>{</span><br><span class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="type">CardInfo</span> <span class="variable">ci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardInfo</span>();</span><br><span class="line">            taskList.add(ci);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01 </p></li><li><p>运维团队首先受到报警信息（CPU Memory） </p></li><li><p>top 命令观察到问题：内存不断增长 CPU 占用率居高不下 </p></li><li><p>top -Hp 观察进程中的线程，哪个线程 CPU 和内存占比高 </p></li><li><p>jps 定位具体 java 进程<br>jstack 定位线程状况，重点关注：WAITING BLOCKED<br>eg.<br>waiting on &lt;0x0000000088ca3310&gt; （a java.lang.Object）<br>假如有一个进程中 100 个线程，很多线程都在 waiting on <xx> ，一定要找到是哪个线程持有这把锁<br>怎么找？搜索 jstack dump 的信息，找<xx> ，看哪个线程持有这把锁 RUNNABLE </xx></xx></p></li><li><p>线程的名称（尤其是线程池）都要写有意义的名称 </p></li><li><p>jinfo pid </p></li><li><p>jstat -gc 动态观察 gc 情况 / 阅读 GC 日志发现频繁 GC /arthas 观察 /jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个 500 个毫秒打印 GC 的情况<br>如果面试官问你是怎么定位 OOM 问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmdline arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察） </p></li><li><p>jmap - histo 4655 | head -20，查找有多少对象产生 </p></li><li><p>jmap -dump:format=b,file=xxx pid ：<br>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<br>1：设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件<br>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响<br>3：在线定位（一般小点儿公司用不到） </p></li><li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01 </p></li><li><p>使用 MAT /jhat/jvisualvm 进行 dump 文件分析<br><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html">java 命令 –jhat 命令使用</a><br>jhat -J-mx512M xxx.dump<br><a href="http://192.168.17.11:7000/">http://192.168.17.11:7000</a><br>拉到最后：找到对应链接<br>可以使用 OQL 查找特定问题对象 </p></li><li><p>找到代码的问题</p></li></ol><h3 id="jconsole-远程连接"><a href="#jconsole-远程连接" class="headerlink" title="jconsole 远程连接"></a>jconsole 远程连接</h3><ol><li><p>程序启动加入参数： </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果遭遇 Local host name unknown：XXX 的错误，修改 /etc/hosts 文件，把 XXX 加入进去 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.17</span><span class="number">.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></tbody></table></figure></li><li><p>关闭 linux 防火墙（实战中应该打开对应端口） </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></tbody></table></figure></li><li><p>windows 上打开 jconsole 远程连接 192.168.17.11:11111</p></li></ol><h3 id="jvisualvm-远程连接"><a href="#jvisualvm-远程连接" class="headerlink" title="jvisualvm 远程连接"></a>jvisualvm 远程连接</h3><p>简单做法：<a href="https://www.cnblogs.com/liugh/p/7620336.html">使用 jvisualvm 的 jstatd 方式远程监控 Java 程序</a></p><h3 id="jprofiler（收费）"><a href="#jprofiler（收费）" class="headerlink" title="jprofiler（收费）"></a>jprofiler（收费）</h3><h3 id="arthas-在线排查工具"><a href="#arthas-在线排查工具" class="headerlink" title="arthas 在线排查工具"></a>arthas 在线排查工具</h3><ul><li>为什么需要在线排查？<br>在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的 threaddump 或者 heapdump 不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li><li>jvm 观察 jvm 信息</li><li> thread &nbsp;定位线程问题</li><li> dashboard 观察系统情况</li><li> heapdump + jhat 分析</li><li> jad 反编译<br>动态代理生成类的问题定位<br>第三方的类（观察代码）<br>版本问题（确定自己最新提交的版本是不是被使用）</li><li>redefine 热替换<br>目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性<br>m() -&gt; mm()</li><li>sc &nbsp;- search class</li><li>watch &nbsp;- watch method</li><li> 没有包含的功能：jmap</li></ul><h3 id="产生原因案例"><a href="#产生原因案例" class="headerlink" title="产生原因案例"></a>产生原因案例</h3><p>OOM 产生的原因多种多样，有些程序未必产生 OOM，不断 FGC（CPU 飙高，但内存回收特别少）（上面案例）</p><ol><li><p>硬件升级系统反而卡顿的问题（见上） </p></li><li><p>线程池不当运用产生 OOM 问题（见上）<br>不断的往 List 里加对象（实在太 LOW） </p></li><li><p>jira 问题<br>实际生产参数案例： </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xms9216m -Xmx9216m </span><br><span class="line">-XX:-OmitStackTraceInFastThrow </span><br><span class="line">-Xloggc:/opt/xxx/logs/xxx-gc-%t.log </span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br><span class="line">-XX:GCLogFileSize=20M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCCause -classpath /opt/xxx/bin/...jar</span><br></pre></td></tr></tbody></table></figure><p><br>实际系统不断重启<br>解决问题 加内存 + 更换垃圾回收器 G1<br>真正问题在哪儿？不知道 </p></li><li><p>tomcat http-header-size 过大问题（Hector） </p></li><li><p>lambda 表达式导致方法区溢出问题（MethodArea / Perm Metaspace）<br>LambdaGC.java &nbsp; &nbsp; -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails <span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">"C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar"</span> com.mashibing.jvm.gc.LambdaGC</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 11341K-&gt;1880K(38400K)] 11341K-&gt;1888K(125952K), <span class="number">0.0022190</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 1880K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;1777K(35328K)] 1888K-&gt;1777K(73728K), [Metaspace: 8164K-&gt;8164K(1056768K)], <span class="number">0.0100681</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(38400K)] 1777K-&gt;1777K(73728K), <span class="number">0.0005698</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Last ditch collection)</span> [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 1777K-&gt;1629K(67584K)] 1777K-&gt;1629K(105984K), [Metaspace: 8164K-&gt;8156K(1056768K)], <span class="number">0.0124299</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:<span class="number">388</span>)</span><br><span class="line">at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:<span class="number">411</span>)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">at sun.misc.Unsafe.defineClass(Native Method)</span><br><span class="line">at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:<span class="number">63</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">399</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">394</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:<span class="number">393</span>)</span><br><span class="line">at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:<span class="number">112</span>)</span><br><span class="line">at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:<span class="number">398</span>)</span><br><span class="line">at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:<span class="number">360</span>)</span><br><span class="line">at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:<span class="number">1574</span>)</span><br><span class="line">at java.io.ObjectStreamClass.access$<span class="number">1500</span>(ObjectStreamClass.java:<span class="number">79</span>)</span><br><span class="line">at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">519</span>)</span><br><span class="line">at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:<span class="number">391</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1134</span>)</span><br><span class="line">at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:<span class="number">727</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:<span class="number">719</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:<span class="number">690</span>)</span><br><span class="line">at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:<span class="number">439</span>)</span><br><span class="line">at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:<span class="number">550</span>)</span><br><span class="line">at sun.management.Agent.startLocalManagementAgent(Agent.java:<span class="number">137</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>直接内存溢出问题（少见）<br>《深入理解 Java 虚拟机》P59，使用 Unsafe 分配直接内存，或者使用 NIO 的问题 </p></li><li><p>栈溢出问题<br>-Xss 设定太小 </p></li><li><p>比较一下这两段程序的异同，分析哪一个是更优的写法： </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) {</span><br><span class="line">    o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>重写 finalize 引发频繁 GC<br>小米云，HBase 同步系统，系统通过 nginx 访问超时报警，最后排查，C++ 程序员重写 finalize 引发频繁 GC 问题<br>为什么 C++ 程序员会重写 finalize？（new delete）<br>finalize 耗时比较长（200ms） </p></li><li><p>如果有一个系统，内存一直消耗不超过 10%，但是观察 GC 日志，发现 FGC 总是频繁产生，会是什么引起的？<br>System.gc () (这个比较 Low) </p></li><li><p>Distuptor 有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出 (来自 死物风情) </p></li><li><p>用 jvm 都会溢出，mycat 用崩过，1.6.5 某个临时版本解析 sql 子查询算法有问题，9 个 exists 的联合 sql 就导致生成几百万的对象（来自 死物风情） </p></li><li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池，<br>解决方案：减少堆空间（太 TM low 了），预留更多内存产生 native thread<br>JVM 内存占物理内存比例 50% - 80%</p></li></ol><h1 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JVM 的命令行参数参考</a><br>HotSpot 参数分类</p><ul><li>标准： - 开头，所有的 HotSpot 都支持 </li><li>非标准：-X 开头，特定版本 HotSpot 支持特定命令 </li><li>不稳定：-XX 开头，下个版本可能取消</li></ul><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li><li> -XX:+UseTLAB<br>使用 TLAB，默认打开</li><li> -XX:+PrintTLAB<br>打印 TLAB 的使用情况</li><li> -XX:TLABSize<br>设置 TLAB 大小</li><li> -XX:+DisableExplictGC<br>System.gc () 不管用 ，FGC</li><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintHeapAtGC</li><li>-XX:+PrintGCTimeStamps</li><li>-XX:+PrintGCCauses</li><li>-XX:+PrintGCApplicationConcurrentTime（低）<br>打印应用程序时间</li><li> -XX:+PrintGCApplicationStoppedTime （低）<br>打印暂停时长</li><li> -XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li><li> -verbose:class<br>类加载详细过程</li><li> -XX:+PrintVMOptions</li><li>-XX:+PrintFlagsFinal</li><li>-XX:+PrintFlagsInitial：查看所有 JVM 参数启动的初始值</li><li> -XX:+PrintCommandLineFlags：默认的参数</li><li> -Xloggc:opt/log/gc.log</li><li>-XX:MaxTenuringThreshold<br>升代年龄，最大值 15</li><li> 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数 -XX:CompileThreshold 逃逸分析 标量替换 …<br>这些不建议设置</li></ul><h2 id="Parallel-常用参数"><a href="#Parallel-常用参数" class="headerlink" title="Parallel 常用参数"></a>Parallel 常用参数</h2><ul><li>-XX:SurvivorRatio</li><li>-XX:PreTenureSizeThreshold<br>大对象到底多大</li><li> -XX:MaxTenuringThreshold</li><li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于 CMS，一般设为和 CPU 核数相同</li><li> -XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li></ul><h2 id="CMS-常用参数"><a href="#CMS-常用参数" class="headerlink" title="CMS 常用参数"></a>CMS 常用参数</h2><ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:ParallelCMSThreads<br>CMS 线程数量</li><li> -XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始 CMS 收集，默认是 68%（近似值），如果频繁发生 SerialOld 卡顿，应该调小，（频繁 CMS 回收）</li><li>-XX:+UseCMSCompactAtFullCollection<br>在 FGC 时进行压缩</li><li> -XX:CMSFullGCsBeforeCompaction<br>多少次 FGC 之后进行压缩</li><li> -XX:+CMSClassUnloadingEnabled</li><li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行 Perm 回收</li><li> GCTimeRatio<br>设置 GC 时间占用程序运行时间的百分比</li><li> -XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代</li></ul><h2 id="G1-常用参数"><a href="#G1-常用参数" class="headerlink" title="G1 常用参数"></a>G1 常用参数</h2><ul><li>-XX:+UseG1GC</li><li>-XX:MaxGCPauseMillis<br>建议值，G1 会尝试调整 Young 区的块数来达到这个值</li><li> -XX:GCPauseIntervalMillis<br>？GC 的间隔时间</li><li> -XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着 size 增加，垃圾的存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长<br>ZGC 做了改进（动态区块大小）</li><li>G1NewSizePercent<br>新生代最小比例，默认为 5%</li><li>G1MaxNewSizePercent<br>新生代最大比例，默认为 60%</li><li>GCTimeRatio<br>GC 时间建议比例，G1 会根据这个值调整堆空间</li><li> ConcGCThreads<br>线程数量</li><li> InitiatingHeapOccupancyPercent<br>启动 G1 的堆空间占用比例</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blogs.oracle.com/jonthecollector/our-collectors">Our Collectors</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">Java Platform, Standard Edition Tools Reference</a></li><li><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp">Java HotSpot VM Options</a></li><li>JVM 调优参考文档： <a href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li><li><a href="https://www.cnblogs.com/nxlhero/p/11660854.html">利用 JVM 在线调试工具排查线上问题</a></li><li><a href="https://www.jianshu.com/p/507f7e0cc3a3">Arthas 使用</a>：arthas 常用命令</li><li> Arthas 手册： <ol><li>启动 arthas java -jar arthas-boot.jar</li><li> 绑定 java 进程</li><li> dashboard 命令观察系统整体情况</li><li> help 查看帮助</li><li> help xx 查看具体命令帮助</li></ol></li><li> jmap 命令参考： <a href="https://www.jianshu.com/p/507f7e0cc3a3">https://www.jianshu.com/p/507f7e0cc3a3</a> <ol><li>jmap -heap pid</li><li>jmap -histo pid</li><li>jmap -clstats pid</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-从编码到执行&quot;&gt;&lt;a href=&quot;#Java-从编码到执行&quot; class=&quot;headerlink&quot; title=&quot;Java 从编码到执行&quot;&gt;&lt;/a&gt;Java 从编码到执行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;-Xmixed：混合模式&lt;ul&gt;
&lt;li&gt;使用解释器 +</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土⑧：常用命令</title>
    <link href="https://ccomma.cn/b4ce99d25d0d/"/>
    <id>https://ccomma.cn/b4ce99d25d0d/</id>
    <published>2023-01-22T09:12:06.000Z</published>
    <updated>2024-04-02T03:56:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><h2 id="1-redis-cli"><a href="#1-redis-cli" class="headerlink" title="1. redis-cli"></a>1. redis-cli</h2><p>执行命令<br><strong><em>例：</em></strong><br>远程 redis 服务上执行命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></tbody></table></figure><h2 id="2-ping"><a href="#2-ping" class="headerlink" title="2. ping"></a>2. ping</h2><p>该命令用于检测 redis 服务是否启动<br><strong><em>例：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PING</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="二、Redis-键"><a href="#二、Redis-键" class="headerlink" title="二、Redis 键"></a>二、Redis 键</h1><h2 id="1-增删查改"><a href="#1-增删查改" class="headerlink" title="1. 增删查改"></a>1. 增删查改</h2><p><strong>1.1. set key value</strong><br>赋值</p><ul><li>setnx key value：key 不存在时设置</li><li> set key value xx：key 存在时才设置</li></ul><p><strong>1.2. get key</strong><br>取值<br><strong>1.3. del key [key…..]</strong><br>可以删除一个或多个键，返回值是删除的键的个数，不支持通配符删除<br><strong>1.4. mget key1 key2 key3</strong><br>批量获取 key，原子操作<br>取不到的 key 返回 null<br><strong>1.5. mset key1 value1 key2 value2</strong><br>批量设置 key-value<br><strong>1.6. getset key newvalue</strong><br>设值后返回旧值<br><strong>1.7. append key value</strong><br>追加值</p><h2 id="2-key-信息"><a href="#2-key-信息" class="headerlink" title="2. key 信息"></a>2. key 信息</h2><p><strong>2.1. keys</strong></p><ul><li>? 匹配一个字符</li><li><ul><li>匹配任意个（包括 0 个）字符</li></ul></li><li> [] 匹配括号间的任一个字符，可以使用 “-“ 符号表示一个范围，如 a [b-d] 可以匹配 “ab”,”ac”,”ad”</li><li>\x 匹配字符 x，用于转义符号，如果要匹配 “?” 就需要使用？</li></ul><p>注： 一般不在生产环境中使用<br><strong>2.2. dbsize</strong><br>计算 key 的总数<br><strong>2.3. exists key</strong><br>如果存在，返回整数类型 1 ，否则返回 0<br><strong>2.4. type key</strong><br>获得键值的数据类型<br>返回值可能是 string (字符串类型) hash (散列类型) list (列表类型) set (集合类型) zset (有序集合类型)</p><h2 id="3-自增-自减"><a href="#3-自增-自减" class="headerlink" title="3. 自增/自减"></a>3. 自增 / 自减</h2><p><strong>3.1. incr key</strong><br>当存储的字符串是整数形式时，redis 提供了一个使用的命令 incr 作用是让当前的键值递增，并返回递增后的值<br>当要操作的键不存在时会默认键值为 0 ，所以第一次递增后的结果是 1 ，当键值不是整数时 redis 会提示错误<br><strong>3.2. incrby key increment</strong><br>通过 increment 参数指定一次增加的数值<br>incrby num 2<br><strong>3.3. decr key</strong><br>自减<br>同 incr key<br><strong>3.4. decrby key</strong><br>自减<br>同 incrby key increment</p><h2 id="4-过期时间"><a href="#4-过期时间" class="headerlink" title="4. 过期时间"></a>4. 过期时间</h2><p><strong>4.1. expire key seconds</strong><br>设置过期时间<br><strong>4.2. ttl key</strong><br>查询 key 的剩余过期时间<br>-2： 不存在 key<br>-1： 未设置过期时间<br><strong>4.3. persist key</strong><br>去掉 key 的过期时间</p><h2 id="5-hash"><a href="#5-hash" class="headerlink" title="5. hash"></a>5. hash</h2><p><strong>5.1. hset key field value</strong><br>设置 hash key 对应 的 field 的 value<br><strong>5.2. hget key field</strong><br>获取 hash key 对应 的 field 的 value<br><strong>5.3. hdel key field</strong><br>删除 hash key 对应 的 field 的 value<br><strong>5.4. hexists key field</strong><br>判断 hash key 是否有 field<br><strong>5.5. hlen key</strong><br>获取 hash key field 的数量<br><strong>5.6. hgetall key</strong><br>获取 hash key 所有的 field 和 value<br><strong>5.7. hkeys key</strong><br>获取 hash key 所有的 field<br><strong>5.8. hvals key</strong><br>获取 hash key 所有的 field 中的 value</p><h2 id="6-list"><a href="#6-list" class="headerlink" title="6. list"></a>6. list</h2><p><strong>6.1. 插入</strong></p><ul><li><strong>rpush key value1 value2 value3：</strong> 列表右端插入多个值</li><li><strong> lpush key value1 value2 value3：</strong> 列表左端插入多个值</li><li><strong> linsert key before|after value newValue：</strong> 在键为 key 的 list 的指定值 value 的 前 | 后 插入 newValue</li></ul><p><strong>6.2. 删除</strong></p><ul><li><strong>lpop key：</strong> 从列表左侧弹出一个元素</li><li><strong> rpop key：</strong> 从列表右侧弹出一个元素</li><li><strong> lrem key count value：</strong> 删除 count 个与 value 的值相等的值<ul><li> count &gt; 0： 从左到右删除 count 个与 value 的值相等的值</li><li> count &lt; 0： 从右到左删除 count 个与 value 的值相等的值</li><li> count = 0： 删除所有与 value 的值相等的值</li></ul></li><li><strong> ltrim key start end：</strong> 按索引截取 [start, end] 范围内的值，范围外的值删除。索引从 0 开始</li></ul><p><strong>6.3. 查找</strong></p><ul><li><strong>lrange key start end：</strong> 获取索引在 [start, end] 范围内的值。左边索引从 0 开始递增，右边索引从 -1 开始递减</li><li><strong> lindex key index：</strong> 按索引获取值。左边索引从 0 开始递增，右边索引从 -1 开始递减</li><li><strong> llen：</strong> 获取列表长度</li></ul><p><strong>6.4. 更新</strong></p><ul><li><strong>lset key index newValue：</strong> 设置列表指定索引值为 newValue</li></ul><h2 id="7-set"><a href="#7-set" class="headerlink" title="7. set"></a>7. set</h2><p><strong>7.1. 添加</strong></p><ul><li><strong>sadd key element：</strong> 添加 element（若已存在，则添加失败）</li></ul><p><strong>7.2. 删除</strong></p><ul><li><strong>spop key：</strong> 随机弹出一个元素</li><li><strong> srem key element：</strong> 删除 element</li></ul><p><strong>7.3. 查找</strong></p><ul><li><strong>scard key：</strong> 获取元素总数</li><li><strong> sismember key element：</strong> 判断键为 key 的 set 中是否存在 element</li><li><strong>srandmember key count：</strong> 从键为 key 的 set 中随机选出 count 个元素</li><li><strong> smembers key：</strong> 获取键为 key 的 set 的全部元素（无序）</li></ul><p><strong>7.4. 差集、交集、并集</strong></p><ul><li><strong>sdiff key1 key2：</strong> 求得键为 key1 、key2 的两个 set 的差集（key1 - key2）</li><li><strong>sinter key1 key2：</strong> 求得键为 key1、key2 的两个 set 的交集</li><li><strong> sunion key1 key2：</strong> 求得键为 key1、key2 的两个 set 的并集</li></ul><h2 id="8-zset"><a href="#8-zset" class="headerlink" title="8. zset"></a>8. zset</h2><p><strong>8.1. 添加</strong></p><ul><li><strong>zadd key score element：</strong> 添加 score 和 element（可以多对）</li><li><strong>zincrby key increScore element：</strong> 使 element 的分数增加 increScore</li></ul><p><strong>8.2. 删除</strong></p><ul><li><strong>zrem key element：</strong> 删除 element</li><li><strong>zremrangebyrank key startRank endRank：</strong> 删除排名在 [startRank, endRank] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li><li><strong>zremrangebyscore key startScore endScore：</strong> 删除分数在 [startScore, endScore] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li></ul><p><strong>8.3. 查询</strong></p><ul><li><strong>zcard key：</strong> 获取元素总数</li><li><strong> zount key startScore endScore：</strong> 获取分数在 [startScore, endScore] 范围内的元素个数，左边索引从 0 开始递增，右边索引从 -1 开始递减。</li><li><strong>zrank key element：</strong> 获取 element 的排名（升序）</li><li><strong>zscore key element：</strong> 获取 element 的分数</li><li><strong> zrange key startRank endRank [withscores]：</strong> 获取排名在 [startRank, endRank] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。<ul><li>withscores：携带分数</li></ul></li><li> **zrangebyscore key startScore endScore [withscores]： ** 获取分数在 [startScore, endScore] 范围内的升序元素，左边索引从 0 开始递增，右边索引从 -1 开始递减。<ul><li>withscores：携带分数</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://redis.io/commands">commands</a></li><li><a href="https://www.cnblogs.com/kevinws/p/6281395.html">Redis 常用命令整理</a></li><li><a href="http://doc.redisfans.com/?tdsourcetag=s_pctim_aiomsg#redis">Redis 命令参考</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、准备&quot;&gt;&lt;a href=&quot;#一、准备&quot; class=&quot;headerlink&quot; title=&quot;一、准备&quot;&gt;&lt;/a&gt;一、准备&lt;/h1&gt;&lt;h2 id=&quot;1-redis-cli&quot;&gt;&lt;a href=&quot;#1-redis-cli&quot; class=&quot;headerlink&quot; title=&quot;1. redis-cli&quot;&gt;&lt;/a&gt;1. redis-cli&lt;/h2&gt;&lt;p&gt;执行命令&lt;br&gt;&lt;strong&gt;&lt;em&gt;例：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;远程 redis 服务上执行命令&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis-cli -h host -p port -a password&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-ping&quot;&gt;&lt;a href=&quot;#2-ping&quot; class=&quot;headerlink&quot; title=&quot;2. ping&quot;&gt;&lt;/a&gt;2. ping&lt;/h2&gt;&lt;p&gt;该命令用于检测 redis 服务是否启动&lt;br&gt;&lt;strong&gt;&lt;em&gt;例：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis 127.0.0.1:6379&amp;gt; PING&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis.conf 配置参考</title>
    <link href="https://ccomma.cn/a3bb20bb5445/"/>
    <id>https://ccomma.cn/a3bb20bb5445/</id>
    <published>2023-01-22T09:12:06.000Z</published>
    <updated>2024-04-02T03:56:26.594Z</updated>
    
    <content type="html"><![CDATA[<ul><li>daemonize no</li><li>port 6379</li><li>dir /usr/local/redis/data</li><li>logfile “6379.log”</li></ul><span id="more"></span><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis配置文件样例</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note on units: when memory size is needed, it is possible to specifiy</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it <span class="keyword">in</span> the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 1k =&gt; 1000 bytes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用<span class="built_in">yes</span>启用守护进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Redis监听端口，默认端口为6379</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果指定0端口，表示Redis不监听TCP连接</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定的主机地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the path <span class="keyword">for</span> the unix socket that will be used to listen <span class="keyword">for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on a unix socket when not specified.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># unixsocket /tmp/redis.sock</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unixsocketperm 755</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">debug (很多信息, 对开发／测试比较有用)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">notice (moderately verbose, what you want <span class="keyword">in</span> production probably)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel verbose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null</span></span><br><span class="line">logfile stdout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">To <span class="built_in">enable</span> logging to the system logger, just <span class="built_in">set</span> <span class="string">'syslog-enabled'</span> to <span class="built_in">yes</span>,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-enabled no</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the syslog identity.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-ident redis</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">syslog-facility local0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置数据库的数量，默认数据库为0，可以使用<span class="keyword">select</span> &lt;dbid&gt;命令在连接上指定数据库<span class="built_in">id</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dbid是从0到‘databases’-1的数目</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################### SNAPSHOTTING  #################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Save the DB on disk:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  number of write operations against the DB occurred.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   满足以下条件将会同步数据:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  900秒（15分钟）内有1个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  300秒（5分钟）内有10个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  60秒内有10000个更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Note: 可以把所有“save”行注释掉，这样就取消同步操作了</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定存储至本地数据库时是否压缩数据，默认为<span class="built_in">yes</span>，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定本地数据库文件名，默认值为dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作目录.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定本地数据库存放目录，文件名由上一个dbfilename配置项指定</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Also the Append Only File will be created inside this directory.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 注意，这里只能指定一个目录，不能指定文件名</span></span></span><br><span class="line">dir ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################ REPLICATION #################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">so <span class="keyword">for</span> example it is possible to configure the slave to save the DB with a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">different interval, or to listen to another port, and so on.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当master服务设置了密码保护时，slav服务连接master的密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下文的“requirepass”配置项可以指定密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When a slave lost the connection with the master, or when the replication</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is still <span class="keyword">in</span> progress, the slave can act <span class="keyword">in</span> two different ways:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   still reply to client requests, possibly with out of data data, or the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   data <span class="built_in">set</span> may just be empty <span class="keyword">if</span> this is the first synchronization.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 2) if slave-serve-stale data is set to 'no' the slave will reply with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   an error <span class="string">"SYNC with master in progress"</span> to all the kind of commands</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   but to INFO and SLAVEOF.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">slave-serve-stale-data <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Slaves send PINGs to server <span class="keyword">in</span> a predefined interval. It<span class="string">'s possible to change</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">this interval with the repl_ping_slave_period option. The default value is 10</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">seconds.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># repl-ping-slave-period 10</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The following option sets a timeout for both Bulk transfer I/O timeout and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">master data or ping response timeout. The default value is 60 seconds.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is important to make sure that this value is greater than the value</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">specified for repl-ping-slave-period otherwise a timeout will be detected</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">every time there is low traffic between the master and the slave.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># repl-timeout 60</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################# SECURITY ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Warning: since Redis is pretty fast an outside user can try up to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">150k passwords per second against a good box. This means that you should</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use a very strong password otherwise it will be very easy to break.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">requirepass foobared</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Command renaming.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is possilbe to change the name of dangerous commands in a shared</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">environment. For instance the CONFIG command may be renamed into something</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of hard to guess so that it will be still available for internal-use</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">tools but not available for general clients.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Example:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It is also possilbe to completely kill a command renaming it into</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">an empty string:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># rename-command CONFIG ""</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################## LIMITS ####################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">maxclients 128</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Don'</span>t use more memory than the specified amount of bytes.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When the memory <span class="built_in">limit</span> is reached Redis will try to remove keys with an</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">EXPIRE <span class="built_in">set</span>. It will try to start freeing keys that are going to expire</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> little time and preserve keys with a longer time to live.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis will also try to remove objects from free lists <span class="keyword">if</span> possible.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If all this fails, Redis will start to reply with errors to commands</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that will use more memory, like SET, LPUSH, and so on, and will <span class="built_in">continue</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to reply to most read-only commands like GET.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># WARNING: maxmemory can be a good idea mainly if you want to use Redis as a</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">'state'</span> server or cache, not as a real DB. When Redis is used as a real</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">database the memory usage will grow over the weeks, it will be obvious <span class="keyword">if</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it is going to use too much memory <span class="keyword">in</span> the long run, and you<span class="string">'ll have the time</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to upgrade. With maxmemory after the limit is reached you'</span>ll start to get</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">errors <span class="keyword">for</span> write operations, and this may even lead to DB inconsistency.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MAXMEMORY POLICY: how Redis will <span class="keyword">select</span> what to remove when maxmemory</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is reached? You can <span class="keyword">select</span> among five behavior:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">volatile-random -&gt; remove a random key with an expire <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">allkeys-&gt;random -&gt; remove a random key, any key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">noeviction -&gt; don<span class="string">'t expire at all, just return an error on write operations</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Note: with all the kind of policies, Redis will return an error on write</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      operations, when there are not suitable keys for eviction.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash">#       At the date of writing this commands are: set setnx setex append</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      getset mset msetnx exec sort</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># The default is:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># maxmemory-policy volatile-lru</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">LRU and minimal TTL algorithms are not precise algorithms but approximated</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">algorithms (in order to save memory), so you can select as well the sample</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">size to check. For instance for default Redis will check three keys and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">pick the one that was used less recently, you can change the sample size</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">using the following configuration directive.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># maxmemory-samples 3</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">############################# APPEND ONLY MODE ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Note that you can have both the async dumps and the append only file if you</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">like (you have to comment the "save" statements above to disable the dumps).</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Still if append only mode is enabled Redis will load the data from the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">log file at startup ignoring the dump.rdb file.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">log file in background when it gets too big.</span></span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定更新日志文件名，默认为appendonly.aof</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">appendfilename appendonly.aof</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The fsync() call tells the Operating System to actually write data on disk</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">instead to wait for more data in the output buffer. Some OS will really flush</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">data on disk, some other OS will just try to do it ASAP.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定更新日志条件，共有3个可选值：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">no:表示等操作系统进行数据缓存同步到磁盘（快）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">everysec:表示每秒同步一次（折衷，默认值）</span></span></span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">appendfsync no</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">When the AOF fsync policy is set to always or everysec, and a background</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">saving process (a background save or AOF log background rewriting) is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">performing a lot of I/O against the disk, in some Linux configurations</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Redis may block too long on the fsync() call. Note that there is no fix for</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">this currently, as even performing fsync in a different thread will block</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">our synchronous write(2) call.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># In order to mitigate this problem it'</span>s possible to use the following option</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that will prevent fsync() from being called <span class="keyword">in</span> the main process <span class="keyword">while</span> a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BGSAVE or BGREWRITEAOF is <span class="keyword">in</span> progress.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This means that while another child is saving the durability of Redis is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the same as <span class="string">"appendfsync none"</span>, that <span class="keyword">in</span> pratical terms means that it is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">possible to lost up to 30 seconds of <span class="built_in">log</span> <span class="keyword">in</span> the worst scenario (with the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default Linux settings).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If you have latency problems turn this to "yes". Otherwise leave it as</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">"no"</span> that is the safest pick from the point of view of durability.</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis is able to automatically rewrite the <span class="built_in">log</span> file implicitly calling</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BGREWRITEAOF when the AOF <span class="built_in">log</span> size will growth by the specified percentage.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">latest rewrite (or <span class="keyword">if</span> no rewrite happened since the restart, the size of</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the AOF at startup is used).</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This base size is compared to the current size. If the current size is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">you need to specify a minimal size <span class="keyword">for</span> the AOF file to be rewritten, this</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is useful to avoid rewriting the AOF file even <span class="keyword">if</span> the percentage increase</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">is reached but it is still pretty small.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Specify a precentage of zero in order to disable the automatic AOF</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################################# SLOW LOG ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The Redis Slow Log is a system to <span class="built_in">log</span> queries that exceeded a specified</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">but just the time needed to actually execute the <span class="built_in">command</span> (this is the only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stage of <span class="built_in">command</span> execution <span class="built_in">where</span> the thread is blocked and can not serve</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">other requests <span class="keyword">in</span> the meantime).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">what is the execution time, <span class="keyword">in</span> microseconds, to exceed <span class="keyword">in</span> order <span class="keyword">for</span> the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slow <span class="built_in">log</span>. When a new <span class="built_in">command</span> is logged the oldest one is removed from the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">queue of logged commands.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following time is expressed <span class="keyword">in</span> microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to one second. Note that a negative number disables the slow <span class="built_in">log</span>, <span class="keyword">while</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a value of zero forces the logging of every <span class="built_in">command</span>.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">There is no <span class="built_in">limit</span> to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can reclaim memory used by the slow <span class="built_in">log</span> with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 1024</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################### VIRTUAL MEMORY ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## WARNING! Virtual Memory is deprecated in Redis 2.4</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The use of Virtual Memory is strongly discouraged.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## WARNING! Virtual Memory is deprecated in Redis 2.4</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The use of Virtual Memory is strongly discouraged.</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Virtual Memory allows Redis to work with datasets bigger than the actual</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">amount of RAM needed to hold the whole dataset <span class="keyword">in</span> memory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">In order to <span class="keyword">do</span> so very used keys are taken <span class="keyword">in</span> memory <span class="keyword">while</span> the other keys</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">are swapped into a swap file, similarly to what operating systems <span class="keyword">do</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with memory pages.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定是否启用虚拟内存机制，默认值为no，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把vm-enabled设置为<span class="built_in">yes</span>，根据需要设置好接下来的三个VM参数，就可以启动VM了</span></span><br><span class="line">vm-enabled no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vm-enabled <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the path of the Redis swap file. As you can guess, swap files</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">can<span class="string">'t be shared by different Redis instances, so make sure to use a swap</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">file for every redis process you are running. Redis will complain if the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">swap file is already in use.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># Redis交换文件最好的存储是SSD（固态硬盘）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">*** WARNING *** if you are using a shared hosting the default of putting</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">the swap file under /tmp is not secure. Create a dir with access granted</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">only to Redis user and configure Redis to create the swap file there.</span></span></span><br><span class="line">vm-swap-file /tmp/redis.swap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">With vm-max-memory 0 the system will swap everything it can. Not a good</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">default, just specify the max amount of RAM you can in bytes, but it'</span>s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">better to leave some margin. For instance specify an amount of RAM</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that<span class="string">'s more or less between 60 and 80% of your free RAM.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</span></span></span><br><span class="line">vm-max-memory 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值</span></span></span><br><span class="line">vm-page-size 32</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">swap空间总容量为 vm-page-size * vm-pages</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># With the default of 32-bytes memory pages and 134217728 pages Redis will</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use a 4 GB swap file, that will use 16 MB of RAM for the page table.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># It'</span>s better to use the smallest acceptable value <span class="keyword">for</span> your application,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">but the default is large <span class="keyword">in</span> order to work <span class="keyword">in</span> most conditions.</span></span><br><span class="line">vm-pages 134217728</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Max number of VM I/O threads running at the same time.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This threads are used to <span class="built_in">read</span>/write data from/to swap file, since they</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">also encode and decode objects from disk to memory or the reverse, a bigger</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">number of threads can <span class="built_in">help</span> with big objects even <span class="keyword">if</span> they can<span class="string">'t help with</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">I/O itself as the physical device may not be able to couple with many</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">reads/writes operations at the same time.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4</span></span></span><br><span class="line">vm-max-threads 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">############################## ADVANCED CONFIG ###############################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Hashes are encoded in a special way (much more memory efficient) when they</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">have at max a given numer of elements, and the biggest element does not</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">exceed a given threshold. You can configure this limits with the following</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">configuration directives.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></span></span><br><span class="line">hash-max-zipmap-entries 512</span><br><span class="line">hash-max-zipmap-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Similarly to hashes, small lists are also encoded in a special way in order</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to save a lot of space. The special representation is only used when</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">you are under the following limits:</span></span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Sets have a special encoding in just one case: when a set is composed</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of just strings that happens to be integers in radix 10 in the range</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">of 64 bit signed integers.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">The following configuration setting sets the limit in the size of the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">set in order to use this special memory saving encoding.</span></span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Similarly to hashes and lists, sorted sets are also specially encoded in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">order to save a lot of space. This encoding is only used when the length and</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">elements of a sorted set are below the following limits:</span></span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">order to help rehashing the main Redis hash table (the one mapping top-level</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">keys to values). The hash table implementation redis uses (see dict.c)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">performs a lazy rehashing: the more operation you run into an hash table</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">that is rhashing, the more rehashing "steps" are performed, so if the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">server is idle the rehashing is never complete and some more memory is used</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">by the hash table.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># The default is to use this millisecond 10 times every second in order to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">active rehashing the main dictionaries, freeing memory when possible.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># If unsure:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">use "activerehashing no" if you have hard latency requirements and it is</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">not a good thing in your environment that Redis can reply form time to time</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">to queries with 2 milliseconds delay.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定是否激活重置哈希，默认为开启</span></span></span><br><span class="line">activerehashing yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">################################# INCLUDES ###################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">include /path/to/local.conf</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">include /path/to/other.conf</span></span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;daemonize no&lt;/li&gt;
&lt;li&gt;port 6379&lt;/li&gt;
&lt;li&gt;dir /usr/local/redis/data&lt;/li&gt;
&lt;li&gt;logfile “6379.log”&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土⑦：高级特性</title>
    <link href="https://ccomma.cn/56926004f999/"/>
    <id>https://ccomma.cn/56926004f999/</id>
    <published>2022-12-28T11:35:09.000Z</published>
    <updated>2024-04-02T03:56:26.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、慢查询"><a href="#一、慢查询" class="headerlink" title="一、慢查询"></a>一、慢查询</h1><h2 id="1-Redis-请求过程"><a href="#1-Redis-请求过程" class="headerlink" title="1. Redis 请求过程"></a>1. Redis 请求过程</h2><p>慢查询发生在 执行命令阶段<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e54533b87280e919df50ae491be9c654.png" alt="image.png"></p><span id="more"></span><h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h2><p>保存在内存中的长度固定的 <strong>先进先出队列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d8834ce0eb85fc2f1215b30305114cc7.png" alt="image.png"></p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p><strong><em>slowlog-max-len：</em></strong> 最大长度，默认为 128<br><strong><em>slowlog-log-slower-than=1000：</em></strong> 超过 1s 则加入慢查队列中，默认为 10000</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 动态配置</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config set slowlog-log-slower-than=10000</span><br></pre></td></tr></tbody></table></figure><h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><p><strong><em>slowlog get [n]：</em></strong> 获取慢查询队列，n 为条数<br><strong><em>slowlog len：</em></strong> 获取慢查询队列长度<br><strong><em>slowlog reset：</em></strong> 清空慢查询队列</p><h1 id="二、流水线（pipeline）"><a href="#二、流水线（pipeline）" class="headerlink" title="二、流水线（pipeline）"></a>二、流水线（pipeline）</h1><p><strong><em>作用：</em></strong> 解决批量执行 hset、hget 等操作的问题<br><strong><em>非原子命令</em></strong><br><strong><em>只能作用在一个 Redis 节点上</em></strong><br><strong><em>例：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis("127.0.0.1", 6379);</span><br><span class="line">for (int i = 0; i &lt; 100; i++) {</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    for (int j = i * 100; j &lt; (i + 1) * 100; j++) {</span><br><span class="line">        pipeline.hset("hashkey:" + j, "field" + j, "value" + j);</span><br><span class="line">    }</span><br><span class="line">    pipeline.syncAndReturnAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、位图（Bitmap）"><a href="#三、位图（Bitmap）" class="headerlink" title="三、位图（Bitmap）"></a>三、位图（Bitmap）</h1><p><strong><em>setbit key offset value：</em></strong> 给位图指定索引设置值，返回之前位的值<br><strong>例：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bb66464075181714bc5d0e455049de93.png" alt="image.png"><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bca2b6ea3715c2b07d6589450a2542ef.png" alt="image.png"><br><strong><em>get key offset：</em></strong> 返回位图指定索引的值<br><strong><em>bitcount key [start] [end]：</em></strong> 获取位图指定范围值为 1 的个数<br><strong><em>bitops key targetBit [start] [end]：</em></strong> 计算位图指定范围内第一个值等于 targetBit 的位置<br><strong><em>bitop op destkey key [key…]：</em></strong> 把多个 Bitmap 的 与、或、非、异或 操作的结果保存在 destkey 中</p><ul><li>op： and（与）、or（或）、not（非）、xor（异或）</li></ul><h1 id="四、HyperLogLog"><a href="#四、HyperLogLog" class="headerlink" title="四、HyperLogLog"></a>四、HyperLogLog</h1><p><strong><em>概述：</em></strong> 以极小的空间统计独立数量，本质还是 string 类型</p><h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><p><strong><em>pfadd key element [element…]：</em></strong> 添加元素<br><strong><em>pfcount key [key…]：</em></strong> 计算总数<br><strong><em>pfmerge destkey key [key…]：</em></strong> 合并多个 hyperloglog</p><h2 id="2-缺陷"><a href="#2-缺陷" class="headerlink" title="2. 缺陷"></a>2. 缺陷</h2><p><strong><em>错误率：</em></strong> 0.81%</p><h1 id="五、GEO"><a href="#五、GEO" class="headerlink" title="五、GEO"></a>五、GEO</h1><p><strong><em>概述：</em></strong> 地理信息定位。存储经纬度，计算两地距离和范围等，本质是 zset 类型</p><h2 id="1-命令-1"><a href="#1-命令-1" class="headerlink" title="1. 命令"></a>1. 命令</h2><p><strong><em>geo key longitude latitude member [longitude latitude member…]：</em></strong> 添加地理位置信息<br><strong><em>geopos key member：</em></strong> 获取地理位置信息<br><strong><em>geodist key member1 member2 [unit]：</em></strong> 获取两个地理位置的距离</p><ul><li>unit： m、km、mi、ft</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、慢查询&quot;&gt;&lt;a href=&quot;#一、慢查询&quot; class=&quot;headerlink&quot; title=&quot;一、慢查询&quot;&gt;&lt;/a&gt;一、慢查询&lt;/h1&gt;&lt;h2 id=&quot;1-Redis-请求过程&quot;&gt;&lt;a href=&quot;#1-Redis-请求过程&quot; class=&quot;headerlink&quot; title=&quot;1. Redis 请求过程&quot;&gt;&lt;/a&gt;1. Redis 请求过程&lt;/h2&gt;&lt;p&gt;慢查询发生在 执行命令阶段&lt;br&gt;&lt;img data-src=&quot;https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e54533b87280e919df50ae491be9c654.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土⑥：分片</title>
    <link href="https://ccomma.cn/045695264e87/"/>
    <id>https://ccomma.cn/045695264e87/</id>
    <published>2022-12-12T14:35:12.000Z</published>
    <updated>2024-04-02T03:56:26.595Z</updated>
    
    <content type="html"><![CDATA[<p>分片位置：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上</li><li>服务器分片：Redis Cluster</li></ul><span id="more"></span><h2 id="1-顺序分片"><a href="#1-顺序分片" class="headerlink" title="1. 顺序分片"></a>1. 顺序分片</h2><p><strong><em>概述：</em></strong> 将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分片可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000<br><strong><em>优点：</em></strong></p><ul><li>能保持数据 <strong>原有的顺序</strong></li><li>并且能够 <strong>准确控制每台服务器存储的数据量</strong>，从而使得存储空间的利用率最大</li></ul><h2 id="2-哈希分片"><a href="#2-哈希分片" class="headerlink" title="2. 哈希分片"></a>2. 哈希分片</h2><p><strong><em>概述：</em></strong> 哈希分片就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash (key)% N<br><strong><em>问题：</em></strong> 传统的哈希分片算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移</p><h2 id="3-一致性哈希"><a href="#3-一致性哈希" class="headerlink" title="3. 一致性哈希"></a>3. 一致性哈希</h2><p><strong><em>概述：</em></strong> Distributed Hash Table（DHT）是一种哈希分片方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题<br><strong><em>基本原理：</em></strong><br>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/34b25f0e3b87856daa5e01354922f618.png" alt="image.png"></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点<br>例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba169b2511d0030a34be78d0f88bc2b0.png" alt="image.png"></p><h2 id="4-虚拟节点（Redis-Cluster）"><a href="#4-虚拟节点（Redis-Cluster）" class="headerlink" title="4. 虚拟节点（Redis Cluster）"></a>4. 虚拟节点（Redis Cluster）</h2><p><strong><em>问题：</em></strong> 上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同<br><strong><em>原因：</em></strong> 数据不均匀主要是因为 <strong>节点在哈希环上分布的不均匀</strong>，这种情况在节点数量很少的情况下尤其明显<br><strong><em>解决方式：</em></strong> 通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/823cf8a9c7593081a5d5e6ddea68e730.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分片位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点&lt;/li&gt;
&lt;li&gt;代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上&lt;/li&gt;
&lt;li&gt;服务器分片：Redis Cluster&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土④：持久化</title>
    <link href="https://ccomma.cn/d4581e6c9497/"/>
    <id>https://ccomma.cn/d4581e6c9497/</id>
    <published>2022-11-27T14:56:29.000Z</published>
    <updated>2024-04-02T03:56:26.595Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><span id="more"></span><h2 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1. RDB 持久化"></a>1. RDB 持久化</h2><p><strong><em>概述：</em></strong><br>将 ** 某个时间点 ** 的所有数据都存放到硬盘上<br>可以将 <strong>快照 <strong>复制到其它服务器从而创建具有相同数据的服务器副本<br></strong><em>缺点：</em></strong></p><ul><li>如果数据量很大，保存快照的 <strong>时间会很长</strong></li><li>如果系统发生故障，将会 ** 丢失 ** 最后一次创建快照之后的数据</li><li>不支持拉链，只有一个 dump.rdb</li></ul><p><strong><em>优点：</em></strong> 回复速度相对快<br><strong><em>场景：</em></strong> 关机维护<br><strong><em>三种触发机制：</em></strong></p><ul><li><strong>save 命令：</strong><ul><li>同步</li><li>直接生成 rdb 二进制文件</li><li>若有老的备份，新的备份会替换老的备份</li></ul></li><li><strong> bgsave 命令：</strong><ul><li>异步</li><li>通过 fork () 创建一个子进程去创建 rdb 文件</li><li> fork ()：浅拷贝 + copy on write：可以做到快速拷贝，且父子互不影响<ul><li>快速拷贝</li><li>写时复制触发次数不多（不可能父子进程把所有数据都改一遍）</li></ul></li></ul></li><li><strong>配置：</strong><ul><li>save seconds changes（save 900 1）</li><li>本质为执行 bgsave</li><li> 一般都会把配置关闭</li><li>推荐配置如下 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份命名为 dump-<span class="variable">${port}</span>.rdb</span></span><br><span class="line">dbfilename "dump-${port}.rdb"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份存储位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bgsave 错误时停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩格式</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验和</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2. AOF 持久化"></a>2. AOF 持久化</h2><p><strong><em>概述：</em></strong> 将写命令添加到 AOF 文件（Append Only File）的末尾<br><strong><em>过程：</em></strong> 每次执行写命令时会把命令加入缓冲区，缓冲区根据策略进行持久化<br><strong><em>缺点：</em></strong> 体量无限变大</p><h3 id="2-1-同步选项"><a href="#2-1-同步选项" class="headerlink" title="2.1. 同步选项"></a>2.1. 同步选项</h3><p>使用 AOF 持久化需要设置同步选项，从而确保写命令 ** 什么时候 ** 会同步到磁盘文件上<br>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</p><table><thead><tr><th><strong>选项</strong></th><th><strong>同步频率</strong></th></tr></thead><tbody><tr><td> always</td><td> 每个写命令都同步</td></tr><tr><td> everysec</td><td> 每秒同步一次</td></tr><tr><td> no</td><td> 让操作系统来决定何时同步</td></tr></tbody></table><ul><li><strong> always：</strong> 会严重减低服务器的性能</li><li><strong> everysec：</strong> 比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li><li><strong> no：</strong> 并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</li></ul><h3 id="2-2-AOF-重写（4-0-以前）"><a href="#2-2-AOF-重写（4-0-以前）" class="headerlink" title="2.2. AOF 重写（4.0 以前）"></a>2.2. AOF 重写（4.0 以前）</h3><p>随着服务器写请求的增多，AOF 文件会越来越大<br>Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令<br><strong><em>原理：</em></strong> 删除抵消的命令，合并重复的命令<br><strong><em>两种方式：</em></strong></p><ul><li>bgrewriteaof 命令：<ul><li>异步</li><li>通过 fork () 创建一个子进程来在内存中执行 AOF 重写</li></ul></li><li>配置：<ul><li>推荐配置如下 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 AOF</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份名</span></span><br><span class="line">appendfilename "appendonly-${port}.aof"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">持久化策略为每秒进行</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份存储位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 重写时不会执行 AOF</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 文件重写所需的最小大小</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 文件增长率</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="2-3-AOF-重写（4-0-以后）"><a href="#2-3-AOF-重写（4-0-以后）" class="headerlink" title="2.3. AOF 重写（4.0 以后）"></a>2.3. AOF 重写（4.0 以后）</h3><p>RDB 和 AOF 混合</p><ul><li>将老的数据 RDB 到 AOF 文件中</li><li>将增量的数据以指令的方式 append 到 AOF 中</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土⑤：事务与事件</title>
    <link href="https://ccomma.cn/4ee5322c6d14/"/>
    <id>https://ccomma.cn/4ee5322c6d14/</id>
    <published>2022-11-27T12:39:22.000Z</published>
    <updated>2024-04-02T03:56:26.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><p>一个事务包含了 <strong>多个命令</strong>，服务器在执行事务期间，<strong>不会改去执行其它客户端的命令请求</strong><br>事务中的多个命令被 ** 一次性 ** 发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。<br>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><span id="more"></span><h1 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h1><p>Redis 服务器是一个事件驱动程序。</p><h2 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h2><p><strong><em>概述：</em></strong> 服务器通过套接字与客户端或者其它服务器进行通信，<strong>文件事件就是对套接字操作的抽象</strong>。<br>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 **I/O 多路复用程序 ** 来同时监听多个套接字，并将到达的事件传送给 <strong>文件事件分派器</strong>，分派器会根据套接字产生的事件类型调用相应的 <strong>事件处理器</strong>。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a1f750912f7a07dac7d91d18f89b3aeb.png" alt="image.png"></p><h2 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2. 时间事件"></a>2. 时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。<br>时间事件又分为：</p><ul><li><strong>定时事件：</strong> 是让一段程序在指定的时间之内执行一次</li><li><strong>周期性事件：</strong> 是让一段程序每隔指定时间就执行一次</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h2 id="3-事件的调度与执行"><a href="#3-事件的调度与执行" class="headerlink" title="3. 事件的调度与执行"></a>3. 事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。<br>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def aeProcessEvents():</span><br><span class="line">    # 获取到达时间离当前时间最接近的时间事件</span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    # 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br><span class="line">    if remaind_ms &lt; 0:</span><br><span class="line">        remaind_ms = 0</span><br><span class="line">    # 根据 remaind_ms 的值，创建 timeval</span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    # 处理所有已产生的文件事件</span><br><span class="line">    procesFileEvents()</span><br><span class="line">    # 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></tbody></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 初始化服务器</span><br><span class="line">    init_server()</span><br><span class="line">    # 一直处理事件，直到服务器关闭为止</span><br><span class="line">    while server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    # 服务器关闭，执行清理操作</span><br><span class="line">    clean_server()</span><br></pre></td></tr></tbody></table></figure><p>从事件处理的角度来看，服务器运行流程如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/63c539a813dc898a9f8aa3669cb5caf3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h1&gt;&lt;p&gt;一个事务包含了 &lt;strong&gt;多个命令&lt;/strong&gt;，服务器在执行事务期间，&lt;strong&gt;不会改去执行其它客户端的命令请求&lt;/strong&gt;&lt;br&gt;事务中的多个命令被 ** 一次性 ** 发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。&lt;br&gt;Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 从入门到入土③：过期策略与数据淘汰</title>
    <link href="https://ccomma.cn/9e6a2758b52d/"/>
    <id>https://ccomma.cn/9e6a2758b52d/</id>
    <published>2022-11-19T17:04:49.000Z</published>
    <updated>2024-04-02T03:56:26.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1. 过期策略"></a>1. 过期策略</h2><p><strong><em>定期删除：</em></strong> 默认每隔 <strong>100ms 随机抽取 <strong>进行检查，是否有过期的 key，有过期 key 则删除。因此没抽查到的需要惰性删除进一步筛选<br></strong><em>惰性删除：</em></strong> 获取某个 key 的时候，如果该 key 已过期，则删除。</p><span id="more"></span><h2 id="2-数据淘汰"><a href="#2-数据淘汰" class="headerlink" title="2. 数据淘汰"></a>2. 数据淘汰</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰。<br>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th><strong>策略</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td> volatile-lru</td><td> 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td> volatile-ttl</td><td> 从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td> volatile-random</td><td> 从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td> allkeys-lru</td><td> 从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td> allkeys-random</td><td> 从所有数据集中任意选择数据进行淘汰</td></tr><tr><td> noeviction</td><td> 禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。<br>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。<br>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-过期策略&quot;&gt;&lt;a href=&quot;#1-过期策略&quot; class=&quot;headerlink&quot; title=&quot;1. 过期策略&quot;&gt;&lt;/a&gt;1. 过期策略&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;定期删除：&lt;/em&gt;&lt;/strong&gt; 默认每隔 &lt;strong&gt;100ms 随机抽取 &lt;strong&gt;进行检查，是否有过期的 key，有过期 key 则删除。因此没抽查到的需要惰性删除进一步筛选&lt;br&gt;&lt;/strong&gt;&lt;em&gt;惰性删除：&lt;/em&gt;&lt;/strong&gt; 获取某个 key 的时候，如果该 key 已过期，则删除。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ccomma.cn/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>对 1e9 + 7 取模</title>
    <link href="https://ccomma.cn/6a28fa6963c0/"/>
    <id>https://ccomma.cn/6a28fa6963c0/</id>
    <published>2022-11-19T13:45:19.000Z</published>
    <updated>2024-04-02T03:56:26.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么取模"><a href="#为什么取模" class="headerlink" title="为什么取模"></a>为什么取模</h2><p>OJ 上很多题目因为难度原因需要非常大的测试数据量（数据量大了自然会对算法的时间复杂度要求更高），而大数据量往往会导致溢出，虽然可以用 BigInt 等方式做题，但这就失去了这道题的原本意义。</p><p>这种情况题目会要求计算结果对 1e9 + 7 取模，因为对取模不会影响算法的正确性，既避免了高精度运算，又能保证极少的冲突情况。<br>这里可以先回顾下模除运算的等价性</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p</span><br><span class="line">(a - b) % p = (a % p - b % p ) % p</span><br><span class="line">(a * b) % p = (a % p * b % p) % p</span><br><span class="line">a ^ b % p = ((a % p)^b) % p</span><br></pre></td></tr></tbody></table></figure><p>由上述各个公式可知只要每次运算后觉得结果过大都可以对其进行取模，只要避免数据溢出，那么最终结果都是一样的。例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> MOD + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + <span class="number">1</span> + a * a;</span><br><span class="line">sum %= MOD;</span><br></pre></td></tr></tbody></table></figure><p>只要 sum 不溢出，那么其结果和对每次运算结果都 <code>%MOD</code> 一遍是一样的。</p><p>所以 <strong>取模成了简化大数据的一种约定</strong>，服务端给定算法取模后的测试数据，我们写算法时也进行取模，那么依然能验证算法的正确性。</p><span id="more"></span><h2 id="为什么是-1e9-7"><a href="#为什么是-1e9-7" class="headerlink" title="为什么是 1e9 + 7"></a>为什么是 1e9 + 7</h2><p>参考：<br><a href="https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E9%99%A4#%E7%AD%89%E4%BB%B7%E6%80%A7">wiki 模除 #等价性</a><br><a href="https://blog.csdn.net/qq_46689648/article/details/122795304">为什么对 1e9+7 取模</a><br><a href="https://blog.csdn.net/cpb____/article/details/107959450?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">C++ 中 1e9（初始化、无穷大）解析</a><br><a href="https://blog.csdn.net/qq_43827595/article/details/104267327?utm_term=1e9%207java%E5%8F%96%E6%A8%A1&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-104267327&amp;spm=3001.4430">【C++ 取模 mod 易错点】由于答案可能会很大，请你将结果对 1e9+7 取模后再返回</a><br><a href="https://www.zhihu.com/question/49374703">为什么很多程序竞赛题目都要求答案对 1e9+7 取模？</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么取模&quot;&gt;&lt;a href=&quot;#为什么取模&quot; class=&quot;headerlink&quot; title=&quot;为什么取模&quot;&gt;&lt;/a&gt;为什么取模&lt;/h2&gt;&lt;p&gt;OJ 上很多题目因为难度原因需要非常大的测试数据量（数据量大了自然会对算法的时间复杂度要求更高），而大数据量往往会导致溢出，虽然可以用 BigInt 等方式做题，但这就失去了这道题的原本意义。&lt;/p&gt;
&lt;p&gt;这种情况题目会要求计算结果对 1e9 + 7 取模，因为对取模不会影响算法的正确性，既避免了高精度运算，又能保证极少的冲突情况。&lt;br&gt;这里可以先回顾下模除运算的等价性&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(a + b) % p = (a % p + b % p) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(a - b) % p = (a % p - b % p ) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(a * b) % p = (a % p * b % p) % p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a ^ b % p = ((a % p)^b) % p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由上述各个公式可知只要每次运算后觉得结果过大都可以对其进行取模，只要避免数据溢出，那么最终结果都是一样的。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;MOD&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;1e9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; MOD + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; a + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + a * a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sum %= MOD;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只要 sum 不溢出，那么其结果和对每次运算结果都 &lt;code&gt;%MOD&lt;/code&gt; 一遍是一样的。&lt;/p&gt;
&lt;p&gt;所以 &lt;strong&gt;取模成了简化大数据的一种约定&lt;/strong&gt;，服务端给定算法取模后的测试数据，我们写算法时也进行取模，那么依然能验证算法的正确性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>891. 子序列宽度之和</title>
    <link href="https://ccomma.cn/38f6854c01e2/"/>
    <id>https://ccomma.cn/38f6854c01e2/</id>
    <published>2022-11-19T12:54:17.000Z</published>
    <updated>2024-04-02T03:56:26.606Z</updated>
    
    <content type="html"><![CDATA[<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。<br>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>1e9 + 7</code> <strong>取余</strong> 后的结果。<br><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p><span id="more"></span><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pow2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            pow2[i] = pow2[i - <span class="number">1</span>] * <span class="number">2</span> % MOD; <span class="comment">// 预处理 2 的幂次</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += (<span class="type">long</span>) (pow2[i] - pow2[n - <span class="number">1</span> - i]) * nums[i]; <span class="comment">// 在题目的数据范围下，这不会溢出</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (ans % MOD + MOD) % MOD; <span class="comment">// 注意上面有减法，ans 可能为负数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个序列的 &lt;strong&gt;宽度&lt;/strong&gt; 定义为该序列中最大元素和最小元素的差值。&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;code&gt;nums&lt;/code&gt; 的所有非空 &lt;strong&gt;子序列&lt;/strong&gt; 的 &lt;strong&gt;宽度之和&lt;/strong&gt; 。由于答案可能非常大，请返回对 &lt;code&gt;1e9 + 7&lt;/code&gt; &lt;strong&gt;取余&lt;/strong&gt; 后的结果。&lt;br&gt;&lt;strong&gt;子序列&lt;/strong&gt; 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 就是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的一个子序列。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>792. 匹配子序列的单词数</title>
    <link href="https://ccomma.cn/66915abb06c0/"/>
    <id>https://ccomma.cn/66915abb06c0/</id>
    <published>2022-11-17T15:10:37.000Z</published>
    <updated>2024-04-02T03:56:26.607Z</updated>
    
    <content type="html"><![CDATA[<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<code>words[i]</code>&nbsp;中是 <code>s</code> 的子序列的单词个数&nbsp;。<br>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符 (可以是 none)，而不改变其余字符的相对顺序。</p><ul><li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定字符串 &lt;code&gt;s&lt;/code&gt;&amp;nbsp;和字符串数组&amp;nbsp;&lt;code&gt;words&lt;/code&gt;, 返回&amp;nbsp;&amp;nbsp;&lt;code&gt;words[i]&lt;/code&gt;&amp;nbsp;中是 &lt;code&gt;s&lt;/code&gt; 的子序列的单词个数&amp;nbsp;。&lt;br&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂</title>
    <link href="https://ccomma.cn/e8fc79331955/"/>
    <id>https://ccomma.cn/e8fc79331955/</id>
    <published>2022-11-13T10:27:20.000Z</published>
    <updated>2024-04-02T03:56:26.605Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">790. 多米诺和托米诺平铺</a><br>做题时看到官方除了 DP，还给出了这样一种解法，有点好奇便研究了一下</p><p>矩阵快速幂由 **_ 矩阵运算 _** 和 **_快速幂 _** 两部分组成</p><span id="more"></span><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/domino-and-tromino-tiling/&quot;&gt;790. 多米诺和托米诺平铺&lt;/a&gt;&lt;br&gt;做题时看到官方除了 DP，还给出了这样一种解法，有点好奇便研究了一下&lt;/p&gt;
&lt;p&gt;矩阵快速幂由 **_ 矩阵运算 _** 和 **_快速幂 _** 两部分组成&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="矩阵快速幂" scheme="https://ccomma.cn/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>764. 最大加号标志</title>
    <link href="https://ccomma.cn/6dc201714435/"/>
    <id>https://ccomma.cn/6dc201714435/</id>
    <published>2022-11-13T10:18:38.000Z</published>
    <updated>2024-04-02T03:56:26.606Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [xi, yi]</code> 表示&nbsp;<code>grid[xi][yi] == 0</code><br>返回 &nbsp;<code>grid</code> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong><em>轴对齐</em></strong> 加号标志的阶数 。如果未找到加号标志，则返回 <code>0</code> 。</p><p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<code>1</code>&nbsp;组成的 <strong><em>“轴对称” 加号标志</em></strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及 4 个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p><span id="more"></span><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] mines)</span> {</span><br><span class="line">        <span class="type">boolean</span>[][] map = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mines.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> mines[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span>  <span class="operator">=</span> mines[i][<span class="number">1</span>];</span><br><span class="line">            map[x][y] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n % <span class="number">2</span> == <span class="number">0</span> ? n - <span class="number">1</span>: n;</span><br><span class="line">        <span class="keyword">for</span> (; m &gt; <span class="number">0</span>; m -= <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// i =&gt; 上下偏移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">                <span class="comment">// j =&gt; 左右偏移</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n - m; j++) {</span><br><span class="line">                    <span class="comment">// 横向</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> m / <span class="number">2</span> + i;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j;</span><br><span class="line">                    <span class="keyword">for</span> (; y &lt; j + m; y++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 横向有 0</span></span><br><span class="line">                    <span class="keyword">if</span> (y != j + m) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 纵向</span></span><br><span class="line">                    x = i;</span><br><span class="line">                    y = m / <span class="number">2</span> + j;</span><br><span class="line">                    <span class="keyword">for</span> (; x &lt; i + m; x++) {</span><br><span class="line">                        <span class="keyword">if</span> (map[x][y]) <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 可行，返回</span></span><br><span class="line">                    <span class="keyword">if</span> (x == i + m) {</span><br><span class="line">                        <span class="keyword">return</span> m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵&amp;nbsp;&lt;code&gt;grid&lt;/code&gt;&amp;nbsp;中，除了在数组&amp;nbsp;&lt;code&gt;mines&lt;/code&gt;&amp;nbsp;中给出的元素为&amp;nbsp;&lt;code&gt;0&lt;/code&gt;，其他每个元素都为&amp;nbsp;&lt;code&gt;1&lt;/code&gt;。&lt;code&gt;mines[i] = [xi, yi]&lt;/code&gt; 表示&amp;nbsp;&lt;code&gt;grid[xi][yi] == 0&lt;/code&gt;&lt;br&gt;返回 &amp;nbsp;&lt;code&gt;grid&lt;/code&gt; 中包含&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;的最大的 &lt;strong&gt;&lt;em&gt;轴对齐&lt;/em&gt;&lt;/strong&gt; 加号标志的阶数 。如果未找到加号标志，则返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;阶由&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;组成的 &lt;strong&gt;&lt;em&gt;“轴对称” 加号标志&lt;/em&gt;&lt;/strong&gt; 具有中心网格&amp;nbsp;&lt;code&gt;grid[r][c] == 1&lt;/code&gt;&amp;nbsp;，以及 4 个从中心向上、向下、向左、向右延伸，长度为&amp;nbsp;&lt;code&gt;k-1&lt;/code&gt;，由&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 &lt;code&gt;0&lt;/code&gt; 也可能为 &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>864. 获取所有钥匙的最短路径</title>
    <link href="https://ccomma.cn/1728e5a327c0/"/>
    <id>https://ccomma.cn/1728e5a327c0/</id>
    <published>2022-11-13T10:16:16.000Z</published>
    <updated>2024-04-02T03:56:26.606Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格&nbsp;grid&nbsp;，其中：</p><ul><li><code>'.'</code> 代表一个空房间</li><li><code>'#'</code> 代表一堵</li><li><code>'@'</code>&nbsp;是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 k&nbsp;为 钥匙 / 锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p><span id="more"></span><h2 id="BFS-状态压缩"><a href="#BFS-状态压缩" class="headerlink" title="BFS + 状态压缩"></a>BFS + 状态压缩</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">35</span>, K = <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N][N][<span class="number">1</span> &lt;&lt; K];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]{{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">0</span>,-<span class="number">1</span>}};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] g)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length, m = g[<span class="number">0</span>].length(), cnt = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                Arrays.fill(dist[i][j], INF);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[i].charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'@'</span>) {</span><br><span class="line">                    d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, j, <span class="number">0</span>});</span><br><span class="line">                    dist[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) {</span><br><span class="line">            <span class="type">int</span>[] info = d.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> info[<span class="number">0</span>], y = info[<span class="number">1</span>], cur = info[<span class="number">2</span>], step = dist[x][y][cur];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] di : dirs) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + di[<span class="number">0</span>], ny = y + di[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> g[nx].charAt(ny);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &amp;&amp; (cur &gt;&gt; (c - <span class="string">'A'</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ncur</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) ncur |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ncur == (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (step + <span class="number">1</span> &gt;= dist[nx][ny][ncur]) <span class="keyword">continue</span>;</span><br><span class="line">                dist[nx][ny][ncur] = step + <span class="number">1</span>;</span><br><span class="line">                d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{nx, ny, ncur});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个二维网格&amp;nbsp;grid&amp;nbsp;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;.&#39;&lt;/code&gt; 代表一个空房间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;#&#39;&lt;/code&gt; 代表一堵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;@&#39;&lt;/code&gt;&amp;nbsp;是起点&lt;/li&gt;
&lt;li&gt;小写字母代表钥匙&lt;/li&gt;
&lt;li&gt;大写字母代表锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。&lt;br&gt;假设 k&amp;nbsp;为 钥匙 / 锁 的个数，且满足&amp;nbsp;&lt;code&gt;1 &amp;lt;= k&amp;nbsp;&amp;lt;= 6&lt;/code&gt;，字母表中的前 &lt;code&gt;k&lt;/code&gt;&amp;nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。&lt;br&gt;返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&amp;nbsp;&lt;code&gt;-1&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://ccomma.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://ccomma.cn/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
