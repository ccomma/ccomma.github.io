<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CComma&#39;s Blog</title>
  
  <subtitle>Connect the world</subtitle>
  <link href="https://ccomma.cn/atom.xml" rel="self"/>
  
  <link href="https://ccomma.cn/"/>
  <updated>2024-04-01T09:03:37.223Z</updated>
  <id>https://ccomma.cn/</id>
  
  <author>
    <name>CComma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper 从入门到入土⑩：相关源码阅读</title>
    <link href="https://ccomma.cn/953105e9306b/"/>
    <id>https://ccomma.cn/953105e9306b/</id>
    <published>2024-04-01T08:48:03.000Z</published>
    <updated>2024-04-01T09:03:37.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-搭建"><a href="#1-搭建" class="headerlink" title="1. 搭建"></a>1. 搭建</h2><p>版本：3.7<br>github clone 下来之后用 IDEA 打开，maven clean install<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1a0a1a4b76e08bad4113feeb143f891d.png"></p><p>服务端 debug 配置：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b3f81e08916f00be69061801b48fa2b8.png"></p><p>客户端 debug 配置</p><h2 id="2-Server-启动流程"><a href="#2-Server-启动流程" class="headerlink" title="2. Server 启动流程"></a>2. Server 启动流程</h2><p>QuorumPeerMain#initializeAndRun 启动类：</p><ol><li><strong>解析配置文件：</strong> QuorumPeerConfig#parse。zoo.cfg 配置运行时的基本参数，如 tickTime、dataDir、clientPort 等参数</li><li><strong>创建并启动历史文件清理器：</strong> DatadirCleanupManager#start。对事务日志和快照数据文件进行定时清理。</li><li><strong>判断是否是集群模式：</strong> QuorumPeerConfig#isDistributed</li></ol><h3 id="2-1-集群模式"><a href="#2-1-集群模式" class="headerlink" title="2.1. 集群模式"></a>2.1. 集群模式</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/521dfdd47784c4e23b4ae0b345019080.png"></p><p>是集群模式则调用 QuorumPeerMain#runFromConfig</p><ol><li><strong>开启集群模式：</strong> QuorumPeerMain#runFromConfig </li><li><strong>创建并配置 ServerCnxnFactory：</strong><br>调用 ServerCnxnFactory#createFactory () 创建 ServerCnxnFactory。<br>调用 ServerCnxnFactory#configure (java.net.InetSocketAddress, int, int, boolean) 配置 ServerCnxnFactory。 </li><li><strong>获取 QuorumPeer 并设置相关组件：</strong><br>调用 QuorumPeerMain#getQuorumPeer 获取 QuorumPeer。其父类继承了 Thread<br>调用 QuorumPeer#setTxnFactory 设置数据管理器<br>调用 QuorumPeer#setZKDatabase 设置 zkDataBase<br>调用 QuorumPeer#initialize 进行初始化 </li><li><strong>启动服务：</strong> QuorumPeer#start。<br>  1. 恢复本地数据：QuorumPeer#loadDataBase<br>  2. 启动主线程：QuorumPeer#startServerCnxnFactory<br>  3. 初始化 Leader 选举：QuorumPeer#startLeaderElection。创建选举环境，启动相关线程 <ol><li>创建选给自身的选票</li><li>初始化选举算法：QuorumPeer#createElectionAlgorithm (electionType) <ol><li>开启监听：<code>QuorumCnxManager.Listener listener = qcm.listener; listener.start();</code>。</li><li>开启选举：FastLeaderElection#start</li></ol></li></ol></li></ol><pre><code>  4. 启动 QuorumPeer：Thread#start，调用其 run() 方法。一直循环判断状态      1. 节点状态为 LOOKING：调用 lookForLeader() 方法。`setCurrentVote(makeLEStrategy().lookForLeader())`。进行选举     2. 节点状态为 OBSERVING：设置当前节点启动模式为 Observer，调用 Observer#observeLeader 与 Leader 节点进行数据同步     3. 节点状态为 FOLLOWER：设置当前节点启动模式为 Follower，调用 Follower#followLeader 与 Leader 节点进行数据同步     4. 节点状态为 Leader：设置当前节点启动模式为 Leader，调用 Leader#lead 发送自己是 Leader 的通知</code></pre><h3 id="2-2-单机模式"><a href="#2-2-单机模式" class="headerlink" title="2.2. 单机模式"></a>2.2. 单机模式</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/33788250631fa23974c6f54c17942828.png"></p><p>是单机模式则调用 ZooKeeperServerMain#main：把启动工作委派给 ZooKeeperServerMain 类。调用 ZooKeeperServerMain#initializeAndRun</p><ol><li><strong>重新解析配置文件：</strong> ServerConfig#parse (java.lang.String)。创建服务配置对象，重新解析 </li><li><strong>运行服务：</strong> ZooKeeperServerMain#runFromConfig </li><li><strong>创建数据管理器：</strong> new FileTxnSnapLog(config.dataLogDir, config.dataDir) </li><li><strong>创建 Server 实例：</strong> <code>new ZooKeeperServer()</code>。<br>Zookeeper 服务器首先会进行服务器实例的创建<br>然后对该服务器实例进行初始化，包括连接器、内存数据库、请求处理器等组件的初始化 </li><li><strong>创建 admin 服务：</strong> AdminServerFactory#createAdminServer。用于接收请求（创建 jetty 服务） </li><li><strong>创建并配置 ServerCnxnFactory：</strong><br>调用 ServerCnxnFactory#createFactory () 负责客户端与服务器的连接<br>调用 ServerCnxnFactory#configure (java.net.InetSocketAddress, int, int, boolean) 配置 ServerCnxnFactory </li><li><strong>启动服务：</strong> ServerCnxnFactory#startup(ZooKeeperServer)<br>  1.  启动相关线程：NIOServerCnxnFactory#startxup <blockquote><pre><code>  1. new WorkerService("NIOWorker", numWorkerThreads, false)：初始化 worker 线程池  2. 开启所有 SelectorThread 线程，用于处理客户端请求  3. 启动 acceptThread 线程，用于处理接收连接进行事件  4. 启动 expirerThread 线程，用于处理过期连接</code></pre></blockquote></li></ol><pre><code>  2.  加载数据到 zkDataBase：ZooKeeperServer#startdata。ZooKeeperServer#loadData：加载磁盘上已经存储的数据   3.  ZooKeeperServer#startup：      1.  初始化 Session 追踪器：ZooKeeperServer#createSessionTracker      2.  启动 Session 追踪器：ZooKeeperServer#startSessionTracker      3.  建立请求处理链路：ZooKeeperServer#setupRequestProcessors </code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setupRequestProcessors</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">RequestProcessor</span> <span class="variable">finalProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalRequestProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">RequestProcessor</span> <span class="variable">syncProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncRequestProcessor</span>(<span class="built_in">this</span>, finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor) syncProcessor).start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> <span class="title class_">PrepRequestProcessor</span>(<span class="built_in">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor) firstProcessor).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>     4.  注册 JMX：ZooKeeperServer#registerJMX </code></pre><h2 id="3-Leader-选举"><a href="#3-Leader-选举" class="headerlink" title="3. Leader 选举"></a>3. Leader 选举</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Election</span> {</span><br><span class="line">    <span class="comment">// 寻找 Leader</span></span><br><span class="line">    Vote <span class="title function_">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 关闭服务端之间的连接</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>选举类图：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8c34e37f7a5f4819fb28a38db7cbbb08.png"></p><p><strong>FastLeaderElection#lookForLeader：</strong></p><ol><li><strong>更新时钟：</strong> <code>logicalclock.incrementAndGet()</code>。logicalclock 为 AtomicLong 类型。</li><li><strong>初始化选票为自身的选票（myid，zxid，epoch）：</strong> FastLeaderElection#updateProposal(long leader, long zxid, long epoch)</li><li><strong> 发送选票：</strong> FastLeaderElection#sendNotifications。将选票信息封装成 ToSend 对象，由 workerSender（LinkedBlockingQueue）发送出去</li><li>（循环）判断是否为 LOOKING 状态 <ol><li><strong>接收外部投票：</strong> <code>Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS)</code>。每台服务器会不断的从 recvqueue 中获取外部投票 </li><li><strong>处理接收到的投票（选票 PK）</strong> </li><li>接收到的投票的 epoch &gt; 当前投票的 epoch 时：<code>n.electionEpoch &gt; logicalclock.get()</code><br>  1.  更新 epoch（选举轮次）为接收到的外部投票的 epoch：<code>logicalclock.set(n.electionEpoch)</code><br>  2.  清空之前所有已经收到的投票：<code>recvset.clear()</code>。recvset（HashMap&lt;Long, Vote&gt;，意在收集本轮收到的选票）<br>  3.  选票 PK：用 FastLeaderElection#totalOrderPredicate (long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) 方法判断。返回 true 则更新为接收到的选票，false 则更新为当前自身生成的选票。<br>此次 PK 为 <strong>接收到的外部选票</strong> 与 <strong>自身生成的选票（myid，zxid，epoch）</strong> 之间的 PK。 <ul><li>newEpoch &gt; curEpoch：更新为接收到的选票 </li><li>newEpoch == curEpoch &amp;&amp; newZxid &gt; curZxid：更新为接收到的选票 </li><li>newEpoch == curEpoch &amp;&amp; newZxid == curZxid &amp;&amp; newId &gt; curId：更新为接收到的选票 </li><li>其余情况更新为当前自身生成的选票</li></ul></li></ol></li></ol><p>依然用 FastLeaderElection#updateProposal 方法更新选票 </p><pre><code>     4.  发送更新完的选票：FastLeaderElection#sendNotifications   1.  接收到的投票的 epoch &lt; 当前投票的 epoch 时：忽略   2.  接收到的投票的 epoch == 当前投票的 epoch 时：      1.  FastLeaderElection#totalOrderPredicate 选票 PK，与第一种情况类似，返回 true 则更新为接收到的选票，false 则更新为当前持有的选票。&lt;br /&gt;此次 PK 为 **接收到的外部选票** 与 **当前持有的选票** 之间的 PK。      2.  发送更新完的选票：FastLeaderElection#sendNotifications </code></pre><ol><li><strong>记录选票：</strong> 记录收到的选票到 Map 中 <code>recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch))</code> </li><li><strong>统计选票：</strong> 判断当前 Server 收到的票数是否可以结束选举<br>  1. 遍历 recvset 中的所有投票信息，将等于当前投票的 <code>&lt;sid, vote&gt;</code> 放入 voteSet 中<br>  2. 统计投票：SyncedLearnerTracker#hasAllQuorums。查看投给某个 sid（myid） 的票数是否超过一半，过半则更新服务器状态</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-搭建&quot;&gt;&lt;a href=&quot;#1-搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 搭建&quot;&gt;&lt;/a&gt;1. 搭建&lt;/h2&gt;&lt;p&gt;版本：3.7&lt;br&gt;github clone 下来之后用 IDEA 打开，maven clean install&lt;br&gt;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土⑨：ZAB 协议</title>
    <link href="https://ccomma.cn/d2656fde5511/"/>
    <id>https://ccomma.cn/d2656fde5511/</id>
    <published>2024-04-01T08:47:04.000Z</published>
    <updated>2024-04-01T09:03:37.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Zookeeper 使用⼀个单⼀的主进程来接收并处理客户端的所有事务请求</p><p>并采用 ZAB （ Zookeeper Atomic Broadcast，原子广播协议），将服务器数据的状态变更以事务 Proposal 的形式广播到所有的副本进程中</p><p><strong>读写请求官方压测：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7bee1d45d9132d4cc362f7b83d99edd3.png"></p><p><strong>3888 端口通信模型：</strong><br>任何两个节点都互通<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/2540cbee09bd8a4e1f2ef002e8b61d7b.png"></p><h2 id="2-恢复模式（选-Master-数据同步）"><a href="#2-恢复模式（选-Master-数据同步）" class="headerlink" title="2. 恢复模式（选 Master + 数据同步）"></a>2. 恢复模式（选 Master + 数据同步）</h2><p>官方压测 200ms 恢复</p><p><strong>步骤：</strong></p><ol><li><em>Leader 选举过程：</em> Leader 与过半 Follower 失去联系，Follower 服务器都会将自己的服务器状态变更为 LOOKING，并进⼊ Leader 选举过程。 </li><li><em>数据同步：</em> ZAB 会选举产生新的 Leader 服务器，然后有过半（防止脑裂）的机器与该 Leader 服务器完成了数据同步之后会退出恢复模式。</li></ol><p><strong>注意的问题：</strong></p><ul><li>ZAB 协议需要确保那些已经在 Leader 上提交的事务最终被所有服务器都提交</li><li> ZAB 协议需要确保丢弃那些只在 Leader 上被提出但尚未发出的事务</li></ul><p>ZAB 保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）事务 Id 的 Proposal 来解决上述问题</p><h3 id="2-1-Leader-选举"><a href="#2-1-Leader-选举" class="headerlink" title="2.1. Leader 选举"></a>2.1. Leader 选举</h3><p>Leader 所在的机器挂了或者失去大多数的 Follower 会进入恢复模式，进行新⼀轮的 Leader 选举。<br>服务器运行期间的 Leader 选举和启动时期的 Leader 选举基本过程是⼀致的。</p><p><strong><em>选举算法：</em></strong><br>通过 zoo.cfg 配置文件中的 electionAlg 属性指定（0-3）<br>FastLeaderElection 算法（值为 3。TCP 实现，zk 3.4.0 之后只保留了该算法，废弃了 0-2）</p><p><strong><em>过程：</em></strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3bed488b8c94c6165de6883718f48f04.png"></p><ol><li><p>每个 Server 会将自身的（myid，ZXID）发送给集群以便通知其他 Server 自己的选择。 </p><blockquote><p>这是投给自己的票，因为此时还不知道其他 Server 的状态。例如 Server1 的 myid 为 1，ZXID 为 0，则发送（1, 0）</p></blockquote></li><li><p>接受来自各个服务器的投票 </p></li><li><p>集群的每个服务器收到投票后，判断该投票的有效性，如检查是否是本轮投票、是否来⾃ LOOKING 状态的服务器。</p></li><li><p>针对每⼀个投票，服务器都需要将别人的投票和自己的投票进行选择，以确定是否变更投票 </p><ul><li>比较 ZXID：如果接收到的投票的 ZXID 比自己的大，则当前 Server 认可收到的投票，并再次将该投票发送出去。反之，若接收到的投票的 ZXID 比自己的小，则不做任何操作</li><li>比较 myid：如果 ZXID 相同则比较 myid。myid 较⼤的投票会被认可并再次发送出去。反之，若接收到的 myid 比自己的小，则不做任何操作</li></ul></li><li><p>统计投票<br>Server 都接收到其他 Server 的变更投票后会开始统计投票，如果一台 Server 中相同的投票超过半数则该投票对应的 myid 的 Server 成为 Leader。 </p><blockquote><p>为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂</p></blockquote></li><li><p>改变服务器状态<br>⼀旦确定了 Leader，每个服务器就会更新⾃⼰的状态：如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，那么就变更为 LEADING。</p></li></ol><h3 id="2-2-数据同步"><a href="#2-2-数据同步" class="headerlink" title="2.2. 数据同步"></a>2.2. 数据同步</h3><p><em>数据同步消息方式：</em></p><table><thead><tr><th>消息类型</th><th>发送方向</th><th>说明</th></tr></thead><tbody><tr><td> DIFF</td><td>Leader -&gt; Learner</td><td> 通知 Learner 即将与 Learner 进行增量方式的数据同步</td></tr><tr><td> TRUNC</td><td>Leader -&gt; Learner</td><td> 触发 Learner 进行其内存数据库的回滚操作</td></tr><tr><td> SNAP</td><td>Leader -&gt; Learner</td><td> 通知 Learner 即将与 Learner 进行全量方式的数据同步</td></tr><tr><td> UPTODATE</td><td>Leader -&gt; Learner</td><td> 通知 Learner 已完成数据同步，可对外提供服务</td></tr></tbody></table><p><em>服务器初始化消息类型：</em></p><table><thead><tr><th>消息类型</th><th>发送方向</th><th>说明</th></tr></thead><tbody><tr><td> OBSERVERINFO</td><td>Observer -&gt; Leader</td><td>Observer 启动时发送自身的（myid，zxid）给 Leader，用于向 Leader 表明角色并注册自己</td></tr><tr><td> FOLLOWERINFO</td><td>Follower -&gt; Leader</td><td>Follower 启动时发送自身的（myid，zxid）给 Leader，用于向 Leader 表明角色并注册自己</td></tr><tr><td> LEADERINFO</td><td>Leader -&gt; Learner</td><td>Leader 接收到来自 Learner 的上述两类消息后会将当前 Leader 的 epoch 发送 Learner</td></tr><tr><td>ACKEPOCH</td><td>Learner -&gt; Leader</td><td>Learner 收到 LEADERINFO 消息后会将自己最新的 zxid 和 epoch 发送给 Leader</td></tr><tr><td>NEWLEAEDER</td><td>Leader -&gt; Learner</td><td> 足够多的 Follower 连上 Leader 或完成数据同步后，Leader 会向 Learner 发送当前 Leader 最新的 zxid</td></tr></tbody></table><p><strong><em>过程：</em></strong></p><ol><li><p><em>Leader 加载快照：</em> 重新加载本地磁盘上的数据快照至内存，并从日志文件中取出快照之后的所有事务操作，逐条应用至内存，并添加到已提交事务缓存 commitedProposals。 </p><blockquote><p>这样能保证日志文件中的事务操作，必定会应用到 leader 的内存数据库中。</p></blockquote></li><li><p><em>确定同步方式：</em> </p></li><li><p>获取 Learner 发送的 <code>OBSERVERINFO/FOLLOWERINFO</code> 信息（myid，zxid），即 id 和已提交过的最大消息 zxid。 </p></li><li><p>用 Learner 的最大 zxid 与 Leader 提交过的消息（commitedProposals）中的最小 zxid（min_zxid）和最大 zxid（max_zxid）分别作比对，确定采用哪种同步方式（DIFF 同步、TRUNC+DIFF 同步、SNAP 同步）。<br>  - 如果该 zxid 介于 min_zxid 与 max_zxid 之间，但又不存在于 commitedProposals 中时，说明该 zxid 对应的事务需要 TRUNC 回滚<br>  - 如果该 zxid 介于 min_zxid 与 max_zxid 之间且存在于 commitedProposals 中，则 Leader 需要将 zxid+1~max_zxid 间所有事务同步给 Learner（DIFF）<br>  - 如果该 zxid == max_zxid，说明已经完全同步了</p></li><li><p><em>数据同步：</em> Leader 主动向所有 Learner 发送同步数据消息，每个 Learner 有自己的发送队列。<br>同步结束时，Leader 会向 Learner 发送 NEWLEADER 消息，同时 Learner 会反馈一个 ACK。当 Leader 接收到来自 Learner 的 ACK 消息后，就认为当前 Learner 已经完成了数据同步，然后进入 等待是否过半阶段。 </p></li><li><p><em>同步完成：</em> 当 Leader 统计到收到了一半已上的 ACK 时，会向所有已经完成数据同步的 Learner 发送一个 <code>UPTODATE</code> 消息，用来通知 Learner 集群已经完成了数据同步，可以对外服务了。</p></li></ol><h2 id="3-广播模式（事务操作节点同步）"><a href="#3-广播模式（事务操作节点同步）" class="headerlink" title="3. 广播模式（事务操作节点同步）"></a>3. 广播模式（事务操作节点同步）</h2><p><strong>原子广播协议特性：</strong></p><ul><li>原子性：要么成功，要么失败，不存在中间状态。（队列 + 2PC 实现）</li><li>广播：Leader 通知所有节点进行操作</li></ul><p>有过半的 Follower 服务器完成了和 Leader 服务器的数据同步，那么就会进⼊消息⼴播模式。<br>扩容加入的新服务器会与 Leader 进行数据同步然后参与到消息⼴播流程中<br>Leader/Follower/Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9f27cd7993e2ce58e318a97357e40a8c.png"></p><ol><li><em>转发请求：</em> Follower 接收到写请求后会转发给 Leader 来处理</li><li><em>发送事务消息：</em> Leader 接收到写请求后会把该写请求转换成带有各种状态的事务，并会分配给 Proposal 一个单调递增的唯一 id（zxid）。然后 Leader 会将广播的事务 Proposal 依次添加到 <strong>发送队列</strong> 中，并且根据 FIFO 策略进行消息发送。<strong>保证最终一致性</strong></li><li><em>返回应答：</em> 每⼀个 Follower 接收到这个事务 Proposal 之后，都会将其以事务日志的形式写入到本地磁盘中去，然后向 Leader 返回 Ack 进行投票。Observer 不参与投票</li><li><em>提交事务：</em> Leader 接收到超过半数 Ack，会给所有的 Follower 广播⼀个 COMMIT 消息进行事务提交，给所有的 Observer 广播 INFORM 消息进行提交，同时 Leader 也会进行事务提交</li></ol><p>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p><h2 id="4-ZAB-与-Paxos-的异同"><a href="#4-ZAB-与-Paxos-的异同" class="headerlink" title="4. ZAB 与 Paxos 的异同"></a>4. ZAB 与 Paxos 的异同</h2><p><strong>相同点：</strong></p><ul><li>都存在⼀个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</li><li> Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将⼀个提议进行提交</li><li>在 ZAB 协议中，每个 Proposal 中都包含了⼀个 epoch 值，用来代表当前的 Leader 周期。在 Paxos 算法中为 Ballot</li></ul><p><strong>不同点：</strong> ZAB 协议主要⽤于构建⼀个⾼可⽤的分布式数据主备系统，Paxos 算法则⽤于构建⼀个分布式的⼀致性状态机系统</p><ul><li>Paxos 算法中，新选举产⽣的主进程会进⾏两个阶段的⼯作，第⼀阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第⼆阶段称为写阶段，当前主进程开始提出自己的提议。</li><li>ZAB 协议在 Paxos 基础上添加了同步阶段。新选出的 Leader 会确保存在过半的 Follower 提交<br>了之前接收到的所有事务 Proposal。这⼀同步阶段的引入，能够有效地保证 Leader 在新的周期中提出事务 Proposal 之前，所有的进程都已经完成了对之前所有事务 Proposal 的提交</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Zookeeper 使用⼀个单⼀的主进程来接收并处理客户端的所有事务请求&lt;/p&gt;
&lt;p&gt;并采用 ZAB （ Zookee</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土⑧：集群</title>
    <link href="https://ccomma.cn/60519794d329/"/>
    <id>https://ccomma.cn/60519794d329/</id>
    <published>2024-04-01T08:46:25.000Z</published>
    <updated>2024-04-01T09:03:37.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-事务-Id"><a href="#1-事务-Id" class="headerlink" title="1. 事务 Id"></a>1. 事务 Id</h2><p><strong>概述：</strong></p><ul><li><em>变更状态：</em> 事务是指能够改变 ZooKeeper 服务器状态的操作，我们也称之为事务操作或更新操作。⼀般包括数据节点创建与删除、数据节点内容更新等操作。 </li><li><em>ZXID：</em> 对于每⼀个事务请求（proposal 提议），ZooKeeper 都会为其分配⼀个全局唯⼀（zk 中唯一）且有序的事务 ID，用 ZXID 来表示，通常是⼀个 64 位的数字。 <ul><li>高 32 位是 epoch（投票轮次），用来标识 Leader 是否发生改变。从 1 开始，如果有新的 Leader 产生出来，epoch 会自增。</li><li>低 32 位用来递增计数。每次 epoch 变化，都将低 32 位的序号重置。</li></ul></li></ul><p><strong>作用：</strong> 标识节点同步状态。</p><h2 id="2-Server-工作状态"><a href="#2-Server-工作状态" class="headerlink" title="2. Server 工作状态"></a>2. Server 工作状态</h2><ol><li><em>LOOKING：</em> 不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举。</li><li><em>FOLLOWING：</em> 跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁。</li><li><em>OBSERVING：</em> 观察者状态。表明当前服务器角色是 Observer</li><li><em>LEADING：</em> 领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳。</li></ol><h2 id="3-服务器角色"><a href="#3-服务器角色" class="headerlink" title="3. 服务器角色"></a>3. 服务器角色</h2><ul><li>Leader</li><li>Follower：参与选举，参与写操作时的投票。对外提供读服务。</li><li>Observer：与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票。对外提供读服务。</li></ul><p>Follower 与 Observer 统称 Learner</p><h3 id="3-1-Leader"><a href="#3-1-Leader" class="headerlink" title="3.1. Leader"></a>3.1. Leader</h3><p><strong>主要工作</strong></p><ul><li>有且仅有一个。事务请求的唯⼀调度和处理者，保证集群事务处理的顺序性。</li><li>集群内部各服务器的调度者。</li></ul><p><strong>请求处理链</strong><br>使⽤责任链来处理每个客户端的请求<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9e09d263ffe7352b95ec92aedf683899.png"></p><ol><li><strong>预处理器（PrepRequestProcessor）：</strong> 识别出当前客户端请求是否是事务请求，并对其进行预处理。<br>对事务请求进⾏⼀系列预处理，如创建请求事务头、事务体、会话检查、ACL 检查和版本检查等 </li><li><strong>事务处理器（ProposalRequestProcessor）：</strong> Leader 事务处理流程的发起者。</li></ol><ul><li>非事务性请求：将请求转发到 CommitProcessor 处理器</li><li>事务性请求：将请求转发到 CommitProcessor 处理器。根据请求类型创建对应的 Proposal 提议广播给所有的 Follower。还会将 Proposal 交付给 SyncRequestProcessor 进⾏事务⽇志的记录。</li></ul><ol start="3"><li><strong>事务⽇志处理器（SyncRequestProcessor）：</strong> ⽤来将事务请求记录到事务⽇志⽂件中，同时<br>会触发 Zookeeper 进⾏数据快照。 </li><li><strong>应答处理器（AckRequestProcessor）：</strong> 负责在 SyncRequestProcessor 完成事务⽇志记录后，向 Proposal 的投票收集器发送 ACK 反馈，以通知投票收集器当前服务器已经完成了对该 Proposal 的事务⽇志记录。 </li><li><strong>事务提交处理器（CommitProcessor）：</strong></li></ol><ul><li>对于非事务请求：该处理器会直接将其交付给下⼀级处理器处理</li><li>对于事务请求：其会等待集群内针对 Proposal 的投票直到该 Proposal 可被提交，利⽤ CommitProcessor，每个服务器都可以很好地控制对事务请求的顺序处理。</li></ul><ol start="6"><li><strong>应用队列处理器（ToBeAppliedRequestProcessor）：</strong> 该处理器有⼀个 toBeApplied 队列，用来存储那些已经被 CommitProcessor 处理过的可被提交的 Proposal。其会将这些请求交付给 FinalRequestProcessor 处理器处理，待其处理完后，再将其从 toBeApplied 队列中移除。 </li><li><strong>最终处理器（FinalRequestProcessor）：</strong> ⽤来进⾏返回请求前的操作，包括创建客户端请求的响应。针对事务请求，该处理器还会负责将事务应⽤到内存数据库中。</li></ol><h3 id="3-2-Follower"><a href="#3-2-Follower" class="headerlink" title="3.2. Follower"></a>3.2. Follower</h3><p><strong>主要工作</strong></p><ul><li>处理客户端非事务性请求（读取数据），转发事务请求给 Leader。</li><li>参与事务请求 Proposal 的投票。</li><li>参与 Leader 选举投票。</li></ul><p><strong>请求处理链</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1f49db44f526ef48b7667901bd083a56.png"></p><ol><li>FollowerRequestProcessor：当前请求若是事务请求则会将该请求转发给 Leader， Leader 在接收到这个事务请求后，就会将其提交到请求处理链，按照正常事务请求进行处理。</li><li>SendAckRequestProcessor：承担了事务日志记录反馈的角色，在完成事务日志记录后，会向 Leader 发送 ACK 消息以表明⾃身完成了事务日志的记录工作</li></ol><h3 id="3-3-Observer"><a href="#3-3-Observer" class="headerlink" title="3.3. Observer"></a>3.3. Observer</h3><p>Observer 是 ZooKeeper 自 3.3.0 版本开始引⼊的⼀个全新的服务器角色。<br>和 Follower 唯⼀的区别在于，Observer 不参与任何形式的投票，包括事务请求 Proposal 的投票和 Leader 选举投票。<br>Observer 服务器只提供非事务服务，通常⽤于在不影响集群事务处理能⼒的前提下提升集群的非事务处理能力。</p><h2 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h2><h3 id="4-1-数据快照"><a href="#4-1-数据快照" class="headerlink" title="4.1. 数据快照"></a>4.1. 数据快照</h3><p><strong>概述：</strong> 用来记录 zk 服务器上某一时刻的全量内存数据内容，并将其写入到指定的磁盘文件中，可通过 dataDir 配置文件目录。</p><p><strong>snapCount 参数：</strong> 设置两次快照之间的事务操作个数。zk 节点记录完事务日志时，若距离上次快照，事务操作次数等于 <strong>snapCount/2~snapCount</strong> 中的某个值时，会触发快照生成操作，随机值是为了避免所有节点同时生成快照，导致集群影响缓慢）。</p><h3 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2. 事务日志"></a>4.2. 事务日志</h3><p>所有事务操作都是需要记录到日志文件中的，可通过 dataLogDir 配置文件目录，文件是以写入的第一条事务 zxid 为后缀，方便后续的定位查找。</p><p>zk 会采取 “磁盘空间预分配” 的策略，来避免磁盘 Seek 频率，提升 zk 服务器对事务请求的影响能力。默认设置下，每次事务日志写入操作都会实时刷入磁盘，也可以设置成非实时（写到内存文件流，定时批量写入磁盘），但那样断电时会带来丢失数据的风险。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-事务-Id&quot;&gt;&lt;a href=&quot;#1-事务-Id&quot; class=&quot;headerlink&quot; title=&quot;1. 事务 Id&quot;&gt;&lt;/a&gt;1. 事务 Id&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;变更状态：&lt;/em&gt;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土⑦：应用场景</title>
    <link href="https://ccomma.cn/f29d3530f0bf/"/>
    <id>https://ccomma.cn/f29d3530f0bf/</id>
    <published>2024-04-01T08:44:16.000Z</published>
    <updated>2024-04-01T09:03:37.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1. 数据发布/订阅"></a>1. 数据发布 / 订阅</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><p>即所谓的配置中⼼，顾名思义就是发布者将数据发布到 ZooKeeper 的⼀个或⼀系列节点上，供订阅者进⾏数据订阅，进⽽达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p><p><em>两种设计模式：</em></p><ul><li>推（Push）模式：服务端主动将数据更新发送给所有订阅的客户端 </li><li>拉（Pull）模式：由客户端主动发起请求来获取最新数据，通常客户端都采⽤定时进⾏轮询拉取的⽅式 </li><li>ZooKeeper 采⽤的是推拉相结合的⽅式： <ul><li>客户端向服务端注册⾃⼰需要关注的节点，⼀旦该节点的数据 发⽣变更，那么服务端就会向相应的客户端发送 Watcher 事件通知。 </li><li>客户端接收到这个消息通知之后， 需要主动到服务端获取最新的数据。</li></ul></li></ul><h3 id="1-2-配置中心"><a href="#1-2-配置中心" class="headerlink" title="1.2. 配置中心"></a>1.2. 配置中心</h3><ul><li>配置获取：应⽤在启动的时候都会主动到 ZooKeeper 服务端上进⾏⼀次配置信息的获取。同时，在指定节点上注册⼀个 Watcher 监听。</li><li>配置变更：当配置信息发⽣变更，服务端都会实时通知到所有订阅的客户端，从而达到实时获取最新配置信息的目的。</li></ul><h2 id="2-命名服务"><a href="#2-命名服务" class="headerlink" title="2. 命名服务"></a>2. 命名服务</h2><p>通过调⽤ ZooKeeper 节点创建的 API 接⼝可以创建⼀个顺序节点，并且在 API 返回值中会返回这个节点的完整名字。利⽤这个特性，我们就可以借助 ZooKeeper 来⽣成全局唯⼀的 ID</p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/872ac0d047ee554d2bc6134cc2c7b4ae.png"></p><h2 id="3-集群管理"><a href="#3-集群管理" class="headerlink" title="3. 集群管理"></a>3. 集群管理</h2><p>我们经常会有类似于如下的需求：</p><ul><li>如何快速的统计出当前⽣产环境下⼀共有多少台机器</li><li>如何快速的获取到机器上下线的情况</li><li>如何实时监控集群中每台主机的运⾏时状态</li></ul><h3 id="3-1-分布式日志收集系统"><a href="#3-1-分布式日志收集系统" class="headerlink" title="3.1. 分布式日志收集系统"></a>3.1. 分布式日志收集系统</h3><p><strong>问题：</strong><br>如何快速、合理、动态地为每个日志收集器分配对应的⽇志生产机器。<br>⽇志生产机器和日志收集机器的扩容和缩容</p><p><strong>步骤：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/172876d295f806af735b9948b1cb3e59.png"></p><ol><li><p><em>注册收集器：</em> 每个收集机器启动时，都会在总节点下创建⾃⼰的节点，例如 <code>/logs/collector/[Hostname]</code> </p><blockquote><p>节点类型为持久节点。若为临时节点，其在会话结束后会被删除，分配的日志生产节点也会消失。</p><p>所以可以通过定期维护 status 子节点来表明机器状态</p></blockquote></li><li><p><em>任务分发：</em> 系统根据收集器节点下⼦节点的个数，将所有⽇志生产机器分成对应的若⼲组，然后将分组后的机器列表分别写到这些收集器机器创建的⼦节点上去 </p></li><li><p><em>状态汇报：</em></p></li></ol><ul><li>每个收集器在创建完节点后，还需要在其⼦节点上创建⼀个⼦节点代表状态，例如 <code>/logs/collector/host1/status</code>。</li><li>每个收集器需要定期向该节点写⼊⾃⼰的状态信息（⼼跳检测机制），通常写⼊⽇志收集进度信息。⽇志系统根据该节点的最后更新时间来判断对应的收集器是否存活。</li></ul><ol start="4"><li><em>动态分配：</em> ⽇志系统始终关注 <code>/logs/collector</code> 这个节点下所有⼦节点的变更，⼀旦检测到有收集器停⽌汇报或是有新的收集器加⼊，就要开始进⾏任务的重新分配。 <blockquote><p>若采⽤ Watcher 机制，那么通知的消息量的⽹络开销⾮常⼤。</p><p>可采⽤⽇志系统主动轮询收集器节点的策略，这样可以节省⽹络流量，但是存在⼀定的延时。</p></blockquote></li></ol><h2 id="4-Master-选举"><a href="#4-Master-选举" class="headerlink" title="4. Master 选举"></a>4. Master 选举</h2><p><strong>作用：</strong> 达到只使用一台 Master 处理逻辑，同步至多台 Follower 的效果<br><strong>原理：</strong> ZooKeeper 在分布式高并发下能使节点的创建保证全局唯⼀性，Master 选举可理解成多机器抢分布式锁的过程。<br><strong>过程：</strong></p><ol><li>Client 集群每天定时会通过 ZooKeeper 来实现 Master 选举 <ol><li>在 ZooKeeper 上创建⼀个⽇期节点，例如 2020-11-11。</li><li>Client 集群每天都会定时创建⼀个临时节点，例如 <code>/master_election/2020-1111/binding</code>。创建成功的客户端成为 Master。其他成功创建节点的客户端，都会在节点 <code>/master_election/2020-11-11</code> 上注册⼀个子节点变更的 Watcher，⽤于监控当前的 Master 机器是否存活。</li><li>⼀旦发现当前的 Master 挂了，那么其余的客户端将会重新进行 Master 选举。</li></ol></li><li>Master 会负责进⾏⼀系列的海量数据处理，最终计算得到⼀个数据结果，并将其放置在⼀个内存 / 数据库中。同时，Master 还需要通知集群中其他所有的客户端从这个内存 / 数据库中共享计算结果。</li></ol><p><strong>缺点：</strong><br>负载大，扩展性差。如果有上万个客户端都参与竞选，意味着同时会有上万个写请求。<br>由于 ZooKeeper 会把写请求转发到 Leader 来处理，再广播到 Follower，所以其写性能不高。<br>同时一旦 Leader 放弃领导权，ZooKeeper 需要同时通知上万个 Follower，负载较大。</p><h2 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. 分布式锁</h2><h3 id="5-1-排他锁（非公平）"><a href="#5-1-排他锁（非公平）" class="headerlink" title="5.1. 排他锁（非公平）"></a>5.1. 排他锁（非公平）</h3><p><strong>概述：</strong> 加锁期间，只允许持有锁的对象对数据进⾏读取和更新操作<br><strong>实现：</strong></p><ul><li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，例如 <code>/exclusive_lock/lock</code> 节点就可以被定义为⼀个锁</li><li><em>获取锁：</em> 在 <code>/exclusive_lock</code> 节点下创建临时⼦节点 <code>/exclusive_lock/lock</code>，成功创建的客户端就被认为获取了锁。所有没有获取到锁的客户端就需要到 <code>/exclusive_lock</code> 节点上注册⼀个⼦节点变更的 Watcher 监听</li><li><em>释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知所有在 <code>/exclusive_lock</code> 节点上注册了⼦节点变更 Watcher 监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li></ul><h3 id="5-2-排他锁（公平）"><a href="#5-2-排他锁（公平）" class="headerlink" title="5.2. 排他锁（公平）"></a>5.2. 排他锁（公平）</h3><p><strong>实现：</strong></p><ul><li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，<code>/shared_lock/[Hostname]-请求类型-序号</code> 的临时顺序节点 </li><li><em>获取锁：</em> 所有客户端都会到 <code>/shared_lock</code> 这个节点下⾯创建⼀个临时顺序节点，然后获取 <code>/shared_lock</code> 节点下所有⼦节点 <ol><li>若自己不是序号最小的子节点，那么客户端调用 <code>exist()</code> 方法监听前一个节点。</li><li>接收到 Watcher 通知后，检查自己是不是最小子节点（可能只是前面的未持锁节点宕机了）</li></ol></li><li><em>释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li></ul><h3 id="5-3-共享锁"><a href="#5-3-共享锁" class="headerlink" title="5.3. 共享锁"></a>5.3. 共享锁</h3><p><strong>概述：</strong> 加锁期间，只允许所有持锁对象对数据进行读取操作，不允许写操作。<br><strong>实现：</strong> 与公平排他锁类似</p><ul><li><em>定义锁：</em> 通过 ZooKeeper 上的临时数据节点来表示⼀个锁，<code>/shared_lock/[Hostname]-请求类型-序号</code> 的临时顺序节点 <img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8a9f71d3efc49a65b07fe21eceb64447.png"> </li><li><em>获取锁：</em> 所有客户端都会到 <code>/shared_lock</code> 这个节点下⾯创建⼀个临时顺序节点，然后获取 <code>/shared_lock</code> 节点下所有⼦节点 <ol start="3"><li><em>对于读请求：</em> 若没有比自己序号小的子节点或所有比自己序号小的⼦节点都是读请求，那么表明自己已经成功获取到共享锁，同时开始执行读取逻辑。否则客户端调用 <code>exist()</code> 方法监听前一个 <strong>写请求</strong> 节点。</li><li><em>对于写请求：</em> 若⾃⼰不是序号最小的⼦节点，那么客户端调用 <code>exist()</code> 方法监听前一个节点。</li><li>接收到 Watcher 通知后，重复步骤 1</li></ol></li><li><em> 释放锁：</em> 客户端挂掉或者客户端完成业务删除节点。ZooKeeper 会通知监听的客户端。客户端在接收到通知后，再次重新发起分布式锁获取。</li></ul><h2 id="6-分布式队列"><a href="#6-分布式队列" class="headerlink" title="6. 分布式队列"></a>6. 分布式队列</h2><p>ZooKeeper 不适合作为队列</p><ul><li><em>节点大小不足：</em> ZK 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含的消息非常大。</li><li><em>内存空间不足：</em> ZK 的数据库完全放在内存中。 大量的 Queue 意味着会占用很多的内存空间。</li><li><em>启动慢：</em> 如果有很多节点，ZK 启动时相当的慢。 而使用 queue 会导致好多 ZNode. 你需要显著增大 initLimit 和 syncLimit。</li><li><em>性能差：</em> 包含成千上万的子节点的 ZNode 时， ZK 的性能变得不好</li></ul><h3 id="6-1-FIFO-先入先出队列"><a href="#6-1-FIFO-先入先出队列" class="headerlink" title="6.1. FIFO 先入先出队列"></a>6.1. FIFO 先入先出队列</h3><p>和锁的实现相似<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/45d398e97319878e6f0f72aabc3ae369.png"></p><ol><li>创建持久顺序节点（由于创建的节点是持久化的，所以不必担心队列消息的丢失问题）</li><li>获取列表判断是否为最小顺序节点 <ol><li>最小：处理逻辑，之后删除</li><li>不是最小：监听并等待前一个节点</li></ol></li></ol><h3 id="6-2-Barrier-分布式屏障（同步队列）"><a href="#6-2-Barrier-分布式屏障（同步队列）" class="headerlink" title="6.2. Barrier 分布式屏障（同步队列）"></a>6.2. Barrier 分布式屏障（同步队列）</h3><p><strong>概述：</strong> 特指系统之间的⼀个协调条件，规定了⼀个队列的元素必须都集聚后才能统⼀进⾏安排，否则⼀直等待<br><strong>应⽤场景：</strong> ⼤规模分布式并⾏计算，最终的合并计算需要基于很多并⾏计算的⼦结果来进⾏<br><strong>过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d7ca5543eda4547bae7f6f90e287bb7e.png"></p><ol><li>/queque_barrier 节点值为 10，客户端再该节点下创建子节点</li><li>获取 /queue_barrier 节点的数据内容：10</li><li> 获取全部节点列表并注册对 /queque_barrier 子节点变化的监听</li><li>若子节点个数不足 10 个则等待直到个数等于 10</li><li> 若子节点个数等于 10 则进行业务处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-数据发布-订阅&quot;&gt;&lt;a href=&quot;#1-数据发布-订阅&quot; class=&quot;headerlink&quot; title=&quot;1. 数据发布/订阅&quot;&gt;&lt;/a&gt;1. 数据发布 / 订阅&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土⑥：API</title>
    <link href="https://ccomma.cn/6ca75d594150/"/>
    <id>https://ccomma.cn/6ca75d594150/</id>
    <published>2024-04-01T08:40:32.000Z</published>
    <updated>2024-04-01T09:03:37.221Z</updated>
    
    <content type="html"><![CDATA[<p>zk 有 Session，没有线程池的概念</p><h2 id="1-原生-API"><a href="#1-原生-API" class="headerlink" title="1. 原生 API"></a>1. 原生 API</h2><p>Zookeeper API 共包含五个包：</p><ul><li>org.apache.zookeeper</li><li>org.apache.zookeeper.data</li><li>org.apache.zookeeper.server</li><li>org.apache.zookeeper.server.quorum</li><li>org.apache.zookeeper.server.upgrade</li></ul><p>依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-1-建立会话"><a href="#1-1-建立会话" class="headerlink" title="1.1. 建立会话"></a>1.1. 建立会话</h3><p>ZooKeeper 客户端和服务端会话的建⽴是⼀个异步的过程。<br>所以如果在 <code>new ZooKeeper</code> 后立即结束方法会话不能建立完毕，会话的⽣命周期中处于 CONNECTING 的状态。<br>当会话真正创建完毕后 ZooKeeper 服务端会向会话对应的客户端发送⼀个事件通知以告知客户端。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateSession</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端可以通过创建⼀个 zk 实例来连接 zk 服务器</span></span><br><span class="line"><span class="comment">- connectString：连接地址：IP：端⼝</span></span><br><span class="line"><span class="comment">- sesssionTimeOut：会话超时时间：单位毫秒</span></span><br><span class="line"><span class="comment">- Wather：监听器(当特定事件触发监听时，zk 会通过 watcher 通知到客户端)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181,10.211.55.5:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        System.out.println(zooKeeper.getState());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"=========Client Connected to zookeeper=========="</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-创建节点"><a href="#1-2-创建节点" class="headerlink" title="1.2. 创建节点"></a>1.2. 创建节点</h3><p><em>ZooKeeper#create(String path, byte[] data, List<acl> acl, CreateMode createMode)：</acl></em></p><ul><li>path：节点创建的路径</li><li> data：节点创建要保存的数据</li><li> acl：节点创建的权限信息（4 种类型） <ul><li>ZooDefs.Ids.ANYONE_ID_UNSAFE：表示任何⼈</li><li> ZooDefs.Ids.AUTH_IDS：此 ID 仅可⽤于设置 ACL。它将被客户机验证的 ID 替换。</li><li>ZooDefs.Ids.OPEN_ACL_UNSAFE：这是⼀个完全开放的 ACL （常⽤）–&gt; world:anyone</li><li>ZooDefs.Ids.CREATOR_ALL_ACL：此 ACL 授予创建者身份验证 ID 的所有权限</li></ul></li><li> createMode：创建节点的类型（4 种类型） <ul><li>CreateMode.PERSISTENT：持久节点</li><li> CreateMode.PERSISTENT_SEQUENTIAL：持久顺序节点</li><li> CreateMode.EPHEMERAL：临时节点</li><li> CreateMode.EPHEMERAL_SEQUENTIAL：临时顺序节点 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateNote</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调⽤创建节点⽅法</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                createNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodePersistent</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_persistent"</span>, <span class="string">"持久节点内容"</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodePersistentSequential</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_persistent_sequential"</span>, <span class="string">"持久节点内容"</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nodeEpersistent</span> <span class="operator">=</span> zooKeeper.create(<span class="string">"/lg_ephemeral"</span>, <span class="string">"临时节点内容"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"创建的持久节点是:"</span> + nodePersistent);</span><br><span class="line">        System.out.println(<span class="string">"创建的持久顺序节点是:"</span> + nodePersistentSequential);</span><br><span class="line">        System.out.println(<span class="string">"创建的临时节点是:"</span> + nodeEpersistent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="1-3-获取节点数据"><a href="#1-3-获取节点数据" class="headerlink" title="1.3. 获取节点数据"></a>1.3. 获取节点数据</h3><ol><li><em>ZooKeeper#getData(String path, boolean watch, Stat stat)：</em></li></ol><ul><li>path：获取数据的路径</li><li> watch：是否开启监听。ture 代表使用创建 zk 的那个监听</li><li> stat：节点状态信息，null 则表示获取最新版本的数据</li></ul><ol start="2"><li><em> ZooKeeper#getChildren(String path, boolean watch)</em></li></ol><ul><li>path：路径</li><li> watch：是否要启动监听，当⼦节点列表发⽣变化，会触发监听 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNoteData</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">10000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    getNoteData();</span><br><span class="line">                    getChildren();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ⼦节点列表发⽣变化时，服务器会发出 NodeChildrenChanged 通知，但不会把变化情况告诉给客户端</span></span><br><span class="line">            <span class="comment">// 需要客户端⾃⾏获取，且通知是⼀次性的，需反复注册监听</span></span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getType() == Watcher.Event.EventType.NodeChildrenChanged) {</span><br><span class="line">                <span class="comment">// 再次获取节点数据</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    List&lt;String&gt; children = zooKeeper.getChildren(watchedEvent.getPath(), <span class="literal">true</span>);</span><br><span class="line">                    System.out.println(children);</span><br><span class="line">                } <span class="keyword">catch</span> (KeeperException | InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNoteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException {</span><br><span class="line">        List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">"/lg_persistent"</span>, <span class="literal">true</span>);</span><br><span class="line">        System.out.println(children);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="1-4-修改节点数据"><a href="#1-4-修改节点数据" class="headerlink" title="1.4. 修改节点数据"></a>1.4. 修改节点数据</h3><p>Stat ZooKeeper#setData(String path, byte[] data, int version)</p><ul><li>path：路径</li><li> data：要修改的内容</li><li> version：为 -1，表示对最新版本的数据进⾏修改 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateNote</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                updateNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">"/lg_persistent"</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改前的值:"</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 stat:状态信息对象</span></span><br><span class="line">        <span class="comment">// version: -1 代表最新版本</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.setData(<span class="string">"/lg_persistent"</span>, <span class="string">"客户端修改内容"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data2 = zooKeeper.getData(<span class="string">"/lg_persistent"</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改后的值:"</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data2));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="1-5-删除节点"><a href="#1-5-删除节点" class="headerlink" title="1.5. 删除节点"></a>1.5. 删除节点</h3><ol><li><em>ZooKeeper#exists(String path, boolean watch)：</em> 判断节点是否存在</li><li><em> ZooKeeper#delete(String path, int version)：</em> 删除节点 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteNote</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">"10.211.55.4:2181"</span>, <span class="number">5000</span>, watchedEvent -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                deleteNodeSync();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNodeSync</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException {</span><br><span class="line">        <span class="type">Stat</span> <span class="variable">exists</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(exists == <span class="literal">null</span> ? <span class="string">"该节点不存在"</span>:<span class="string">"该节点存在"</span>);</span><br><span class="line"></span><br><span class="line">        zooKeeper.delete(<span class="string">"/lg_persistent/lg-children"</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">exists2</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">"/lg_persistent/lg-children"</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(exists2 == <span class="literal">null</span> ? <span class="string">"该节点不存在"</span>:<span class="string">"该节点存在"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="2-Curator"><a href="#2-Curator" class="headerlink" title="2. Curator"></a>2. Curator</h2><ol><li><a href="http://cmsblogs.com/?p=4121">【跟着实例学习 ZooKeeper】–队列</a></li><li><a href="http://cmsblogs.com/?p=4123">【跟着实例学习 ZooKeeper】–缓存</a></li><li><a href="http://cmsblogs.com/?p=4125">【跟着实例学习 ZooKeeper】–计数器</a></li><li><a href="http://cmsblogs.com/?p=4127">【跟着实例学习 ZooKeeper】–Curator 扩展库</a></li><li><a href="http://cmsblogs.com/?p=4129">【跟着实例学习 ZooKeeper】–Barrier</a></li><li><a href="http://cmsblogs.com/?p=4131">【跟着实例学习 ZooKeeper】–临时节点</a></li><li><a href="http://cmsblogs.com/?p=4133">【跟着实例学习 ZooKeeper】–Curator 框架应用</a></li><li><a href="http://cmsblogs.com/?p=4135">【跟着实例学习 ZooKeeper】– Leader 选举</a></li><li><a href="http://cmsblogs.com/?p=4137">【跟着实例学习 ZooKeeper】–分布式锁</a></li></ol><h3 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1. 连接"></a>2.1. 连接</h3><p><strong>重试策略：</strong></p><ul><li><strong>RetryNTimes：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;重试 n 次</li><li><strong> RetryOneTime：</strong> &nbsp; &nbsp; &nbsp; &nbsp;重试 1 次</li><li><strong> RetryForever：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;永远重试</li><li><strong> RetryUntilElapsed：</strong> 重试直到超过最大重试时间 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同 RetryNTimes</span></span><br><span class="line"><span class="comment">// RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 5);</span></span><br><span class="line"><span class="comment">// 实际调用 CuratorFrameworkFactory.builder().build();</span></span><br><span class="line"><span class="comment">// CuratorFramework client = CuratorFrameworkFactory.newClient("192.168.1.110:2181", retryPolicy);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 重试 3 次，每次间隔 5s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 只重试 1 次</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryOneTime</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 永远重试，每次间隔 3s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryForever</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 重试直到超过 2s，每次间隔 3s</span></span><br><span class="line"><span class="type">RetryPolicy</span> <span class="variable">retryPolicy4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryUntilElapsed</span>(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">"192.168.1.110:2181"</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .namespace(<span class="string">"workspace"</span>)</span><br><span class="line">        .build();</span><br><span class="line">client.start();</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-2-创建"><a href="#2-2-创建" class="headerlink" title="2.2. 创建"></a>2.2. 创建</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create()</span><br><span class="line">    <span class="comment">// 1.递归创建节点</span></span><br><span class="line">        <span class="comment">//.creatingParentsIfNeeded()</span></span><br><span class="line">        <span class="comment">//.withMode(createMode)</span></span><br><span class="line">    <span class="comment">// 2.ACL</span></span><br><span class="line">        <span class="comment">//.withACL(aclList)</span></span><br><span class="line">        .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-设置节点数据"><a href="#2-3-设置节点数据" class="headerlink" title="2.3. 设置节点数据"></a>2.3. 设置节点数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.setData()</span><br><span class="line">    <span class="comment">// 可带版本</span></span><br><span class="line">    <span class="comment">//.withVersion(version)</span></span><br><span class="line">    .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-删除"><a href="#2-4-删除" class="headerlink" title="2.4. 删除"></a>2.4. 删除</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">    <span class="comment">// 1.如果删除失败，那么在后端还是继续会删除，直到成功（强制删除）</span></span><br><span class="line">    <span class="comment">//.guaranteed()</span></span><br><span class="line">    <span class="comment">// 2.如果有子节点，就删除</span></span><br><span class="line">    <span class="comment">//.deletingChildrenIfNeeded()</span></span><br><span class="line">    <span class="comment">// 3.指定版本</span></span><br><span class="line">    <span class="comment">//.withVersion(1)</span></span><br><span class="line">    .forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-5-读取节点数据"><a href="#2-5-读取节点数据" class="headerlink" title="2.5. 读取节点数据"></a>2.5. 读取节点数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">    <span class="comment">// 包含状态查询</span></span><br><span class="line">    <span class="comment">//.storingStatIn(stat)</span></span><br><span class="line">    .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"节点"</span> + nodePath + <span class="string">"的数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">System.out.println(<span class="string">"该节点的版本号为："</span>+ stat.getVersion());</span><br></pre></td></tr></tbody></table></figure><h3 id="2-6-获取子节点"><a href="#2-6-获取子节点" class="headerlink" title="2.6. 获取子节点"></a>2.6. 获取子节点</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nodeList = client.getChildren().forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-7-检查节点是否存在"><a href="#2-7-检查节点是否存在" class="headerlink" title="2.7. 检查节点是否存在"></a>2.7. 检查节点是否存在</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkExists</span><span class="params">(String nodePath)</span> {</span><br><span class="line">    <span class="keyword">return</span> client.checkExists().forPath(nodePath) != <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-8-监听器"><a href="#2-8-监听器" class="headerlink" title="2.8. 监听器"></a>2.8. 监听器</h3><p>usingWatcher<br><strong>概述：</strong> 监听只会触发一次</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">            .usingWatcher(event -&gt; System.out.println(<span class="string">"触发watcher，节点路径为："</span> + event.getPath()))</span><br><span class="line">            .forPath(nodePath);</span><br></pre></td></tr></tbody></table></figure><p>NodeCache<br><strong>概述：</strong> 永久监听 <strong>当前路径的节点</strong> 的创建、更新、删除</p><p><em>start()：</em></p><ul><li>NodeCache#start()</li><li>NodeCache#start (boolean buildInitial)： true 表示初始化时获取 node 的值并保存 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, nodePath);</span><br><span class="line"><span class="comment">// true 表示初始化时获取 node 的值并保存</span></span><br><span class="line">nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">nodeCache.getListenable().addListener(() -&gt; {</span><br><span class="line">    <span class="type">ChildData</span> <span class="variable">currentData</span> <span class="operator">=</span> nodeCache.getCurrentData();</span><br><span class="line">    System.out.println(<span class="string">"节点 "</span>+ currentData.getPath() + <span class="string">" 的数据为："</span> + <span class="keyword">new</span> <span class="title class_">String</span>(currentData.getData()));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li></ul><p>PathChildrenCache<br><strong>概述：</strong> 永久监听 <strong>当前路径下的子节点</strong> 的创建、更新、删除</p><p><strong>start()：</strong></p><ul><li><strong>NodeCache#start()：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;默认 buildInitial 为 false </li><li><strong>NodeCache#start(boolean buildInitial)：</strong> true 表示初始化时获取 node 的值并保存 </li><li><strong>NodeCache#start(StartMode mode)：</strong> </li><li><ul><li>StartMode.<em>POST_INITIALIZED_EVENT：</em> 异步初始化，并触发 INITIALIZED 事件</li><li> StartMode.<em>NORMAL：</em> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 异步初始化</li><li> StartMode.<em>BUILD_INITIAL_CACHE：</em> &nbsp; &nbsp; &nbsp; &nbsp;同步初始化</li></ul></li></ul><p><strong>事件类型：</strong></p><ul><li><strong>INITIALIZED：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 初始化事件</li><li><strong> CHILD_ADDED：</strong> &nbsp; &nbsp; &nbsp;子节点添加事件</li><li><strong> CHILD_REMOVED：</strong> 子节点删除事件</li><li><strong> CHILD_UPDATED：</strong> &nbsp;子节点更新事件 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true 表示把节点内容放入 stat 里</span></span><br><span class="line"><span class="type">PathChildrenCache</span> <span class="variable">childrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, nodePath, <span class="literal">true</span>);</span><br><span class="line">childrenCache.start(StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步初始化后可获取子节点数据</span></span><br><span class="line">List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line"><span class="keyword">for</span> (ChildData childData : childDataList) {</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(childData.getData()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听子节点</span></span><br><span class="line">childrenCache.getListenable().addListener((client, event) -&gt; {</span><br><span class="line">    <span class="type">ChildData</span> <span class="variable">eventData</span> <span class="operator">=</span> event.getData();</span><br><span class="line">    <span class="comment">// 初始化事件</span></span><br><span class="line">    <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) {</span><br><span class="line">        System.out.println(<span class="string">"子节点初始化完成"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点添加事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) {</span><br><span class="line">        System.out.println(<span class="string">"添加子节点 "</span> + eventData.getPath() + <span class="string">": "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(eventData.getData()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点删除事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {</span><br><span class="line">        System.out.println(<span class="string">"删除子节点 "</span> + eventData.getPath());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 子节点更新事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {</span><br><span class="line">        System.out.println(<span class="string">"修改子节点 "</span> + eventData.getPath() + <span class="string">": "</span> + <span class="keyword">new</span> <span class="title class_">String</span>(eventData.getData()));</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;zk 有 Session，没有线程池的概念&lt;/p&gt;
&lt;h2 id=&quot;1-原生-API&quot;&gt;&lt;a href=&quot;#1-原生-API&quot; class=&quot;headerlink&quot; title=&quot;1. 原生 API&quot;&gt;&lt;/a&gt;1. 原生 API&lt;/h2&gt;&lt;p&gt;Zookeeper API 共</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土⑤：四字命令（Four Letter Words）</title>
    <link href="https://ccomma.cn/3766fb8154b0/"/>
    <id>https://ccomma.cn/3766fb8154b0/</id>
    <published>2024-04-01T08:39:46.000Z</published>
    <updated>2024-04-01T09:03:37.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装 nc：</strong> <code>yum install nc</code><br><strong>命令格式：</strong> echo [commond] | nc [ip] [port]<br><strong>stat：</strong> 查看 zk 的状态信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo stat | nc localhost 2181</span><br><span class="line">Zookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients:</span><br><span class="line">/127.0.0.1:55394 [0] (queued-0, recved=1, sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 2</span><br><span class="line">Sent: 1</span><br><span class="line">Connections: 1</span><br><span class="line">Outatanding: 0</span><br><span class="line">Zxid: 0xed</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 29</span><br></pre></td></tr></tbody></table></figure><p><strong>conf：</strong> 查看服务器配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo conf | nc localhost 2181</span><br><span class="line">clientFort=2181</span><br><span class="line">dataDir=/uar/local/zookeeper-3.4.9/dataDir/version-2</span><br><span class="line">dataLogDir=/usr/local/zookeeper-3.4.9/dataLoaDir/version-2</span><br><span class="line">tickTime=2000</span><br><span class="line">maxClientCnxns=60</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=40000</span><br><span class="line">serverId=0</span><br></pre></td></tr></tbody></table></figure><p><strong>cons：</strong> 显示连接到服务器的客户端信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo cons | nc localhost 2181</span><br><span class="line">/127.0.0.1:55442[1](queued-0,recved=1,sent=1,sid=0x16b1af459260001,lop=SESS,est=1559532063700,to=30000,lcxid=0x0,lzxid=0x0,lresp=1559532063718,llat=5,minlat=0,avglat=5,maxlat=5)</span><br><span class="line">/127.0.0.1:55444[0](queued=0,recved=1,sent=0)</span><br></pre></td></tr></tbody></table></figure><p><strong>envi：</strong> 环境变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo envi | nc localhost 2181</span><br><span class="line">Environment:</span><br><span class="line">zookeeper.version=3.4.9-1757313, built on 08/23/2016 06:50 GMT</span><br><span class="line">host,name=izbp101vzs716yznuegsliz</span><br><span class="line">java.version=1.8.0_201</span><br><span class="line">java.vendor=Oracle Corporation</span><br><span class="line">java.home=/usr/jdk/jdk1.8.0_ 201/jre</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p><strong>mntr：</strong> 监控 zk 健康信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo mntr | nc localhost 2181</span><br><span class="line">zk_version  3.4.9-1757313, built on o8/23/2016 06:50 GMT</span><br><span class="line">zk_avg_latency 0</span><br><span class="line">zk_max_latency 25</span><br><span class="line">zk_min_latency 0</span><br><span class="line">zk_packets_received  78</span><br><span class="line">zk_packets_sent 77</span><br><span class="line">zk_num_alive_connections</span><br><span class="line">zk_outstanding_requests 0</span><br><span class="line">zk_server_state standalone</span><br><span class="line">zk_znode_count 29</span><br><span class="line">zk_watch_count 0</span><br><span class="line">zk_ephemerals_count 0</span><br><span class="line">zk_approximate_data_size  553</span><br><span class="line">zk_open_file_descriptor_count 27</span><br><span class="line">zk_max_file_descriptor_count 65535</span><br></pre></td></tr></tbody></table></figure><p><strong>wchs：</strong> 显示 watch 的信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchs | nc localhost 2181</span><br><span class="line">1 connections watching 1 paths</span><br><span class="line">Total watches:1</span><br></pre></td></tr></tbody></table></figure><p><strong>wchc：</strong> watch 的 session 与 watch</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchc | nc localhost 2181</span><br><span class="line">0x16b1af459260001</span><br><span class="line">/zookeeper</span><br></pre></td></tr></tbody></table></figure><p><strong>wchp：</strong> watch 的 path 与 watch 信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo wchp | nc localhost 2181</span><br><span class="line">/zookeeper</span><br><span class="line">0x16b1af459260001</span><br></pre></td></tr></tbody></table></figure><p><strong>ruok（Are you OK？）：</strong> 查看当前 &nbsp;zkServer 是否启动，返回 imok（I am OK）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo ruok | nc localhost 2181</span><br><span class="line">imok</span><br></pre></td></tr></tbody></table></figure><p><strong>dump：</strong> 列出未经处理的会话和临时节点</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp101vzs716yznuegsljz bin]# echo dump | nc localhost 2181</span><br><span class="line">SessionTracker dump:</span><br><span class="line">Session Sets (4):</span><br><span class="line">0 expire at Mon Jun 03 11:11:24 CST 2019:</span><br><span class="line">0 expire at Mon Jun 03 11:11:34 CST 2019:</span><br><span class="line">0 expire at Mon Jun 03 11:11:44 CST 2019:</span><br><span class="line">1 expire at Mon Jun 03 11:11:48 CST 2019:</span><br><span class="line">0x16b1af459260000</span><br><span class="line">ephemeral nodes dump:</span><br><span class="line">Sessions with Ephemerals (1):</span><br><span class="line">0x16b1af459260000:</span><br><span class="line">/test/temg</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;安装 nc：&lt;/strong&gt; &lt;code&gt;yum install nc&lt;/code&gt;&lt;br&gt;&lt;strong&gt;命令格式：&lt;/strong&gt; echo [commond] | nc [ip] [port]&lt;br&gt;&lt;strong&gt;stat：&lt;/strong&gt; 查</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土④：ACL 权限</title>
    <link href="https://ccomma.cn/b4d982169ec9/"/>
    <id>https://ccomma.cn/b4d982169ec9/</id>
    <published>2024-04-01T08:38:42.000Z</published>
    <updated>2024-04-01T09:03:37.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ACL-构成"><a href="#1-ACL-构成" class="headerlink" title="1. ACL 构成"></a>1. ACL 构成</h2><p><strong>概述：</strong> 针对节点可以设置相关读写权限，保障数据安全</p><p>通过 <code>scheme:id:permissions</code> 来构成权限列表</p><ul><li><strong>scheme：</strong> &nbsp; &nbsp; &nbsp; &nbsp; 代表采用的某种权限机制</li><li><strong> id：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 代表允许访问的用户</li><li><strong> permissions：</strong> 代表允许的操作权限</li></ul><p><em>例：</em> setAcl path world:anyone:d 代表为 path 下的节点设置权限为所有人都只能删除该节点</p><h3 id="1-1-scheme-类型"><a href="#1-1-scheme-类型" class="headerlink" title="1.1. scheme 类型"></a>1.1. scheme 类型</h3><ul><li><strong>world（world:anyone:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 默认权限。只有一个用户 —— anyone</li><li><strong>auth（auth:user:password:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;代表认证登录，需要注册用户拥有权限</li><li><strong> digest（digest:username:BASE64(SHA1(password)):[permissions]）：</strong> 需要对密码加密才能访问</li><li><strong> ip（ip:192.168.1.1:[permissions]）：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;限制 ip 进行访问</li><li><strong> super：</strong> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 超级管理员，拥有所有权限</li></ul><h3 id="1-2-permissions"><a href="#1-2-permissions" class="headerlink" title="1.2. permissions"></a>1.2. permissions</h3><p><em>crdwa 代表的权限含义：</em></p><ul><li><strong>CREATE：</strong> 创建 <strong>子节点</strong></li><li><strong> READ：</strong> &nbsp; &nbsp; 读取节点数据</li><li><strong> WRITE：</strong> &nbsp; &nbsp;往节点写入数据</li><li><strong> DELETE：</strong> 删除 <strong>子节点，对于 delete 权限，要谨慎规划</strong></li><li><strong> ADMIN：</strong> &nbsp; 可以使用 setAcl 命令设置权限</li></ul><h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h2><h3 id="2-1-addauth-scheme-auth"><a href="#2-1-addauth-scheme-auth" class="headerlink" title="2.1. addauth scheme auth"></a>2.1. addauth scheme auth</h3><p><strong>概述：</strong><br>添加认证授权信息到 Zookeeper 库中（注册）<br>并使用该认证作为当前客户端的认证信息（登录），这之后进行的所有操作会以该认证为前提<br>密码需输入明文，但在 Zookeeper 中密码以加密形式存储</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] addauth digest ccomma:ccomma</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-setAcl-path-schemepwd-permissions"><a href="#2-2-setAcl-path-schemepwd-permissions" class="headerlink" title="2.2. setAcl path schemepwd:permissions"></a>2.2. setAcl path scheme<img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/da6180df7a470ee728d47348410724ae.svg">pwd:permissions</h3><p><strong>auth：</strong></p><ul><li><p>设置某个节点的 acl 权限信息 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] setAcl /ccomma auth:ccomma:ccomma:crdwa</span><br><span class="line">cZxid = 0x18</span><br><span class="line">ctime = Mon May 27 16:36:40 CST 2019</span><br><span class="line">mZxid = 0x2b</span><br><span class="line">mtime = Mon May 30 16:10:49 CST 2019</span><br><span class="line">pZxid = 0x1f</span><br><span class="line">cversion = 5</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure></li><li><p>当使用 addauth 添加认证后，setAcl 账号和密码可以省略，默认取第一个认证 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] setAcl /ccomma auth::crdwa</span><br><span class="line">cZxid = 0x18</span><br><span class="line">ctime = Mon May 27 16:36:40 CST 2019</span><br><span class="line">mZxid = 0x2b</span><br><span class="line">mtime = Mon May 30 16:10:49 CST 2019</span><br><span class="line">pZxid = 0x1f</span><br><span class="line">cversion = 5</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>digest：</strong> 密码加密</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] setAcl /ccomma digest:ccomma:91PXC4WimSDWZikp99kGvvjeVnY=:crdwa</span><br><span class="line">cZxid = 0x60</span><br><span class="line">ctime = Fri May 31 13:33:42 CST 2019</span><br><span class="line">mZxid = 0x60</span><br><span class="line">mtime = Fri May 31 13:33:42 CST 2019</span><br><span class="line">pZxid = 0x60</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 1</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure><p><strong>ip：</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] setAcl /ccomma/ip ip:192.168.1.7:crdwa</span><br><span class="line">cZxid = 0x62</span><br><span class="line">ctime = Fri May 31 13:36:51 CST 2019</span><br><span class="line">mZxid = 0x62</span><br><span class="line">mtime = Fri May 31 13:36:51 CST 2019</span><br><span class="line">pZxid = 0x62</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 2</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] getAcl /ccomma/ip</span><br><span class="line">'ip,'192.168.1.7</span><br><span class="line">:crdwa</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-getAcl-path"><a href="#2-3-getAcl-path" class="headerlink" title="2.3. getAcl path"></a>2.3. getAcl path</h3><p>获取某个节点的 acl 权限信息<br>密码以密文形式存储</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /ccomma</span><br><span class="line">'digest,'ccomma:91PXC4WimSDWZikp99kGvvjeVnY=</span><br><span class="line">:crdwa</span><br></pre></td></tr></tbody></table></figure><h2 id="3-super-auth"><a href="#3-super-auth" class="headerlink" title="3. super auth"></a>3. super auth</h2><p><strong>添加超级用户：</strong><br>在 nohup “JAVA” “-Dzookeeper.log.dir={ZOO_LOG_DIR}” “-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}” &nbsp;后面加上 “-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:9iPCX4WimSDWZikp99kGvvjeVnY=”</p><p>代表添加超级用户 admin:9iPCX4WimSDWZikp99kGvvjeVnY= （明文：ccomma）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">    echo  -n "Starting zookeeper ... "</span><br><span class="line">    if [ -f "$ZOOPIDFILE" ]; then</span><br><span class="line">      if kill -0 `cat "$ZOOPIDFILE"` &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">         echo $command already running as process `cat "$ZOOPIDFILE"`.</span><br><span class="line">         exit 0</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">    nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" </span><br><span class="line">    "-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:9iPCX4WimSDWZikp99kGvvjeVnY=" \</span><br><span class="line">    -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG" &gt; "$_ZOO_DAEMON_OUT" 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">      case "$OSTYPE" in</span><br><span class="line">      *solaris*)</span><br><span class="line">        /bin/echo "${!}\\c" &gt; "$ZOOPIDFILE"</span><br><span class="line">        ;;</span><br><span class="line">      *)</span><br><span class="line">        /bin/echo -n $! &gt; "$ZOOPIDFILE"</span><br><span class="line">        ;;</span><br><span class="line">      esac</span><br><span class="line">      if [ $? -eq 0 ];</span><br><span class="line">      then</span><br><span class="line">        sleep 1</span><br><span class="line">        echo STARTED</span><br><span class="line">      else</span><br><span class="line">        echo FAILED TO WRITE PID</span><br><span class="line">        exit 1</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">      echo SERVER DID NOT START</span><br><span class="line">      exit 1</span><br><span class="line">    fi</span><br><span class="line">    ;;</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ACL-构成&quot;&gt;&lt;a href=&quot;#1-ACL-构成&quot; class=&quot;headerlink&quot; title=&quot;1. ACL 构成&quot;&gt;&lt;/a&gt;1. ACL 构成&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt; 针对节点可以设置相关读写权限，保障数据安全&lt;/</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土③：Watcher</title>
    <link href="https://ccomma.cn/e8305ee4e550/"/>
    <id>https://ccomma.cn/e8305ee4e550/</id>
    <published>2024-04-01T08:37:14.000Z</published>
    <updated>2024-04-01T09:03:37.224Z</updated>
    
    <content type="html"><![CDATA[<p><em>概述：</em> 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h2><ul><li><em>一次性：</em> watcher 触发后立即销毁。</li><li><em>轻量级：</em> watch 是轻量级的，其实就是本地 JVM 的 Callback，服务器端只是存了是否有设置了 watcher 的布尔类型</li><li><em>可见性：</em> Watch 被触发的同时再次读取数据，客户端会得到 Watch 消息再看到更新后的数据。</li><li><em>可能会丢失：</em> 对于一个未创建的 znode 的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 Watch 事件可能会被丢失。</li></ul><h2 id="2-设置-watcher"><a href="#2-设置-watcher" class="headerlink" title="2. 设置 watcher"></a>2. 设置 watcher</h2><p>只有 stat、get、ls 才能设置 watcher</p><h2 id="3-事件类型"><a href="#3-事件类型" class="headerlink" title="3. 事件类型"></a>3. 事件类型</h2><p><em>NodeCreated：</em> 创建节点事件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 38] stat /ccomma watch</span><br><span class="line">Note does not exist: /ccomma</span><br><span class="line">[zk: localhost:2181(CONNECTED) 39] create /ccomma data</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteCreated path:/ccomma</span><br><span class="line">Created /ccomma</span><br></pre></td></tr></tbody></table></figure><p><em>NodeDataChanged：</em> 修改节点数据事件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 40] get /ccomma watch</span><br><span class="line">data</span><br><span class="line">cZxid = 0x15</span><br><span class="line">ctime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">mZxid = 0x15</span><br><span class="line">mtime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">pZxid = 0x15</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] set /ccomma 123</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteDataChanged path:/ccomma</span><br><span class="line">cZxid = 0x15</span><br><span class="line">ctime = Mon May 27 16:09:24 CST 2019</span><br><span class="line">mZxid = 0x16</span><br><span class="line">mtime = Mon May 27 16:17:17 CST 2019</span><br><span class="line">pZxid = 0x15</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure><p><em>NodeDeleted：</em> 删除节点事件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 43] delete /ccomma</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteDeleted path:/ccomma</span><br></pre></td></tr></tbody></table></figure><p><em>NodeChildrenChanged：</em> 子节点变更事件（修改子节点不会触发事件）</p><ul><li><p>创建： </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 47] ls /ccomma watch</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 48] create /ccomma/abc data</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteChildrenChanged path:/ccomma</span><br><span class="line">Created /ccomma/abc</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除： </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 49] ls /ccomma watch</span><br><span class="line">[abc]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 48] delete /ccomma/abc</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NoteChildrenChanged path:/ccomma</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="4-watcher-原理框架"><a href="#4-watcher-原理框架" class="headerlink" title="4. watcher 原理框架"></a>4. watcher 原理框架</h2><p><strong>过程：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e3a61f750e1698c43d402acc21740487.png"></p><ul><li>zk 客户端向 zk 服务器注册 watcher 的同时，会将 watcher 对象存储在客户端的 watchManager。</li><li>zk 服务器触发 watcher 事件后，会向客户端发送通知，客户端线程从 watchManager 中回调 watcher 执行相应的功能。</li></ul><p><strong>watchManager：</strong><br>Zk 服务器端 watcher 的管理者。负责 watcher 事件的触发。</p><p>从两个维度维护 watcher</p><ul><li>watchTable：从数据节点的粒度来维护</li><li> watch2Paths：从 watcher 的粒度来维护 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WatchManager</span> {</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; watchTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Watcher, Set&lt;String&gt;&gt; watch2Paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Watcher, Set&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type)</span> { </span><br><span class="line">        <span class="keyword">return</span> triggerWatch(path, type, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;概述：&lt;/em&gt; 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。&lt;/p&gt;
&lt;h2 id=&quot;1-特性&quot;&gt;&lt;a href=&quot;#1-特性&quot; class=&quot;headerlink&quot; title=&quot;1. 特性&quot;&gt;&lt;/a&gt;1. 特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土②：常用命令</title>
    <link href="https://ccomma.cn/c71f39133dc3/"/>
    <id>https://ccomma.cn/c71f39133dc3/</id>
    <published>2024-04-01T08:36:11.000Z</published>
    <updated>2024-04-01T09:03:37.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ls-path-watch"><a href="#1-ls-path-watch" class="headerlink" title="1. ls path [watch]"></a>1. ls path [watch]</h2><p>查看某个路径下有多少个节点</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></tbody></table></figure><h2 id="2-ls2-path-watch"><a href="#2-ls2-path-watch" class="headerlink" title="2. ls2 path [watch]"></a>2. ls2 path [watch]</h2><p>= ls + stat</p><h2 id="3-get-path-watch"><a href="#3-get-path-watch" class="headerlink" title="3. get path [watch]"></a>3. get path [watch]</h2><p>获取值</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] get /test</span><br><span class="line">test</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0x8</span><br><span class="line">mtime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">pZxid = 0x8</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 4 </span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure><h2 id="4-stat-path-watch"><a href="#4-stat-path-watch" class="headerlink" title="4. stat path [watch]"></a>4. stat path [watch]</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] stat /</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0 </span><br><span class="line">numChildren = 1</span><br></pre></td></tr></tbody></table></figure><ul><li>cZxid：Create ZXID，表示节点被创建时的事务 ID。</li><li>ctime：Create Time，表示节点创建时间。</li><li>mZxid：Modified ZXID，表示节点最后⼀次被修改时的事务 ID。</li><li>mtime：Modified Time，表示节点最后⼀次被修改的时间。</li><li>pZxid：该节点的⼦节点列表最后⼀次被修改时的事务 ID。只有⼦节点列表变更才会更新 pZxid， ⼦节点内容变更不会更新。</li><li>cversion：⼦节点的版本号。</li><li>dataVersion：内容版本号。</li><li>aclVersion：标识 acl 版本</li><li> ephemeralOwner：创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 0</li><li>dataLength：数据⻓度。</li><li>numChildren：直系⼦节点数。</li></ul><h2 id="5-create-s-e-path-data-acl"><a href="#5-create-s-e-path-data-acl" class="headerlink" title="5. create [-s] [-e] path data acl"></a>5. create [-s] [-e] path data acl</h2><p><em>-s： sequence。顺序节点，为节点自动添加</em></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] create -s /test/sec seq</span><br><span class="line">Created test/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] ls /test</span><br><span class="line">[sec0000000001]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] create -s /test/sec seq</span><br><span class="line">Created test/sec0000000002</span><br><span class="line">[zk: localhost:2181(CONNECTED) 18] ls /test</span><br><span class="line">[sec0000000001, sec0000000002]</span><br></pre></td></tr></tbody></table></figure><p><em>-e： ephemeral。Session 创建临时节点</em></p><ul><li>非持久化，临时节点</li><li>客户端与服务端之间维持心跳联系，无心跳则删除</li><li><strong> ephemeralOwner</strong> 为非 0x0<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] create -e /test/tmp test-data</span><br><span class="line">Created test/tmp</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] get /test/tmp</span><br><span class="line">test-data</span><br><span class="line">cZxid = 0x9</span><br><span class="line">ctime = Mon May 27 14:26:43 CST 2019</span><br><span class="line">mZxid = 0x9</span><br><span class="line">mtime = Mon May 27 14:26:43 CST 2019</span><br><span class="line">pZxid = 0x9</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0 </span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x16adeeddbe80003</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="6-set-path-data-version"><a href="#6-set-path-data-version" class="headerlink" title="6. set path data [version]"></a>6. set path data [version]</h2><p><em>dataVersion 会 +1</em></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 23] set /test new-test-data</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0xc</span><br><span class="line">mtime = Mon May 27 14:53:38 CST 2019</span><br><span class="line">pZxid = 0xb</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 13</span><br><span class="line">numChildren = 3</span><br></pre></td></tr></tbody></table></figure><p><strong>version： 验证版本号</strong><br>若填写的版本号与当前版本号不一致则 set 失败</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 25] set /test new-test-data-2 1</span><br><span class="line">cZxid = 0x8</span><br><span class="line">ctime = Mon May 27 14:12:38 CST 2019</span><br><span class="line">mZxid = 0xd</span><br><span class="line">mtime = Mon May 27 15:15:12 CST 2019</span><br><span class="line">pZxid = 0xb</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 15</span><br><span class="line">numChildren = 3</span><br><span class="line">[zk: localhost:2181(CONNECTED) 26] set /test new-test-data-2 1</span><br><span class="line">version No is not valid : /test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 27] set /test new-test-data-2 3</span><br><span class="line">version No is not valid : /test</span><br></pre></td></tr></tbody></table></figure><h2 id="7-delete-path-version"><a href="#7-delete-path-version" class="headerlink" title="7. delete path [version]"></a>7. delete path [version]</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 31] delete /test/sec</span><br><span class="line">[zk: localhost:2181(CONNECTED) 32] ls /test</span><br><span class="line">[tmp]</span><br></pre></td></tr></tbody></table></figure><p><strong>version： 验证版本号</strong><br>若填写的版本号与当前版本号不一致则 delete 失败（ 同 set）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ls-path-watch&quot;&gt;&lt;a href=&quot;#1-ls-path-watch&quot; class=&quot;headerlink&quot; title=&quot;1. ls path [watch]&quot;&gt;&lt;/a&gt;1. ls path [watch]&lt;/h2&gt;&lt;p&gt;查看某个路径下有多少个节</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 从入门到入土①：概述</title>
    <link href="https://ccomma.cn/7ef86e889d3a/"/>
    <id>https://ccomma.cn/7ef86e889d3a/</id>
    <published>2024-04-01T08:33:29.000Z</published>
    <updated>2024-04-01T09:03:37.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>ZooKeeper 是一个分布式协调中间件，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p><strong><em>特性：</em></strong></p><ul><li><em>顺序一致性：</em> 客户端的更新将按顺序执行。因其写操作完全由单一 Leader 节点来执行（事务 id）</li><li><em>原子性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 操作要么成功要么失败（事务）</li><li><em>单一视图：</em> &nbsp; &nbsp; 无论连接到哪个节点，客户端都能看到相同的视图。（恢复模式 + 广播模式）</li><li><em>及时性：</em> &nbsp; &nbsp; &nbsp; &nbsp; 在特定时间范围内的数据是最新的。由最终一致性保证，同步需一定时间（数据同步）</li><li><em>可靠性：</em> <ul><li>数据不会丢失。zk 是将数据存储到内存中的，所以肯定会有持久化（日志 + 快照）</li><li>快速恢复 Leader。恢复模式（选主 + 数据同步）</li></ul></li></ul><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p><strong><em>conf/zoo.cfg：</em></strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算时间的基本单元 ms</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许从节点连接并同步到主节点的初始化连接时间，以 tickTime 为单位</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点与从节点请求和应答（心跳）的时间长度，以 tickTime 为单位</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快照及 Log 存储位置</span></span><br><span class="line">dataDir=/usr/local/zookeeper/dataDir</span><br><span class="line">dataLogDir=/usr/local/zookeeper/dataLogDir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端口</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host4，observer 角色</span></span><br><span class="line">server.4=49.56.165.144:2888:3888:observer</span><br></pre></td></tr></tbody></table></figure><p><strong>集群：</strong></p><ol><li>创建 dataDir/myid，内容为 1 代表 id 为 1。其他实例同上创建不同 id 的 myid 文件 </li><li>server. 服务器 id = 服务器 ip: 服务器之间的通信端口：服务器之间的投票选举端口 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host1 当前机器的 host，用 0.0.0.0 表示</span></span><br><span class="line">server.1=0.0.0.0:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host2</span></span><br><span class="line">server.2=121.43.178.178:2888:3888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host3</span></span><br><span class="line">server.3=47.99.220.125:2888:3888</span><br></pre></td></tr></tbody></table></figure></li></ol><h1 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h1><p>启动服务：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></tbody></table></figure><p>启动客户端：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh</span><br></pre></td></tr></tbody></table></figure><p>查看启动状态：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></tbody></table></figure><h1 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h1><ul><li>每当客户端连接到服务端会创建一个 SessionId。<strong>创建 / 删除 SessionId 也是事务操作，会有 zxid，会被同步到所有节点中</strong> </li><li> Session 过期，则根据该 Session 创建的临时节点 znode 都会被抛弃 </li><li>可设置超时时间。未超时的情况下，客户端 api 若保存了 SessionId，重连后 Session 不会消失（还是原来的 Session） </li><li>心跳机制</li></ul><h1 id="5-基本模型"><a href="#5-基本模型" class="headerlink" title="5. 基本模型"></a>5. 基本模型</h1><h2 id="5-1-Zookeeper-抽象模型"><a href="#5-1-Zookeeper-抽象模型" class="headerlink" title="5.1. Zookeeper 抽象模型"></a>5.1. Zookeeper 抽象模型</h2><p>Zookeeper 提供了一种树形结构级的命名空间<br>为了保证高吞吐和低延迟，Zookeeper 在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper <strong>不能用于存放大量的数据</strong>，每个节点的存放数据上限为 <strong>1M</strong>。</p><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/71cee598f8577e486a102cf8e2e06ba4.png"></p><h2 id="5-2-节点类型"><a href="#5-2-节点类型" class="headerlink" title="5.2. 节点类型"></a>5.2. 节点类型</h2><ul><li><strong>永久无序节点：</strong> 不会因为会话结束或者超时而消失</li><li><strong>永久有序节点：</strong> 不会因为会话结束或者超时而消失，且有序</li><li><strong>临时无序节点：</strong> 如果会话结束或者超时就会消失</li><li><strong>临时有序节点：</strong> 如果会话结束或者超时就会消失，且有序<blockquote><p>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h1&gt;&lt;p&gt;ZooKeeper 是一个分布式协调中间件，是 Google 的 Chubby 一个开源的实现。它是集群的管理者，监视着</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://ccomma.cn/tags/Zookeeper/"/>
    
    <category term="从入门到入土" scheme="https://ccomma.cn/tags/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>ES 写入原理及调优</title>
    <link href="https://ccomma.cn/4216ce6ea7d2/"/>
    <id>https://ccomma.cn/4216ce6ea7d2/</id>
    <published>2024-03-12T02:37:13.000Z</published>
    <updated>2024-04-01T08:13:04.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？</p><p><strong>1. 解决写入问题</strong><br>心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。</p><p><strong>2. 学习架构设计思想</strong><br>这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。</p><p><strong>3. 应对面试</strong><br>虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题</p><p>常见的面试问题：</p><ul><li>你了解 ES 的写入原理吗</li><li>你了解文档的写入 / 删除过程吗</li><li>如何保证 ES 数据写入一致性</li><li>文档写入超时原因</li><li> ES 写入实时性如何去保证</li><li>数据量大时如何保证数据写入性能</li><li>如何提高数据检索能力</li></ul><span id="more"></span><h2 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h2><p>ES 中的数据写入均发生在主分片上。由于 ES 是分布式系统，实际接收到写入请求的节点可能是任意一台节点，这就需要将请求通过 routing 路由到具体主分片所在的节点，将数据写入该节点的主分片中，然后主分片再同步数据到其他节点的副分片中。<br>路由公式：<code>shard_num = hash(_routing) % num_primary_shards</code><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b20c17eb26dfc1a90e9433ae005a39e.jpeg"><br>具体流程：</p><ol><li>客户端发起写入请求至 node 4</li><li>node 4 通过文档 id 在路由表中的映射信息确定当前数据的位置为分片 0，分片 0 的主分片位于 node 5，并将数据转发至 node 5。</li><li>数据在 node 5 写入，写入成功之后将数据的同步请求转发至其副本所在的 node 4 和 node 6 上面，等待所有副本数据写入成功之后 node 5 将结果报告 node 4，并由 node 4 将结果返回给客户端，报告数据写入成功。</li></ol><h2 id="写一致性策略"><a href="#写一致性策略" class="headerlink" title="写一致性策略"></a>写一致性策略</h2><p>ES 5.x 之后，一致性策略由 <code>wait_for_active_shards</code> 参数控制：状态为 active 的主副分片数量达到设定阈值时才视为写入成功，才会返回数据给客户端。默认为 1，即只需要主分片写入成功，可设置为 <code>all</code> 或任何正整数，最大值为索引中的分片总数 (&nbsp;<code>number_of_replicas + 1</code> )。</p><p>如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间 30 秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。</p><p>执行索引操作时，分配给执行索引操作的主分片可能不可用。造成这种情况的原因可能是主分片当前正在从网关恢复或正在进行重定位。默认情况下，索引操作将在主分片上等待最多 1 分钟，然后才会失败并返回错误。</p><h2 id="写入原理"><a href="#写入原理" class="headerlink" title="写入原理"></a>写入原理</h2><p>我们已经知道了宏观上的写入流程：先找到主节点，写入主节点后再同步到副节点。<br><strong>那 ES 是怎么把数据写入主节点和副节点中的呢？</strong></p><p>大家可能会有疑问，难道不是直接写入到磁盘吗？<strong>我们可以思考下，每次请求都直接写入到磁盘这种方式在高并发的场景下会消耗大量的 IO 资源，每次都要寻址然后写入磁盘。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ba7282dc7f49c616767143d774646a3b.jpeg" alt="未命名文件.jpg"></p><p>对此我们可以用缓存来解决，即把数据写入系统缓存后，定期批量写入磁盘，同时缓存也提供检索服务。<br>而 Lucene 中索引是细分为多个 segment 的，segment 是索引中存储索引数据的内部存储元素，并且是不可变的。较小的 segment 会定期合并到较大的 segment 中，以控制索引大小。问题又来了：<strong>如果每次请求都创建一个新的 segment，那么会导致频繁的合并操作（merge）。</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/ec5aedd4c9bc6e805872b3f5944957a8.jpeg" alt="未命名文件.jpg"></p><p>所以 ES 在请求进入缓存之前先让请求进缓冲区（memory buffer），每秒或每 100 个缓存才会执行刷新操作（Refresh）把缓冲区中的数据创建 segment 写入系统缓存中。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/10b375c43ff4ab15fe0c8ed7fa469f8e.jpeg" alt="未命名文件 (1).jpg"></p><p>至此这套批量持久化结构已经比较完善，但还有一个问题：<strong>缓存虽然提高了性能，但毕竟未持久化到磁盘，一旦系统出现故障数据就会丢失。</strong>ES 采用事务日志（translog）的方式解决此问题，当请求进来时会同时写入缓冲区和事务日志中，当服务重启后就会从事务日志中恢复数据到缓存。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/dcb5acedec3e2a0f97e678cd403a0eea.jpeg" alt="未命名文件 (1).jpg"></p><p>整体结构：</p><ul><li>Memory Buffer（缓冲区）：数据批量操作，高性能写入</li><li> Translog（事务日志）：保证数据写入安全性，防止丢失</li><li> OS Cache（内存）：保证数据高性能检索</li><li> OS Disk（磁盘）：保证数据持久化</li></ul><p>具体流程：</p><ol><li>客户端写入 Memory Buffer 缓冲区，并追加写入 Translog 事务日志（删除、写入…）以保证数据安全性。</li><li>Memory Buffer 达到阈值（100 条 / 1s）后执行 Refresh 操作生成 Segment 索引文件到系统缓存中。<ol><li>然后系统缓存会把该 Segment 标记为可被检索，因此数据有 1s 不可读的延迟。</li><li>Refresh 操作不能过于频繁，因此针对实时性不高的数据，可以配置 refresh 的间隔时间为 30s 一次。</li></ol></li><li>每个 Segment 都会消耗文件句柄、内存、CPU 运行周期，所以每隔一段时间会执行 Merge 操作，合并 Segment。<ol><li>Merge 操作发生在 JVM 中，频率过高会占用堆内存空间，所以 Refresh 的频率不能太高，否则会使 Merge 频率增高。</li><li>不合并 Segment 的影响：<ol><li>每个 Segment 占据的内存不会随着 GC 释放的。导致系统内存不足，进一步导致超时问题。</li><li>查询时会遍历每个 Segment，过多的 Segment 会导致查询速度下降。</li></ol></li></ol></li><li>执行 Flush 操作缓存写入 OS Disk（磁盘）并提交一次，并清空 Translog。<ol><li>系统缓存每隔 30 分钟、Translog 每隔 5 秒刷一次到磁盘中，所以默认情况下，可能会有 5s 数据丢失。</li><li>系统缓存和 Translog 写满时也会刷磁盘。</li></ol></li><li>断电等异常操作导致数据丢失时，服务重启后会读取 Translog 中的数据到缓存中，以完成回滚操作。</li></ol><p>相关参数：</p><ul><li>index.translog.durability：同步还是异步<ul><li> request：（默认）主副分片在每个请求后执行 fsync 和 commit，才会向客户端报告索引、删除、更新或批量请求的成功。如果发生崩溃，那么所有只要是已经确认的写操作都已经被提交到磁盘。</li><li>async：在后台每 index.translog.sync_interval 时间进行一次 fsync 和 commit。意味着如果发生崩溃，那么所有在上一次自动提交以后的已确认的写操作将会丢失。</li></ul></li><li>index.translog.sync_interval：translog 多久被同步到磁盘并提交一次。默认 5 秒。这个值不能小于 100ms。</li><li>index.translog.flush_threshold_size：translog 执行 flush 操作的空间最大阈值，默认 512 MB。</li></ul><h2 id="写入性能调优"><a href="#写入性能调优" class="headerlink" title="写入性能调优"></a>写入性能调优</h2><p>生产经常面临的写入可以分为两种情况：</p><ul><li>高并发：高频的创建 / 更新索引文档，一般发生在 C 端场景下</li><li>高吞吐：定期重建索引或批量更新文档数据，一般为 B 端场景</li></ul><p><strong>1. 提升写入吞吐量和并发</strong><br>ES 数据写入具有一定的延时性，这是为了减少频繁的索引文件产生。默认情况下 ES 每秒生成一个 segment 文件，当达到一定阈值的时候会执行 merge，merge 过程发生在 JVM 中，频繁的生成 segmen 文件可能会导致频繁的触发 FGC，导致 OOM。<br>为了避免避免这种情况，通常采取的手段是降低 segment 文件的生成频率，手段有两个，一个是增加时间阈值，另一个是增大 buffer 的空间阈值。</p><ol><li>增加 flush 时间间隔。Flush 是 IO 操作，很消耗性能，不能太频繁</li><li>增加 refresh_interval 的参数值<ol><li>目的是减少 segment 文件的创建，减少 segment 的 merge 次数。</li><li>merge 是发生在 JVM 中的，有可能导致 full GC，增加 refresh 会降低搜索的实时性。</li></ol></li><li>增加 buffer 大小<ol><li>减小 refresh 的时间间隔，因为导致 segment 文件创建的原因不仅有时间阈值，还有 buffer 空间大小，写满了也会创建。</li><li>默认最小值 48MB &lt; 默认值 JVM 空间的 10% &lt; 默认最大无限制</li></ol></li><li>关闭副本（提高单次吞吐）<ol><li>需要单次写入大量数据的时候，可以关闭副本（减少数据同步），暂停搜索服务，或选择在检索请求量谷值区间时间段来完成。因为副本的存在会导致主从之间频繁的进行数据同步，大大增加服务器的资源占用。</li><li>可通过则设置 index.number_of_replicas 为 0 以加快索引速度。没有副本意味着丢失单个节点可能会导致数据丢失，因此数据保存在其他地方很重要，以便在出现问题时可以重试初始加载。初始加载完成后，可以设置 index.number_of_replicas 改回其原始值。</li></ol></li><li>max_result_window 参数</li></ol><p>分页返回的最大数值，默认值为 10000。通过设定一个合理的阈值，避免初学者分页查询时由于单页数据过大而导致 OOM。</p><p><strong>2. 提高写入实时性（不推荐）</strong><br>在搜索引擎的业务场景下，用户一般并不需要那么高的写入实时性。有时这个延时的过程需要处理很多事情，比如信息需要后台审核。<br>可以提高 Memory Buffer 的 refresh 操作频率，但是过高的 refresh 会导致频繁 merge segment，会消耗更多堆内存、CPU 的资源。</p><h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><p>1. 避免单次召回大量数据<br>搜索引擎最擅长的事情是从海量数据中查询少量相关文档，而非单次检索大量文档。非常不建议动辄查询上万数据。如果有这样的需求，建议使用滚动查询。<br> <br>2. 避免单个文档过大<br>硬性限制：<br>鉴于默认 http.max_content_length 设置为 100MB，Elasticsearch 将拒绝索引任何大于该值的文档。可以增加该特定设置，但 Lucene 仍然有大约 2GB 的限制。<br> <br>大型文档对网络、内存使用和磁盘造成了更大的压力，即使对于不请求的搜索请求也是如此。<br> <br>3. 使用 filter 代替 query<br>query 是要对查询的每个结果计算相关性得分的，而 filter 不会。另外 filter 有相应的缓存机制，可以提高查询效率。<br> <br>4. 避免深度分页<br> <br>5. 使用 Keyword 类型<br>并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为查询优化数字字段，例如 integeror long。如果不需要范围查找，对于 term 查询而言，keyword 比 integer 性能更好。</p><p>参考：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index-modules-translog.html">Translog | Elasticsearch Guide [7.17] | Elastic</a></li><li><a href="https://blog.csdn.net/a645293829/article/details/132223065">【HBZ 分享】ES 索引分片的写入原理 及 流程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;ES 支持四种对文档的数据写操作：create、delete、index、update，这些对数据进行更改的操作的流程和原理是怎么样的呢？以及，了解写入原理对我们有什么帮助？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 解决写入问题&lt;/strong&gt;&lt;br&gt;心心念念用上了 ES，但是却在项目中遇到写入并发问题及写入大吞吐量数据之类的问题，这时候需要好好了解下 ES 的写入原理，再结合项目实际情况对相关参数进行调优。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 学习架构设计思想&lt;/strong&gt;&lt;br&gt;这也是很重要的一点，了解 ES 是如何处理写入中遇到的问题，以及这些处理方式是否在我们平常项目中有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 应对面试&lt;/strong&gt;&lt;br&gt;虽然比较功利，但不可否认，写入原理是 ES 面试的高频问题&lt;/p&gt;
&lt;p&gt;常见的面试问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你了解 ES 的写入原理吗&lt;/li&gt;
&lt;li&gt;你了解文档的写入 / 删除过程吗&lt;/li&gt;
&lt;li&gt;如何保证 ES 数据写入一致性&lt;/li&gt;
&lt;li&gt;文档写入超时原因&lt;/li&gt;
&lt;li&gt; ES 写入实时性如何去保证&lt;/li&gt;
&lt;li&gt;数据量大时如何保证数据写入性能&lt;/li&gt;
&lt;li&gt;如何提高数据检索能力&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ES 写入原理" scheme="https://ccomma.cn/categories/ES-%E5%86%99%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="ES" scheme="https://ccomma.cn/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 快速搭建博客</title>
    <link href="https://ccomma.cn/58a80fbce4aa/"/>
    <id>https://ccomma.cn/58a80fbce4aa/</id>
    <published>2024-02-13T07:05:42.000Z</published>
    <updated>2024-03-12T12:09:52.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么搭建博客"><a href="#为什么搭建博客" class="headerlink" title="为什么搭建博客"></a>为什么搭建博客</h1><ul><li>知识积累</li><li>分享</li><li>影响力</li></ul><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="静态页面生成"><a href="#静态页面生成" class="headerlink" title="静态页面生成"></a>静态页面生成</h2><p>我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。</p><p>像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress</p><p>为什么选择 hexo？主题较现代化、方便快捷<br><a href="https://github.com/hexojs/hexo">hexo github</a></p><span id="more"></span><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>_config.yml 里配置你的项目地址</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ccomma/ccomma.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></tbody></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多主题，这里推荐 Next 主题，因为 Next 的社区非常活跃，这就导致 Next 主题有非常多的配置和插件</p><p>Next 主题配置<br><a href="https://theme-next.js.org/docs/theme-settings/">Theme Settings</a></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>博客可以部署在阿里云等云服务器上，但是特地买一台服务器专门用来部署博客还是有点太浪费了。</p><p>以下几种方式可以免费部署静态 web 应用</p><ul><li>github pages<ul><li> 服务器地理位置：美国</li><li>推荐：push 即部署，简单快捷 </li><li>缺点：网络连接严重不稳定</li></ul></li><li> cloudflare pages<ul><li> 服务器地理位置：美国自家节点</li><li>推荐原因：速度稳定，在全球各地均有 CDN，支持从 Github/Gitlab 等平台自动部署 </li><li>缺点：部署速度较慢，但不算太影响</li></ul></li><li> Vercel<ul><li> 服务器地理位置：美国 AWS</li><li> 推荐原因：部署速度快，支持自动部署</li><li>缺点：被墙过一次，速度有可能出现不稳定</li></ul></li></ul><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>hexo 能让我们更专心写博客，但即使是如此，我们还是要先使用 <code>hexo new "xxx"</code> 命令来新建文档。而我们平时的笔记可能是写在 notion、语雀、飞书上。</p><p>写作同步工具 <a href="https://github.com/LetTTGACO/elog">elog</a> 能让我们的在 notion、语雀、飞书上的笔记自动部署到 github 上</p><p>elog 会在本地创建缓存，每次同步只会增量更新，包括图片上传也是。</p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>github pages 自带域名：xxxx.github.io，够用，但是有点 low</p><ul><li><a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520112.products-recent.ddomain.5c0234c0saWuKP#/overview">阿里云域名</a>：基本都是国内的，30+/ 年 </li><li><a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412">cloudflare</a>：国外域名，9.77～45 美元</li></ul><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>1. 阿里云付费 SSL<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e79690ec1537f107639504c426c7654f.png" alt="image.png"></p><p>2. 阿里个人测试证书，有效期 3 个月<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7abb7f515c8c087585cf82b749f58856.png" alt="image.png"></p><p> 3.<a href="https://letsencrypt.org/">Let’s Encrypt</a>：提供免费 TLS 证书的非营利证书颁发机构，就个人博客而言足以</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>阿里云 DNS：DNS 解析与域名服务捆绑，声誉一般</p><p>cloudflare：</p><ul><li>支持 CDN（国内减速）</li><li>自带 DDos 防御服务</li><li>支持解析 A、AAAA、CNAME、MX、LOC、SRV、SPF、TXT、NS、CAA、PTR、CERT、DNSKEY、DS、NAPTR、SMIMEA、SSHFP、TLSA、URI</li><li> 支持 DNSSEC</li><li> 免费版支持一部分其他地方收费的配套服务，例如 Worker，Page，访客规则</li></ul><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>搜索引擎优化，让你的网站更好的被搜索引擎收录</p><p>google：<a href="https://search.google.com/search-console">https://search.google.com/search-console</a><br>bing：<a href="https://www.bing.com/webmasters">https://www.bing.com/webmasters</a><br>百度：<a href="https://ziyuan.baidu.com/site">https://ziyuan.baidu.com/site</a></p><p>以 google 为例：<br>登录到 Google Search Console，选择您要验证的网站。输入网址<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/060a5e066eda3911a4d4b938a91b23b3.png" alt="image.png"><br>将验证码复制到 DNS 记录中<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/eb3c64f775d04dc6ff8dabc1d6990035.png" alt="image.png"></p><h1 id="站点分析"><a href="#站点分析" class="headerlink" title="站点分析"></a>站点分析</h1><p>对网站流量访问进行分析</p><p>1.<a href="https://dash.cloudflare.com/a6c6359e7e3af154f46b1d98c1f57412/web-analytics/sites">cloudflare</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b39742d06912a9f134af70c3df193507.png" alt="image.png"></p><p>2.<a href="https://search.google.com/search-console?resource_id=sc-domain:ccomma.cn">google</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8d5ef6ca57eb04a42125cc57f9f95af0.png" alt="image.png"></p><p>3. <a href="https://tongji.baidu.com/main/overview/10000609568/overview/index?siteId=20141034">百度统计</a><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/bfbbe9f8eda65e69abc5b9b1074671cd.png" alt="image.png"></p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>百度云 CDN：百度云加速分为免费版和付费版，免费版不支持 SSL 证书，海外网站也支持加速。</p><p>cloudflare CDN：<br>免费提供，对于国外的服务器还行，国内服务器反而减速。支持 SSL，无须备案</p><p>七牛云 CDN：<br>每个月可使用 10G 的免费存储量和 10G 的 CDN 流量与 100 万次的 Get 请求数，七牛云在海外也有众多加速节点，七牛云 TCP 压缩优化使网页中大图和样式等实现秒加载。但请注意使用七牛 CDN，须保证账户中有最低金额 10 元。国内必须备案，支持 SSL。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.bilibili.com/video/BV1Sp4y157br/?vd_source=8f8a2ec64a5f07bb8bf30a6ef4819025">将 Hexo 博客部署到 CloudFlare Pages 使用全球加速</a></li><li><a href="https://cloud.tencent.com/developer/article/1987796?areaSource=102001.7&amp;traceId=zTjHWNtLK7p3TbHHsvayg">5 个免费的静态 Web 应用部署平台</a></li><li><a href="https://hqyman.cn/post/4255.html">国内外免费域名 DNS 解析推荐</a></li><li><a href="https://www.zhihu.com/question/342631132">如何使用 Notion 制作个人网站？</a></li><li><a href="https://www.cnblogs.com/wangyuehan/p/12743624.html">Notion 做个人博客的两种实现方式</a></li><li><a href="https://blog.ithuo.net/post/2023-11-07%2FNotion%E5%8D%9A%E5%AE%A2%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97">Notion 博客折腾指南</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2">使用 hexo+github 搭建免费个人博客</a></li><li><a href="https://juejin.cn/post/7304540675668181003">语雀写作，Kubernetes 部署 ——Elog+Hexo 博客持续集成</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么搭建博客&quot;&gt;&lt;a href=&quot;#为什么搭建博客&quot; class=&quot;headerlink&quot; title=&quot;为什么搭建博客&quot;&gt;&lt;/a&gt;为什么搭建博客&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;知识积累&lt;/li&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;影响力&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建站&quot;&gt;&lt;a href=&quot;#建站&quot; class=&quot;headerlink&quot; title=&quot;建站&quot;&gt;&lt;/a&gt;建站&lt;/h1&gt;&lt;h2 id=&quot;静态页面生成&quot;&gt;&lt;a href=&quot;#静态页面生成&quot; class=&quot;headerlink&quot; title=&quot;静态页面生成&quot;&gt;&lt;/a&gt;静态页面生成&lt;/h2&gt;&lt;p&gt;我们可以自己写一套个人博客网站，不过那样做周期太长，样式之类的东西都得手动去调整，也不利于我们去专心的写作。&lt;/p&gt;
&lt;p&gt;像博客这种静态页面可以由工具直接生成。市面上的博客工具有很多，像 hexo、vuepress&lt;/p&gt;
&lt;p&gt;为什么选择 hexo？主题较现代化、方便快捷&lt;br&gt;&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;hexo github&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://ccomma.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="https://ccomma.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>并行流导致接口慢调用问题</title>
    <link href="https://ccomma.cn/cb2072810346/"/>
    <id>https://ccomma.cn/cb2072810346/</id>
    <published>2023-08-14T00:55:38.000Z</published>
    <updated>2024-02-23T05:26:09.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。</p><span id="more"></span><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8ff9b37602e5bee3be548af291c7348e.png" alt="image.png"><br>根据 ARMS 分析该接口的调用量在 18:31-18:41 出现断崖式增长，每分钟请求数从 5.1k 增加到 14.7k，10 分钟增长了 9.6k。（后续调查表明在该时间段内大部分接口调用量都出现了断崖式增长）<br>异常时刻的 qps 大致为 236.1，几乎是一周前的 2 倍。</p><p><strong>响应时间：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3dd26f56b4afe1a4bfcb5a79450452d1.png" alt="image.png"><br>每分钟响应时间平均为 3747 ms，整个异常过程中该接口最长的响应时间达到 8s 多。</p><p><strong>dubbo 线程池：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5d7b54ac7097680e22af442ccbd6b276.png" alt="image.png"><br>所有接口的每分钟 dubbo 请求调用量在 18:35-18:45 内从 14.2k 增长至 35.6k<br>也是在这段时间内 dubbo 线程池被打满，在 18:40 左右基本被打满<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/decb4154e9d3362f4dd2e3b7dbd1892f.png" alt="image.png"></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>初步判断流量突增的原因是客户端开放灰度，使得预定业务中的一个轮询调用的接口调用次数上升。<br>该接口调用桌位状态服务的一个较为通用的查询接口，里面使用 parallelStream 来进行 RPC 调用获取账单。<br>parallelStream 使用与 CPU 核数一致的线程数来处理任务，当请求量增大时线程池中的线程全部被打满，导致后续的任务一直在排队等待延迟处理，最终 dubbo 线程池也被占满。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>从问题的核心代码到外部调用，可优化的点如下：</p><ol><li>取消并行流</li><li>加大批量获取数，让调用量减小</li><li>经查看代码发现出现问题的使用并行流查账单是为了设置桌位状态的 payStatus，但是上层并不关心这个字段，所以可以让上层调用更轻量级的接口</li><li>降低客户端轮询次数，轮询调用需谨慎，轮询策略需要好好设计</li></ol><h2 id="2023-08-13（代码修改后）"><a href="#2023-08-13（代码修改后）" class="headerlink" title="2023.08.13（代码修改后）"></a>2023.08.13（代码修改后）</h2><p>141 部署了优化后的代码，取消了并行流，分页大小增加到 10<br>142 没有改动，以此作为对照。</p><p>总体应用每分钟调用量峰值也有 14.7k，但是 13 号这天的曲线明显更加平滑，没有出现 dubbo 线程池被打满的情况，慢调用的数量和时长都在正常范围内。</p><p><strong>调用量：</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/b6f1ef4f96f597a9b716feb0c2990204.png" alt="image.png"></p><p><strong>响应时间：</strong><br>141 比 142 更缓和</p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4cbe6c1f08b59f911f0a0aa91140deae.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4573954d3923199d395b8c80d3cb6909.png" alt="image.png"></p><p><strong>dubbo 线程数：</strong></p><ul><li>141：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/50b9cd579f52f5b56e2e28be3205d865.png" alt="image.png"></p><ul><li>142：</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/d1f735878b6e9667f825e70e452c8492.png" alt="image.png"></p><p>08.13 修改优化后至今，142 会依然出现一定量的慢调用，141 没有出现过<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/532b6fca9a1b64382d8ac364a4851385.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次问题应该是由于短时间内的调用量突增，加上使用并发流处理 RPC 调用引起的。<br>根据 13 号的对照来看，流量平滑增加的情况不会出现特别严重的线程池等待现象，但依然有慢调用，存在隐患。</p><p>取消并行流，增加分页大小的方案是可行的，以后并行流需要谨慎使用。后续也和客户端讨论了上层接口的调整方案。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;2023.08.12 18:30 开始，桌位状态应用的请求量大幅增长，dubbo 线程数达到最大值，与此同时查询桌位状态接口出现大量慢调用。&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="问题" scheme="https://ccomma.cn/tags/%E9%97%AE%E9%A2%98/"/>
    
    <category term="并行流" scheme="https://ccomma.cn/tags/%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>如何快速定位问题</title>
    <link href="https://ccomma.cn/6c827d88b19c/"/>
    <id>https://ccomma.cn/6c827d88b19c/</id>
    <published>2023-08-10T14:23:27.000Z</published>
    <updated>2024-02-23T03:15:00.055Z</updated>
    
    <content type="html"><![CDATA[<p>这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。</p><p>整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再去更新打印状态。</p><p>排查了很久发现是客户端接收不到消息，客户端同学也表示不知所措，问了消息通道那边的同学后发现安卓客户端在这之前就断开连接了，重新连接后立马就接收到了消息。一度怀疑是消息通道的问题，后来才发现客户端一直运行在后台，且自动刷新是关闭的。</p><p>因整个排查浪费了太多时间故在此做个复盘<br>整个链路很长，任何环节都有可能出现问题。</p><ol><li>先尽可能排除用户误操作产生的影响</li><li>有些地方不好排查（如消息通道），排查必须得有侧重点</li><li>需要有一个负责人协调多位项目相关人，依次推进进度，提高效率</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周碰到一个问题：客户在 C 端下单后，打印机延迟打印甚至不打印。很是让人头疼，耗费了大把时间结果发现只是因为手机 B 端 APP 处于后台无法自动更新。&lt;/p&gt;
&lt;p&gt;整个链路流程大致是这样，用户在小程序上下单后通过消息通道发消息给客户端，客户端再去调用打印机打印，然后再</summary>
      
    
    
    
    <category term="问题记录" scheme="https://ccomma.cn/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="思考" scheme="https://ccomma.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>可重入锁实现</title>
    <link href="https://ccomma.cn/71c0fe543a49/"/>
    <id>https://ccomma.cn/71c0fe543a49/</id>
    <published>2023-08-03T03:43:48.000Z</published>
    <updated>2024-04-01T08:13:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantCacheLockManager：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReentrantCacheLockManager implements ICacheLockManager {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ICacheService cacheService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(String key, int expireSecond) {</span><br><span class="line">        return tryLock(Collections.singletonList(key), expireSecond);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(List&lt;String&gt; keyList, int expireSecond) {</span><br><span class="line">        Assert.isTrue(CollectionUtils.isNotEmpty(keyList), "获取锁失败：key 不能为空");</span><br><span class="line"></span><br><span class="line">        // 1.从未获取过锁的 key 先去获取锁</span><br><span class="line">        List&lt;String&gt; unCacheKeyList = keyList.stream()</span><br><span class="line">                .filter(k -&gt; !LockKeyCountHolder.exist(k))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量获取锁</span><br><span class="line">        if (CollectionUtils.isNotEmpty(unCacheKeyList)) {</span><br><span class="line">            Map&lt;String, String&gt; lockMap = unCacheKeyList.stream().collect(Collectors.toMap(Function.identity(), k -&gt; "1", (a, b) -&gt; b));</span><br><span class="line">            long msetnx = cacheService.msetnx(lockMap, expireSecond);</span><br><span class="line">            // 未取到锁</span><br><span class="line">            if (Objects.equals(msetnx, 0L)) {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 2.重入计数 +1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            LockKeyCountHolder.increment(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(String key) {</span><br><span class="line">        unlock(Collections.singletonList(key));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(List&lt;String&gt; keyList) {</span><br><span class="line">        List&lt;String&gt; releaseKeyList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        // 重入 -1</span><br><span class="line">        for (String key : keyList) {</span><br><span class="line">            if (LockKeyCountHolder.decrement(key) == 0) {</span><br><span class="line">                releaseKeyList.add(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 释放锁</span><br><span class="line">        cacheService.del(releaseKeyList.toArray(new String[0]));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>LockKeyCountHolder：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 已锁的 key 重入计数</span><br><span class="line"> *</span><br><span class="line"> * @author mianxian</span><br><span class="line"> * 2023/8/2 14:56</span><br><span class="line"> */</span><br><span class="line">public class LockKeyCountHolder {</span><br><span class="line"></span><br><span class="line">    private LockKeyCountHolder() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * lockKey -&gt; 重入次数</span><br><span class="line">     */</span><br><span class="line">    private static final ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; THREAD_LOCAL = ThreadLocal.withInitial(Maps::newConcurrentMap);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 +1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int increment(String key) {</span><br><span class="line">        int count = get(key);</span><br><span class="line">        THREAD_LOCAL.get().put(key, ++count);</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取计数</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int get(String key) {</span><br><span class="line">        Map&lt;String, Integer&gt; keyMap = THREAD_LOCAL.get();</span><br><span class="line">        return keyMap.getOrDefault(key, 0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数是否 &gt; 0</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 是否 &gt; 0</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static boolean exist(String key) {</span><br><span class="line">        return get(key) &gt; 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计数 -1</span><br><span class="line">     *</span><br><span class="line">     * @param key key</span><br><span class="line">     * @return 操作后的计数</span><br><span class="line">     * @author ccomma</span><br><span class="line">     */</span><br><span class="line">    public static int decrement(String key) {</span><br><span class="line">        if (!exist(key)) {</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int count = get(key) - 1;</span><br><span class="line">        if (count == 0) {</span><br><span class="line">            THREAD_LOCAL.get().remove(key);</span><br><span class="line">        } else {</span><br><span class="line">            THREAD_LOCAL.get().put(key, count);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ReentrantCacheLockManager：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="https://ccomma.cn/2181815722f9/"/>
    <id>https://ccomma.cn/2181815722f9/</id>
    <published>2023-06-26T09:21:45.000Z</published>
    <updated>2024-04-01T08:13:04.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/14ce66fea5c132fb2889b56af226f5c9.png" alt="image.png"></p><h2 id="2-ACID"><a href="#2-ACID" class="headerlink" title="2. ACID"></a>2. ACID</h2><h3 id="2-1-原子性（Atomicity）"><a href="#2-1-原子性（Atomicity）" class="headerlink" title="2.1. 原子性（Atomicity）"></a>2.1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可</p><h3 id="2-2-一致性（Consistency）"><a href="#2-2-一致性（Consistency）" class="headerlink" title="2.2. 一致性（Consistency）"></a>2.2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的</p><h3 id="2-3-隔离性（Isolation）"><a href="#2-3-隔离性（Isolation）" class="headerlink" title="2.3. 隔离性（Isolation）"></a>2.3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的</p><h3 id="2-4-持久性（Durability）"><a href="#2-4-持久性（Durability）" class="headerlink" title="2.4. 持久性（Durability）"></a>2.4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失<br>使用重做日志来保证持久性<br><strong><em>理解：</em></strong> 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</li><li>事务满足持久化是为了能应对数据库崩溃的情况</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/340df236be6073235c93ec32f85bccb2.png" alt="image.png"></p><h2 id="3-AUTOCOMMIT"><a href="#3-AUTOCOMMIT" class="headerlink" title="3. AUTOCOMMIT"></a>3. AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。<br>如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p><strong><em>概述：</em></strong> 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题<br>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1. 丢失修改"></a>1. 丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5699ecb598913f47c5e996bd30467a1b.png" alt="image.png"></p><h2 id="2-读脏数据"><a href="#2-读脏数据" class="headerlink" title="2. 读脏数据"></a>2. 读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/1e7a318bb33ae42872be8b6f981afe99.png" alt="image.png"></p><h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/600643f3fa1c4175a70b2e7e419dd444.png" alt="image.png"></p><h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4. 幻读"></a>4. 幻读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/cc2dd0b4a10f306d6eb1d39200abc61c.png" alt="image.png"></p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="1-封锁粒度"><a href="#1-封锁粒度" class="headerlink" title="1. 封锁粒度"></a>1. 封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁<br>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h2 id="2-封锁类型"><a href="#2-封锁类型" class="headerlink" title="2. 封锁类型"></a>2. 封锁类型</h2><h3 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1. 读写锁"></a>2.1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/26454bd0fd3a5fe1a6f848d7237335fc.png" alt="image.png"></p><h3 id="2-2-意向锁"><a href="#2-2-意向锁" class="headerlink" title="2.2. 意向锁"></a>2.2. 意向锁</h3><p><strong><em>概念：</em></strong> 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁。它们表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。<br><strong><em>现象：</em></strong> 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br><strong>规定：</strong></p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li></ul><p><strong><em>原理：</em></strong> 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。<br>各种锁的兼容关系如下：<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3eed892c3a7ec589352d30f9b14fa561.png" alt="image.png"></p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁</li><li> S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁</li></ul><h2 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3. 封锁协议"></a>3. 封锁协议</h2><h3 id="3-1-三级封锁协议"><a href="#3-1-三级封锁协议" class="headerlink" title="3.1. 三级封锁协议"></a>3.1. 三级封锁协议</h3><p><strong><em>一级封锁协议：</em></strong><br>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁<br>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f31b55014ddb0a0a435cf553af74da2b.png" alt="image.png"><br><strong><em>二级封锁协议：</em></strong><br>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。<br>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/c88864935fbcdf40bda35f48ca62f25e.png" alt="image.png"><br><strong><em>三级封锁协议：</em></strong><br>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。<br>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/8b258ef58d2448d4e983995c3adb129c.png" alt="image.png"></p><h3 id="3-2-两段锁协议"><a href="#3-2-两段锁协议" class="headerlink" title="3.2. 两段锁协议"></a>3.2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。<br>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。<br>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><blockquote><p>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)</p></blockquote><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><blockquote><p>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)</p></blockquote><h2 id="4-MySQL-隐式与显示锁定"><a href="#4-MySQL-隐式与显示锁定" class="headerlink" title="4. MySQL 隐式与显示锁定"></a>4. MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><p><a href="https://www.cnblogs.com/shoshana-kong/p/10516404.html">Mysql 默认的事务隔离级别为什么是可重复读</a><br><strong>1. 未提交读（READ UNCOMMITTED）</strong><br>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>2. 提交读（READ COMMITTED）</strong><br>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>3. 可重复读（REPEATABLE READ）</strong><br>保证在同一个事务中多次读取同样数据的结果是一样的。<br>对 update 语句进行行加锁</p><p><strong>4. 可串行化（SERIALIZABLE）</strong><br>强制事务串行执行。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/92baf28f1dd4b475882244d42de388b5.png" alt="image.png"></p><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p><a href="https://www.jianshu.com/p/db334404d909">浅析 Mysql 的隔离级别及 MVCC</a><br>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="1-版本号"><a href="#1-版本号" class="headerlink" title="1. 版本号"></a>1. 版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><h2 id="2-隐藏的列"><a href="#2-隐藏的列" class="headerlink" title="2. 隐藏的列"></a>2. 隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了</li></ul><h2 id="3-Undo-日志"><a href="#3-Undo-日志" class="headerlink" title="3. Undo 日志"></a>3. Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6d8b260999c124ace1b2e329bc62ec5d.png" alt="image.png"></p><h2 id="4-实现过程"><a href="#4-实现过程" class="headerlink" title="4. 实现过程"></a>4. 实现过程</h2><p>以下实现过程针对可重复读隔离级别。<br>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h3 id="4-1-SELECT"><a href="#4-1-SELECT" class="headerlink" title="4.1. SELECT"></a>4.1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。<br>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="4-2-INSERT"><a href="#4-2-INSERT" class="headerlink" title="4.2. INSERT"></a>4.2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="4-3-DELETE"><a href="#4-3-DELETE" class="headerlink" title="4.3. DELETE"></a>4.3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-4-UPDATE"><a href="#4-4-UPDATE" class="headerlink" title="4.4. UPDATE"></a>4.4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="5-快照读与当前读"><a href="#5-快照读与当前读" class="headerlink" title="5. 快照读与当前读"></a>5. 快照读与当前读</h2><h3 id="5-1-快照读"><a href="#5-1-快照读" class="headerlink" title="5.1. 快照读"></a>5.1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-当前读"><a href="#5-2-当前读" class="headerlink" title="5.2. 当前读"></a>5.2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。<br>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p><strong><em>记录索引：</em></strong> 锁定一个记录上的索引，而不是记录本身。<br>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p><strong><em>记录索引间隙：</em></strong> 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-Next-Key-Locks"><a href="#3-Next-Key-Locks" class="headerlink" title="3. Next-Key Locks"></a>3. Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, positive infinity)</span><br></pre></td></tr></tbody></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h2><p>属性不可分。</p><h2 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h2><p>每个非主属性完全函数依赖于键码。<br>可以通过分解来满足。</p><h2 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h2><p>非主属性不传递函数依赖于键码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 常用函数</title>
    <link href="https://ccomma.cn/cd5f30760ffd/"/>
    <id>https://ccomma.cn/cd5f30760ffd/</id>
    <published>2023-06-26T09:08:26.000Z</published>
    <updated>2024-04-01T08:13:04.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="concat-str1-str2-…"><a href="#concat-str1-str2-…" class="headerlink" title="concat(str1, str2,…)"></a>concat(str1, str2,…)</h2><h2 id="date-sub-curdate-interval-7-day"><a href="#date-sub-curdate-interval-7-day" class="headerlink" title="date_sub(curdate(), interval 7 day)"></a>date_sub(curdate(), interval 7 day)</h2><h2 id="substring-str-start-len"><a href="#substring-str-start-len" class="headerlink" title="substring(str, start, len)"></a>substring(str, start, len)</h2><h3 id="3-1-从字符串的第-4-个字符位置开始取，直到结束"><a href="#3-1-从字符串的第-4-个字符位置开始取，直到结束" class="headerlink" title="3.1. 从字符串的第 4 个字符位置开始取，直到结束"></a>3.1. 从字符串的第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/6f989799d1594d6c6347f726aa6db249.png" alt="image.png"></p><h3 id="3-2-从字符串的倒数第-4-个字符位置开始取，直到结束"><a href="#3-2-从字符串的倒数第-4-个字符位置开始取，直到结束" class="headerlink" title="3.2 从字符串的倒数第 4 个字符位置开始取，直到结束"></a>3.2 从字符串的倒数第 4 个字符位置开始取，直到结束</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/0636d54c94efe5f728e072b11e5d04dc.png" alt="image.png"></p><h3 id="3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符"><a href="#3-3-从字符串的第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符"></a>3.3 从字符串的第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/4aca25208e5313e87f299a38e4d2c0c4.png" alt="image.png"></p><h3 id="3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符"><a href="#3-4-从字符串的倒数第-4-个字符位置开始取，只取-2-个字符" class="headerlink" title="3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符"></a>3.4 从字符串的倒数第 4 个字符位置开始取，只取 2 个字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5b3176ddb272f1050b3f9616ff715d5d.png" alt="image.png"></p><h2 id="substring-index-str-‘-’-2"><a href="#substring-index-str-‘-’-2" class="headerlink" title="substring_index(str, ‘>’, 2)"></a>substring_index(str, ‘&gt;’, 2)</h2><h3 id="4-1-截取第二个-‘-’-之前的所有字符"><a href="#4-1-截取第二个-‘-’-之前的所有字符" class="headerlink" title="4.1. 截取第二个 ‘.’ 之前的所有字符"></a>4.1. 截取第二个 ‘.’ 之前的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a2f362bf0cf1858e59d7096f97caf712.png" alt="image.png"></p><h3 id="4-2-截取倒数第二个-‘-’-之后的所有字符"><a href="#4-2-截取倒数第二个-‘-’-之后的所有字符" class="headerlink" title="4.2. 截取倒数第二个 ‘.’ 之后的所有字符"></a>4.2. 截取倒数第二个 ‘.’ 之后的所有字符</h3><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/7bd62c1fcce43cc5037a59c28a74533f.png" alt="image.png"></p><h2 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP_CONCAT"></a>GROUP_CONCAT</h2><p>测试数据表<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/f5cec81e840d7468bdc4c338f528d9c8.png" alt="image.png"><br> <br>以 product_id; 分组，把 name 字段的值打印在一行，逗号分隔 (默认) <br> SELECT id,GROUP_CONCAT(name) FROM test_brand GROUP BY product_id;<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3b8b8c51da8a0c3eb4b4fe0e2a61c970.png" alt="image.png"></p><ul><li>group_concat () 有长度限制 1024， 需要修改配置 group_concat_max_len，如果超过大小会被截断</li><li>排序 GROUP_CONCAT (name ORDER BY id DESC) </li><li>当你用 group_concat 的时候请注意，连接起来的字段如果是 int 型，一定要转换成 char 再拼起来，否则在你执行后 (ExecuteScalar 或者其它任何执行 SQL 返回结果的方法) 返回的将不是一个逗号隔开的串，而是 byte []</li></ul><h2 id="COUNT-等聚合函数"><a href="#COUNT-等聚合函数" class="headerlink" title="COUNT 等聚合函数"></a>COUNT 等聚合函数</h2><p>count 不会统计 null：</p><ul><li>count(t.aae140 = ‘390’ or null)</li><li>count(case when region_stat.city_num &gt; 0 and prov_stat.city_num &gt; city_stat.city_num then 1 end)</li></ul><h2 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNIX_TIMESTAMP(NOW(3)) * 1000</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;concat-str1-str2-…&quot;&gt;&lt;a href=&quot;#concat-str1-str2-…&quot; class=&quot;headerlink&quot; title=&quot;concat(str1, str2,…)&quot;&gt;&lt;/a&gt;concat(str1, str2,…)&lt;/h2&gt;&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://ccomma.cn/0c6c9beb5c26/"/>
    <id>https://ccomma.cn/0c6c9beb5c26/</id>
    <published>2023-06-26T09:01:33.000Z</published>
    <updated>2024-04-01T08:13:04.831Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/myseries/p/10728533.html">MySQL 中的几种日志了解</a></p><h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="1-B-Tree-原理"><a href="#1-B-Tree-原理" class="headerlink" title="1. B+ Tree 原理"></a>1. B+ Tree 原理</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1. 数据结构"></a>1.1. 数据结构</h3><p><strong><em>B Tree：</em></strong> B Tree 指的是 Balance Tree，也就是 <strong>平衡树</strong>。平衡树是一颗查找树，并且 <strong>所有叶子节点位于同一层</strong><br><strong><em>B+ Tree：</em></strong> B+ Tree 是基于 B Tree 和叶子节点 <strong>顺序访问指针 <strong>进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br></strong><em>非递减：</em></strong> 在 B+ Tree 中，一个节点中的 key 从左到右 <strong>非递减排列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2d1103b4d71fad09128907f8eca6190.png" alt="image.png"></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2. 操作"></a>1.2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data<br>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性</p><h3 id="1-3-与红黑树的比较"><a href="#1-3-与红黑树的比较" class="headerlink" title="1.3. 与红黑树的比较"></a>1.3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><ol><li>更少的查找次数<ol><li>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O (h)=O (logdN)，其中 d 为每个节点的出度。</li><li>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</li></ol></li><li>利用磁盘预读特性<ol><li>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</li><li>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li></ol></li></ol><h2 id="2-MySQL-索引"><a href="#2-MySQL-索引" class="headerlink" title="2. MySQL 索引"></a>2. MySQL 索引</h2><h3 id="2-1-B-Tree-索引"><a href="#2-1-B-Tree-索引" class="headerlink" title="2.1. B+ Tree 索引"></a>2.1. B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型<br><strong><em>速度快：</em></strong> 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多<br><strong><em>排序、分组：</em></strong> 除了用于查找，还可以用于排序和分组<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引<br><strong><em>主索引（聚簇索引）：</em></strong><br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/30543773300e9ea98415981a1d06e6cf.png" alt="image.png"><br><strong><em>辅助索引（非聚簇索引）：</em></strong><br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/314a86a9ddf86481c7ccb3a16791ef29.png" alt="image.png"></p><h3 id="2-2-哈希索引"><a href="#2-2-哈希索引" class="headerlink" title="2.2. 哈希索引"></a>2.2. 哈希索引</h3><p>哈希索引能以 O (1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3. 全文索引"></a>2.3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="2-4-空间数据索引"><a href="#2-4-空间数据索引" class="headerlink" title="2.4. 空间数据索引"></a>2.4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1. 独立的列"></a>3.1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> sakila.actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2. 多列索引"></a>3.2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好<br>例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id </span><br><span class="line"><span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-索引列的顺序"><a href="#3-3-索引列的顺序" class="headerlink" title="3.3. 索引列的顺序"></a>3.3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。<br><strong><em>索引的选择性：</em></strong> 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。<br>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line"></span><br><span class="line">   staff_id_selectivity: <span class="number">0.0001</span></span><br><span class="line">customer_id_selectivity: <span class="number">0.0373</span></span><br><span class="line">               <span class="built_in">COUNT</span>(<span class="operator">*</span>): <span class="number">16049</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-前缀索引"><a href="#3-4-前缀索引" class="headerlink" title="3.4. 前缀索引"></a>3.4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5. 覆盖索引"></a>3.5. 覆盖索引</h3><p>索引包含 <strong>所有需要查询的字段的值</strong>。<br><strong><em>优点：</em></strong></p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="4-索引的优点"><a href="#4-索引的优点" class="headerlink" title="4. 索引的优点"></a>4. 索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="5-索引的使用条件"><a href="#5-索引的使用条件" class="headerlink" title="5. 索引的使用条件"></a>5. 索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="1-使用-Explain-进行分析"><a href="#1-使用-Explain-进行分析" class="headerlink" title="1. 使用 Explain 进行分析"></a>1. 使用 Explain 进行分析</h2><p>Explain 用来 <strong>分析 SELECT 查询语句</strong>，开发人员可以通过分析 Explain 结果来优化查询语句<br><strong><em>重要字段：</em></strong></p><ul><li><strong>select_type：</strong> 查询类型，有简单查询、联合查询、子查询等</li><li><strong> key：</strong> 使用的索引</li><li><strong> rows：</strong> 扫描的行数</li></ul><h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><h3 id="2-1-减少请求的数据量"><a href="#2-1-减少请求的数据量" class="headerlink" title="2.1. 减少请求的数据量"></a>2.1. 减少请求的数据量</h3><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="2-2-减少服务器端扫描的行数"><a href="#2-2-减少服务器端扫描的行数" class="headerlink" title="2.2. 减少服务器端扫描的行数"></a>2.2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="3-重构查询方式"><a href="#3-重构查询方式" class="headerlink" title="3. 重构查询方式"></a>3. 重构查询方式</h2><h3 id="3-1-切分大查询"><a href="#3-1-切分大查询" class="headerlink" title="3.1. 切分大查询"></a>3.1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do {</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")</span><br><span class="line">} while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-分解大连接查询"><a href="#3-2-分解大连接查询" class="headerlink" title="3.2. 分解大连接查询"></a>3.2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联<br><strong><em>好处：</em></strong></p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN () 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><p><strong><em>概述：</em></strong> MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br><strong><em>隔离级别：</em></strong><br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<br>在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻读。<br><strong><em>索引：</em></strong> 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。<br><strong><em>内部优化：</em></strong> 包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。<br><strong><em>热备份：</em></strong> 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h2><p><strong><em>概述：</em></strong> 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br><strong><em>特性：</em></strong> 提供了压缩表、空间数据索引等。<br><strong><em>事务：</em></strong> 不支持事务。<br><strong><em>读写锁：</em></strong> 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。<br><strong><em>索引：</em></strong> 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ul><li><strong>事务：</strong> InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li><li><strong>并发：</strong> MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li><li><strong>外键：</strong> InnoDB 支持外键</li><li><strong>备份：</strong> InnoDB 支持在线热备份</li><li><strong>崩溃恢复：</strong> MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li><strong>其它特性：</strong> MyISAM 支持压缩表和空间数据索引</li></ul><h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT (11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL (18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。<br>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h2 id="4-时间和日期"><a href="#4-时间和日期" class="headerlink" title="4. 时间和日期"></a>4. 时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3 id="4-1-DATETIME"><a href="#4-1-DATETIME" class="headerlink" title="4.1. DATETIME"></a>4.1. DATETIME</h3><p><strong><em>概述：</em></strong> 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。<br><strong><em>时区：</em></strong> 与时区无关。<br>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如 “2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3 id="4-2-TIMESTAMP"><a href="#4-2-TIMESTAMP" class="headerlink" title="4.2. TIMESTAMP"></a>4.2. TIMESTAMP</h3><p><strong><em>概述：</em></strong> 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。<br><strong><em>时区：</em></strong> 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。<br>MySQL 提供了 FROM_UNIXTIME () 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP () 函数把日期转换为 UNIX 时间戳。<br><strong><em>优点：</em></strong> 比 DATETIME 空间效率更高。</p><h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><p><a href="https://blog.csdn.net/bluishglc/column/info/sharding">数据库分库分表 (sharding)</a></p><h2 id="1-水平切分"><a href="#1-水平切分" class="headerlink" title="1. 水平切分"></a>1. 水平切分</h2><p><strong><em>概述：</em></strong> 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。<br>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c737fd088f55ee87e034c39ac838861.png" alt="image.png"></p><h2 id="2-垂直切分"><a href="#2-垂直切分" class="headerlink" title="2. 垂直切分"></a>2. 垂直切分</h2><p><strong><em>概述：</em></strong> 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。<br>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9cb0ca9f7892a9d4fca291f0674da13c.png" alt="image.png"></p><h2 id="3-Sharding-策略"><a href="#3-Sharding-策略" class="headerlink" title="3. Sharding 策略"></a>3. Sharding 策略</h2><p><strong><em>策略：</em></strong></p><ul><li><strong>哈希取模：</strong> hash(key) % N</li><li><strong> 范围：</strong> 可以是 ID 范围也可以是时间范围</li><li><strong>映射表：</strong> 使用单独的一个数据库来存储映射关系</li></ul><p><strong><em>问题：</em></strong></p><ol><li><strong>事务问题：</strong> 使用分布式事务来解决，比如 XA 接口。</li><li><strong>连接：</strong> 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li><li><strong>ID 唯一性：</strong><ol><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ol></li></ol><h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><p><a href="https://www.cnblogs.com/idoljames/p/11694039.html">Mysql 主从复制原理及同步延迟问题</a><br><a href="https://blog.51cto.com/6300167/2344750">mysql 主从复制延迟问题</a><br><a href="https://www.jianshu.com/p/37f54c32c93c">mysql 读写分离和解决主从同步延时问题</a></p><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><p>主要涉及三个线程： binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程：</strong> 负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程：</strong> 负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li><li><strong>SQL 线程：</strong> 负责读取重放日志并重放其中的 SQL 语句。</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5ebee84b776054508db67f7a9ca22bc1.png" alt="image.png"></p><h2 id="2-读写分离"><a href="#2-读写分离" class="headerlink" title="2. 读写分离"></a>2. 读写分离</h2><p><strong>概述：</strong> 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br><strong>优点：</strong></p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p><strong>实现：</strong> 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a18825649461134799421b2a56728e4d.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/myseries/p/10728533.html&quot;&gt;MySQL 中的几种日志了解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、索引&quot;&gt;&lt;a href=&quot;#一、索引&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 知识点梳理</title>
    <link href="https://ccomma.cn/588e4736ebc9/"/>
    <id>https://ccomma.cn/588e4736ebc9/</id>
    <published>2023-06-26T09:01:33.000Z</published>
    <updated>2024-04-01T09:03:37.227Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/myseries/p/10728533.html">MySQL 中的几种日志了解</a></p><h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="1-B-Tree-原理"><a href="#1-B-Tree-原理" class="headerlink" title="1. B+ Tree 原理"></a>1. B+ Tree 原理</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1. 数据结构"></a>1.1. 数据结构</h3><p><strong><em>B Tree：</em></strong> B Tree 指的是 Balance Tree，也就是 <strong>平衡树</strong>。平衡树是一颗查找树，并且 <strong>所有叶子节点位于同一层</strong><br><strong><em>B+ Tree：</em></strong> B+ Tree 是基于 B Tree 和叶子节点 <strong>顺序访问指针 <strong>进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br></strong><em>非递减：</em></strong> 在 B+ Tree 中，一个节点中的 key 从左到右 <strong>非递减排列</strong><br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/e2d1103b4d71fad09128907f8eca6190.png" alt="image.png"></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2. 操作"></a>1.2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data<br>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性</p><h3 id="1-3-与红黑树的比较"><a href="#1-3-与红黑树的比较" class="headerlink" title="1.3. 与红黑树的比较"></a>1.3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><ol><li>更少的查找次数<ol><li>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O (h)=O (logdN)，其中 d 为每个节点的出度。</li><li>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</li></ol></li><li>利用磁盘预读特性<ol><li>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</li><li>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</li></ol></li></ol><h2 id="2-MySQL-索引"><a href="#2-MySQL-索引" class="headerlink" title="2. MySQL 索引"></a>2. MySQL 索引</h2><h3 id="2-1-B-Tree-索引"><a href="#2-1-B-Tree-索引" class="headerlink" title="2.1. B+ Tree 索引"></a>2.1. B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型<br><strong><em>速度快：</em></strong> 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多<br><strong><em>排序、分组：</em></strong> 除了用于查找，还可以用于排序和分组<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引<br><strong><em>主索引（聚簇索引）：</em></strong><br>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/30543773300e9ea98415981a1d06e6cf.png" alt="image.png"><br><strong><em>辅助索引（非聚簇索引）：</em></strong><br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/314a86a9ddf86481c7ccb3a16791ef29.png" alt="image.png"></p><h3 id="2-2-哈希索引"><a href="#2-2-哈希索引" class="headerlink" title="2.2. 哈希索引"></a>2.2. 哈希索引</h3><p>哈希索引能以 O (1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3. 全文索引"></a>2.3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。<br>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="2-4-空间数据索引"><a href="#2-4-空间数据索引" class="headerlink" title="2.4. 空间数据索引"></a>2.4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p><h2 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h2><h3 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1. 独立的列"></a>3.1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。<br>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id </span><br><span class="line"><span class="keyword">FROM</span> sakila.actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-多列索引"><a href="#3-2-多列索引" class="headerlink" title="3.2. 多列索引"></a>3.2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好<br>例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id </span><br><span class="line"><span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-索引列的顺序"><a href="#3-3-索引列的顺序" class="headerlink" title="3.3. 索引列的顺序"></a>3.3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。<br><strong><em>索引的选择性：</em></strong> 不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。<br>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line"></span><br><span class="line">   staff_id_selectivity: <span class="number">0.0001</span></span><br><span class="line">customer_id_selectivity: <span class="number">0.0373</span></span><br><span class="line">               <span class="built_in">COUNT</span>(<span class="operator">*</span>): <span class="number">16049</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-前缀索引"><a href="#3-4-前缀索引" class="headerlink" title="3.4. 前缀索引"></a>3.4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="3-5-覆盖索引"><a href="#3-5-覆盖索引" class="headerlink" title="3.5. 覆盖索引"></a>3.5. 覆盖索引</h3><p>索引包含 <strong>所有需要查询的字段的值</strong>。<br><strong><em>优点：</em></strong></p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="4-索引的优点"><a href="#4-索引的优点" class="headerlink" title="4. 索引的优点"></a>4. 索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="5-索引的使用条件"><a href="#5-索引的使用条件" class="headerlink" title="5. 索引的使用条件"></a>5. 索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="1-使用-Explain-进行分析"><a href="#1-使用-Explain-进行分析" class="headerlink" title="1. 使用 Explain 进行分析"></a>1. 使用 Explain 进行分析</h2><p>Explain 用来 <strong>分析 SELECT 查询语句</strong>，开发人员可以通过分析 Explain 结果来优化查询语句<br><strong><em>重要字段：</em></strong></p><ul><li><strong>select_type：</strong> 查询类型，有简单查询、联合查询、子查询等</li><li><strong> key：</strong> 使用的索引</li><li><strong> rows：</strong> 扫描的行数</li></ul><h2 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2. 优化数据访问"></a>2. 优化数据访问</h2><h3 id="2-1-减少请求的数据量"><a href="#2-1-减少请求的数据量" class="headerlink" title="2.1. 减少请求的数据量"></a>2.1. 减少请求的数据量</h3><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="2-2-减少服务器端扫描的行数"><a href="#2-2-减少服务器端扫描的行数" class="headerlink" title="2.2. 减少服务器端扫描的行数"></a>2.2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="3-重构查询方式"><a href="#3-重构查询方式" class="headerlink" title="3. 重构查询方式"></a>3. 重构查询方式</h2><h3 id="3-1-切分大查询"><a href="#3-1-切分大查询" class="headerlink" title="3.1. 切分大查询"></a>3.1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do {</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    "DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")</span><br><span class="line">} while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-分解大连接查询"><a href="#3-2-分解大连接查询" class="headerlink" title="3.2. 分解大连接查询"></a>3.2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联<br><strong><em>好处：</em></strong></p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN () 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><p><strong><em>概述：</em></strong> MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br><strong><em>隔离级别：</em></strong><br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<br>在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻读。<br><strong><em>索引：</em></strong> 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。<br><strong><em>内部优化：</em></strong> 包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。<br><strong><em>热备份：</em></strong> 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h2><p><strong><em>概述：</em></strong> 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br><strong><em>特性：</em></strong> 提供了压缩表、空间数据索引等。<br><strong><em>事务：</em></strong> 不支持事务。<br><strong><em>读写锁：</em></strong> 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。<br><strong><em>索引：</em></strong> 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><ul><li><strong>事务：</strong> InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li><li><strong>并发：</strong> MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li><li><strong>外键：</strong> InnoDB 支持外键</li><li><strong>备份：</strong> InnoDB 支持在线热备份</li><li><strong>崩溃恢复：</strong> MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li><strong>其它特性：</strong> MyISAM 支持压缩表和空间数据索引</li></ul><h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT (11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。<br>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL (18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。<br>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。<br>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h2 id="4-时间和日期"><a href="#4-时间和日期" class="headerlink" title="4. 时间和日期"></a>4. 时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3 id="4-1-DATETIME"><a href="#4-1-DATETIME" class="headerlink" title="4.1. DATETIME"></a>4.1. DATETIME</h3><p><strong><em>概述：</em></strong> 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。<br><strong><em>时区：</em></strong> 与时区无关。<br>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如 “2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3 id="4-2-TIMESTAMP"><a href="#4-2-TIMESTAMP" class="headerlink" title="4.2. TIMESTAMP"></a>4.2. TIMESTAMP</h3><p><strong><em>概述：</em></strong> 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。<br><strong><em>时区：</em></strong> 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。<br>MySQL 提供了 FROM_UNIXTIME () 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP () 函数把日期转换为 UNIX 时间戳。<br><strong><em>优点：</em></strong> 比 DATETIME 空间效率更高。</p><h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><p><a href="https://blog.csdn.net/bluishglc/column/info/sharding">数据库分库分表 (sharding)</a></p><h2 id="1-水平切分"><a href="#1-水平切分" class="headerlink" title="1. 水平切分"></a>1. 水平切分</h2><p><strong><em>概述：</em></strong> 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。<br>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/3c737fd088f55ee87e034c39ac838861.png" alt="image.png"></p><h2 id="2-垂直切分"><a href="#2-垂直切分" class="headerlink" title="2. 垂直切分"></a>2. 垂直切分</h2><p><strong><em>概述：</em></strong> 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。<br>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/9cb0ca9f7892a9d4fca291f0674da13c.png" alt="image.png"></p><h2 id="3-Sharding-策略"><a href="#3-Sharding-策略" class="headerlink" title="3. Sharding 策略"></a>3. Sharding 策略</h2><p><strong><em>策略：</em></strong></p><ul><li><strong>哈希取模：</strong> hash(key) % N</li><li><strong> 范围：</strong> 可以是 ID 范围也可以是时间范围</li><li><strong>映射表：</strong> 使用单独的一个数据库来存储映射关系</li></ul><p><strong><em>问题：</em></strong></p><ol><li><strong>事务问题：</strong> 使用分布式事务来解决，比如 XA 接口。</li><li><strong>连接：</strong> 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li><li><strong>ID 唯一性：</strong><ol><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ol></li></ol><h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><p><a href="https://www.cnblogs.com/idoljames/p/11694039.html">Mysql 主从复制原理及同步延迟问题</a><br><a href="https://blog.51cto.com/6300167/2344750">mysql 主从复制延迟问题</a><br><a href="https://www.jianshu.com/p/37f54c32c93c">mysql 读写分离和解决主从同步延时问题</a></p><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><p>主要涉及三个线程： binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程：</strong> 负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程：</strong> 负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li><li><strong>SQL 线程：</strong> 负责读取重放日志并重放其中的 SQL 语句。</li></ul><p><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/5ebee84b776054508db67f7a9ca22bc1.png" alt="image.png"></p><h2 id="2-读写分离"><a href="#2-读写分离" class="headerlink" title="2. 读写分离"></a>2. 读写分离</h2><p><strong>概述：</strong> 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br><strong>优点：</strong></p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p><strong>实现：</strong> 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。<br><img data-src="https://ccomma-pic-storage.oss-cn-hangzhou.aliyuncs.com/img/a18825649461134799421b2a56728e4d.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/myseries/p/10728533.html&quot;&gt;MySQL 中的几种日志了解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、索引&quot;&gt;&lt;a href=&quot;#一、索引&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DATETIME 与 TIMESTAMP 的一些区别与问题</title>
    <link href="https://ccomma.cn/ce89239438f9/"/>
    <id>https://ccomma.cn/ce89239438f9/</id>
    <published>2023-06-26T09:00:48.000Z</published>
    <updated>2024-04-01T08:13:04.831Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个问题，明明数据有更新，update_time 字段却还停留在创建数据的时候。<br>按常理来说这个字段应该是自动更新的才对。<br>查了一下表结构，<code>update_time</code> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP<br>发现 update_time 字段的类型是 datetime<br>由此牵扯出两个问题，（1）timestamp 与 datetime 的区别；（2）CURRENT_TIMESTAMP 为什么能用于 datetime 类型</p><ul><li>timestamp 与 datetime 的区别<br>a）DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空（not null）, 默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且 update 语句中没有指定该列的更新值，则默认更新为当前时间。<br>这个区别就解释了为什么平时我们都不用可以管这个字段就能自动更新了，因为多数时候用的是 timestamp；而此处用的是 datetime，不会有自动更新当前时间的机制，所以需要在上层手动更新该字段 b）DATETIME 使用 8 字节的存储空间，TIMESTAMP 的存储空间为 4 字节。因此，TIMESTAMP 比 DATETIME 的空间利用率更高。这个区别解释了为啥 timestamp 类型用的多 c）两者的存储方式不一样 ，对于 TIMESTAMP，它把客户端插入的时间从当前时区转化为 UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于 DATETIME，不做任何改变，基本上是原样输入和输出。d）两者所能存储的时间范围不一样 timestamp 所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’；datetime 所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</li><li>CURRENT_TIMESTAMP 为什么能用于 datetime 类型<br>在 mysql 5.6 之前的版本，CURRENT_TIMESTAMP 只能用于 timestamp 类型，<br>5.6 版本之后，CURRENT_TIMESTAMP 也能用于 datetime 类型了<br>select version () 查了一下数据库发现确实版本是 5.6.29</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天遇到一个问题，明明数据有更新，update_time 字段却还停留在创建数据的时候。&lt;br&gt;按常理来说这个字段应该是自动更新的才对。&lt;br&gt;查了一下表结构，&lt;code&gt;update_time&lt;/code&gt; datetime NOT NULL DEFAULT CURREN</summary>
      
    
    
    
    
  </entry>
  
</feed>
